# pytest documentation

URL: https://docs.pytest.org/en/stable/


Next Open Trainings and Events Professional Testing with Python , via Python Academy (3 day in-depth training), March 4th – 6th 2025 , Remote Also see previous talks and blogposts

# pytest: helps you write better programs¶

The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries. pytest requires: Python 3.8+ or PyPy3. PyPI package name : pytest

# A quick example¶

```

# content of test_sample.py
def
inc
(
x
):
return
x
+
1
def
test_answer
():
assert
inc
(
3
)
==
5

```

To execute it:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_sample.py
F
[100%]
================================= FAILURES =================================
_______________________________ test_answer ________________________________
def test_answer():
>       assert inc(3) == 5
E       assert 4 == 5
E        +  where 4 = inc(3)
test_sample.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_sample.py::
test_answer
- assert 4 == 5
============================
1 failed
in 0.12s =============================

```

Due to pytest ’s detailed assertion introspection, only plain assert statements are used. See Get started for a basic introduction to using pytest.

# Features¶

Detailed info on failing assert statements (no need to remember self.assert* names) Auto-discovery of test modules and functions Modular fixtures for managing small or parametrized long-lived test resources Can run unittest (including trial) test suites out of the box Python 3.8+ or PyPy 3 Rich plugin architecture, with over 1300+ external plugins and thriving community

# Documentation¶

Get started - install pytest and grasp its basics in just twenty minutes How-to guides - step-by-step guides, covering a vast range of use-cases and needs Reference guides - includes the complete pytest API reference, lists of plugins and more Explanation - background, discussion of key topics, answers to higher-level questions

# Bugs/Requests¶

Please use the GitHub issue tracker to submit bugs or request features.

# Support pytest¶

Open Collective is an online funding platform for open and transparent communities. It provides tools to raise money and share your finances in full transparency. It is the platform of choice for individuals and companies that want to make one-time or monthly donations directly to the project. See more details in the pytest collective .

# pytest for enterprise¶

Available as part of the Tidelift Subscription. The maintainers of pytest and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.

# Security¶


---


# Writing hook functions - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/writing_hook_functions.html


# Writing hook functions¶

# hook function validation and execution¶

pytest calls hook functions from registered plugins for any given hook specification. Let’s look at a typical hook function for the pytest_collection_modifyitems(session, config, items) hook which pytest calls after collection of all test items is completed. When we implement a pytest_collection_modifyitems function in our plugin pytest will during registration verify that you use argument names which match the specification and bail out if not. Let’s look at a possible implementation:

```

def
pytest_collection_modifyitems
(
config
,
items
):
# called after collection is completed
# you can modify the ``items`` list
...

```

Here, pytest will pass in config (the pytest config object) and items (the list of collected test items) but will not pass in the session argument because we didn’t list it in the function signature. This dynamic “pruning” of arguments allows pytest to be “future-compatible”: we can introduce new hook named parameters without breaking the signatures of existing hook implementations. It is one of the reasons for the general long-lived compatibility of pytest plugins. Note that hook functions other than pytest_runtest_* are not allowed to raise exceptions. Doing so will break the pytest run.

# firstresult: stop at first non-None result¶

Most calls to pytest hooks result in a list of results which contains all non-None results of the called hook functions. Some hook specifications use the firstresult=True option so that the hook call only executes until the first of N registered functions returns a non-None result which is then taken as result of the overall hook call. The remaining hook functions will not be called in this case.

# hook wrappers: executing around other hooks¶

pytest plugins can implement hook wrappers which wrap the execution of other hook implementations. A hook wrapper is a generator function which yields exactly once. When pytest invokes hooks it first executes hook wrappers and passes the same arguments as to the regular hooks. At the yield point of the hook wrapper pytest will execute the next hook implementations and return their result to the yield point, or will propagate an exception if they raised. Here is an example definition of a hook wrapper:

```

import
pytest
@pytest
.
hookimpl
(
wrapper
=
True
)
def
pytest_pyfunc_call
(
pyfuncitem
):
do_something_before_next_hook_executes
()
# If the outcome is an exception, will raise the exception.
res
=
yield
new_res
=
post_process_result
(
res
)
# Override the return value to the plugin system.
return
new_res

```

The hook wrapper needs to return a result for the hook, or raise an exception. In many cases, the wrapper only needs to perform tracing or other side effects around the actual hook implementations, in which case it can return the result value of the yield . The simplest (though useless) hook wrapper is return (yield) . In other cases, the wrapper wants the adjust or adapt the result, in which case it can return a new value. If the result of the underlying hook is a mutable object, the wrapper may modify that result, but it’s probably better to avoid it. If the hook implementation failed with an exception, the wrapper can handle that exception using a try-catch-finally around the yield , by propagating it, suppressing it, or raising a different exception entirely. For more information, consult the pluggy documentation about hook wrappers .

# Hook function ordering / call example¶

For any given hook specification there may be more than one implementation and we thus generally view hook execution as a 1:N function call where N is the number of registered functions. There are ways to influence if a hook implementation comes before or after others, i.e. the position in the N -sized list of functions:

```

# Plugin 1
@pytest
.
hookimpl
(
tryfirst
=
True
)
def
pytest_collection_modifyitems
(
items
):
# will execute as early as possible
...
# Plugin 2
@pytest
.
hookimpl
(
trylast
=
True
)
def
pytest_collection_modifyitems
(
items
):
# will execute as late as possible
...
# Plugin 3
@pytest
.
hookimpl
(
wrapper
=
True
)
def
pytest_collection_modifyitems
(
items
):
# will execute even before the tryfirst one above!
try
:
return
(
yield
)
finally
:
# will execute after all non-wrappers executed
...

```

Here is the order of execution: Plugin3’s pytest_collection_modifyitems called until the yield point because it is a hook wrapper. Plugin1’s pytest_collection_modifyitems is called because it is marked with tryfirst=True . Plugin2’s pytest_collection_modifyitems is called because it is marked with trylast=True (but even without this mark it would come after Plugin1). Plugin3’s pytest_collection_modifyitems then executing the code after the yield point. The yield receives the result from calling the non-wrappers, or raises an exception if the non-wrappers raised. It’s possible to use tryfirst and trylast also on hook wrappers in which case it will influence the ordering of hook wrappers among each other.

# Declaring new hooks¶

Note This is a quick overview on how to add new hooks and how they work in general, but a more complete overview can be found in the pluggy documentation . Plugins and conftest.py files may declare new hooks that can then be implemented by other plugins in order to alter behaviour or interact with the new plugin: Called at plugin registration time to allow adding new hooks via a call to pluginmanager.add_hookspecs(module_or_class, prefix) . pluginmanager ( PytestPluginManager ) – The pytest plugin manager. Note This hook is incompatible with hook wrappers.

# Use in conftest plugins¶

If a conftest plugin implements this hook, it will be called immediately when the conftest is registered. Hooks are usually declared as do-nothing functions that contain only documentation describing when the hook will be called and what return values are expected. The names of the functions must start with pytest_ otherwise pytest won’t recognize them. Here’s an example. Let’s assume this code is in the sample_hook.py module.

```

def
pytest_my_hook
(
config
):
"""
Receives the pytest config and does things with it
"""

```

To register the hooks with pytest they need to be structured in their own module or class. This class or module can then be passed to the pluginmanager using the pytest_addhooks function (which itself is a hook exposed by pytest).

```

def
pytest_addhooks
(
pluginmanager
):
"""This example assumes the hooks are grouped in the 'sample_hook' module."""
from
my_app.tests
import
sample_hook
pluginmanager
.
add_hookspecs
(
sample_hook
)

```

For a real world example, see newhooks.py from xdist . Hooks may be called both from fixtures or from other hooks. In both cases, hooks are called through the hook object, available in the config object. Most hooks receive a config object directly, while fixtures may use the pytestconfig fixture which provides the same object.

```

@pytest
.
fixture
()
def
my_fixture
(
pytestconfig
):
# call the hook called "pytest_my_hook"
# 'result' will be a list of return values from all registered functions.
result
=
pytestconfig
.
hook
.
pytest_my_hook
(
config
=
pytestconfig
)

```

Note Hooks receive parameters using only keyword arguments. Now your hook is ready to be used. To register a function at the hook, other plugins or users must now simply define the function pytest_my_hook with the correct signature in their conftest.py . Example:

```

def
pytest_my_hook
(
config
):
"""
Print all active hooks to the screen.
"""
print
(
config
.
hook
)

```

# Using hooks in pytest_addoption¶

Occasionally, it is necessary to change the way in which command line options are defined by one plugin based on hooks in another plugin. For example, a plugin may expose a command line option for which another plugin needs to define the default value. The pluginmanager can be used to install and use hooks to accomplish this. The plugin would define and add the hooks and use pytest_addoption as follows:

```

# contents of hooks.py
# Use firstresult=True because we only want one plugin to define this
# default value
@hookspec
(
firstresult
=
True
)
def
pytest_config_file_default_value
():
"""Return the default value for the config file command line option."""
# contents of myplugin.py
def
pytest_addhooks
(
pluginmanager
):
"""This example assumes the hooks are grouped in the 'hooks' module."""
from
.
import
hooks
pluginmanager
.
add_hookspecs
(
hooks
)
def
pytest_addoption
(
parser
,
pluginmanager
):
default_value
=
pluginmanager
.
hook
.
pytest_config_file_default_value
()
parser
.
addoption
(
"--config-file"
,
help
=
"Config file to use, defaults to
%(default)s
"
,
default
=
default_value
,
)

```

The conftest.py that is using myplugin would simply define the hook as follows:

```

def
pytest_config_file_default_value
():
return
"config.yaml"

```

# Optionally using hooks from 3rd party plugins¶

Using new hooks from plugins as explained above might be a little tricky because of the standard validation mechanism : if you depend on a plugin that is not installed, validation will fail and the error message will not make much sense to your users. One approach is to defer the hook implementation to a new plugin instead of declaring the hook functions directly in your plugin module, for example:

```

# contents of myplugin.py
class
DeferPlugin
:
"""Simple plugin to defer pytest-xdist hook functions."""
def
pytest_testnodedown
(
self
,
node
,
error
):
"""standard xdist hook function."""
def
pytest_configure
(
config
):
if
config
.
pluginmanager
.
hasplugin
(
"xdist"
):
config
.
pluginmanager
.
register
(
DeferPlugin
())

```

This has the added benefit of allowing you to conditionally install hooks depending on which plugins are installed.

# Storing data on items across hook functions¶

Plugins often need to store data on Item s in one hook implementation, and access it in another. One common solution is to just assign some private attribute directly on the item, but type-checkers like mypy frown upon this, and it may also cause conflicts with other plugins. So pytest offers a better way to do this, item.stash . To use the “stash” in your plugins, first create “stash keys” somewhere at the top level of your plugin:

```

been_there_key
=
pytest
.
StashKey
[
bool
]()
done_that_key
=
pytest
.
StashKey
[
str
]()

```

then use the keys to stash your data at some point:

```

def
pytest_runtest_setup
(
item
:
pytest
.
Item
)
->
None
:
item
.
stash
[
been_there_key
]
=
True
item
.
stash
[
done_that_key
]
=
"no"

```

and retrieve them at another point:

```

def
pytest_runtest_teardown
(
item
:
pytest
.
Item
)
->
None
:
if
not
item
.
stash
[
been_there_key
]:
print
(
"Oh?"
)
item
.
stash
[
done_that_key
]
=
"yes!"

```


---


# How to implement xunit-style set-up - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/xunit_setup.html


# How to implement xunit-style set-up¶

This section describes a classic and popular way how you can implement fixtures (setup and teardown test state) on a per-module/class/function basis. Note While these setup/teardown methods are simple and familiar to those coming from a unittest or nose background, you may also consider using pytest’s more powerful fixture mechanism which leverages the concept of dependency injection, allowing for a more modular and more scalable approach for managing test state, especially for larger projects and for functional testing. You can mix both fixture mechanisms in the same file but test methods of unittest.TestCase subclasses cannot receive fixture arguments.

# Module level setup/teardown¶

If you have multiple test functions and test classes in a single module you can optionally implement the following fixture methods which will usually be called once for all the functions:

```

def
setup_module
(
module
):
"""setup any state specific to the execution of the given module."""
def
teardown_module
(
module
):
"""teardown any state that was previously setup with a setup_module
method.
"""

```

As of pytest-3.0, the module parameter is optional.

# Class level setup/teardown¶

Similarly, the following methods are called at class level before and after all test methods of the class are called:

```

@classmethod
def
setup_class
(
cls
):
"""setup any state specific to the execution of the given class (which
usually contains tests).
"""
@classmethod
def
teardown_class
(
cls
):
"""teardown any state that was previously setup with a call to
setup_class.
"""

```

# Method and function level setup/teardown¶

Similarly, the following methods are called around each method invocation:

```

def
setup_method
(
self
,
method
):
"""setup any state tied to the execution of the given method in a
class.  setup_method is invoked for every test method of a class.
"""
def
teardown_method
(
self
,
method
):
"""teardown any state that was previously setup with a setup_method
call.
"""

```

As of pytest-3.0, the method parameter is optional. If you would rather define test functions directly at module level you can also use the following functions to implement fixtures:

```

def
setup_function
(
function
):
"""setup any state tied to the execution of the given function.
Invoked for every test function in the module.
"""
def
teardown_function
(
function
):
"""teardown any state that was previously setup with a setup_function
call.
"""

```


---


# How to use pytest with an existing test suite - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/existingtestsuite.html


# How to use pytest with an existing test suite¶

Pytest can be used with most existing test suites, but its behavior differs from other test runners such as Python’s default unittest framework. Before using this section you will want to install pytest .

# Running an existing test suite with pytest¶

Say you want to contribute to an existing repository somewhere. After pulling the code into your development space using some flavor of version control and (optionally) setting up a virtualenv you will want to run:

```

cd
<repository>
pip
install
-e
.
# Environment dependent alternatives include
# 'python setup.py develop' and 'conda develop'

```


---


# Using a custom directory collector - pytest documentation

URL: https://docs.pytest.org/en/stable/example/customdirectory.html


# Using a custom directory collector¶

By default, pytest collects directories using pytest.Package , for directories with __init__.py files, and pytest.Dir for other directories. If you want to customize how a directory is collected, you can write your own pytest.Directory collector, and use pytest_collect_directory to hook it up.

# A basic example for a directory manifest file¶

Suppose you want to customize how collection is done on a per-directory basis. Here is an example conftest.py plugin that allows directories to contain a manifest.json file, which defines how the collection should be done for the directory. In this example, only a simple list of files is supported, however you can imagine adding other keys, such as exclusions and globs.

```

# content of conftest.py
from
__future__
import
annotations
import
json
import
pytest
class
ManifestDirectory
(
pytest
.
Directory
):
def
collect
(
self
):
# The standard pytest behavior is to loop over all `test_*.py` files and
# call `pytest_collect_file` on each file. This collector instead reads
# the `manifest.json` file and only calls `pytest_collect_file` for the
# files defined there.
manifest_path
=
self
.
path
/
"manifest.json"
manifest
=
json
.
loads
(
manifest_path
.
read_text
(
encoding
=
"utf-8"
))
ihook
=
self
.
ihook
for
file
in
manifest
[
"files"
]:
yield from
ihook
.
pytest_collect_file
(
file_path
=
self
.
path
/
file
,
parent
=
self
)
@pytest
.
hookimpl
def
pytest_collect_directory
(
path
,
parent
):
# Use our custom collector for directories containing a `manifest.json` file.
if
path
.
joinpath
(
"manifest.json"
)
.
is_file
():
return
ManifestDirectory
.
from_parent
(
parent
=
parent
,
path
=
path
)
# Otherwise fallback to the standard behavior.
return
None

```

You can create a manifest.json file and some test files:

```

{
"files"
:
[
"test_first.py"
,
"test_second.py"
]
}

```

```

# content of test_first.py
from
__future__
import
annotations
def
test_1
():
pass

```

```

# content of test_second.py
from
__future__
import
annotations
def
test_2
():
pass

```

```

# content of test_third.py
from
__future__
import
annotations
def
test_3
():
pass

```

An you can now execute the test specification:

```

customdirectory $ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project/customdirectory
configfile: pytest.ini
collected 2 items

tests/test_first.py
.
[ 50%]
tests/test_second.py
.
[100%]
============================
2 passed
in 0.12s =============================

```

Notice how test_three.py was not executed, because it is not listed in the manifest. You can verify that your custom collector appears in the collection tree:

```

customdirectory $ pytest --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project/customdirectory
configfile: pytest.ini
collected 2 items

<Dir customdirectory>
  <ManifestDirectory tests>
    <Module test_first.py>
      <Function test_1>
    <Module test_second.py>
      <Function test_2>

======================== 2 tests collected in 0.12s ========================

```


---


# How to install and use plugins - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/plugins.html


# How to install and use plugins¶

This section talks about installing and using third party plugins. For writing your own plugins, please refer to Writing plugins . Installing a third party plugin can be easily done with pip :

```

pip
install
pytest-NAME
pip
uninstall
pytest-NAME

```

If a plugin is installed, pytest automatically finds and integrates it, there is no need to activate it. Here is a little annotated list for some popular plugins: pytest-django : write tests for django apps, using pytest integration. pytest-twisted : write tests for twisted apps, starting a reactor and processing deferreds from test functions. pytest-cov : coverage reporting, compatible with distributed testing pytest-xdist : to distribute tests to CPUs and remote hosts, to run in boxed mode which allows to survive segmentation faults, to run in looponfailing mode, automatically re-running failing tests on file changes. pytest-instafail : to report failures while the test run is happening. pytest-bdd : to write tests using behaviour-driven testing. pytest-timeout : to timeout tests based on function marks or global definitions. pytest-pep8 : a --pep8 option to enable PEP8 compliance checking. pytest-flakes : check source code with pyflakes. allure-pytest : report test results via allure-framework . To see a complete list of all plugins with their latest testing status against different pytest and Python versions, please visit Pytest Plugin List . You may also discover more plugins through a pytest- pypi.org search .

# Requiring/Loading plugins in a test module or conftest file¶

You can require plugins in a test module or a conftest file using pytest_plugins :

```

pytest_plugins
=
(
"myapp.testsupport.myplugin"
,)

```

When the test module or conftest plugin is loaded the specified plugins will be loaded as well. Note Requiring plugins using a pytest_plugins variable in non-root conftest.py files is deprecated. See full explanation in the Writing plugins section. Note The name pytest_plugins is reserved and should not be used as a name for a custom plugin module.

# Finding out which plugins are active¶

If you want to find out which plugins are active in your environment you can type:

```

pytest
--trace-config

```

and will get an extended test header which shows activated plugins and their names. It will also print local plugins aka conftest.py files when they are loaded.

# Deactivating / unregistering a plugin by name¶

You can prevent plugins from loading or unregister them:

```

pytest
-p
no:NAME

```

This means that any subsequent try to activate/load the named plugin will not work. If you want to unconditionally disable a plugin for a project, you can add this option to your pytest.ini file:

```

[pytest]
addopts
=
-p no:NAME

```


---


# Basic patterns and examples - pytest documentation

URL: https://docs.pytest.org/en/stable/example/simple.html


# Basic patterns and examples¶

# How to change command line options defaults¶

It can be tedious to type the same series of command line options every time you use pytest . For example, if you always want to see detailed info on skipped and xfailed tests, as well as have terser “dot” progress output, you can write it into a configuration file:

```

# content of pytest.ini
[pytest]
addopts
=
-ra -q

```

Alternatively, you can set a PYTEST_ADDOPTS environment variable to add command line options while the environment is in use:

```

export
PYTEST_ADDOPTS
=
"-v"

```

Here’s how the command-line is built in the presence of addopts or the environment variable:

```

<pytest.ini:addopts> $PYTEST_ADDOPTS <extra command-line arguments>

```

So if the user executes in the command-line:

```

pytest
-m
slow

```

The actual command line executed is:

```

pytest
-ra
-q
-v
-m
slow

```

Note that as usual for other command-line applications, in case of conflicting options the last one wins, so the example above will show verbose output because -v overwrites -q .

# Pass different values to a test function, depending on command line options¶

Suppose we want to write a test that depends on a command line option. Here is a basic pattern to achieve this:

```

# content of test_sample.py
def
test_answer
(
cmdopt
):
if
cmdopt
==
"type1"
:
print
(
"first"
)
elif
cmdopt
==
"type2"
:
print
(
"second"
)
assert
0
# to see what was printed

```

For this to work we need to add a command line option and provide the cmdopt through a fixture function :

```

# content of conftest.py
import
pytest
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--cmdopt"
,
action
=
"store"
,
default
=
"type1"
,
help
=
"my option: type1 or type2"
)
@pytest
.
fixture
def
cmdopt
(
request
):
return
request
.
config
.
getoption
(
"--cmdopt"
)

```

Let’s run this without supplying our new option:

```

$ pytest -q test_sample.py
F
[100%]
================================= FAILURES =================================
_______________________________ test_answer ________________________________
cmdopt = 'type1'

    def test_answer(cmdopt):
        if cmdopt == "type1":
            print("first")
        elif cmdopt == "type2":
            print("second")
>       assert 0  # to see what was printed
E       assert 0
test_sample.py
:6: AssertionError
--------------------------- Captured stdout call ---------------------------
first
========================= short test summary info ==========================
FAILED
test_sample.py::
test_answer
- assert 0
1 failed
in 0.12s

```

And now with supplying a command line option:

```

$ pytest -q --cmdopt=type2
F
[100%]
================================= FAILURES =================================
_______________________________ test_answer ________________________________
cmdopt = 'type2'

    def test_answer(cmdopt):
        if cmdopt == "type1":
            print("first")
        elif cmdopt == "type2":
            print("second")
>       assert 0  # to see what was printed
E       assert 0
test_sample.py
:6: AssertionError
--------------------------- Captured stdout call ---------------------------
second
========================= short test summary info ==========================
FAILED
test_sample.py::
test_answer
- assert 0
1 failed
in 0.12s

```

You can see that the command line option arrived in our test. We could add simple validation for the input by listing the choices:

```

# content of conftest.py
import
pytest
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--cmdopt"
,
action
=
"store"
,
default
=
"type1"
,
help
=
"my option: type1 or type2"
,
choices
=
(
"type1"
,
"type2"
),
)

```

Now we’ll get feedback on a bad argument:

```

$ pytest -q --cmdopt=type3
ERROR: usage: pytest [options] [file_or_dir] [file_or_dir] [...]
pytest: error: argument --cmdopt: invalid choice: 'type3' (choose from type1, type2)

```

If you need to provide more detailed error messages, you can use the type parameter and raise pytest.UsageError :

```

# content of conftest.py
import
pytest
def
type_checker
(
value
):
msg
=
"cmdopt must specify a numeric type as typeNNN"
if
not
value
.
startswith
(
"type"
):
raise
pytest
.
UsageError
(
msg
)
try
:
int
(
value
[
4
:])
except
ValueError
:
raise
pytest
.
UsageError
(
msg
)
return
value
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--cmdopt"
,
action
=
"store"
,
default
=
"type1"
,
help
=
"my option: type1 or type2"
,
type
=
type_checker
,
)

```

This completes the basic pattern. However, one often rather wants to process command line options outside of the test and rather pass in different or more complex objects.

# Dynamically adding command line options¶

Through addopts you can statically add command line options for your project. You can also dynamically modify the command line arguments before they get processed:

```

# installable external plugin
import
sys
def
pytest_load_initial_conftests
(
args
):
if
"xdist"
in
sys
.
modules
:
# pytest-xdist plugin
import
multiprocessing
num
=
max
(
multiprocessing
.
cpu_count
()
/
2
,
1
)
args
[:]
=
[
"-n"
,
str
(
num
)]
+
args

```

If you have the xdist plugin installed you will now always perform test runs using a number of subprocesses close to your CPU. Running in an empty directory with the above conftest.py:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 0 items
========================== no tests ran in 0.12s ===========================

```

# Control skipping of tests according to command line option¶

Here is a conftest.py file adding a --runslow command line option to control skipping of pytest.mark.slow marked tests:

```

# content of conftest.py
import
pytest
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--runslow"
,
action
=
"store_true"
,
default
=
False
,
help
=
"run slow tests"
)
def
pytest_configure
(
config
):
config
.
addinivalue_line
(
"markers"
,
"slow: mark test as slow to run"
)
def
pytest_collection_modifyitems
(
config
,
items
):
if
config
.
getoption
(
"--runslow"
):
# --runslow given in cli: do not skip slow tests
return
skip_slow
=
pytest
.
mark
.
skip
(
reason
=
"need --runslow option to run"
)
for
item
in
items
:
if
"slow"
in
item
.
keywords
:
item
.
add_marker
(
skip_slow
)

```

We can now write a test module like this:

```

# content of test_module.py
import
pytest
def
test_func_fast
():
pass
@pytest
.
mark
.
slow
def
test_func_slow
():
pass

```

and when running it will see a skipped “slow” test:

```

$ pytest -rs    # "-rs" means report details on the little 's'
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_module.py
.
s
[100%]
========================= short test summary info ==========================
SKIPPED
[1] test_module.py:8: need --runslow option to run
=======================
1 passed
,
1 skipped
in 0.12s =======================

```

Or run it including the slow marked test:

```

$ pytest --runslow
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_module.py
..
[100%]
============================
2 passed
in 0.12s =============================

```

# Writing well integrated assertion helpers¶

If you have a test helper function called from a test you can use the pytest.fail marker to fail a test with a certain message. The test support function will not show up in the traceback if you set the __tracebackhide__ option somewhere in the helper function. Example:

```

# content of test_checkconfig.py
import
pytest
def
checkconfig
(
x
):
__tracebackhide__
=
True
if
not
hasattr
(
x
,
"config"
):
pytest
.
fail
(
f
"not configured:
{
x
}
"
)
def
test_something
():
checkconfig
(
42
)

```

The __tracebackhide__ setting influences pytest showing of tracebacks: the checkconfig function will not be shown unless the --full-trace command line option is specified. Let’s run our little function:

```

$ pytest -q test_checkconfig.py
F
[100%]
================================= FAILURES =================================
______________________________ test_something ______________________________
def test_something():
>       checkconfig(42)
E       Failed: not configured: 42
test_checkconfig.py
:11: Failed
========================= short test summary info ==========================
FAILED
test_checkconfig.py::
test_something
- Failed: not configured: 42
1 failed
in 0.12s

```

If you only want to hide certain exceptions, you can set __tracebackhide__ to a callable which gets the ExceptionInfo object. You can for example use this to make sure unexpected exception types aren’t hidden:

```

import
operator
import
pytest
class
ConfigException
(
Exception
):
pass
def
checkconfig
(
x
):
__tracebackhide__
=
operator
.
methodcaller
(
"errisinstance"
,
ConfigException
)
if
not
hasattr
(
x
,
"config"
):
raise
ConfigException
(
f
"not configured:
{
x
}
"
)
def
test_something
():
checkconfig
(
42
)

```

This will avoid hiding the exception traceback on unrelated exceptions (i.e. bugs in assertion helpers).

# Detect if running from within a pytest run¶

Usually it is a bad idea to make application code behave differently if called from a test. But if you absolutely must find out if your application code is running from a test you can do this:

```

import
os
if
os
.
environ
.
get
(
"PYTEST_VERSION"
)
is
not
None
:
# Things you want to to do if your code is called by pytest.
...
else
:
# Things you want to to do if your code is not called by pytest.
...

```

# Adding info to test report header¶

It’s easy to present extra information in a pytest run:

```

# content of conftest.py
def
pytest_report_header
(
config
):
return
"project deps: mylib-1.1"

```

which will add the string to the test header accordingly:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
project deps: mylib-1.1
rootdir: /home/sweet/project
collected 0 items
========================== no tests ran in 0.12s ===========================

```

It is also possible to return a list of strings which will be considered as several lines of information. You may consider config.getoption('verbose') in order to display more information if applicable:

```

# content of conftest.py
def
pytest_report_header
(
config
):
if
config
.
get_verbosity
()
>
0
:
return
[
"info1: did you know that ..."
,
"did you?"
]

```

which will add info only when run with “–v”:

```

$ pytest -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
info1: did you know that ...
did you?
rootdir: /home/sweet/project
collecting ...
collected 0 items
========================== no tests ran in 0.12s ===========================

```

and nothing when run plainly:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 0 items
========================== no tests ran in 0.12s ===========================

```

# Profiling test duration¶

If you have a slow running large test suite you might want to find out which tests are the slowest. Let’s make an artificial test suite:

```

# content of test_some_are_slow.py
import
time
def
test_funcfast
():
time
.
sleep
(
0.1
)
def
test_funcslow1
():
time
.
sleep
(
0.2
)
def
test_funcslow2
():
time
.
sleep
(
0.3
)

```

Now we can profile which test functions execute the slowest:

```

$ pytest --durations=3
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 3 items

test_some_are_slow.py
...
[100%]
=========================== slowest 3 durations ============================
0.30s call     test_some_are_slow.py::test_funcslow2
0.20s call     test_some_are_slow.py::test_funcslow1
0.10s call     test_some_are_slow.py::test_funcfast
============================
3 passed
in 0.12s =============================

```

# Incremental testing - test steps¶

Sometimes you may have a testing situation which consists of a series of test steps. If one step fails it makes no sense to execute further steps as they are all expected to fail anyway and their tracebacks add no insight. Here is a simple conftest.py file which introduces an incremental marker which is to be used on classes:

```

# content of conftest.py
from
typing
import
Dict
,
Tuple
import
pytest
# store history of failures per test class name and per index in parametrize (if parametrize used)
_test_failed_incremental
:
Dict
[
str
,
Dict
[
Tuple
[
int
,
...
],
str
]]
=
{}
def
pytest_runtest_makereport
(
item
,
call
):
if
"incremental"
in
item
.
keywords
:
# incremental marker is used
if
call
.
excinfo
is
not
None
:
# the test has failed
# retrieve the class name of the test
cls_name
=
str
(
item
.
cls
)
# retrieve the index of the test (if parametrize is used in combination with incremental)
parametrize_index
=
(
tuple
(
item
.
callspec
.
indices
.
values
())
if
hasattr
(
item
,
"callspec"
)
else
()
)
# retrieve the name of the test function
test_name
=
item
.
originalname
or
item
.
name
# store in _test_failed_incremental the original name of the failed test
_test_failed_incremental
.
setdefault
(
cls_name
,
{})
.
setdefault
(
parametrize_index
,
test_name
)
def
pytest_runtest_setup
(
item
):
if
"incremental"
in
item
.
keywords
:
# retrieve the class name of the test
cls_name
=
str
(
item
.
cls
)
# check if a previous test has failed for this class
if
cls_name
in
_test_failed_incremental
:
# retrieve the index of the test (if parametrize is used in combination with incremental)
parametrize_index
=
(
tuple
(
item
.
callspec
.
indices
.
values
())
if
hasattr
(
item
,
"callspec"
)
else
()
)
# retrieve the name of the first test function to fail for this class name and index
test_name
=
_test_failed_incremental
[
cls_name
]
.
get
(
parametrize_index
,
None
)
# if name found, test has failed for the combination of class name & test name
if
test_name
is
not
None
:
pytest
.
xfail
(
f
"previous test failed (
{
test_name
}
)"
)

```

These two hook implementations work together to abort incremental-marked tests in a class. Here is a test module example:

```

# content of test_step.py
import
pytest
@pytest
.
mark
.
incremental
class
TestUserHandling
:
def
test_login
(
self
):
pass
def
test_modification
(
self
):
assert
0
def
test_deletion
(
self
):
pass
def
test_normal
():
pass

```

If we run this:

```

$ pytest -rx
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items

test_step.py
.
F
x
.
[100%]
================================= FAILURES =================================
____________________ TestUserHandling.test_modification ____________________
self = <test_step.TestUserHandling object at 0xdeadbeef0001>

    def test_modification(self):
>       assert 0
E       assert 0
test_step.py
:11: AssertionError
========================= short test summary info ==========================
XFAIL test_step.py::
TestUserHandling::test_deletion
- reason: previous test failed (test_modification)
==================
1 failed
,
2 passed
,
1 xfailed
in 0.12s ==================

```

We’ll see that test_deletion was not executed because test_modification failed. It is reported as an “expected failure”.

# Package/Directory-level fixtures (setups)¶

If you have nested test directories, you can have per-directory fixture scopes by placing fixture functions in a conftest.py file in that directory. You can use all types of fixtures including autouse fixtures which are the equivalent of xUnit’s setup/teardown concept. It’s however recommended to have explicit fixture references in your tests or test classes rather than relying on implicitly executing setup/teardown functions, especially if they are far away from the actual tests. Here is an example for making a db fixture available in a directory:

```

# content of a/conftest.py
import
pytest
class
DB
:
pass
@pytest
.
fixture
(
scope
=
"package"
)
def
db
():
return
DB
()

```

and then a test module in that directory:

```

# content of a/test_db.py
def
test_a1
(
db
):
assert
0
,
db
# to show value

```

another test module:

```

# content of a/test_db2.py
def
test_a2
(
db
):
assert
0
,
db
# to show value

```

and then a module in a sister directory which will not see the db fixture:

```

# content of b/test_error.py
def
test_root
(
db
):
# no db here, will error out
pass

```

We can run this:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 7 items

a/test_db.py
F
[ 14%]
a/test_db2.py
F
[ 28%]
b/test_error.py
E
[ 42%]
test_step.py
.
F
x
.
[100%]
================================== ERRORS ==================================
_______________________ ERROR at setup of test_root ________________________
file /home/sweet/project/b/test_error.py, line 1
  def test_root(db):  # no db here, will error out
E       fixture 'db' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, doctest_namespace, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/sweet/project/b/test_error.py:1
================================= FAILURES =================================
_________________________________ test_a1 __________________________________
db = <conftest.DB object at 0xdeadbeef0002>

    def test_a1(db):
>       assert 0, db  # to show value
E       AssertionError: <conftest.DB object at 0xdeadbeef0002>
E       assert 0
a/test_db.py
:2: AssertionError
_________________________________ test_a2 __________________________________
db = <conftest.DB object at 0xdeadbeef0002>

    def test_a2(db):
>       assert 0, db  # to show value
E       AssertionError: <conftest.DB object at 0xdeadbeef0002>
E       assert 0
a/test_db2.py
:2: AssertionError
____________________ TestUserHandling.test_modification ____________________
self = <test_step.TestUserHandling object at 0xdeadbeef0003>

    def test_modification(self):
>       assert 0
E       assert 0
test_step.py
:11: AssertionError
========================= short test summary info ==========================
FAILED
a/test_db.py::
test_a1
- AssertionError: <conftest.DB object at 0x7...
FAILED
a/test_db2.py::
test_a2
- AssertionError: <conftest.DB object at 0x...
FAILED
test_step.py::
TestUserHandling::test_modification
- assert 0
ERROR
b/test_error.py::test_root
=============
3 failed
,
2 passed
,
1 xfailed
,
1 error
in 0.12s ==============

```

The two test modules in the a directory see the same db fixture instance while the one test in the sister-directory b doesn’t see it. We could of course also define a db fixture in that sister directory’s conftest.py file. Note that each fixture is only instantiated if there is a test actually needing it (unless you use “autouse” fixture which are always executed ahead of the first test executing).

# Post-process test reports / failures¶

If you want to postprocess test reports and need access to the executing environment you can implement a hook that gets called when the test “report” object is about to be created. Here we write out all failing test calls and also access a fixture (if it was used by the test) in case you want to query/look at it during your post processing. In our case we just write some information out to a failures file:

```

# content of conftest.py
import
os.path
import
pytest
@pytest
.
hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_runtest_makereport
(
item
,
call
):
# execute all other hooks to obtain the report object
rep
=
yield
# we only look at actual failing test calls, not setup/teardown
if
rep
.
when
==
"call"
and
rep
.
failed
:
mode
=
"a"
if
os
.
path
.
exists
(
"failures"
)
else
"w"
with
open
(
"failures"
,
mode
,
encoding
=
"utf-8"
)
as
f
:
# let's also access a fixture for the fun of it
if
"tmp_path"
in
item
.
fixturenames
:
extra
=
" (
{}
)"
.
format
(
item
.
funcargs
[
"tmp_path"
])
else
:
extra
=
""
f
.
write
(
rep
.
nodeid
+
extra
+
"
\n
"
)
return
rep

```

if you then have failing tests:

```

# content of test_module.py
def
test_fail1
(
tmp_path
):
assert
0
def
test_fail2
():
assert
0

```

and run them:

```

$ pytest test_module.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_module.py
FF
[100%]
================================= FAILURES =================================
________________________________ test_fail1 ________________________________
tmp_path = PosixPath('PYTEST_TMPDIR/test_fail10')

    def test_fail1(tmp_path):
>       assert 0
E       assert 0
test_module.py
:2: AssertionError
________________________________ test_fail2 ________________________________
def test_fail2():
>       assert 0
E       assert 0
test_module.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_module.py::
test_fail1
- assert 0
FAILED
test_module.py::
test_fail2
- assert 0
============================
2 failed
in 0.12s =============================

```

you will have a “failures” file which contains the failing test ids:

```

$
cat
failures
test_module.py::test_fail1
(
PYTEST_TMPDIR/test_fail10
)
test_module.py::test_fail2

```

# Making test result information available in fixtures¶

If you want to make test result reports available in fixture finalizers here is a little example implemented via a local plugin:

```

# content of conftest.py
from
typing
import
Dict
import
pytest
from
pytest
import
StashKey
,
CollectReport
phase_report_key
=
StashKey
[
Dict
[
str
,
CollectReport
]]()
@pytest
.
hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_runtest_makereport
(
item
,
call
):
# execute all other hooks to obtain the report object
rep
=
yield
# store test results for each phase of a call, which can
# be "setup", "call", "teardown"
item
.
stash
.
setdefault
(
phase_report_key
,
{})[
rep
.
when
]
=
rep
return
rep
@pytest
.
fixture
def
something
(
request
):
yield
# request.node is an "item" because we use the default
# "function" scope
report
=
request
.
node
.
stash
[
phase_report_key
]
if
report
[
"setup"
]
.
failed
:
print
(
"setting up a test failed or skipped"
,
request
.
node
.
nodeid
)
elif
(
"call"
not
in
report
)
or
report
[
"call"
]
.
failed
:
print
(
"executing test failed or skipped"
,
request
.
node
.
nodeid
)

```

if you then have failing tests:

```

# content of test_module.py
import
pytest
@pytest
.
fixture
def
other
():
assert
0
def
test_setup_fails
(
something
,
other
):
pass
def
test_call_fails
(
something
):
assert
0
def
test_fail2
():
assert
0

```

and run it:

```

$ pytest -s test_module.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 3 items

test_module.py Esetting up a test failed or skipped test_module.py::test_setup_fails
Fexecuting test failed or skipped test_module.py::test_call_fails
F

================================== ERRORS ==================================
____________________ ERROR at setup of test_setup_fails ____________________
@pytest.fixture
    def other():
>       assert 0
E       assert 0
test_module.py
:7: AssertionError
================================= FAILURES =================================
_____________________________ test_call_fails ______________________________
something = None

    def test_call_fails(something):
>       assert 0
E       assert 0
test_module.py
:15: AssertionError
________________________________ test_fail2 ________________________________
def test_fail2():
>       assert 0
E       assert 0
test_module.py
:19: AssertionError
========================= short test summary info ==========================
FAILED
test_module.py::
test_call_fails
- assert 0
FAILED
test_module.py::
test_fail2
- assert 0
ERROR
test_module.py::
test_setup_fails
- assert 0
========================
2 failed
,
1 error
in 0.12s ========================

```

You’ll see that the fixture finalizers could use the precise reporting information.

# PYTEST_CURRENT_TESTenvironment variable¶

Sometimes a test session might get stuck and there might be no easy way to figure out which test got stuck, for example if pytest was run in quiet mode ( -q ) or you don’t have access to the console output. This is particularly a problem if the problem happens only sporadically, the famous “flaky” kind of tests. pytest sets the PYTEST_CURRENT_TEST environment variable when running tests, which can be inspected by process monitoring utilities or libraries like psutil to discover which test got stuck if necessary:

```

import
psutil
for
pid
in
psutil
.
pids
():
environ
=
psutil
.
Process
(
pid
)
.
environ
()
if
"PYTEST_CURRENT_TEST"
in
environ
:
print
(
f
'pytest process
{
pid
}
running:
{
environ
[
"PYTEST_CURRENT_TEST"
]
}
'
)

```

During the test session pytest will set PYTEST_CURRENT_TEST to the current test nodeid and the current stage, which can be setup , call , or teardown . For example, when running a single test function named test_foo from foo_module.py , PYTEST_CURRENT_TEST will be set to: foo_module.py::test_foo (setup) foo_module.py::test_foo (call) foo_module.py::test_foo (teardown) In that order. Note The contents of PYTEST_CURRENT_TEST is meant to be human readable and the actual format can be changed between releases (even bug fixes) so it shouldn’t be relied on for scripting or automation.

# Freezing pytest¶

If you freeze your application using a tool like PyInstaller in order to distribute it to your end-users, it is a good idea to also package your test runner and run your tests using the frozen application. This way packaging errors such as dependencies not being included into the executable can be detected early while also allowing you to send test files to users so they can run them in their machines, which can be useful to obtain more information about a hard to reproduce bug. Fortunately recent PyInstaller releases already have a custom hook for pytest, but if you are using another tool to freeze executables such as cx_freeze or py2exe , you can use pytest.freeze_includes() to obtain the full list of internal pytest modules. How to configure the tools to find the internal modules varies from tool to tool, however. Instead of freezing the pytest runner as a separate executable, you can make your frozen program work as the pytest runner by some clever argument handling during program startup. This allows you to have a single executable, which is usually more convenient. Please note that the mechanism for plugin discovery used by pytest ( entry points ) doesn’t work with frozen executables so pytest can’t find any third party plugins automatically. To include third party plugins like pytest-timeout they must be imported explicitly and passed on to pytest.main.

```

# contents of app_main.py
import
sys
import
pytest_timeout
# Third party plugin
if
len
(
sys
.
argv
)
>
1
and
sys
.
argv
[
1
]
==
"--pytest"
:
import
pytest
sys
.
exit
(
pytest
.
main
(
sys
.
argv
[
2
:],
plugins
=
[
pytest_timeout
]))
else
:
# normal application execution: at this point argv can be parsed
# by your argument-parsing library of choice as usual
...

```

This allows you to execute tests using the frozen application with standard pytest command-line options:

```

./app_main
--pytest
--verbose
--tb
=
long
--junit
=
xml
=
results.xml
test-suite/

```


---


# How to capture stdout/stderr output - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/capture-stdout-stderr.html


# How to capture stdout/stderr output¶

# Default stdout/stderr/stdin capturing behaviour¶

During test execution any output sent to stdout and stderr is captured. If a test or a setup method fails its according captured output will usually be shown along with the failure traceback. (this behavior can be configured by the --show-capture command-line option). In addition, stdin is set to a “null” object which will fail on attempts to read from it because it is rarely desired to wait for interactive input when running automated tests. By default capturing is done by intercepting writes to low level file descriptors. This allows to capture output from simple print statements as well as output from a subprocess started by a test.

# Setting capturing methods or disabling capturing¶

There are three ways in which pytest can perform capturing: fd (file descriptor) level capturing (default): All writes going to the operating system file descriptors 1 and 2 will be captured. sys level capturing: Only writes to Python files sys.stdout and sys.stderr will be captured. No capturing of writes to filedescriptors is performed. tee-sys capturing: Python writes to sys.stdout and sys.stderr will be captured, however the writes will also be passed-through to the actual sys.stdout and sys.stderr . This allows output to be ‘live printed’ and captured for plugin use, such as junitxml (new in pytest 5.4). You can influence output capturing mechanisms from the command line:

```

pytest
-s
# disable all capturing
pytest
--capture
=
sys
# replace sys.stdout/stderr with in-mem files
pytest
--capture
=
fd
# also point filedescriptors 1 and 2 to temp file
pytest
--capture
=
tee-sys
# combines 'sys' and '-s', capturing sys.stdout/stderr
# and passing it along to the actual sys.stdout/stderr

```

# Using print statements for debugging¶

One primary benefit of the default capturing of stdout/stderr output is that you can use print statements for debugging:

```

# content of test_module.py
def
setup_function
(
function
):
print
(
"setting up"
,
function
)
def
test_func1
():
assert
True
def
test_func2
():
assert
False

```

and running this module will show you precisely the output of the failing function and hide the other one:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_module.py
.
F
[100%]
================================= FAILURES =================================
________________________________ test_func2 ________________________________
def test_func2():
>       assert False
E       assert False
test_module.py
:12: AssertionError
-------------------------- Captured stdout setup ---------------------------
setting up <function test_func2 at 0xdeadbeef0001>
========================= short test summary info ==========================
FAILED
test_module.py::
test_func2
- assert False
=======================
1 failed
,
1 passed
in 0.12s ========================

```

# Accessing captured output from a test function¶

The capsys , capsysbinary , capfd , and capfdbinary fixtures allow access to stdout / stderr output created during test execution. Here is an example test function that performs some output related checks:

```

def
test_myoutput
(
capsys
):
# or use "capfd" for fd-level
print
(
"hello"
)
sys
.
stderr
.
write
(
"world
\n
"
)
captured
=
capsys
.
readouterr
()
assert
captured
.
out
==
"hello
\n
"
assert
captured
.
err
==
"world
\n
"
print
(
"next"
)
captured
=
capsys
.
readouterr
()
assert
captured
.
out
==
"next
\n
"

```

The readouterr() call snapshots the output so far - and capturing will be continued. After the test function finishes the original streams will be restored. Using capsys this way frees your test from having to care about setting/resetting output streams and also interacts well with pytest’s own per-test capturing. The return value of readouterr() is a namedtuple with two attributes, out and err . If the code under test writes non-textual data ( bytes ), you can capture this using the capsysbinary fixture which instead returns bytes from the readouterr method. If you want to capture at the file descriptor level you can use the capfd fixture which offers the exact same interface but allows to also capture output from libraries or subprocesses that directly write to operating system level output streams (FD1 and FD2). Similarly to capsysbinary , capfdbinary can be used to capture bytes at the file descriptor level. To temporarily disable capture within a test, the capture fixtures have a disabled() method that can be used as a context manager, disabling capture inside the with block:

```

def
test_disabling_capturing
(
capsys
):
print
(
"this output is captured"
)
with
capsys
.
disabled
():
print
(
"output not captured, going directly to sys.stdout"
)
print
(
"this output is also captured"
)

```


---


# How to run doctests - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/doctest.html


# How to run doctests¶

By default, all files matching the test*.txt pattern will be run through the python standard doctest module. You can change the pattern by issuing:

```

pytest
--doctest-glob
=
"*.rst"

```

on the command line. --doctest-glob can be given multiple times in the command-line. If you then have a text file like this:

```

# content of test_example.txt

hello this is a doctest
>>> x = 3
>>> x
3

```

then you can just invoke pytest directly:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_example.txt
.
[100%]
============================
1 passed
in 0.12s =============================

```

By default, pytest will collect test*.txt files looking for doctest directives, but you can pass additional globs using the --doctest-glob option (multi-allowed). In addition to text files, you can also execute doctests directly from docstrings of your classes and functions, including from test modules:

```

# content of mymodule.py
def
something
():
"""a doctest in a docstring
>>> something()
42
"""
return
42

```

```

$
pytest
--doctest-modules
===========================
test
session
starts
============================
platform
linux
--
Python
3
.x.y,
pytest-8.x.y,
pluggy-1.x.y
rootdir:
/home/sweet/project
collected
2
items

mymodule.py
.
[
50
%
]
test_example.txt
.
[
100
%
]
============================
2
passed
in
0
.12s
=============================

```

You can make these changes permanent in your project by putting them into a pytest.ini file like this:

```

# content of pytest.ini
[pytest]
addopts
=
--doctest-modules

```

# Encoding¶

The default encoding is UTF-8 , but you can specify the encoding that will be used for those doctest files using the doctest_encoding ini option:

```

# content of pytest.ini
[pytest]
doctest_encoding
=
latin1

```

# Using ‘doctest’ options¶

Python’s standard doctest module provides some options to configure the strictness of doctest tests. In pytest, you can enable those flags using the configuration file. For example, to make pytest ignore trailing whitespaces and ignore lengthy exception stack traces you can just write:

```

[pytest]
doctest_optionflags
=
NORMALIZE_WHITESPACE IGNORE_EXCEPTION_DETAIL

```

Alternatively, options can be enabled by an inline comment in the doc test itself:

```

>>> something_that_raises()  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
ValueError: ...

```

pytest also introduces new options: ALLOW_UNICODE : when enabled, the u prefix is stripped from unicode strings in expected doctest output. This allows doctests to run in Python 2 and Python 3 unchanged. ALLOW_BYTES : similarly, the b prefix is stripped from byte strings in expected doctest output. NUMBER : when enabled, floating-point numbers only need to match as far as the precision you have written in the expected doctest output. The numbers are compared using pytest.approx() with relative tolerance equal to the precision. For example, the following output would only need to match to 2 decimal places when comparing 3.14 to pytest.approx(math.pi, rel=10**-2) :

```

>>>
math
.
pi
3.14

```

If you wrote 3.1416 then the actual output would need to match to approximately 4 decimal places; and so on. This avoids false positives caused by limited floating-point precision, like this:

```

Expected
:
0.233
Got
:
0.23300000000000001

```

NUMBER also supports lists of floating-point numbers – in fact, it matches floating-point numbers appearing anywhere in the output, even inside a string! This means that it may not be appropriate to enable globally in doctest_optionflags in your configuration file. Added in version 5.1.

# Continue on failure¶

By default, pytest would report only the first failure for a given doctest. If you want to continue the test even when you have failures, do:

```

pytest
--doctest-modules
--doctest-continue-on-failure

```

# Output format¶

You can change the diff output format on failure for your doctests by using one of standard doctest modules format in options (see doctest.REPORT_UDIFF , doctest.REPORT_CDIFF , doctest.REPORT_NDIFF , doctest.REPORT_ONLY_FIRST_FAILURE ):

```

pytest
--doctest-modules
--doctest-report
none
pytest
--doctest-modules
--doctest-report
udiff
pytest
--doctest-modules
--doctest-report
cdiff
pytest
--doctest-modules
--doctest-report
ndiff
pytest
--doctest-modules
--doctest-report
only_first_failure

```

# pytest-specific features¶

Some features are provided to make writing doctests easier or with better integration with your existing test suite. Keep in mind however that by using those features you will make your doctests incompatible with the standard doctests module.

# Using fixtures¶

It is possible to use fixtures using the getfixture helper:

```

# content of example.rst
>>> tmp = getfixture('tmp_path')
>>> ...
>>>

```

Note that the fixture needs to be defined in a place visible by pytest, for example, a conftest.py file or plugin; normal python files containing docstrings are not normally scanned for fixtures unless explicitly configured by python_files . Also, the usefixtures mark and fixtures marked as autouse are supported when executing text doctest files.

# ‘doctest_namespace’ fixture¶

The doctest_namespace fixture can be used to inject items into the namespace in which your doctests run. It is intended to be used within your own fixtures to provide the tests that use them with context. doctest_namespace is a standard dict object into which you place the objects you want to appear in the doctest namespace:

```

# content of conftest.py
import
pytest
import
numpy
@pytest
.
fixture
(
autouse
=
True
)
def
add_np
(
doctest_namespace
):
doctest_namespace
[
"np"
]
=
numpy

```

which can then be used in your doctests directly:

```

# content of numpy.py
def
arange
():
"""
>>> a = np.arange(10)
>>> len(a)
10
"""

```

Note that like the normal conftest.py , the fixtures are discovered in the directory tree conftest is in. Meaning that if you put your doctest with your source code, the relevant conftest.py needs to be in the same directory tree. Fixtures will not be discovered in a sibling directory tree!

# Skipping tests¶

For the same reasons one might want to skip normal tests, it is also possible to skip tests inside doctests. To skip a single check inside a doctest you can use the standard doctest.SKIP directive:

```

def
test_random
(
y
):
"""
>>> random.random()  # doctest: +SKIP
0.156231223
>>> 1 + 1
2
"""

```

This will skip the first check, but not the second. pytest also allows using the standard pytest functions pytest.skip() and pytest.xfail() inside doctests, which might be useful because you can then skip/xfail tests based on external conditions:

```

>>> import sys, pytest
>>> if sys.platform.startswith('win'):
...     pytest.skip('this doctest does not work on Windows')
...
>>> import fcntl
>>> ...

```

However using those functions is discouraged because it reduces the readability of the docstring. Note pytest.skip() and pytest.xfail() behave differently depending if the doctests are in a Python file (in docstrings) or a text file containing doctests intermingled with text: Python modules (docstrings): the functions only act in that specific docstring, letting the other docstrings in the same module execute as normal. Text files: the functions will skip/xfail the checks for the rest of the entire file.

# Alternatives¶


---


# Good Integration Practices - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/goodpractices.html


# Good Integration Practices¶

# Install package with pip¶

For development, we recommend you use venv for virtual environments and pip for installing your application and any dependencies, as well as the pytest package itself. This ensures your code and dependencies are isolated from your system Python installation. Create a pyproject.toml file in the root of your repository as described in Packaging Python Projects . The first few lines should look like this:

```

[build-system]
requires
=
[
"hatchling"
]
build-backend
=
"hatchling.build"
[project]
name
=
"PACKAGENAME"
version
=
"PACKAGEVERSION"

```

where PACKAGENAME and PACKAGEVERSION are the name and version of your package respectively. You can then install your package in “editable” mode by running from the same directory:

```

pip
install
-e
.

```

which lets you change your source code (both tests and application) and rerun tests at will.

# Conventions for Python test discovery¶

pytest implements the following standard test discovery: If no arguments are specified then collection starts from testpaths (if configured) or the current directory. Alternatively, command line arguments can be used in any combination of directories, file names or node ids. Recurse into directories, unless they match norecursedirs . In those directories, search for test_*.py or *_test.py files, imported by their test package name . From those files, collect test items: test prefixed test functions or methods outside of class. test prefixed test functions or methods inside Test prefixed test classes (without an __init__ method). Methods decorated with @staticmethod and @classmethods are also considered. For examples of how to customize your test discovery Changing standard (Python) test discovery . Within Python modules, pytest also discovers tests using the standard unittest.TestCase subclassing technique.

# Choosing a test layout¶

pytest supports two common test layouts:

# Tests outside application code¶

Putting tests into an extra directory outside your actual application code might be useful if you have many functional tests or for other reasons want to keep tests separate from actual application code (often a good idea):

```

pyproject.toml
src/
    mypkg/
        __init__.py
        app.py
        view.py
tests/
    test_app.py
    test_view.py
    ...

```

This has the following benefits: Your tests can run against an installed version after executing pip install . . Your tests can run against the local copy with an editable install after executing pip install --editable . . For new projects, we recommend to use importlib import mode (see which-import-mode for a detailed explanation). To this end, add the following to your pyproject.toml :

```

[tool.pytest.ini_options]
addopts
=
[
"--import-mode=importlib"
,
]

```

Generally, but especially if you use the default import mode prepend , it is strongly suggested to use a src layout. Here, your application root package resides in a sub-directory of your root, i.e. src/mypkg/ instead of mypkg . This layout prevents a lot of common pitfalls and has many benefits, which are better explained in this excellent blog post by Ionel Cristian Mărieș. Note If you do not use an editable install and use the src layout as above you need to extend the Python’s search path for module files to execute the tests against the local copy directly. You can do it in an ad-hoc manner by setting the PYTHONPATH environment variable:

```

PYTHONPATH
=
src
pytest

```

or in a permanent manner by using the pythonpath configuration variable and adding the following to your pyproject.toml :

```

[tool.pytest.ini_options]
pythonpath
=
"src"

```

Note If you do not use an editable install and not use the src layout ( mypkg directly in the root directory) you can rely on the fact that Python by default puts the current directory in sys.path to import your package and run python -m pytest to execute the tests against the local copy directly. See Invoking pytest versus python -m pytest for more information about the difference between calling pytest and python -m pytest .

# Tests as part of application code¶

Inlining test directories into your application package is useful if you have direct relation between tests and application modules and want to distribute them along with your application:

```

pyproject.toml
[src/]mypkg/
    __init__.py
    app.py
    view.py
    tests/
        __init__.py
        test_app.py
        test_view.py
        ...

```

In this scheme, it is easy to run your tests using the --pyargs option:

```

pytest
--pyargs
mypkg

```

pytest will discover where mypkg is installed and collect tests from there. Note that this layout also works in conjunction with the src layout mentioned in the previous section. Note You can use namespace packages (PEP420) for your application but pytest will still perform test package name discovery based on the presence of __init__.py files. If you use one of the two recommended file system layouts above but leave away the __init__.py files from your directories, it should just work. From “inlined tests”, however, you will need to use absolute imports for getting at your application code. Note In prepend and append import-modes, if pytest finds a "a/b/test_module.py" test file while recursing into the filesystem it determines the import name as follows: determine basedir : this is the first “upward” (towards the root) directory not containing an __init__.py . If e.g. both a and b contain an __init__.py file then the parent directory of a will become the basedir . perform sys.path.insert(0, basedir) to make the test module importable under the fully qualified import name. import a.b.test_module where the path is determined by converting path separators / into “.” characters. This means you must follow the convention of having directory and file names map directly to the import names. The reason for this somewhat evolved importing technique is that in larger projects multiple test modules might import from each other and thus deriving a canonical import name helps to avoid surprises such as a test module getting imported twice. With --import-mode=importlib things are less convoluted because pytest doesn’t need to change sys.path , making things much less surprising.

# Choosing an import mode¶

For historical reasons, pytest defaults to the prepend import mode instead of the importlib import mode we recommend for new projects. The reason lies in the way the prepend mode works: Since there are no packages to derive a full package name from, pytest will import your test files as top-level modules. The test files in the first example ( src layout ) would be imported as test_app and test_view top-level modules by adding tests/ to sys.path . This results in a drawback compared to the import mode importlib : your test files must have unique names . If you need to have test modules with the same name, as a workaround you might add __init__.py files to your tests folder and subfolders, changing them to packages:

```

pyproject.toml
mypkg/
    ...
tests/
    __init__.py
    foo/
        __init__.py
        test_view.py
    bar/
        __init__.py
        test_view.py

```

Now pytest will load the modules as tests.foo.test_view and tests.bar.test_view , allowing you to have modules with the same name. But now this introduces a subtle problem: in order to load the test modules from the tests directory, pytest prepends the root of the repository to sys.path , which adds the side-effect that now mypkg is also importable. This is problematic if you are using a tool like tox to test your package in a virtual environment, because you want to test the installed version of your package, not the local code from the repository. The importlib import mode does not have any of the drawbacks above, because sys.path is not changed when importing test modules.

# tox¶

Once you are done with your work and want to make sure that your actual package passes all tests you may want to look into tox , the virtualenv test automation tool. tox helps you to setup virtualenv environments with pre-defined dependencies and then executing a pre-configured test command with options. It will run tests against the installed package and not against your source code checkout, helping to detect packaging glitches.

# Do not run via setuptools¶

Integration with setuptools is not recommended , i.e. you should not be using python setup.py test or pytest-runner , and may stop working in the future. This is deprecated since it depends on deprecated features of setuptools and relies on features that break security mechanisms in pip. For example ‘setup_requires’ and ‘tests_require’ bypass pip --require-hashes . For more information and migration instructions, see the pytest-runner notice . See also pypa/setuptools#1684 . setuptools intends to remove the test command .

# Checking with flake8-pytest-style¶


---


# Demo of Python failure reports with pytest - pytest documentation

URL: https://docs.pytest.org/en/stable/example/reportingdemo.html


# Demo of Python failure reports with pytest¶

Here is a nice run of several failures and how pytest presents things:

```

assertion $ pytest failure_demo.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project/assertion
collected 44 items

failure_demo.py
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
[100%]
================================= FAILURES =================================
___________________________ test_generative[3-6] ___________________________
param1 = 3, param2 = 6

    @pytest.mark.parametrize("param1, param2", [(3, 6)])
    def test_generative(param1, param2):
>       assert param1 * 2 < param2
E       assert (3 * 2) < 6
failure_demo.py
:21: AssertionError
_________________________ TestFailing.test_simple __________________________
self = <failure_demo.TestFailing object at 0xdeadbeef0001>

    def test_simple(self):
        def f():
            return 42

        def g():
            return 43

>       assert f() == g()
E       assert 42 == 43
E        +  where 42 = <function TestFailing.test_simple.<locals>.f at 0xdeadbeef0002>()
E        +  and   43 = <function TestFailing.test_simple.<locals>.g at 0xdeadbeef0003>()
failure_demo.py
:32: AssertionError
____________________ TestFailing.test_simple_multiline _____________________
self = <failure_demo.TestFailing object at 0xdeadbeef0004>

    def test_simple_multiline(self):
>       otherfunc_multi(42, 6 * 9)
failure_demo.py
:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
a = 42, b = 54

    def otherfunc_multi(a, b):
>       assert a == b
E       assert 42 == 54
failure_demo.py
:16: AssertionError
___________________________ TestFailing.test_not ___________________________
self = <failure_demo.TestFailing object at 0xdeadbeef0005>

    def test_not(self):
        def f():
            return 42

>       assert not f()
E       assert not 42
E        +  where 42 = <function TestFailing.test_not.<locals>.f at 0xdeadbeef0006>()
failure_demo.py
:41: AssertionError
_________________ TestSpecialisedExplanations.test_eq_text _________________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0007>

    def test_eq_text(self):
>       assert "spam" == "eggs"
E       AssertionError: assert 'spam' == 'eggs'
E
E         - eggs
E         + spam
failure_demo.py
:46: AssertionError
_____________ TestSpecialisedExplanations.test_eq_similar_text _____________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0008>

    def test_eq_similar_text(self):
>       assert "foo 1 bar" == "foo 2 bar"
E       AssertionError: assert 'foo 1 bar' == 'foo 2 bar'
E
E         - foo 2 bar
E         ?     ^
E         + foo 1 bar
E         ?     ^
failure_demo.py
:49: AssertionError
____________ TestSpecialisedExplanations.test_eq_multiline_text ____________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0009>

    def test_eq_multiline_text(self):
>       assert "foo\nspam\nbar" == "foo\neggs\nbar"
E       AssertionError: assert 'foo\nspam\nbar' == 'foo\neggs\nbar'
E
E           foo
E         - eggs
E         + spam
E           bar
failure_demo.py
:52: AssertionError
______________ TestSpecialisedExplanations.test_eq_long_text _______________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef000a>

    def test_eq_long_text(self):
        a = "1" * 100 + "a" + "2" * 100
        b = "1" * 100 + "b" + "2" * 100
>       assert a == b
E       AssertionError: assert '111111111111...2222222222222' == '111111111111...2222222222222'
E
E         Skipping 90 identical leading characters in diff, use -v to show
E         Skipping 91 identical trailing characters in diff, use -v to show
E         - 1111111111b222222222
E         ?           ^
E         + 1111111111a222222222
E         ?           ^
failure_demo.py
:57: AssertionError
_________ TestSpecialisedExplanations.test_eq_long_text_multiline __________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef000b>

    def test_eq_long_text_multiline(self):
        a = "1\n" * 100 + "a" + "2\n" * 100
        b = "1\n" * 100 + "b" + "2\n" * 100
>       assert a == b
E       AssertionError: assert '1\n1\n1\n1\n...n2\n2\n2\n2\n' == '1\n1\n1\n1\n...n2\n2\n2\n2\n'
E
E         Skipping 190 identical leading characters in diff, use -v to show
E         Skipping 191 identical trailing characters in diff, use -v to show
E           1
E           1
E           1
E           1...
E
E         ...Full output truncated (7 lines hidden), use '-vv' to show
failure_demo.py
:62: AssertionError
_________________ TestSpecialisedExplanations.test_eq_list _________________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef000c>

    def test_eq_list(self):
>       assert [0, 1, 2] == [0, 1, 3]
E       assert [0, 1, 2] == [0, 1, 3]
E
E         At index 2 diff: 2 != 3
E         Use -v to get more diff
failure_demo.py
:65: AssertionError
______________ TestSpecialisedExplanations.test_eq_list_long _______________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef000d>

    def test_eq_list_long(self):
        a = [0] * 100 + [1] + [3] * 100
        b = [0] * 100 + [2] + [3] * 100
>       assert a == b
E       assert [0, 0, 0, 0, 0, 0, ...] == [0, 0, 0, 0, 0, 0, ...]
E
E         At index 100 diff: 1 != 2
E         Use -v to get more diff
failure_demo.py
:70: AssertionError
_________________ TestSpecialisedExplanations.test_eq_dict _________________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef000e>

    def test_eq_dict(self):
>       assert {"a": 0, "b": 1, "c": 0} == {"a": 0, "b": 2, "d": 0}
E       AssertionError: assert {'a': 0, 'b': 1, 'c': 0} == {'a': 0, 'b': 2, 'd': 0}
E
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {'b': 1} != {'b': 2}
E         Left contains 1 more item:
E         {'c': 0}
E         Right contains 1 more item:
E         {'d': 0}
E         Use -v to get more diff
failure_demo.py
:73: AssertionError
_________________ TestSpecialisedExplanations.test_eq_set __________________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef000f>

    def test_eq_set(self):
>       assert {0, 10, 11, 12} == {0, 20, 21}
E       assert {0, 10, 11, 12} == {0, 20, 21}
E
E         Extra items in the left set:
E         10
E         11
E         12
E         Extra items in the right set:
E         20
E         21
E         Use -v to get more diff
failure_demo.py
:76: AssertionError
_____________ TestSpecialisedExplanations.test_eq_longer_list ______________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0010>

    def test_eq_longer_list(self):
>       assert [1, 2] == [1, 2, 3]
E       assert [1, 2] == [1, 2, 3]
E
E         Right contains one more item: 3
E         Use -v to get more diff
failure_demo.py
:79: AssertionError
_________________ TestSpecialisedExplanations.test_in_list _________________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0011>

    def test_in_list(self):
>       assert 1 in [0, 2, 3, 4, 5]
E       assert 1 in [0, 2, 3, 4, 5]
failure_demo.py
:82: AssertionError
__________ TestSpecialisedExplanations.test_not_in_text_multiline __________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0012>

    def test_not_in_text_multiline(self):
        text = "some multiline\ntext\nwhich\nincludes foo\nand a\ntail"
>       assert "foo" not in text
E       AssertionError: assert 'foo' not in 'some multil...nand a\ntail'
E
E         'foo' is contained here:
E           some multiline
E           text
E           which
E           includes foo
E         ?          +++
E           and a
E           tail
failure_demo.py
:86: AssertionError
___________ TestSpecialisedExplanations.test_not_in_text_single ____________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0013>

    def test_not_in_text_single(self):
        text = "single foo line"
>       assert "foo" not in text
E       AssertionError: assert 'foo' not in 'single foo line'
E
E         'foo' is contained here:
E           single foo line
E         ?        +++
failure_demo.py
:90: AssertionError
_________ TestSpecialisedExplanations.test_not_in_text_single_long _________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0014>

    def test_not_in_text_single_long(self):
        text = "head " * 50 + "foo " + "tail " * 20
>       assert "foo" not in text
E       AssertionError: assert 'foo' not in 'head head h...l tail tail '
E
E         'foo' is contained here:
E           head head foo tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail
E         ?           +++
failure_demo.py
:94: AssertionError
______ TestSpecialisedExplanations.test_not_in_text_single_long_term _______
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0015>

    def test_not_in_text_single_long_term(self):
        text = "head " * 50 + "f" * 70 + "tail " * 20
>       assert "f" * 70 not in text
E       AssertionError: assert 'fffffffffff...ffffffffffff' not in 'head head h...l tail tail '
E
E         'ffffffffffffffffff...fffffffffffffffffff' is contained here:
E           head head fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffftail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail tail
E         ?           ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
failure_demo.py
:98: AssertionError
______________ TestSpecialisedExplanations.test_eq_dataclass _______________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0016>

    def test_eq_dataclass(self):
        from dataclasses import dataclass

        @dataclass
        class Foo:
            a: int
            b: str

        left = Foo(1, "b")
        right = Foo(1, "c")
>       assert left == right
E       AssertionError: assert TestSpecialis...oo(a=1, b='b') == TestSpecialis...oo(a=1, b='c')
E
E         Omitting 1 identical items, use -vv to show
E         Differing attributes:
E         ['b']
E
E         Drill down into differing attribute b:
E           b: 'b' != 'c'
E           - c
E           + b
failure_demo.py
:110: AssertionError
________________ TestSpecialisedExplanations.test_eq_attrs _________________
self = <failure_demo.TestSpecialisedExplanations object at 0xdeadbeef0017>

    def test_eq_attrs(self):
        import attr

        @attr.s
        class Foo:
            a = attr.ib()
            b = attr.ib()

        left = Foo(1, "b")
        right = Foo(1, "c")
>       assert left == right
E       AssertionError: assert Foo(a=1, b='b') == Foo(a=1, b='c')
E
E         Omitting 1 identical items, use -vv to show
E         Differing attributes:
E         ['b']
E
E         Drill down into differing attribute b:
E           b: 'b' != 'c'
E           - c
E           + b
failure_demo.py
:122: AssertionError
______________________________ test_attribute ______________________________
def test_attribute():
        class Foo:
            b = 1

        i = Foo()
>       assert i.b == 2
E       assert 1 == 2
E        +  where 1 = <failure_demo.test_attribute.<locals>.Foo object at 0xdeadbeef0018>.b
failure_demo.py
:130: AssertionError
_________________________ test_attribute_instance __________________________
def test_attribute_instance():
        class Foo:
            b = 1

>       assert Foo().b == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = <failure_demo.test_attribute_instance.<locals>.Foo object at 0xdeadbeef0019>.b
E        +    where <failure_demo.test_attribute_instance.<locals>.Foo object at 0xdeadbeef0019> = <class 'failure_demo.test_attribute_instance.<locals>.Foo'>()
failure_demo.py
:137: AssertionError
__________________________ test_attribute_failure __________________________
def test_attribute_failure():
        class Foo:
            def _get_b(self):
                raise Exception("Failed to get attrib")

            b = property(_get_b)

        i = Foo()
>       assert i.b == 2
failure_demo.py
:148:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
self = <failure_demo.test_attribute_failure.<locals>.Foo object at 0xdeadbeef001a>

    def _get_b(self):
>       raise Exception("Failed to get attrib")
E       Exception: Failed to get attrib
failure_demo.py
:143: Exception
_________________________ test_attribute_multiple __________________________
def test_attribute_multiple():
        class Foo:
            b = 1

        class Bar:
            b = 2

>       assert Foo().b == Bar().b
E       AssertionError: assert 1 == 2
E        +  where 1 = <failure_demo.test_attribute_multiple.<locals>.Foo object at 0xdeadbeef001b>.b
E        +    where <failure_demo.test_attribute_multiple.<locals>.Foo object at 0xdeadbeef001b> = <class 'failure_demo.test_attribute_multiple.<locals>.Foo'>()
E        +  and   2 = <failure_demo.test_attribute_multiple.<locals>.Bar object at 0xdeadbeef001c>.b
E        +    where <failure_demo.test_attribute_multiple.<locals>.Bar object at 0xdeadbeef001c> = <class 'failure_demo.test_attribute_multiple.<locals>.Bar'>()
failure_demo.py
:158: AssertionError
__________________________ TestRaises.test_raises __________________________
self = <failure_demo.TestRaises object at 0xdeadbeef001d>

    def test_raises(self):
        s = "qwe"
>       raises(TypeError, int, s)
E       ValueError: invalid literal for int() with base 10: 'qwe'
failure_demo.py
:168: ValueError
______________________ TestRaises.test_raises_doesnt _______________________
self = <failure_demo.TestRaises object at 0xdeadbeef001e>

    def test_raises_doesnt(self):
>       raises(OSError, int, "3")
E       Failed: DID NOT RAISE <class 'OSError'>
failure_demo.py
:171: Failed
__________________________ TestRaises.test_raise ___________________________
self = <failure_demo.TestRaises object at 0xdeadbeef001f>

    def test_raise(self):
>       raise ValueError("demo error")
E       ValueError: demo error
failure_demo.py
:174: ValueError
________________________ TestRaises.test_tupleerror ________________________
self = <failure_demo.TestRaises object at 0xdeadbeef0020>

    def test_tupleerror(self):
>       a, b = [1]  # noqa: F841
E       ValueError: not enough values to unpack (expected 2, got 1)
failure_demo.py
:177: ValueError
______ TestRaises.test_reinterpret_fails_with_print_for_the_fun_of_it ______
self = <failure_demo.TestRaises object at 0xdeadbeef0021>

    def test_reinterpret_fails_with_print_for_the_fun_of_it(self):
        items = [1, 2, 3]
        print(f"items is {items!r}")
>       a, b = items.pop()
E       TypeError: cannot unpack non-iterable int object
failure_demo.py
:182: TypeError
--------------------------- Captured stdout call ---------------------------
items is [1, 2, 3]
________________________ TestRaises.test_some_error ________________________
self = <failure_demo.TestRaises object at 0xdeadbeef0022>

    def test_some_error(self):
>       if namenotexi:  # noqa: F821
E       NameError: name 'namenotexi' is not defined
failure_demo.py
:185: NameError
____________________ test_dynamic_compile_shows_nicely _____________________
def test_dynamic_compile_shows_nicely():
        import importlib.util
        import sys

        src = "def foo():\n assert 1 == 0\n"
        name = "abc-123"
        spec = importlib.util.spec_from_loader(name, loader=None)
        module = importlib.util.module_from_spec(spec)
        code = compile(src, name, "exec")
        exec(code, module.__dict__)
        sys.modules[name] = module
>       module.foo()
failure_demo.py
:204:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
>   ???
E   AssertionError
abc-123
:2: AssertionError
____________________ TestMoreErrors.test_complex_error _____________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef0023>

    def test_complex_error(self):
        def f():
            return 44

        def g():
            return 43

>       somefunc(f(), g())
failure_demo.py
:215:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
failure_demo.py
:12: in somefunc
    otherfunc(x, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
a = 44, b = 43

    def otherfunc(a, b):
>       assert a == b
E       assert 44 == 43
failure_demo.py
:8: AssertionError
___________________ TestMoreErrors.test_z1_unpack_error ____________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef0024>

    def test_z1_unpack_error(self):
        items = []
>       a, b = items
E       ValueError: not enough values to unpack (expected 2, got 0)
failure_demo.py
:219: ValueError
____________________ TestMoreErrors.test_z2_type_error _____________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef0025>

    def test_z2_type_error(self):
        items = 3
>       a, b = items
E       TypeError: cannot unpack non-iterable int object
failure_demo.py
:223: TypeError
______________________ TestMoreErrors.test_startswith ______________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef0026>

    def test_startswith(self):
        s = "123"
        g = "456"
>       assert s.startswith(g)
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0xdeadbeef0027>('456')
E        +    where <built-in method startswith of str object at 0xdeadbeef0027> = '123'.startswith
failure_demo.py
:228: AssertionError
__________________ TestMoreErrors.test_startswith_nested ___________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef0028>

    def test_startswith_nested(self):
        def f():
            return "123"

        def g():
            return "456"

>       assert f().startswith(g())
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0xdeadbeef0027>('456')
E        +    where <built-in method startswith of str object at 0xdeadbeef0027> = '123'.startswith
E        +      where '123' = <function TestMoreErrors.test_startswith_nested.<locals>.f at 0xdeadbeef0029>()
E        +    and   '456' = <function TestMoreErrors.test_startswith_nested.<locals>.g at 0xdeadbeef0003>()
failure_demo.py
:237: AssertionError
_____________________ TestMoreErrors.test_global_func ______________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef002a>

    def test_global_func(self):
>       assert isinstance(globf(42), float)
E       assert False
E        +  where False = isinstance(43, float)
E        +    where 43 = globf(42)
failure_demo.py
:240: AssertionError
_______________________ TestMoreErrors.test_instance _______________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef002b>

    def test_instance(self):
        self.x = 6 * 7
>       assert self.x != 42
E       assert 42 != 42
E        +  where 42 = <failure_demo.TestMoreErrors object at 0xdeadbeef002b>.x
failure_demo.py
:244: AssertionError
_______________________ TestMoreErrors.test_compare ________________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef002c>

    def test_compare(self):
>       assert globf(10) < 5
E       assert 11 < 5
E        +  where 11 = globf(10)
failure_demo.py
:247: AssertionError
_____________________ TestMoreErrors.test_try_finally ______________________
self = <failure_demo.TestMoreErrors object at 0xdeadbeef002d>

    def test_try_finally(self):
        x = 1
        try:
>           assert x == 0
E           assert 1 == 0
failure_demo.py
:252: AssertionError
___________________ TestCustomAssertMsg.test_single_line ___________________
self = <failure_demo.TestCustomAssertMsg object at 0xdeadbeef002e>

    def test_single_line(self):
        class A:
            a = 1

        b = 2
>       assert A.a == b, "A.a appears not to be b"
E       AssertionError: A.a appears not to be b
E       assert 1 == 2
E        +  where 1 = <class 'failure_demo.TestCustomAssertMsg.test_single_line.<locals>.A'>.a
failure_demo.py
:263: AssertionError
____________________ TestCustomAssertMsg.test_multiline ____________________
self = <failure_demo.TestCustomAssertMsg object at 0xdeadbeef002f>

    def test_multiline(self):
        class A:
            a = 1

        b = 2
>       assert (
            A.a == b
        ), "A.a appears not to be b\nor does not appear to be b\none of those"
E       AssertionError: A.a appears not to be b
E         or does not appear to be b
E         one of those
E       assert 1 == 2
E        +  where 1 = <class 'failure_demo.TestCustomAssertMsg.test_multiline.<locals>.A'>.a
failure_demo.py
:270: AssertionError
___________________ TestCustomAssertMsg.test_custom_repr ___________________
self = <failure_demo.TestCustomAssertMsg object at 0xdeadbeef0030>

    def test_custom_repr(self):
        class JSON:
            a = 1

            def __repr__(self):
                return "This is JSON\n{\n  'foo': 'bar'\n}"

        a = JSON()
        b = 2
>       assert a.a == b, a
E       AssertionError: This is JSON
E         {
E           'foo': 'bar'
E         }
E       assert 1 == 2
E        +  where 1 = This is JSON\n{\n  'foo': 'bar'\n}.a
failure_demo.py
:283: AssertionError
========================= short test summary info ==========================
FAILED
failure_demo.py::
test_generative[3-6]
- assert (3 * 2) < 6
FAILED
failure_demo.py::
TestFailing::test_simple
- assert 42 == 43
FAILED
failure_demo.py::
TestFailing::test_simple_multiline
- assert 42 == 54
FAILED
failure_demo.py::
TestFailing::test_not
- assert not 42
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_text
- Asser...
FAILED
failure_demo.py::TestSpecialisedExplanations::test_eq_similar_text
FAILED
failure_demo.py::TestSpecialisedExplanations::test_eq_multiline_text
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_long_text
- ...
FAILED
failure_demo.py::TestSpecialisedExplanations::test_eq_long_text_multiline
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_list
- asser...
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_list_long
- ...
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_dict
- Asser...
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_set
- assert...
FAILED
failure_demo.py::TestSpecialisedExplanations::test_eq_longer_list
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_in_list
- asser...
FAILED
failure_demo.py::TestSpecialisedExplanations::test_not_in_text_multiline
FAILED
failure_demo.py::TestSpecialisedExplanations::test_not_in_text_single
FAILED
failure_demo.py::TestSpecialisedExplanations::test_not_in_text_single_long
FAILED
failure_demo.py::TestSpecialisedExplanations::test_not_in_text_single_long_term
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_dataclass
- ...
FAILED
failure_demo.py::
TestSpecialisedExplanations::test_eq_attrs
- Asse...
FAILED
failure_demo.py::
test_attribute
- assert 1 == 2
FAILED
failure_demo.py::
test_attribute_instance
- AssertionError: assert ...
FAILED
failure_demo.py::
test_attribute_failure
- Exception: Failed to get...
FAILED
failure_demo.py::
test_attribute_multiple
- AssertionError: assert ...
FAILED
failure_demo.py::
TestRaises::test_raises
- ValueError: invalid lit...
FAILED
failure_demo.py::
TestRaises::test_raises_doesnt
- Failed: DID NOT ...
FAILED
failure_demo.py::
TestRaises::test_raise
- ValueError: demo error
FAILED
failure_demo.py::
TestRaises::test_tupleerror
- ValueError: not eno...
FAILED
failure_demo.py::TestRaises::test_reinterpret_fails_with_print_for_the_fun_of_it
FAILED
failure_demo.py::
TestRaises::test_some_error
- NameError: name 'na...
FAILED
failure_demo.py::
test_dynamic_compile_shows_nicely
- AssertionError
FAILED
failure_demo.py::
TestMoreErrors::test_complex_error
- assert 44 == 43
FAILED
failure_demo.py::
TestMoreErrors::test_z1_unpack_error
- ValueError...
FAILED
failure_demo.py::
TestMoreErrors::test_z2_type_error
- TypeError: c...
FAILED
failure_demo.py::
TestMoreErrors::test_startswith
- AssertionError:...
FAILED
failure_demo.py::
TestMoreErrors::test_startswith_nested
- Assertio...
FAILED
failure_demo.py::
TestMoreErrors::test_global_func
- assert False
FAILED
failure_demo.py::
TestMoreErrors::test_instance
- assert 42 != 42
FAILED
failure_demo.py::
TestMoreErrors::test_compare
- assert 11 < 5
FAILED
failure_demo.py::
TestMoreErrors::test_try_finally
- assert 1 == 0
FAILED
failure_demo.py::
TestCustomAssertMsg::test_single_line
- Assertion...
FAILED
failure_demo.py::
TestCustomAssertMsg::test_multiline
- AssertionEr...
FAILED
failure_demo.py::
TestCustomAssertMsg::test_custom_repr
- Assertion...
============================
44 failed
in 0.12s ============================

```


---


# Contact channels - pytest documentation

URL: https://docs.pytest.org/en/stable/contact.html


# Contact channels¶

# Web¶

pytest issue tracker to report bugs or suggest features. pytest discussions at GitHub for general questions. pytest on stackoverflow.com to post precise questions with the tag pytest . New questions will usually be seen by pytest users or developers and answered quickly.

# Chat¶

pytest discord server for pytest development visibility and general assistance. #pytest on irc.libera.chat IRC channel for random questions (using an IRC client, or via webchat ) #pytest on Matrix .

# Microblogging¶

Bluesky: @pytest.org Mastodon: @pytest@fosstodon.org Twitter/X: @pytestdotorg

# Mail¶

Testing In Python : a mailing list for Python testing tools and discussion. pytest-dev at python.org a mailing list for pytest specific announcements and discussions. Mail to core @ pytest . org for topics that cannot be discussed in public. Mails sent there will be distributed among the members in the pytest core team, who can also be contacted individually: Bruno Oliveira ( @nicoddemus , bruno @ pytest . org ) Florian Bruhin ( @The-Compiler , florian @ pytest . org ) Pierre Sassoulas ( @Pierre-Sassoulas , pierre @ pytest . org ) Ran Benita ( @bluetech , ran @ pytest . org ) Ronny Pfannschmidt ( @RonnyPfannschmidt , ronny @ pytest . org ) Zac Hatfield-Dodds ( @Zac-HD , zac @ pytest . org )

# Other¶


---


# Writing plugins - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/writing_plugins.html


# Writing plugins¶

It is easy to implement local conftest plugins for your own project or pip-installable plugins that can be used throughout many projects, including third party projects. Please refer to How to install and use plugins if you only want to use but not write plugins. A plugin contains one or multiple hook functions. Writing hooks explains the basics and details of how you can write a hook function yourself. pytest implements all aspects of configuration, collection, running and reporting by calling well specified hooks of the following plugins: builtin plugins: loaded from pytest’s internal _pytest directory. external plugins : installed third-party modules discovered through entry points in their packaging metadata conftest.py plugins : modules auto-discovered in test directories In principle, each hook call is a 1:N Python function call where N is the number of registered implementation functions for a given specification. All specifications and implementations follow the pytest_ prefix naming convention, making them easy to distinguish and find.

# Plugin discovery order at tool startup¶

pytest loads plugin modules at tool startup in the following way: by scanning the command line for the -p no:name option and blocking that plugin from being loaded (even builtin plugins can be blocked this way). This happens before normal command-line parsing. by loading all builtin plugins. by scanning the command line for the -p name option and loading the specified plugin. This happens before normal command-line parsing. by loading all plugins registered through installed third-party package entry points , unless the PYTEST_DISABLE_PLUGIN_AUTOLOAD environment variable is set. by loading all plugins specified through the PYTEST_PLUGINS environment variable. by loading all “initial “ conftest.py files: determine the test paths: specified on the command line, otherwise in testpaths if defined and running from the rootdir, otherwise the current dir for each test path, load conftest.py and test*/conftest.py relative to the directory part of the test path, if exist. Before a conftest.py file is loaded, load conftest.py files in all of its parent directories. After a conftest.py file is loaded, recursively load all plugins specified in its pytest_plugins variable if present.

# conftest.py: local per-directory plugins¶

Local conftest.py plugins contain directory-specific hook implementations. Hook Session and test running activities will invoke all hooks defined in conftest.py files closer to the root of the filesystem. Example of implementing the pytest_runtest_setup hook so that is called for tests in the a sub directory but not for other directories:

```

a
/
conftest
.
py
:
def
pytest_runtest_setup
(
item
):
# called for running each test in 'a' directory
print
(
"setting up"
,
item
)
a
/
test_sub
.
py
:
def
test_sub
():
pass
test_flat
.
py
:
def
test_flat
():
pass

```

Here is how you might run it:

```

pytest
test_flat
.
py
--
capture
=
no
# will not show "setting up"
pytest
a
/
test_sub
.
py
--
capture
=
no
# will show "setting up"

```

Note If you have conftest.py files which do not reside in a python package directory (i.e. one containing an __init__.py ) then “import conftest” can be ambiguous because there might be other conftest.py files as well on your PYTHONPATH or sys.path . It is thus good practice for projects to either put conftest.py under a package scope or to never import anything from a conftest.py file. See also: pytest import mechanisms and sys.path/PYTHONPATH . Note Some hooks cannot be implemented in conftest.py files which are not initial due to how pytest discovers plugins during startup. See the documentation of each hook for details.

# Writing your own plugin¶

If you want to write a plugin, there are many real-life examples you can copy from: a custom collection example plugin: A basic example for specifying tests in Yaml files builtin plugins which provide pytest’s own functionality many external plugins providing additional features All of these plugins implement hooks and/or fixtures to extend and add functionality. Note Make sure to check out the excellent cookiecutter-pytest-plugin project, which is a cookiecutter template for authoring plugins. The template provides an excellent starting point with a working plugin, tests running with tox, a comprehensive README file as well as a pre-configured entry-point. Also consider contributing your plugin to pytest-dev once it has some happy users other than yourself.

# Making your plugin installable by others¶

If you want to make your plugin externally available, you may define a so-called entry point for your distribution so that pytest finds your plugin module. Entry points are a feature that is provided by packaging tools . pytest looks up the pytest11 entrypoint to discover its plugins, thus you can make your plugin available by defining it in your pyproject.toml file.

```

# sample ./pyproject.toml file
[build-system]
requires
=
[
"hatchling"
]
build-backend
=
"hatchling.build"
[project]
name
=
"myproject"
classifiers
=
[
"Framework :: Pytest"
,
]
[project.entry-points.pytest11]
myproject
=
"myproject.pluginmodule"

```

If a package is installed this way, pytest will load myproject.pluginmodule as a plugin which can define hooks . Confirm registration with pytest --trace-config Note Make sure to include Framework :: Pytest in your list of PyPI classifiers to make it easy for users to find your plugin.

# Assertion Rewriting¶

One of the main features of pytest is the use of plain assert statements and the detailed introspection of expressions upon assertion failures. This is provided by “assertion rewriting” which modifies the parsed AST before it gets compiled to bytecode. This is done via a PEP 302 import hook which gets installed early on when pytest starts up and will perform this rewriting when modules get imported. However, since we do not want to test different bytecode from what you will run in production, this hook only rewrites test modules themselves (as defined by the python_files configuration option), and any modules which are part of plugins. Any other imported module will not be rewritten and normal assertion behaviour will happen. If you have assertion helpers in other modules where you would need assertion rewriting to be enabled you need to ask pytest explicitly to rewrite this module before it gets imported. Register one or more module names to be rewritten on import. This function will make sure that this module or all modules inside the package will get their assert statements rewritten. Thus you should make sure to call this before the module is actually imported, usually in your __init__.py if you are a plugin using a package. names ( str ) – The module names to register. This is especially important when you write a pytest plugin which is created using a package. The import hook only treats conftest.py files and any modules which are listed in the pytest11 entrypoint as plugins. As an example consider the following package:

```

pytest_foo
/
__init__
.
py
pytest_foo
/
plugin
.
py
pytest_foo
/
helper
.
py

```

With the following typical setup.py extract:

```

setup
(
...
,
entry_points
=
{
"pytest11"
:
[
"foo = pytest_foo.plugin"
]},
...
)

```

In this case only pytest_foo/plugin.py will be rewritten. If the helper module also contains assert statements which need to be rewritten it needs to be marked as such, before it gets imported. This is easiest by marking it for rewriting inside the __init__.py module, which will always be imported first when a module inside a package is imported. This way plugin.py can still import helper.py normally. The contents of pytest_foo/__init__.py will then need to look like this:

```

import
pytest
pytest
.
register_assert_rewrite
(
"pytest_foo.helper"
)

```

# Requiring/Loading plugins in a test module or conftest file¶

You can require plugins in a test module or a conftest.py file using pytest_plugins :

```

pytest_plugins
=
[
"name1"
,
"name2"
]

```

When the test module or conftest plugin is loaded the specified plugins will be loaded as well. Any module can be blessed as a plugin, including internal application modules:

```

pytest_plugins
=
"myapp.testsupport.myplugin"

```

pytest_plugins are processed recursively, so note that in the example above if myapp.testsupport.myplugin also declares pytest_plugins , the contents of the variable will also be loaded as plugins, and so on. Note Requiring plugins using pytest_plugins variable in non-root conftest.py files is deprecated. This is important because conftest.py files implement per-directory hook implementations, but once a plugin is imported, it will affect the entire directory tree. In order to avoid confusion, defining pytest_plugins in any conftest.py file which is not located in the tests root directory is deprecated, and will raise a warning. This mechanism makes it easy to share fixtures within applications or even external applications without the need to create external plugins using the entry point packaging metadata technique. Plugins imported by pytest_plugins will also automatically be marked for assertion rewriting (see pytest.register_assert_rewrite() ). However for this to have any effect the module must not be imported already; if it was already imported at the time the pytest_plugins statement is processed, a warning will result and assertions inside the plugin will not be rewritten. To fix this you can either call pytest.register_assert_rewrite() yourself before the module is imported, or you can arrange the code to delay the importing until after the plugin is registered.

# Accessing another plugin by name¶

If a plugin wants to collaborate with code from another plugin it can obtain a reference through the plugin manager like this:

```

plugin
=
config
.
pluginmanager
.
get_plugin
(
"name_of_plugin"
)

```

If you want to look at the names of existing plugins, use the --trace-config option.

# Registering custom markers¶

If your plugin uses any markers, you should register them so that they appear in pytest’s help text and do not cause spurious warnings . For example, the following plugin would register cool_marker and mark_with for all users:

```

def
pytest_configure
(
config
):
config
.
addinivalue_line
(
"markers"
,
"cool_marker: this one is for cool tests."
)
config
.
addinivalue_line
(
"markers"
,
"mark_with(arg, arg2): this marker takes arguments."
)

```

# Testing plugins¶

pytest comes with a plugin named pytester that helps you write tests for your plugin code. The plugin is disabled by default, so you will have to enable it before you can use it. You can do so by adding the following line to a conftest.py file in your testing directory:

```

# content of conftest.py
pytest_plugins
=
[
"pytester"
]

```

Alternatively you can invoke pytest with the -p pytester command line option. This will allow you to use the pytester fixture for testing your plugin code. Let’s demonstrate what you can do with the plugin with an example. Imagine we developed a plugin that provides a fixture hello which yields a function and we can invoke this function with one optional parameter. It will return a string value of Hello World! if we do not supply a value or Hello {value}! if we do supply a string value.

```

import
pytest
def
pytest_addoption
(
parser
):
group
=
parser
.
getgroup
(
"helloworld"
)
group
.
addoption
(
"--name"
,
action
=
"store"
,
dest
=
"name"
,
default
=
"World"
,
help
=
'Default "name" for hello().'
,
)
@pytest
.
fixture
def
hello
(
request
):
name
=
request
.
config
.
getoption
(
"name"
)
def
_hello
(
name
=
None
):
if
not
name
:
name
=
request
.
config
.
getoption
(
"name"
)
return
f
"Hello
{
name
}
!"
return
_hello

```

Now the pytester fixture provides a convenient API for creating temporary conftest.py files and test files. It also allows us to run the tests and return a result object, with which we can assert the tests’ outcomes.

```

def
test_hello
(
pytester
):
"""Make sure that our plugin works."""
# create a temporary conftest.py file
pytester
.
makeconftest
(
"""
import pytest
@pytest.fixture(params=[
"Brianna",
"Andreas",
"Floris",
])
def name(request):
return request.param
"""
)
# create a temporary pytest test file
pytester
.
makepyfile
(
"""
def test_hello_default(hello):
assert hello() == "Hello World!"
def test_hello_name(hello, name):
assert hello(name) == "Hello {0}!".format(name)
"""
)
# run all tests with pytest
result
=
pytester
.
runpytest
()
# check that all 4 tests passed
result
.
assert_outcomes
(
passed
=
4
)

```

Additionally it is possible to copy examples to the pytester ’s isolated environment before running pytest on it. This way we can abstract the tested logic to separate files, which is especially useful for longer tests and/or longer conftest.py files. Note that for pytester.copy_example to work we need to set pytester_example_dir in our pytest.ini to tell pytest where to look for example files.

```

# content of pytest.ini
[pytest]
pytester_example_dir
=
.

```

```

# content of test_example.py
def
test_plugin
(
pytester
):
pytester
.
copy_example
(
"test_example.py"
)
pytester
.
runpytest
(
"-k"
,
"test_example"
)
def
test_example
():
pass

```

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
configfile: pytest.ini
collected 2 items

test_example.py
..
[100%]
============================
2 passed
in 0.12s =============================

```


---


# Examples and customization tricks - pytest documentation

URL: https://docs.pytest.org/en/stable/example/index.html


# Examples and customization tricks¶


---


# How to handle test failures - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/failures.html


# How to handle test failures¶

# Stopping after the first (or N) failures¶

To stop the testing process after the first (N) failures:

```

pytest
-x
# stop after first failure
pytest
--maxfail
=
2
# stop after two failures

```

# Usingpdb — The Python Debuggerwith pytest¶

# Dropping topdbon failures¶

Python comes with a builtin Python debugger called pdb . pytest allows one to drop into the pdb prompt via a command line option:

```

pytest
--pdb

```

This will invoke the Python debugger on every failure (or KeyboardInterrupt). Often you might only want to do this for the first failing test to understand a certain failure situation:

```

pytest
-x
--pdb
# drop to PDB on first failure, then end test session
pytest
--pdb
--maxfail
=
3
# drop to PDB for first three failures

```

Note that on any failure the exception information is stored on sys.last_value , sys.last_type and sys.last_traceback . In interactive use, this allows one to drop into postmortem debugging with any debug tool. One can also manually access the exception information, for example:

```

>>>
import
sys
>>>
sys
.
last_traceback
.
tb_lineno
42
>>>
sys
.
last_value
AssertionError('assert result == "ok"',)

```

# Dropping topdbat the start of a test¶

pytest allows one to drop into the pdb prompt immediately at the start of each test via a command line option:

```

pytest
--trace

```

This will invoke the Python debugger at the start of every test.

# Setting breakpoints¶

To set a breakpoint in your code use the native Python import pdb;pdb.set_trace() call in your code and pytest automatically disables its output capture for that test: Output capture in other tests is not affected. Any prior test output that has already been captured and will be processed as such. Output capture gets resumed when ending the debugger session (via the continue command).

# Using the builtin breakpoint function¶

Python 3.7 introduces a builtin breakpoint() function. Pytest supports the use of breakpoint() with the following behaviours: When breakpoint() is called and PYTHONBREAKPOINT is set to the default value, pytest will use the custom internal PDB trace UI instead of the system default Pdb . When tests are complete, the system will default back to the system Pdb trace UI. With --pdb passed to pytest, the custom internal Pdb trace UI is used with both breakpoint() and failed tests/unhandled exceptions. --pdbcls can be used to specify a custom debugger class.

# Fault Handler¶

Added in version 5.0. The faulthandler standard module can be used to dump Python tracebacks on a segfault or after a timeout. The module is automatically enabled for pytest runs, unless the -p no:faulthandler is given on the command-line. Also the faulthandler_timeout=X configuration option can be used to dump the traceback of all threads if a test takes longer than X seconds to finish (not available on Windows). Note This functionality has been integrated from the external pytest-faulthandler plugin, with two small differences: To disable it, use -p no:faulthandler instead of --no-faulthandler : the former can be used with any plugin, so it saves one option. The --faulthandler-timeout command-line option has become the faulthandler_timeout configuration option. It can still be configured from the command-line using -o faulthandler_timeout=X .

# Warning about unraisable exceptions and unhandled thread exceptions¶


---


# Contributing - pytest documentation

URL: https://docs.pytest.org/en/stable/contributing.html


# Contributing¶

Contributions are highly welcomed and appreciated. Every little bit of help counts, so do not hesitate!

# Feature requests and feedback¶

Do you like pytest? Share some love on Twitter or in your blog posts! We’d also like to hear about your propositions and suggestions. Feel free to submit them as issues and: Explain in detail how they should work. Keep the scope as narrow as possible. This will make it easier to implement.

# Report bugs¶

Report bugs for pytest in the issue tracker . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting, specifically the Python interpreter version, installed libraries, and pytest version. Detailed steps to reproduce the bug. If you can write a demonstration test that currently fails but should pass (xfail), that is a very useful commit to make as well, even if you cannot fix the bug itself.

# Fix bugs¶

Look through the GitHub issues for bugs . See also the “good first issue” issues that are friendly to new contributors. Talk to developers to find out how you can fix specific bugs. To indicate that you are going to work on a particular issue, add a comment to that effect on the specific issue. Don’t forget to check the issue trackers of your favourite plugins, too!

# Implement features¶

Look through the GitHub issues for enhancements . Talk to developers to find out how you can implement specific features.

# Write documentation¶

Pytest could always use more documentation. What exactly is needed? More complementary documentation. Have you perhaps found something unclear? Documentation translations. We currently have only English. Docstrings. There can never be too many of them. Blog posts, articles and such – they’re all very appreciated. You can also edit documentation files directly in the GitHub web interface, without using a local copy. This can be convenient for small fixes. Note Build the documentation locally with the following command:

```

$
tox
-e
docs

```

The built documentation should be available in doc/en/_build/html , where ‘en’ refers to the documentation language. Pytest has an API reference which in large part is generated automatically from the docstrings of the documented items. Pytest uses the Sphinx docstring format . For example:

```

def
my_function
(
arg
:
ArgType
)
->
Foo
:
"""Do important stuff.
More detailed info here, in separate paragraphs from the subject line.
Use proper sentences -- start sentences with capital letters and end
with periods.
Can include annotated documentation:
:param short_arg: An argument which determines stuff.
:param long_arg:
A long explanation which spans multiple lines, overflows
like this.
:returns: The result.
:raises ValueError:
Detailed information when this can happen.
.. versionadded:: 6.0
Including types into the annotations above is not necessary when
type-hinting is being used (as in this example).
"""

```

# Submitting Plugins to pytest-dev¶

Development of the pytest core, support code, and some plugins happens in repositories living under the pytest-dev organisations: pytest-dev on GitHub All pytest-dev Contributors team members have write access to all contained repositories. Pytest core and plugins are generally developed using pull requests to respective repositories. The objectives of the pytest-dev organisation are: Having a central location for popular pytest plugins Sharing some of the maintenance responsibility (in case a maintainer no longer wishes to maintain a plugin) You can submit your plugin by subscribing to the pytest-dev mail list and writing a mail pointing to your existing pytest plugin repository which must have the following: PyPI presence with packaging metadata that contains a pytest- prefixed name, version number, authors, short and long description. a tox configuration for running tests using tox . a README describing how to use the plugin and on which platforms it runs. a LICENSE file containing the licensing information, with matching info in its packaging metadata. an issue tracker for bug reports and enhancement requests. a changelog . If no contributor strongly objects and two agree, the repository can then be transferred to the pytest-dev organisation. Here’s a rundown of how a repository transfer usually proceeds (using a repository named joedoe/pytest-xyz as example): joedoe transfers repository ownership to pytest-dev administrator calvin . calvin creates pytest-xyz-admin and pytest-xyz-developers teams, inviting joedoe to both as maintainer . calvin transfers repository to pytest-dev and configures team access: pytest-xyz-admin admin access; pytest-xyz-developers write access; The pytest-dev/Contributors team has write access to all projects, and every project administrator is in it. We recommend that each plugin has at least three people who have the right to release to PyPI. Repository owners can rest assured that no pytest-dev administrator will ever make releases of your repository or take ownership in any way, except in rare cases where someone becomes unresponsive after months of contact attempts. As stated, the objective is to share maintenance and avoid “plugin-abandon”.

# Preparing Pull Requests¶

# Short version¶

Fork the repository. Fetch tags from upstream if necessary (if you cloned only main git fetch --tags https://github.com/pytest-dev/pytest ). Enable and install pre-commit to ensure style-guides and code checks are followed. Follow PEP-8 for naming. Tests are run using tox :

```

tox
-
e
linting
,
py39

```

The test environments above are usually enough to cover most cases locally. Write a changelog entry: changelog/2574.bugfix.rst , use issue id number and one of feature , improvement , bugfix , doc , deprecation , breaking , vendor or trivial for the issue type. Unless your change is a trivial or a documentation fix (e.g., a typo or reword of a small section) please add yourself to the AUTHORS file, in alphabetical order.

# Long version¶

What is a “pull request”? It informs the project’s core developers about the changes you want to review and merge. Pull requests are stored on GitHub servers . Once you send a pull request, we can discuss its potential modifications and even add more commits to it later on. There’s an excellent tutorial on how Pull Requests work in the GitHub Help Center . Here is a simple overview, with pytest-specific bits: Fork the pytest GitHub repository . It’s fine to use pytest as your fork repository name because it will live under your user. Clone your fork locally using git and create a branch:

```

$ git clone git@github.com:YOUR_GITHUB_USERNAME/pytest.git
$ cd pytest
$ git fetch --tags https://github.com/pytest-dev/pytest
# now, create your own branch off "main":

    $ git checkout -b your-bugfix-branch-name main

```

Given we have “major.minor.micro” version numbers, bug fixes will usually be released in micro releases whereas features will be released in minor releases and incompatible changes in major releases. You will need the tags to test locally, so be sure you have the tags from the main repository. If you suspect you don’t, set the main repository as upstream and fetch the tags:

```

$ git remote add upstream https://github.com/pytest-dev/pytest
$ git fetch upstream --tags

```

If you need some help with Git, follow this quick start guide: https://git.wiki.kernel.org/index.php/QuickStart Install pre-commit and its hook on the pytest repo:

```

$ pip install --user pre-commit
$ pre-commit install

```

Afterwards pre-commit will run whenever you commit. https://pre-commit.com/ is a framework for managing and maintaining multi-language pre-commit hooks to ensure code-style and code formatting is consistent. Install tox Tox is used to run all the tests and will automatically setup virtualenvs to run the tests in. (will implicitly use https://virtualenv.pypa.io/en/latest/ ):

```

$ pip install tox

```

Run all the tests You need to have Python 3.8 or later available in your system. Now running tests is as simple as issuing this command:

```

$ tox -e linting,py39

```

This command will run tests via the “tox” tool against Python 3.9 and also perform “lint” coding-style checks. You can now edit your local working copy and run the tests again as necessary. Please follow PEP-8 for naming. You can pass different options to tox . For example, to run tests on Python 3.9 and pass options to pytest (e.g. enter pdb on failure) to pytest you can do:

```

$ tox -e py39 -- --pdb

```

Or to only run tests in a particular test module on Python 3.9:

```

$ tox -e py39 -- testing/test_config.py

```

When committing, pre-commit will re-format the files if necessary. If instead of using tox you prefer to run the tests directly, then we suggest to create a virtual environment and use an editable install with the dev extra:

```

$ python3 -m venv .venv
$ source .venv/bin/activate  # Linux
$ .venv/Scripts/activate.bat  # Windows
$ pip install -e ".[dev]"

```

Afterwards, you can edit the files and run pytest normally:

```

$ pytest testing/test_config.py

```

Create a new changelog entry in changelog . The file should be named <issueid>.<type>.rst , where issueid is the number of the issue related to the change and type is one of feature , improvement , bugfix , doc , deprecation , breaking , vendor or trivial . You may skip creating the changelog entry if the change doesn’t affect the documented behaviour of pytest. Add yourself to AUTHORS file if not there yet, in alphabetical order. Commit and push once your tests pass and you are happy with your change(s):

```

$ git commit -a -m "<commit message>"
$ git push -u

```

Finally, submit a pull request through the GitHub website using this data:

```

head
-
fork
:
YOUR_GITHUB_USERNAME
/
pytest
compare
:
your
-
branch
-
name
base
-
fork
:
pytest
-
dev
/
pytest
base
:
main

```

# Writing Tests¶

Writing tests for plugins or for pytest itself is often done using the pytester fixture , as a “black-box” test. For example, to ensure a simple test passes you can write:

```

def
test_true_assertion
(
pytester
):
pytester
.
makepyfile
(
"""
def test_foo():
assert True
"""
)
result
=
pytester
.
runpytest
()
result
.
assert_outcomes
(
failed
=
0
,
passed
=
1
)

```

Alternatively, it is possible to make checks based on the actual output of the termal using glob-like expressions:

```

def
test_true_assertion
(
pytester
):
pytester
.
makepyfile
(
"""
def test_foo():
assert False
"""
)
result
=
pytester
.
runpytest
()
result
.
stdout
.
fnmatch_lines
([
"*assert False*"
,
"*1 failed*"
])

```

When choosing a file where to write a new test, take a look at the existing files and see if there’s one file which looks like a good fit. For example, a regression test about a bug in the --lf option should go into test_cacheprovider.py , given that this option is implemented in cacheprovider.py . If in doubt, go ahead and open a PR with your best guess and we can discuss this over the code.

# Joining the Development Team¶

Anyone who has successfully seen through a pull request which did not require any extra work from the development team to merge will themselves gain commit access if they so wish (if we forget to ask please send a friendly reminder). This does not mean there is any change in your contribution workflow: everyone goes through the same pull-request-and-review process and no-one merges their own pull requests unless already approved. It does however mean you can participate in the development process more fully since you can merge pull requests from other contributors yourself after having reviewed them.

# Merge/squash guidelines¶

When a PR is approved and ready to be integrated to the main branch, one has the option to merge the commits unchanged, or squash all the commits into a single commit. Here are some guidelines on how to proceed, based on examples of a single PR commit history: Miscellaneous commits: Implement X Fix test_a Add myself to AUTHORS fixup! Fix test_a Update tests/test_integration.py Merge origin/main into PR branch Update tests/test_integration.py In this case, prefer to use the Squash merge strategy: the commit history is a bit messy (not in a derogatory way, often one just commits changes because they know the changes will eventually be squashed together), so squashing everything into a single commit is best. You must clean up the commit message, making sure it contains useful details. Separate commits related to the same topic: Implement X Add myself to AUTHORS Update CHANGELOG for X In this case, prefer to use the Squash merge strategy: while the commit history is not “messy” as in the example above, the individual commits do not bring much value overall, specially when looking at the changes a few months/years down the line. Separate commits, each with their own topic (refactorings, renames, etc), but still have a larger topic/purpose. Refactor class X in preparation for feature Y Remove unused method Implement feature Y In this case, prefer to use the Merge strategy: each commit is valuable on its own, even if they serve a common topic overall. Looking at the history later, it is useful to have the removal of the unused method separately on its own commit, along with more information (such as how it became unused in the first place). Separate commits, each with their own topic, but without a larger topic/purpose other than improve the code base (using more modern techniques, improve typing, removing clutter, etc). Improve internal names in X Add type annotations to Y Remove unnecessary dict access Remove unreachable code due to EOL Python In this case, prefer to use the Merge strategy: each commit is valuable on its own, and the information on each is valuable in the long term. As mentioned, those are overall guidelines, not rules cast in stone. This topic was discussed in #12633 . Backport PRs (as those created automatically from a backport label) should always be squashed , as they preserve the original PR author.

# Backporting bug fixes for the next patch release¶

Pytest makes a feature release every few weeks or months. In between, patch releases are made to the previous feature release, containing bug fixes only. The bug fixes usually fix regressions, but may be any change that should reach users before the next feature release. Suppose for example that the latest release was 1.2.3, and you want to include a bug fix in 1.2.4 (check https://github.com/pytest-dev/pytest/releases for the actual latest release). The procedure for this is: First, make sure the bug is fixed in the main branch, with a regular pull request, as described above. An exception to this is if the bug fix is not applicable to main anymore. Automatic method: Add a backport 1.2.x label to the PR you want to backport. This will create a backport PR against the 1.2.x branch. Manual method: git checkout origin/1.2.x -b backport-XXXX # use the main PR number here Locate the merge commit on the PR, in the merged message, for example: nicoddemus merged commit 0f8b462 into pytest-dev:main git cherry-pick -x -m1 REVISION # use the revision you found above ( 0f8b462 ). Open a PR targeting 1.2.x : Prefix the message with [1.2.x] . Delete the PR body, it usually contains a duplicate commit message.

# Who does the backporting¶

As mentioned above, bugs should first be fixed on main (except in rare occasions that a bug only happens in a previous release). So, who should do the backport procedure described above? If the bug was fixed by a core developer, it is the main responsibility of that core developer to do the backport. However, often the merge is done by another maintainer, in which case it is nice of them to do the backport procedure if they have the time. For bugs submitted by non-maintainers, it is expected that a core developer will to do the backport, normally the one that merged the PR on main . If a non-maintainers notices a bug which is fixed on main but has not been backported (due to maintainers forgetting to apply the needs backport label, or just plain missing it), they are also welcome to open a PR with the backport. The procedure is simple and really helps with the maintenance of the project. All the above are not rules, but merely some guidelines/suggestions on what we should expect about backports. Backports should be squashed (rather than merged ), as doing so preserves the original PR author correctly.

# Handling stale issues/PRs¶

Stale issues/PRs are those where pytest contributors have asked for questions/changes and the authors didn’t get around to answer/implement them yet after a somewhat long time, or the discussion simply died because people seemed to lose interest. There are many reasons why people don’t answer questions or implement requested changes: they might get busy, lose interest, or just forget about it, but the fact is that this is very common in open source software. The pytest team really appreciates every issue and pull request, but being a high-volume project with many issues and pull requests being submitted daily, we try to reduce the number of stale issues and PRs by regularly closing them. When an issue/pull request is closed in this manner, it is by no means a dismissal of the topic being tackled by the issue/pull request, but it is just a way for us to clear up the queue and make the maintainers’ work more manageable. Submitters can always reopen the issue/pull request in their own time later if it makes sense.

# When to close¶

Here are a few general rules the maintainers use deciding when to close issues/PRs because of lack of inactivity: Issues labeled question or needs information : closed after 14 days inactive. Issues labeled proposal : closed after six months inactive. Pull requests: after one month, consider pinging the author, update linked issue, or consider closing. For pull requests which are nearly finished, the team should consider finishing it up and merging it. The above are not hard rules , but merely guidelines , and can be (and often are!) reviewed on a case-by-case basis.

# Closing pull requests¶

When closing a Pull Request, it needs to be acknowledging the time, effort, and interest demonstrated by the person which submitted it. As mentioned previously, it is not the intent of the team to dismiss a stalled pull request entirely but to merely to clear up our queue, so a message like the one below is warranted when closing a pull request that went stale: Hi <contributor>, First of all, we would like to thank you for your time and effort on working on this, the pytest team deeply appreciates it. We noticed it has been awhile since you have updated this PR, however. pytest is a high activity project, with many issues/PRs being opened daily, so it is hard for us maintainers to track which PRs are ready for merging, for review, or need more attention. So for those reasons we, think it is best to close the PR for now, but with the only intention to clean up our queue, it is by no means a rejection of your changes. We still encourage you to re-open this PR (it is just a click of a button away) when you are ready to get back to it. Again we appreciate your time for working on this, and hope you might get back to this at a later time! <bye>

# Closing issues¶


---


# Exit codes - pytest documentation

URL: https://docs.pytest.org/en/stable/reference/exit-codes.html


# Exit codes¶

Running pytest can result in six different exit codes: All tests were collected and passed successfully Tests were collected and run but some of the tests failed Test execution was interrupted by the user Internal error happened while executing tests pytest command line usage error No tests were collected They are represented by the pytest.ExitCode enum. The exit codes being a part of the public API can be imported and accessed directly using:

```

from
pytest
import
ExitCode

```


---


# Parametrizing tests - pytest documentation

URL: https://docs.pytest.org/en/stable/example/parametrize.html


# Parametrizing tests¶

pytest allows to easily parametrize test functions. For basic docs, see How to parametrize fixtures and test functions . In the following we provide some examples using the builtin mechanisms.

# Generating parameters combinations, depending on command line¶

Let’s say we want to execute a test with different computation parameters and the parameter range shall be determined by a command line argument. Let’s first write a simple (do-nothing) computation test:

```

# content of test_compute.py
def
test_compute
(
param1
):
assert
param1
<
4

```

Now we add a test configuration like this:

```

# content of conftest.py
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--all"
,
action
=
"store_true"
,
help
=
"run all combinations"
)
def
pytest_generate_tests
(
metafunc
):
if
"param1"
in
metafunc
.
fixturenames
:
if
metafunc
.
config
.
getoption
(
"all"
):
end
=
5
else
:
end
=
2
metafunc
.
parametrize
(
"param1"
,
range
(
end
))

```

This means that we only run 2 tests if we do not pass --all :

```

$ pytest -q test_compute.py
..
[100%]
2 passed
in 0.12s

```

We run only two computations, so we see two dots. let’s run the full monty:

```

$ pytest -q --all
....
F
[100%]
================================= FAILURES =================================
_____________________________ test_compute[4] ______________________________
param1 = 4

    def test_compute(param1):
>       assert param1 < 4
E       assert 4 < 4
test_compute.py
:4: AssertionError
========================= short test summary info ==========================
FAILED
test_compute.py::
test_compute[4]
- assert 4 < 4
1 failed
,
4 passed
in 0.12s

```

As expected when running the full range of param1 values we’ll get an error on the last one.

# Different options for test IDs¶

pytest will build a string that is the test ID for each set of values in a parametrized test. These IDs can be used with -k to select specific cases to run, and they will also identify the specific case when one is failing. Running pytest with --collect-only will show the generated IDs. Numbers, strings, booleans and None will have their usual string representation used in the test ID. For other objects, pytest will make a string based on the argument name:

```

# content of test_time.py
from
datetime
import
datetime
,
timedelta
import
pytest
testdata
=
[
(
datetime
(
2001
,
12
,
12
),
datetime
(
2001
,
12
,
11
),
timedelta
(
1
)),
(
datetime
(
2001
,
12
,
11
),
datetime
(
2001
,
12
,
12
),
timedelta
(
-
1
)),
]
@pytest
.
mark
.
parametrize
(
"a,b,expected"
,
testdata
)
def
test_timedistance_v0
(
a
,
b
,
expected
):
diff
=
a
-
b
assert
diff
==
expected
@pytest
.
mark
.
parametrize
(
"a,b,expected"
,
testdata
,
ids
=
[
"forward"
,
"backward"
])
def
test_timedistance_v1
(
a
,
b
,
expected
):
diff
=
a
-
b
assert
diff
==
expected
def
idfn
(
val
):
if
isinstance
(
val
,
(
datetime
,)):
# note this wouldn't show any hours/minutes/seconds
return
val
.
strftime
(
"%Y%m
%d
"
)
@pytest
.
mark
.
parametrize
(
"a,b,expected"
,
testdata
,
ids
=
idfn
)
def
test_timedistance_v2
(
a
,
b
,
expected
):
diff
=
a
-
b
assert
diff
==
expected
@pytest
.
mark
.
parametrize
(
"a,b,expected"
,
[
pytest
.
param
(
datetime
(
2001
,
12
,
12
),
datetime
(
2001
,
12
,
11
),
timedelta
(
1
),
id
=
"forward"
),
pytest
.
param
(
datetime
(
2001
,
12
,
11
),
datetime
(
2001
,
12
,
12
),
timedelta
(
-
1
),
id
=
"backward"
),
],
)
def
test_timedistance_v3
(
a
,
b
,
expected
):
diff
=
a
-
b
assert
diff
==
expected

```

In test_timedistance_v0 , we let pytest generate the test IDs. In test_timedistance_v1 , we specified ids as a list of strings which were used as the test IDs. These are succinct, but can be a pain to maintain. In test_timedistance_v2 , we specified ids as a function that can generate a string representation to make part of the test ID. So our datetime values use the label generated by idfn , but because we didn’t generate a label for timedelta objects, they are still using the default pytest representation:

```

$ pytest test_time.py --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 8 items

<Dir parametrize.rst-206>
  <Module test_time.py>
    <Function test_timedistance_v0[a0-b0-expected0]>
    <Function test_timedistance_v0[a1-b1-expected1]>
    <Function test_timedistance_v1[forward]>
    <Function test_timedistance_v1[backward]>
    <Function test_timedistance_v2[20011212-20011211-expected0]>
    <Function test_timedistance_v2[20011211-20011212-expected1]>
    <Function test_timedistance_v3[forward]>
    <Function test_timedistance_v3[backward]>

======================== 8 tests collected in 0.12s ========================

```

In test_timedistance_v3 , we used pytest.param to specify the test IDs together with the actual data, instead of listing them separately.

# A quick port of “testscenarios”¶

Here is a quick port to run tests configured with testscenarios , an add-on from Robert Collins for the standard unittest framework. We only have to work a bit to construct the correct arguments for pytest’s Metafunc.parametrize :

```

# content of test_scenarios.py
def
pytest_generate_tests
(
metafunc
):
idlist
=
[]
argvalues
=
[]
for
scenario
in
metafunc
.
cls
.
scenarios
:
idlist
.
append
(
scenario
[
0
])
items
=
scenario
[
1
]
.
items
()
argnames
=
[
x
[
0
]
for
x
in
items
]
argvalues
.
append
([
x
[
1
]
for
x
in
items
])
metafunc
.
parametrize
(
argnames
,
argvalues
,
ids
=
idlist
,
scope
=
"class"
)
scenario1
=
(
"basic"
,
{
"attribute"
:
"value"
})
scenario2
=
(
"advanced"
,
{
"attribute"
:
"value2"
})
class
TestSampleWithScenarios
:
scenarios
=
[
scenario1
,
scenario2
]
def
test_demo1
(
self
,
attribute
):
assert
isinstance
(
attribute
,
str
)
def
test_demo2
(
self
,
attribute
):
assert
isinstance
(
attribute
,
str
)

```

this is a fully self-contained example which you can run with:

```

$ pytest test_scenarios.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items

test_scenarios.py
....
[100%]
============================
4 passed
in 0.12s =============================

```

If you just collect tests you’ll also nicely see ‘advanced’ and ‘basic’ as variants for the test function:

```

$ pytest --collect-only test_scenarios.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items

<Dir parametrize.rst-206>
  <Module test_scenarios.py>
    <Class TestSampleWithScenarios>
      <Function test_demo1[basic]>
      <Function test_demo2[basic]>
      <Function test_demo1[advanced]>
      <Function test_demo2[advanced]>

======================== 4 tests collected in 0.12s ========================

```

Note that we told metafunc.parametrize() that your scenario values should be considered class-scoped. With pytest-2.3 this leads to a resource-based ordering.

# Deferring the setup of parametrized resources¶

The parametrization of test functions happens at collection time. It is a good idea to setup expensive resources like DB connections or subprocess only when the actual test is run. Here is a simple example how you can achieve that. This test requires a db object fixture:

```

# content of test_backends.py
import
pytest
def
test_db_initialized
(
db
):
# a dummy test
if
db
.
__class__
.
__name__
==
"DB2"
:
pytest
.
fail
(
"deliberately failing for demo purposes"
)

```

We can now add a test configuration that generates two invocations of the test_db_initialized function and also implements a factory that creates a database object for the actual test invocations:

```

# content of conftest.py
import
pytest
def
pytest_generate_tests
(
metafunc
):
if
"db"
in
metafunc
.
fixturenames
:
metafunc
.
parametrize
(
"db"
,
[
"d1"
,
"d2"
],
indirect
=
True
)
class
DB1
:
"one database object"
class
DB2
:
"alternative database object"
@pytest
.
fixture
def
db
(
request
):
if
request
.
param
==
"d1"
:
return
DB1
()
elif
request
.
param
==
"d2"
:
return
DB2
()
else
:
raise
ValueError
(
"invalid internal test config"
)

```

Let’s first see how it looks like at collection time:

```

$ pytest test_backends.py --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

<Dir parametrize.rst-206>
  <Module test_backends.py>
    <Function test_db_initialized[d1]>
    <Function test_db_initialized[d2]>

======================== 2 tests collected in 0.12s ========================

```

And then when we run the test:

```

$ pytest -q test_backends.py
.
F
[100%]
================================= FAILURES =================================
_________________________ test_db_initialized[d2] __________________________
db = <conftest.DB2 object at 0xdeadbeef0001>

    def test_db_initialized(db):
        # a dummy test
        if db.__class__.__name__ == "DB2":
>           pytest.fail("deliberately failing for demo purposes")
E           Failed: deliberately failing for demo purposes
test_backends.py
:8: Failed
========================= short test summary info ==========================
FAILED
test_backends.py::
test_db_initialized[d2]
- Failed: deliberately f...
1 failed
,
1 passed
in 0.12s

```

The first invocation with db == "DB1" passed while the second with db == "DB2" failed. Our db fixture function has instantiated each of the DB values during the setup phase while the pytest_generate_tests generated two according calls to the test_db_initialized during the collection phase.

# Indirect parametrization¶

Using the indirect=True parameter when parametrizing a test allows to parametrize a test with a fixture receiving the values before passing them to a test:

```

import
pytest
@pytest
.
fixture
def
fixt
(
request
):
return
request
.
param
*
3
@pytest
.
mark
.
parametrize
(
"fixt"
,
[
"a"
,
"b"
],
indirect
=
True
)
def
test_indirect
(
fixt
):
assert
len
(
fixt
)
==
3

```

This can be used, for example, to do more expensive setup at test run time in the fixture, rather than having to run those setup steps at collection time.

# Apply indirect on particular arguments¶

Very often parametrization uses more than one argument name. There is opportunity to apply indirect parameter on particular arguments. It can be done by passing list or tuple of arguments’ names to indirect . In the example below there is a function test_indirect which uses two fixtures: x and y . Here we give to indirect the list, which contains the name of the fixture x . The indirect parameter will be applied to this argument only, and the value a will be passed to respective fixture function:

```

# content of test_indirect_list.py
import
pytest
@pytest
.
fixture
(
scope
=
"function"
)
def
x
(
request
):
return
request
.
param
*
3
@pytest
.
fixture
(
scope
=
"function"
)
def
y
(
request
):
return
request
.
param
*
2
@pytest
.
mark
.
parametrize
(
"x, y"
,
[(
"a"
,
"b"
)],
indirect
=
[
"x"
])
def
test_indirect
(
x
,
y
):
assert
x
==
"aaa"
assert
y
==
"b"

```

The result of this test will be successful:

```

$ pytest -v test_indirect_list.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 1 item

test_indirect_list.py::test_indirect[a-b]
PASSED
[100%]
============================
1 passed
in 0.12s =============================

```

# Parametrizing test methods through per-class configuration¶

Here is an example pytest_generate_tests function implementing a parametrization scheme similar to Michael Foord’s unittest parametrizer but in a lot less code:

```

# content of ./test_parametrize.py
import
pytest
def
pytest_generate_tests
(
metafunc
):
# called once per each test function
funcarglist
=
metafunc
.
cls
.
params
[
metafunc
.
function
.
__name__
]
argnames
=
sorted
(
funcarglist
[
0
])
metafunc
.
parametrize
(
argnames
,
[[
funcargs
[
name
]
for
name
in
argnames
]
for
funcargs
in
funcarglist
]
)
class
TestClass
:
# a map specifying multiple argument sets for a test method
params
=
{
"test_equals"
:
[
dict
(
a
=
1
,
b
=
2
),
dict
(
a
=
3
,
b
=
3
)],
"test_zerodivision"
:
[
dict
(
a
=
1
,
b
=
0
)],
}
def
test_equals
(
self
,
a
,
b
):
assert
a
==
b
def
test_zerodivision
(
self
,
a
,
b
):
with
pytest
.
raises
(
ZeroDivisionError
):
a
/
b

```

Our test generator looks up a class-level definition which specifies which argument sets to use for each test function. Let’s run it:

```

$ pytest -q
F
..
[100%]
================================= FAILURES =================================
________________________ TestClass.test_equals[1-2] ________________________
self = <test_parametrize.TestClass object at 0xdeadbeef0002>, a = 1, b = 2

    def test_equals(self, a, b):
>       assert a == b
E       assert 1 == 2
test_parametrize.py
:21: AssertionError
========================= short test summary info ==========================
FAILED
test_parametrize.py::
TestClass::test_equals[1-2]
- assert 1 == 2
1 failed
,
2 passed
in 0.12s

```

# Parametrization with multiple fixtures¶

Here is a stripped down real-life example of using parametrized testing for testing serialization of objects between different python interpreters. We define a test_basic_objects function which is to be run with different sets of arguments for its three arguments: python1 : first python interpreter, run to pickle-dump an object to a file python2 : second interpreter, run to pickle-load an object from a file obj : object to be dumped/loaded

```

"""Module containing a parametrized tests testing cross-python serialization
via the pickle module."""
from
__future__
import
annotations
import
shutil
import
subprocess
import
textwrap
import
pytest
pythonlist
=
[
"python3.9"
,
"python3.10"
,
"python3.11"
]
@pytest
.
fixture
(
params
=
pythonlist
)
def
python1
(
request
,
tmp_path
):
picklefile
=
tmp_path
/
"data.pickle"
return
Python
(
request
.
param
,
picklefile
)
@pytest
.
fixture
(
params
=
pythonlist
)
def
python2
(
request
,
python1
):
return
Python
(
request
.
param
,
python1
.
picklefile
)
class
Python
:
def
__init__
(
self
,
version
,
picklefile
):
self
.
pythonpath
=
shutil
.
which
(
version
)
if
not
self
.
pythonpath
:
pytest
.
skip
(
f
"
{
version
!r}
not found"
)
self
.
picklefile
=
picklefile
def
dumps
(
self
,
obj
):
dumpfile
=
self
.
picklefile
.
with_name
(
"dump.py"
)
dumpfile
.
write_text
(
textwrap
.
dedent
(
rf
"""
import pickle
f = open(
{
str
(
self
.
picklefile
)
!r}
, 'wb')
s = pickle.dump(
{
obj
!r}
, f, protocol=2)
f.close()
"""
)
)
subprocess
.
run
((
self
.
pythonpath
,
str
(
dumpfile
)),
check
=
True
)
def
load_and_is_true
(
self
,
expression
):
loadfile
=
self
.
picklefile
.
with_name
(
"load.py"
)
loadfile
.
write_text
(
textwrap
.
dedent
(
rf
"""
import pickle
f = open(
{
str
(
self
.
picklefile
)
!r}
, 'rb')
obj = pickle.load(f)
f.close()
res = eval(
{
expression
!r}
)
if not res:
raise SystemExit(1)
"""
)
)
print
(
loadfile
)
subprocess
.
run
((
self
.
pythonpath
,
str
(
loadfile
)),
check
=
True
)
@pytest
.
mark
.
parametrize
(
"obj"
,
[
42
,
{},
{
1
:
3
}])
def
test_basic_objects
(
python1
,
python2
,
obj
):
python1
.
dumps
(
obj
)
python2
.
load_and_is_true
(
f
"obj ==
{
obj
}
"
)

```

Running it results in some skips if we don’t have all the python interpreters installed and otherwise runs all combinations (3 interpreters times 3 interpreters times 3 objects to serialize/deserialize):

```

. $ pytest -rs -q multipython.py
sssssssssssssssssssssssssss
[100%]
========================= short test summary info ==========================
SKIPPED
[9] multipython.py:67: 'python3.9' not found
SKIPPED
[9] multipython.py:67: 'python3.10' not found
SKIPPED
[9] multipython.py:67: 'python3.11' not found
27 skipped
in 0.12s

```

# Parametrization of optional implementations/imports¶

If you want to compare the outcomes of several implementations of a given API, you can write test functions that receive the already imported implementations and get skipped in case the implementation is not importable/available. Let’s say we have a “base” implementation and the other (possibly optimized ones) need to provide similar results:

```

# content of conftest.py
import
pytest
@pytest
.
fixture
(
scope
=
"session"
)
def
basemod
(
request
):
return
pytest
.
importorskip
(
"base"
)
@pytest
.
fixture
(
scope
=
"session"
,
params
=
[
"opt1"
,
"opt2"
])
def
optmod
(
request
):
return
pytest
.
importorskip
(
request
.
param
)

```

And then a base implementation of a simple function:

```

# content of base.py
def
func1
():
return
1

```

And an optimized version:

```

# content of opt1.py
def
func1
():
return
1.0001

```

And finally a little test module:

```

# content of test_module.py
def
test_func1
(
basemod
,
optmod
):
assert
round
(
basemod
.
func1
(),
3
)
==
round
(
optmod
.
func1
(),
3
)

```

If you run this with reporting for skips enabled:

```

$ pytest -rs test_module.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_module.py
.
s
[100%]
========================= short test summary info ==========================
SKIPPED
[1] test_module.py:3: could not import 'opt2': No module named 'opt2'
=======================
1 passed
,
1 skipped
in 0.12s =======================

```

You’ll see that we don’t have an opt2 module and thus the second test run of our test_func1 was skipped. A few notes: the fixture functions in the conftest.py file are “session-scoped” because we don’t need to import more than once if you have multiple test functions and a skipped import, you will see the [1] count increasing in the report you can put @pytest.mark.parametrize style parametrization on the test functions to parametrize input/output values as well.

# Set marks or test ID for individual parametrized test¶

Use pytest.param to apply marks or set test ID to individual parametrized test. For example:

```

# content of test_pytest_param_example.py
import
pytest
@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[
(
"3+5"
,
8
),
pytest
.
param
(
"1+7"
,
8
,
marks
=
pytest
.
mark
.
basic
),
pytest
.
param
(
"2+4"
,
6
,
marks
=
pytest
.
mark
.
basic
,
id
=
"basic_2+4"
),
pytest
.
param
(
"6*9"
,
42
,
marks
=
[
pytest
.
mark
.
basic
,
pytest
.
mark
.
xfail
],
id
=
"basic_6*9"
),
],
)
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

In this example, we have 4 parametrized tests. Except for the first test, we mark the rest three parametrized tests with the custom marker basic , and for the fourth test we also use the built-in mark xfail to indicate this test is expected to fail. For explicitness, we set test ids for some tests. Then run pytest with verbose mode and with only the basic marker:

```

$ pytest -v -m basic
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 24 items / 21 deselected / 3 selected

test_pytest_param_example.py::test_eval[1+7-8]
PASSED
[ 33%]
test_pytest_param_example.py::test_eval[basic_2+4]
PASSED
[ 66%]
test_pytest_param_example.py::test_eval[basic_6*9]
XFAIL
[100%]
===============
2 passed
,
21 deselected
,
1 xfailed
in 0.12s ================

```

As the result: Four tests were collected One test was deselected because it doesn’t have the basic mark. Three tests with the basic mark was selected. The test test_eval[1+7-8] passed, but the name is autogenerated and confusing. The test test_eval[basic_2+4] passed. The test test_eval[basic_6*9] was expected to fail and did fail.

# Parametrizing conditional raising¶

Use pytest.raises() with the pytest.mark.parametrize decorator to write parametrized tests in which some tests raise exceptions and others do not. contextlib.nullcontext can be used to test cases that are not expected to raise exceptions but that should result in some value. The value is given as the enter_result parameter, which will be available as the with statement’s target ( e in the example below). For example:

```

from
contextlib
import
nullcontext
import
pytest
@pytest
.
mark
.
parametrize
(
"example_input,expectation"
,
[
(
3
,
nullcontext
(
2
)),
(
2
,
nullcontext
(
3
)),
(
1
,
nullcontext
(
6
)),
(
0
,
pytest
.
raises
(
ZeroDivisionError
)),
],
)
def
test_division
(
example_input
,
expectation
):
"""Test how much I know division."""
with
expectation
as
e
:
assert
(
6
/
example_input
)
==
e

```


---


# Changelog - pytest documentation

URL: https://docs.pytest.org/en/stable/changelog.html


# Changelog¶

Versions follow Semantic Versioning ( <major>.<minor>.<patch> ). Backward incompatible (breaking) changes will only be introduced in major versions with advance notice in the Deprecations section of releases.

# pytest 8.3.5 (2025-03-02)¶

# Bug fixes¶

#11777 : Fixed issue where sequences were still being shortened even with -vv verbosity. #12888 : Fixed broken input when using Python 3.13+ and a libedit build of Python, such as on macOS or with uv-managed Python binaries from the python-build-standalone project. This could manifest e.g. by a broken prompt when using Pdb , or seeing empty inputs with manual usage of input() and suspended capturing. #13026 : Fixed AttributeError crash when using --import-mode=importlib when top-level directory same name as another module of the standard library. #13053 : Fixed a regression in pytest 8.3.4 where, when using --import-mode=importlib , a directory containing py file with the same name would cause an ImportError #13083 : Fixed issue where pytest could crash if one of the collected directories got removed during collection.

# Improved documentation¶

#12842 : Added dedicated page about using types with pytest. See Typing in pytest for detailed usage.

# Contributor-facing changes¶

#13112 : Fixed selftest failures in test_terminal.py with Pygments >= 2.19.0 #13256 : Support for Towncier versions released in 2024 has been re-enabled when building Sphinx docs – by @webknjaz .

# pytest 8.3.4 (2024-12-01)¶

# Bug fixes¶

#12592 : Fixed KeyError crash when using --import-mode=importlib in a directory layout where a directory contains a child directory with the same name. #12818 : Assertion rewriting now preserves the source ranges of the original instructions, making it play well with tools that deal with the AST , like executing . #12849 : ANSI escape codes for colored output now handled correctly in pytest.fail() with pytrace=False . #9353 : pytest.approx() now uses strict equality when given booleans.

# Improved documentation¶

#10558 : Fix ambiguous docstring of pytest.Config.getoption() . #10829 : Improve documentation on the current handling of the --basetemp option and its lack of retention functionality ( Temporary directory location and retention ). #12866 : Improved cross-references concerning the recwarn fixture. #12966 : Clarify @pytest.mark.filterwarnings docs on filter precedence/order when using multiple @pytest.mark.filterwarnings marks.

# Contributor-facing changes¶

#12497 : Fixed two failing pdb-related tests on Python 3.13.

# pytest 8.3.3 (2024-09-09)¶

# Bug fixes¶

#12446 : Avoid calling @property (and other instance descriptors) during fixture discovery – by @asottile #12659 : Fixed the issue of not displaying assertion failure differences when using the parameter --import-mode=importlib in pytest>=8.1. #12667 : Fixed a regression where type change in ExceptionInfo.errisinstance caused mypy to fail. #12744 : Fixed typing compatibility with Python 3.9 or less – replaced typing.Self with typing_extensions.Self – by @Avasam #12745 : Fixed an issue with backslashes being incorrectly converted in nodeid paths on Windows, ensuring consistent path handling across environments. #6682 : Fixed bug where the verbosity levels where not being respected when printing the “msg” part of failed assertion (as in assert condition, msg ). #9422 : Fix bug where disabling the terminal plugin via -p no:terminal would cause crashes related to missing the verbose option. – by @GTowers1

# Improved documentation¶

#12663 : Clarify that the pytest_deselected hook should be called from pytest_collection_modifyitems hook implementations when items are deselected. #12678 : Remove erroneous quotes from tmp_path_retention_policy example in docs.

# Miscellaneous internal changes¶

#12769 : Fix typos discovered by codespell and add codespell to pre-commit hooks.

# pytest 8.3.2 (2024-07-24)¶

# Bug fixes¶

#12652 : Resolve regression conda environments where no longer being automatically detected. – by @RonnyPfannschmidt

# pytest 8.3.1 (2024-07-20)¶

The 8.3.0 release failed to include the change notes and docs for the release. This patch release remedies this. There are no other changes.

# pytest 8.3.0 (2024-07-20)¶

# New features¶

#12231 : Added --xfail-tb flag, which turns on traceback output for XFAIL results. If the --xfail-tb flag is not given, tracebacks for XFAIL results are NOT shown. The style of traceback for XFAIL is set with --tb , and can be auto|long|short|line|native|no . Note: Even if you have --xfail-tb set, you won’t see them if --tb=no . Some history: With pytest 8.0, -rx or -ra would not only turn on summary reports for xfail, but also report the tracebacks for xfail results. This caused issues with some projects that utilize xfail, but don’t want to see all of the xfail tracebacks. This change detaches xfail tracebacks from -rx , and now we turn on xfail tracebacks with --xfail-tb . With this, the default -rx / -ra behavior is identical to pre-8.0 with respect to xfail tracebacks. While this is a behavior change, it brings default behavior back to pre-8.0.0 behavior, which ultimately was considered the better course of action. – by @okken #12281 : Added support for keyword matching in marker expressions. Now tests can be selected by marker keyword arguments. Supported values are int , (unescaped) str , bool & None . See marker examples for more information. – by @lovetheguitar #12567 : Added --no-fold-skipped command line option. If this option is set, then skipped tests in short summary are no longer grouped by reason but all tests are printed individually with their nodeid in the same way as other statuses. – by @pbrezina

# Improvements in existing functionality¶

#12469 : The console output now uses the “third-party plugins” terminology, replacing the previously established but confusing and outdated reference to setuptools – by @webknjaz . #12544 , #12545 : Python virtual environment detection was improved by checking for a pyvenv.cfg file, ensuring reliable detection on various platforms – by @zachsnickers . #2871 : Do not truncate arguments to functions in output when running with -vvv . #389 : The readability of assertion introspection of bound methods has been enhanced – by @farbodahm , @webknjaz , @obestwalter , @flub and @glyphack . Earlier, it was like:

```

=================================== FAILURES ===================================
_____________________________________ test _____________________________________
def test():
>       assert Help().fun() == 2
E       assert 1 == 2
E        +  where 1 = <bound method Help.fun of <example.Help instance at 0x256a830>>()
E        +    where <bound method Help.fun of <example.Help instance at 0x256a830>> = <example.Help instance at 0x256a830>.fun
E        +      where <example.Help instance at 0x256a830> = Help()
example.py:7: AssertionError
=========================== 1 failed in 0.03 seconds ===========================

```

And now it’s like:

```

=================================== FAILURES ===================================
_____________________________________ test _____________________________________
def test():
>       assert Help().fun() == 2
E       assert 1 == 2
E        +  where 1 = fun()
E        +    where fun = <test_local.Help object at 0x1074be230>.fun
E        +      where <test_local.Help object at 0x1074be230> = Help()
test_local.py:13: AssertionError
=========================== 1 failed in 0.03 seconds ===========================

```

#7662 : Added timezone information to the testsuite timestamp in the JUnit XML report.

# Bug fixes¶

#11706 : Fixed reporting of teardown errors in higher-scoped fixtures when using --maxfail or --stepwise . Originally added in pytest 8.0.0, but reverted in 8.0.2 due to a regression in pytest-xdist. This regression was fixed in pytest-xdist 3.6.1. #11797 : pytest.approx() now correctly handles Sequence -like objects. #12204 , #12264 : Fixed a regression in pytest 8.0 where tracebacks get longer and longer when multiple tests fail due to a shared higher-scope fixture which raised – by @bluetech . Also fixed a similar regression in pytest 5.4 for collectors which raise during setup. The fix necessitated internal changes which may affect some plugins: FixtureDef.cached_result[2] is now a tuple (exc, tb) instead of exc . SetupState.stack failures are now a tuple (exc, tb) instead of exc . #12275 : Fixed collection error upon encountering an abstract class, including abstract unittest.TestCase subclasses. #12328 : Fixed a regression in pytest 8.0.0 where package-scoped parameterized items were not correctly reordered to minimize setups/teardowns in some cases. #12424 : Fixed crash with assert testcase is not None assertion failure when re-running unittest tests using plugins like pytest-rerunfailures. Regressed in 8.2.2. #12472 : Fixed a crash when returning category "error" or "failed" with a custom test status from pytest_report_teststatus hook – @pbrezina . #12505 : Improved handling of invalid regex patterns in pytest.raises(match=r'...') by providing a clear error message. #12580 : Fixed a crash when using the cache class on Windows and the cache directory was created concurrently. #6962 : Parametrization parameters are now compared using == instead of is ( is is still used as a fallback if the parameter does not support == ). This fixes use of parameters such as lists, which have a different id but compare equal, causing fixtures to be re-computed instead of being cached. #7166 : Fixed progress percentages (the [ 87%] at the edge of the screen) sometimes not aligning correctly when running with pytest-xdist -n .

# Improved documentation¶

#12153 : Documented using PYTEST_VERSION to detect if code is running from within a pytest run. #12469 : The external plugin mentions in the documentation now avoid mentioning setuptools entry-points as the concept is much more generic nowadays. Instead, the terminology of “external”, “installed”, or “third-party” plugins (or packages) replaces that. – by @webknjaz #12577 : CI and BUILD_NUMBER environment variables role is described in the reference doc. They now also appear when doing pytest -h – by @MarcBresson .

# Contributor-facing changes¶

#12467 : Migrated all internal type-annotations to the python3.10+ style by using the annotations future import. – by @RonnyPfannschmidt #11771 , #12557 : The PyPy runtime version has been updated to 3.9 from 3.8 that introduced a flaky bug at the garbage collector which was not expected to fix there as the 3.8 is EoL. – by @x612skm #12493 : The change log draft preview integration has been refactored to use a third party extension sphinxcontib-towncrier . The previous in-repo script was putting the change log preview file at doc/en/_changelog_towncrier_draft.rst . Said file is no longer ignored in Git and might show up among untracked files in the development environments of the contributors. To address that, the contributors can run the following command that will clean it up:

```

$
git
clean
-x
-i
--
doc/en/_changelog_towncrier_draft.rst

```

– by @webknjaz #12498 : All the undocumented tox environments now have descriptions. They can be listed in one’s development environment by invoking tox -av in a terminal. – by @webknjaz #12501 : The changelog configuration has been updated to introduce more accurate audience-tailored categories. Previously, there was a trivial change log fragment type with an unclear and broad meaning. It was removed and we now have contrib , misc and packaging in place of it. The new change note types target the readers who are downstream packagers and project contributors. Additionally, the miscellaneous section is kept for unspecified updates that do not fit anywhere else. – by @webknjaz #12502 : The UX of the GitHub automation making pull requests to update the plugin list has been updated. Previously, the maintainers had to close the automatically created pull requests and re-open them to trigger the CI runs. From now on, they only need to click the Ready for review button instead. – by @webknjaz #12522 : The :pull: RST role has been replaced with a shorter :pr: due to starting to use the implementation from the third-party sphinx-issues Sphinx extension – by @webknjaz . #12531 : The coverage reporting configuration has been updated to exclude pytest’s own tests marked as expected to fail from the coverage report. This has an effect of reducing the influence of flaky tests on the resulting number. – by @webknjaz #12533 : The extlinks Sphinx extension is no longer enabled. The :bpo: role it used to declare has been removed with that. BPO itself has migrated to GitHub some years ago and it is possible to link the respective issues by using their GitHub issue numbers and the :issue: role that the sphinx-issues extension implements. – by @webknjaz #12562 : Possible typos in using the :user: RST role is now being linted through the pre-commit tool integration – by @webknjaz .

# pytest 8.2.2 (2024-06-04)¶

# Bug Fixes¶

#12355 : Fix possible catastrophic performance slowdown on a certain parametrization pattern involving many higher-scoped parameters. #12367 : Fix a regression in pytest 8.2.0 where unittest class instances (a fresh one is created for each test) were not released promptly on test teardown but only on session teardown. #12381 : Fix possible “Directory not empty” crashes arising from concurrent cache dir ( .pytest_cache ) creation. Regressed in pytest 8.2.0.

# Improved Documentation¶

#12290 : Updated Sphinx theme to use Furo instead of Flask, enabling Dark mode theme. #12356 : Added a subsection to the documentation for debugging flaky tests to mention lack of thread safety in pytest as a possible source of flakiness. #12363 : The documentation webpages now links to a canonical version to reduce outdated documentation in search engine results.

# pytest 8.2.1 (2024-05-19)¶

# Improvements¶

#12334 : Support for Python 3.13 (beta1 at the time of writing).

# Bug Fixes¶

#12120 : Fix PermissionError crashes arising from directories which are not selected on the command-line. #12191 : Keyboard interrupts and system exits are now properly handled during the test collection. #12300 : Fixed handling of ‘Function not implemented’ error under squashfuse_ll, which is a different way to say that the mountpoint is read-only. #12308 : Fix a regression in pytest 8.2.0 where the permissions of automatically-created .pytest_cache directories became rwx------ instead of the expected rwxr-xr-x .

# Trivial/Internal Changes¶

#12333 : pytest releases are now attested using the recent Artifact Attestation support from GitHub, allowing users to verify the provenance of pytest’s sdist and wheel artifacts.

# pytest 8.2.0 (2024-04-27)¶

# Breaking Changes¶

#12089 : pytest now requires that unittest.TestCase subclasses can be instantiated freely using MyTestCase('runTest') . If the class doesn’t allow this, you may see an error during collection such as AttributeError: 'MyTestCase' object has no attribute 'runTest' . Classes which do not override __init__ , or do not access the test method in __init__ using getattr or similar, are unaffected. Classes which do should take care to not crash when "runTest" is given, as is shown in unittest.TestCases’s implementation . Alternatively, consider using setUp instead of __init__ . If you run into this issue using tornado.AsyncTestCase , please see issue 12263 . If you run into this issue using an abstract TestCase subclass, please see issue 12275 . Historical note: the effect of this change on custom TestCase implementations was not properly considered initially, this is why it was done in a minor release. We apologize for the inconvenience.

# Deprecations¶

#12069 : A deprecation warning is now raised when implementations of one of the following hooks request a deprecated py.path.local parameter instead of the pathlib.Path parameter which replaced it: pytest_ignore_collect - the path parameter - use collection_path instead. pytest_collect_file - the path parameter - use file_path instead. pytest_pycollect_makemodule - the path parameter - use module_path instead. pytest_report_header - the startdir parameter - use start_path instead. pytest_report_collectionfinish - the startdir parameter - use start_path instead. The replacement parameters are available since pytest 7.0.0. The old parameters will be removed in pytest 9.0.0. See py.path.local arguments for hooks replaced with pathlib.Path for more details.

# Features¶

#11871 : Added support for reading command line arguments from a file using the prefix character @ , like e.g.: pytest @tests.txt . The file must have one argument per line. See Read arguments from file for details.

# Improvements¶

#11523 : pytest.importorskip() will now issue a warning if the module could be found, but raised ImportError instead of ModuleNotFoundError . The warning can be suppressed by passing exc_type=ImportError to pytest.importorskip() . See pytest.importorskip default behavior regarding ImportError for details. #11728 : For unittest -based tests, exceptions during class cleanup (as raised by functions registered with TestCase.addClassCleanup ) are now reported instead of silently failing. #11777 : Text is no longer truncated in the short test summary info section when -vv is given. #12112 : Improved namespace packages detection when consider_namespace_packages is enabled, covering more situations (like editable installs). #9502 : Added PYTEST_VERSION environment variable which is defined at the start of the pytest session and undefined afterwards. It contains the value of pytest.__version__ , and among other things can be used to easily check if code is running from within a pytest run.

# Bug Fixes¶

#12065 : Fixed a regression in pytest 8.0.0 where test classes containing setup_method and tests using @staticmethod or @classmethod would crash with AttributeError: 'NoneType' object has no attribute 'setup_method' . Now the request.instance attribute of tests using @staticmethod and @classmethod is no longer None , but a fresh instance of the class, like in non-static methods. Previously it was None , and all fixtures of such tests would share a single self . #12135 : Fixed issue where fixtures adding their finalizer multiple times to fixtures they request would cause unreliable and non-intuitive teardown ordering in some instances. #12194 : Fixed a bug with --importmode=importlib and --doctest-modules where child modules did not appear as attributes in parent modules. #1489 : Fixed some instances where teardown of higher-scoped fixtures was not happening in the reverse order they were initialized in.

# Trivial/Internal Changes¶

#12069 : pluggy>=1.5.0 is now required. #12167 : cache : create supporting files ( CACHEDIR.TAG , .gitignore , etc.) in a temporary directory to provide atomic semantics.

# pytest 8.1.2 (2024-04-26)¶

# Bug Fixes¶

#12114 : Fixed error in pytest.approx() when used with numpy arrays and comparing with other types.

# pytest 8.1.1 (2024-03-08)¶

Note This release is not a usual bug fix release – it contains features and improvements, being a follow up to 8.1.0 , which has been yanked from PyPI.

# Features¶

#11475 : Added the new consider_namespace_packages configuration option, defaulting to False . If set to True , pytest will attempt to identify modules that are part of namespace packages when importing modules. #11653 : Added the new verbosity_test_cases configuration option for fine-grained control of test execution verbosity. See Fine-grained verbosity for more details.

# Improvements¶

#10865 : pytest.warns() now validates that warnings.warn() was called with a str or a Warning . Currently in Python it is possible to use other types, however this causes an exception when warnings.filterwarnings() is used to filter those warnings (see CPython #103577 for a discussion). While this can be considered a bug in CPython, we decided to put guards in pytest as the error message produced without this check in place is confusing. #11311 : When using --override-ini for paths in invocations without a configuration file defined, the current working directory is used as the relative directory. Previously this would raise an AssertionError . #11475 : –import-mode=importlib now tries to import modules using the standard import mechanism (but still without changing sys.path ), falling back to importing modules directly only if that fails. This means that installed packages will be imported under their canonical name if possible first, for example app.core.models , instead of having the module name always be derived from their path (for example .env310.lib.site_packages.app.core.models ). #11801 : Added the iter_parents() helper method on nodes. It is similar to listchain , but goes from bottom to top, and returns an iterator, not a list. #11850 : Added support for sys.last_exc for post-mortem debugging on Python>=3.12. #11962 : In case no other suitable candidates for configuration file are found, a pyproject.toml (even without a [tool.pytest.ini_options] table) will be considered as the configuration file and define the rootdir . #11978 : Add --log-file-mode option to the logging plugin, enabling appending to log-files. This option accepts either "w" or "a" and defaults to "w" . Previously, the mode was hard-coded to be "w" which truncates the file before logging. #12047 : When multiple finalizers of a fixture raise an exception, now all exceptions are reported as an exception group. Previously, only the first exception was reported.

# Bug Fixes¶

#11475 : Fixed regression where --importmode=importlib would import non-test modules more than once. #11904 : Fixed a regression in pytest 8.0.0 that would cause test collection to fail due to permission errors when using --pyargs . This change improves the collection tree for tests specified using --pyargs , see #12043 for a comparison with pytest 8.0 and <8. #12011 : Fixed a regression in 8.0.1 whereby setup_module xunit-style fixtures are not executed when --doctest-modules is passed. #12014 : Fix the stacklevel used when warning about marks used on fixtures. #12039 : Fixed a regression in 8.0.2 where tests created using tmp_path have been collected multiple times in CI under Windows.

# Improved Documentation¶

#11790 : Documented the retention of temporary directories created using the tmp_path fixture in more detail.

# Trivial/Internal Changes¶

#11785 : Some changes were made to private functions which may affect plugins which access them: FixtureManager._getautousenames() now takes a Node itself instead of the nodeid. FixtureManager.getfixturedefs() now takes the Node itself instead of the nodeid. The _pytest.nodes.iterparentnodeids() function is removed without replacement. Prefer to traverse the node hierarchy itself instead. If you really need to, copy the function from the previous pytest release. #12069 : Delayed the deprecation of the following features to 9.0.0 : fspath argument for Node constructors replaced with pathlib.Path . py.path.local arguments for hooks replaced with pathlib.Path . It was discovered after 8.1.0 was released that the warnings about the impeding removal were not being displayed, so the team decided to revert the removal. This is the reason for 8.1.0 being yanked.

# pytest 8.1.0 (YANKED)¶

Note This release has been yanked : it broke some plugins without the proper warning period, due to some warnings not showing up as expected. See #12069 .

# pytest 8.0.2 (2024-02-24)¶

# Bug Fixes¶

#11895 : Fix collection on Windows where initial paths contain the short version of a path (for example c:\PROGRA~1\tests ). #11953 : Fix an IndexError crash raising from getstatementrange_ast . #12021 : Reverted a fix to --maxfail handling in pytest 8.0.0 because it caused a regression in pytest-xdist whereby session fixture teardowns may get executed multiple times when the max-fails is reached.

# pytest 8.0.1 (2024-02-16)¶

# Bug Fixes¶

#11875 : Correctly handle errors from getpass.getuser() in Python 3.13. #11879 : Fix an edge case where ExceptionInfo._stringify_exception could crash pytest.raises() . #11906 : Fix regression with pytest.warns() using custom warning subclasses which have more than one parameter in their __init__ . #11907 : Fix a regression in pytest 8.0.0 whereby calling pytest.skip() and similar control-flow exceptions within a pytest.warns() block would get suppressed instead of propagating. #11929 : Fix a regression in pytest 8.0.0 whereby autouse fixtures defined in a module get ignored by the doctests in the module. #11937 : Fix a regression in pytest 8.0.0 whereby items would be collected in reverse order in some circumstances.

# pytest 8.0.0 (2024-01-27)¶

# Bug Fixes¶

#11842 : Properly escape the reason of a skip mark when writing JUnit XML files. #11861 : Avoid microsecond exceeds 1_000_000 when using log-date-format with %f specifier, which might cause the test suite to crash.

# pytest 8.0.0rc2 (2024-01-17)¶

# Improvements¶

#11233 : Improvements to -r for xfailures and xpasses: Report tracebacks for xfailures when -rx is set. Report captured output for xpasses when -rX is set. For xpasses, add - in summary between test name and reason, to match how xfail is displayed. #11825 : The pytest_plugin_registered hook has a new plugin_name parameter containing the name by which plugin is registered.

# Bug Fixes¶

#11706 : Fix reporting of teardown errors in higher-scoped fixtures when using --maxfail or --stepwise . NOTE: This change was reverted in pytest 8.0.2 to fix a regression it caused in pytest-xdist. #11758 : Fixed IndexError: string index out of range crash in if highlighted[-1] == "\n" and source[-1] != "\n" . This bug was introduced in pytest 8.0.0rc1. #9765 , #11816 : Fixed a frustrating bug that afflicted some users with the only error being assert mod not in mods . The issue was caused by the fact that str(Path(mod)) and mod.__file__ don’t necessarily produce the same string, and was being erroneously used interchangeably in some places in the code. This fix also broke the internal API of PytestPluginManager.consider_conftest by introducing a new parameter – we mention this in case it is being used by external code, even if marked as private .

# pytest 8.0.0rc1 (2023-12-30)¶

# Breaking Changes¶

# Old Deprecations Are Now Errors¶

#7363 : PytestRemovedIn8Warning deprecation warnings are now errors by default. Following our plan to remove deprecated features with as little disruption as possible, all warnings of type PytestRemovedIn8Warning now generate errors instead of warning messages by default. The affected features will be effectively removed in pytest 8.1 , so please consult the Deprecations and Removals section in the docs for directions on how to update existing code. In the pytest 8.0.X series, it is possible to change the errors back into warnings as a stopgap measure by adding this to your pytest.ini file:

```

[pytest]
filterwarnings
=
ignore
:
:pytest.PytestRemovedIn8Warning

```

But this will stop working when pytest 8.1 is released. If you have concerns about the removal of a specific feature, please add a comment to #7363 .

# Version Compatibility¶

#11151 : Dropped support for Python 3.7, which reached end-of-life on 2023-06-27 . pluggy>=1.3.0 is now required.

# Collection Changes¶

In this version we’ve made several breaking changes to pytest’s collection phase, particularly around how filesystem directories and Python packages are collected, fixing deficiencies and allowing for cleanups and improvements to pytest’s internals. A deprecation period for these changes was not possible. #7777 : Files and directories are now collected in alphabetical order jointly, unless changed by a plugin. Previously, files were collected before directories. See below for an example. #8976 : Running pytest pkg/__init__.py now collects the pkg/__init__.py file (module) only. Previously, it collected the entire pkg package, including other test files in the directory, but excluding tests in the __init__.py file itself (unless python_files was changed to allow __init__.py file). To collect the entire package, specify just the directory: pytest pkg . #11137 : pytest.Package is no longer a pytest.Module or pytest.File . The Package collector node designates a Python package, that is, a directory with an __init__.py file. Previously Package was a subtype of pytest.Module (which represents a single Python module), the module being the __init__.py file. This has been deemed a design mistake (see #11137 and #7777 for details). The path property of Package nodes now points to the package directory instead of the __init__.py file. Note that a Module node for __init__.py (which is not a Package ) may still exist, if it is picked up during collection (e.g. if you configured python_files to include __init__.py files). #7777 : Added a new pytest.Directory base collection node, which all collector nodes for filesystem directories are expected to subclass. This is analogous to the existing pytest.File for file nodes. Changed pytest.Package to be a subclass of pytest.Directory . A Package represents a filesystem directory which is a Python package, i.e. contains an __init__.py file. pytest.Package now only collects files in its own directory; previously it collected recursively. Sub-directories are collected as their own collector nodes, which then collect themselves, thus creating a collection tree which mirrors the filesystem hierarchy. Added a new pytest.Dir concrete collection node, a subclass of pytest.Directory . This node represents a filesystem directory, which is not a pytest.Package , that is, does not contain an __init__.py file. Similarly to Package , it only collects the files in its own directory. pytest.Session now only collects the initial arguments, without recursing into directories. This work is now done by the recursive expansion process of directory collector nodes. session.name is now "" ; previously it was the rootdir directory name. This matches session.nodeid which has always been "" . The collection tree now contains directories/packages up to the rootdir , for initial arguments that are found within the rootdir. For files outside the rootdir, only the immediate directory/package is collected – note however that collecting from outside the rootdir is discouraged. As an example, given the following filesystem tree:

```

myroot/
    pytest.ini
    top/
    ├── aaa
    │   └── test_aaa.py
    ├── test_a.py
    ├── test_b
    │   ├── __init__.py
    │   └── test_b.py
    ├── test_c.py
    └── zzz
        ├── __init__.py
        └── test_zzz.py

```

the collection tree, as shown by pytest --collect-only top/ but with the otherwise-hidden Session node added for clarity, is now the following:

```

<
Session
>
<
Dir
myroot
>
<
Dir
top
>
<
Dir
aaa
>
<
Module
test_aaa
.
py
>
<
Function
test_it
>
<
Module
test_a
.
py
>
<
Function
test_it
>
<
Package
test_b
>
<
Module
test_b
.
py
>
<
Function
test_it
>
<
Module
test_c
.
py
>
<
Function
test_it
>
<
Package
zzz
>
<
Module
test_zzz
.
py
>
<
Function
test_it
>

```

Previously, it was:

```

<
Session
>
<
Module
top
/
test_a
.
py
>
<
Function
test_it
>
<
Module
top
/
test_c
.
py
>
<
Function
test_it
>
<
Module
top
/
aaa
/
test_aaa
.
py
>
<
Function
test_it
>
<
Package
test_b
>
<
Module
test_b
.
py
>
<
Function
test_it
>
<
Package
zzz
>
<
Module
test_zzz
.
py
>
<
Function
test_it
>

```

Code/plugins which rely on a specific shape of the collection tree might need to update. #11676 : The classes Node , Collector , Item , File , FSCollector are now marked abstract (see abc ). We do not expect this change to affect users and plugin authors, it will only cause errors when the code is already wrong or problematic.

# Other breaking changes¶

These are breaking changes where deprecation was not possible. #11282 : Sanitized the handling of the default parameter when defining configuration options. Previously if default was not supplied for parser.addini and the configuration option value was not defined in a test session, then calls to config.getini returned an empty list or an empty string depending on whether type was supplied or not respectively, which is clearly incorrect. Also, None was not honored even if default=None was used explicitly while defining the option. Now the behavior of parser.addini is as follows: If default is NOT passed but type is provided, then a type-specific default will be returned. For example type=bool will return False , type=str will return "" , etc. If default=None is passed and the option is not defined in a test session, then None will be returned, regardless of the type . If neither default nor type are provided, assume type=str and return "" as default (this is as per previous behavior). The team decided to not introduce a deprecation period for this change, as doing so would be complicated both in terms of communicating this to the community as well as implementing it, and also because the team believes this change should not break existing plugins except in rare cases. #11667 : pytest’s setup.py file is removed. If you relied on this file, e.g. to install pytest using setup.py install , please see Why you shouldn’t invoke setup.py directly for alternatives. #9288 : warns() now re-emits unmatched warnings when the context closes – previously it would consume all warnings, hiding those that were not matched by the function. While this is a new feature, we announce it as a breaking change because many test suites are configured to error-out on warnings, and will therefore fail on the newly-re-emitted warnings. The internal FixtureManager.getfixtureclosure method has changed. Plugins which use this method or which subclass FixtureManager and overwrite that method will need to adapt to the change.

# Deprecations¶

#10465 : Test functions returning a value other than None will now issue a pytest.PytestWarning instead of pytest.PytestRemovedIn8Warning , meaning this will stay a warning instead of becoming an error in the future. #3664 : Applying a mark to a fixture function now issues a warning: marks in fixtures never had any effect, but it is a common user error to apply a mark to a fixture (for example usefixtures ) and expect it to work. This will become an error in pytest 9.0.

# Features and Improvements¶

# Improved Diffs¶

These changes improve the diffs that pytest prints when an assertion fails. Note that syntax highlighting requires the pygments package. #11520 : The very verbose ( -vv ) diff output is now colored as a diff instead of a big chunk of red. Python code in error reports is now syntax-highlighted as Python. The sections in the error reports are now better separated. #1531 : The very verbose diff ( -vv ) for every standard library container type is improved. The indentation is now consistent and the markers are on their own separate lines, which should reduce the diffs shown to users. Previously, the standard Python pretty printer was used to generate the output, which puts opening and closing markers on the same line as the first/last entry, in addition to not having consistent indentation. #10617 : Added more comprehensive set assertion rewrites for comparisons other than equality == , with the following operations now providing better failure messages: != , <= , >= , < , and > .

# Separate Control For Assertion Verbosity¶

#11387 : Added the new verbosity_assertions configuration option for fine-grained control of failed assertions verbosity. If you’ve ever wished that pytest always show you full diffs, but without making everything else verbose, this is for you. See Fine-grained verbosity for more details. For plugin authors, config.get_verbosity can be used to retrieve the verbosity level for a specific verbosity type.

# Additional Support For Exception Groups and__notes__¶

These changes improve pytest’s support for exception groups. #10441 : Added ExceptionInfo.group_contains() , an assertion helper that tests if an ExceptionGroup contains a matching exception. See Matching exception groups for an example. #11227 : Allow pytest.raises() match argument to match against PEP-678 <https://peps.python.org/pep-0678/> __notes__ .

# Custom Directory collectors¶

#7777 : Added a new hook pytest_collect_directory , which is called by filesystem-traversing collector nodes, such as pytest.Session , pytest.Dir and pytest.Package , to create a collector node for a sub-directory. It is expected to return a subclass of pytest.Directory . This hook allows plugins to customize the collection of directories .

# “New-style” Hook Wrappers¶

#11122 : pytest now uses “new-style” hook wrappers internally, available since pluggy 1.2.0. See pluggy’s 1.2.0 changelog and the updated docs for details. Plugins which want to use new-style wrappers can do so if they require pytest>=8 .

# Other Improvements¶

#11216 : If a test is skipped from inside an xunit setup fixture , the test summary now shows the test location instead of the fixture location. #11314 : Logging to a file using the --log-file option will use --log-level , --log-format and --log-date-format as fallback if --log-file-level , --log-file-format and --log-file-date-format are not provided respectively. #11610 : Added the LogCaptureFixture.filtering() context manager which adds a given logging.Filter object to the caplog fixture. #11447 : pytest.deprecated_call() now also considers warnings of type FutureWarning . #11600 : Improved the documentation and type signature for pytest.mark.xfail ’s condition param to use False as the default value. #7469 : FixtureDef is now exported as pytest.FixtureDef for typing purposes. #11353 : Added typing to PytestPluginManager .

# Bug Fixes¶

#10701 : pytest.WarningsRecorder.pop() will return the most-closely-matched warning in the list, rather than the first warning which is an instance of the requested type. #11255 : Fixed crash on parametrize(..., scope="package") without a package present. #11277 : Fixed a bug that when there are multiple fixtures for an indirect parameter, the scope of the highest-scope fixture is picked for the parameter set, instead of that of the one with the narrowest scope. #11456 : Parametrized tests now really do ensure that the ids given to each input are unique - for example, a, a, a0 now results in a1, a2, a0 instead of the previous (buggy) a0, a1, a0 . This necessarily means changing nodeids where these were previously colliding, and for readability adds an underscore when non-unique ids end in a number. #11563 : Fixed a crash when using an empty string for the same parametrized value more than once. #11712 : Fixed handling NO_COLOR and FORCE_COLOR to ignore an empty value. #9036 : pytest.warns and similar functions now capture warnings when an exception is raised inside a with block.

# Improved Documentation¶

#11011 : Added a warning about modifying the root logger during tests when using caplog . #11065 : Use pytestconfig instead of request.config in cache example to be consistent with the API documentation.

# Trivial/Internal Changes¶

#11208 : The (internal) FixtureDef.cached_result type has changed. Now the third item cached_result[2] , when set, is an exception instance instead of an exception triplet. #11218 : (This entry is meant to assist plugins which access private pytest internals to instantiate FixtureRequest objects.) FixtureRequest is now an abstract class which can’t be instantiated directly. A new concrete TopRequest subclass of FixtureRequest has been added for the request fixture in test functions, as counterpart to the existing SubRequest subclass for the request fixture in fixture functions. #11315 : The pytester fixture now uses the monkeypatch fixture to manage the current working directory. If you use pytester in combination with monkeypatch.undo() , the CWD might get restored. Use monkeypatch.context() instead. #11333 : Corrected the spelling of Config.ArgsSource.INVOCATION_DIR . The previous spelling INCOVATION_DIR remains as an alias. #11638 : Fixed the selftests to pass correctly if FORCE_COLOR , NO_COLOR or PY_COLORS is set in the calling environment.

# pytest 7.4.4 (2023-12-31)¶

# Bug Fixes¶

#11140 : Fix non-string constants at the top of file being detected as docstrings on Python>=3.8. #11572 : Handle an edge case where sys.stderr and sys.__stderr__ might already be closed when Fault Handler is tearing down. #11710 : Fixed tracebacks from collection errors not getting pruned. #7966 : Removed unhelpful error message from assertion rewrite mechanism when exceptions are raised in __iter__ methods. Now they are treated un-iterable instead.

# Improved Documentation¶

#11091 : Updated documentation to refer to hyphenated options: replaced --junitxml with --junit-xml and --collectonly with --collect-only .

# pytest 7.4.3 (2023-10-24)¶

# Bug Fixes¶

#10447 : Markers are now considered in the reverse mro order to ensure base class markers are considered first – this resolves a regression. #11239 : Fixed := in asserts impacting unrelated test cases. #11439 : Handled an edge case where sys.stderr might already be closed when Fault Handler is tearing down.

# pytest 7.4.2 (2023-09-07)¶

# Bug Fixes¶

#11237 : Fix doctest collection of functools.cached_property objects. #11306 : Fixed bug using --importmode=importlib which would cause package __init__.py files to be imported more than once in some cases. #11367 : Fixed bug where user_properties where not being saved in the JUnit XML file if a fixture failed during teardown. #11394 : Fixed crash when parsing long command line arguments that might be interpreted as files.

# Improved Documentation¶

#11391 : Improved disclaimer on pytest plugin reference page to better indicate this is an automated, non-curated listing.

# pytest 7.4.1 (2023-09-02)¶

# Bug Fixes¶

#10337 : Fixed bug where fake intermediate modules generated by --import-mode=importlib would not include the child modules as attributes of the parent modules. #10702 : Fixed error assertion handling in pytest.approx() when None is an expected or received value when comparing dictionaries. #10811 : Fixed issue when using --import-mode=importlib together with --doctest-modules that caused modules to be imported more than once, causing problems with modules that have import side effects.

# pytest 7.4.0 (2023-06-23)¶

# Features¶

#10901 : Added ExceptionInfo.from_exception() , a simpler way to create an ExceptionInfo from an exception. This can replace ExceptionInfo.from_exc_info() for most uses.

# Improvements¶

#10872 : Update test log report annotation to named tuple and fixed inconsistency in docs for pytest_report_teststatus hook. #10907 : When an exception traceback to be displayed is completely filtered out (by mechanisms such as __tracebackhide__ , internal frames, and similar), now only the exception string and the following message are shown: “All traceback entries are hidden. Pass --full-trace to see hidden and internal frames.”. Previously, the last frame of the traceback was shown, even though it was hidden. #10940 : Improved verbose output ( -vv ) of skip and xfail reasons by performing text wrapping while leaving a clear margin for progress output. Added TerminalReporter.wrap_write() as a helper for that. #10991 : Added handling of %f directive to print microseconds in log format options, such as log-date-format . #11005 : Added the underlying exception to the cache provider’s path creation and write warning messages. #11013 : Added warning when testpaths is set, but paths are not found by glob. In this case, pytest will fall back to searching from the current directory. #11043 : When --confcutdir is not specified, and there is no config file present, the conftest cutoff directory ( --confcutdir ) is now set to the rootdir . Previously in such cases, conftest.py files would be probed all the way to the root directory of the filesystem. If you are badly affected by this change, consider adding an empty config file to your desired cutoff directory, or explicitly set --confcutdir . #11081 : The norecursedirs check is now performed in a pytest_ignore_collect implementation, so plugins can affect it. If after updating to this version you see that your norecursedirs setting is not being respected, it means that a conftest or a plugin you use has a bad pytest_ignore_collect implementation. Most likely, your hook returns False for paths it does not want to ignore, which ends the processing and doesn’t allow other plugins, including pytest itself, to ignore the path. The fix is to return None instead of False for paths your hook doesn’t want to ignore. #8711 : caplog.set_level() and caplog.at_level() will temporarily enable the requested level if level was disabled globally via logging.disable(LEVEL) .

# Bug Fixes¶

#10831 : Terminal Reporting: Fixed bug when running in --tb=line mode where pytest.fail(pytrace=False) tests report None . #11068 : Fixed the --last-failed whole-file skipping functionality (“skipped N files”) for non-python test files . #11104 : Fixed a regression in pytest 7.3.2 which caused to testpaths to be considered for loading initial conftests, even when it was not utilized (e.g. when explicit paths were given on the command line). Now the testpaths are only considered when they are in use. #1904 : Fixed traceback entries hidden with __tracebackhide__ = True still being shown for chained exceptions (parts after “… the above exception …” message). #7781 : Fix writing non-encodable text to log file when using --debug .

# Improved Documentation¶

#9146 : Improved documentation for caplog.set_level() .

# Trivial/Internal Changes¶

#11031 : Enhanced the CLI flag for -c to now include --config-file to make it clear that this flag applies to the usage of a custom config file.

# pytest 7.3.2 (2023-06-10)¶

# Bug Fixes¶

#10169 : Fix bug where very long option names could cause pytest to break with OSError: [Errno 36] File name too long on some systems. #10894 : Support for Python 3.12 (beta at the time of writing). #10987 : testpaths is now honored to load root conftests . #10999 : The monkeypatch setitem / delitem type annotations now allow TypedDict arguments. #11028 : Fixed bug in assertion rewriting where a variable assigned with the walrus operator could not be used later in a function call. #11054 : Fixed --last-failed ’s “(skipped N files)” functionality for files inside of packages (directories with __init__.py files).

# pytest 7.3.1 (2023-04-14)¶

# Improvements¶

#10875 : Python 3.12 support: fixed RuntimeError: TestResult has no addDuration method when running unittest tests. #10890 : Python 3.12 support: fixed shutil.rmtree(onerror=...) deprecation warning when using tmp_path .

# Bug Fixes¶

#10896 : Fixed performance regression related to tmp_path and the new tmp_path_retention_policy option. #10903 : Fix crash INTERNALERROR IndexError: list index out of range which happens when displaying an exception where all entries are hidden. This reverts the change “Correctly handle __tracebackhide__ for chained exceptions.” introduced in version 7.3.0.

# pytest 7.3.0 (2023-04-08)¶

# Features¶

#10525 : Test methods decorated with @classmethod can now be discovered as tests, following the same rules as normal methods. This fills the gap that static methods were discoverable as tests but not class methods. #10755 : console_output_style now supports progress-even-when-capture-no to force the use of the progress output even when capture is disabled. This is useful in large test suites where capture may have significant performance impact. #7431 : --log-disable CLI option added to disable individual loggers. #8141 : Added tmp_path_retention_count and tmp_path_retention_policy configuration options to control how directories created by the tmp_path fixture are kept.

# Improvements¶

#10226 : If multiple errors are raised in teardown, we now re-raise an ExceptionGroup of them instead of discarding all but the last. #10658 : Allow -p arguments to include spaces (eg: -p no:logging instead of -pno:logging ). Mostly useful in the addopts section of the configuration file. #10710 : Added start and stop timestamps to TestReport objects. #10727 : Split the report header for rootdir , config file and testpaths so each has its own line. #10840 : pytest should no longer crash on AST with pathological position attributes, for example testing AST produced by Hylang <https://github.com/hylang/hy>__ . #6267 : The full output of a test is no longer truncated if the truncation message would be longer than the hidden text. The line number shown has also been fixed.

# Bug Fixes¶

#10743 : The assertion rewriting mechanism now works correctly when assertion expressions contain the walrus operator. #10765 : Fixed tmp_path fixture always raising OSError on emscripten platform due to missing os.getuid() . #1904 : Correctly handle __tracebackhide__ for chained exceptions. NOTE: This change was reverted in version 7.3.1.

# Improved Documentation¶

#10782 : Fixed the minimal example in Good Integration Practices : pip install -e . requires a version entry in pyproject.toml to run successfully.

# Trivial/Internal Changes¶

#10669 : pytest no longer directly depends on the attrs package. While we at pytest all love the package dearly and would like to thank the attrs team for many years of cooperation and support, it makes sense for pytest to have as little external dependencies as possible, as this helps downstream projects. With that in mind, we have replaced the pytest’s limited internal usage to use the standard library’s dataclasses instead. Nice diffs for attrs classes are still supported though.

# pytest 7.2.2 (2023-03-03)¶

# Bug Fixes¶

#10533 : Fixed pytest.approx() handling of dictionaries containing one or more values of 0.0 . #10592 : Fixed crash if --cache-show and --help are passed at the same time. #10597 : Fixed bug where a fixture method named teardown would be called as part of nose teardown stage. #10626 : Fixed crash if --fixtures and --help are passed at the same time. #10660 : Fixed pytest.raises() to return a ‘ContextManager’ so that type-checkers could narrow pytest.raises(...) if ... else nullcontext() down to ‘ContextManager’ rather than ‘object’.

# Improved Documentation¶

#10690 : Added CI and BUILD_NUMBER environment variables to the documentation. #10721 : Fixed entry-points declaration in the documentation example using Hatch. #10753 : Changed wording of the module level skip to be very explicit about not collecting tests and not executing the rest of the module.

# pytest 7.2.1 (2023-01-13)¶

# Bug Fixes¶

#10452 : Fix ‘importlib.abc.TraversableResources’ deprecation warning in Python 3.12. #10457 : If a test is skipped from inside a fixture, the test summary now shows the test location instead of the fixture location. #10506 : Fix bug where sometimes pytest would use the file system root directory as rootdir on Windows. #10607 : Fix a race condition when creating junitxml reports, which could occur when multiple instances of pytest execute in parallel. #10641 : Fix a race condition when creating or updating the stepwise plugin’s cache, which could occur when multiple xdist worker nodes try to simultaneously update the stepwise plugin’s cache.

# pytest 7.2.0 (2022-10-23)¶

# Deprecations¶

#10012 : Update pytest.PytestUnhandledCoroutineWarning to a deprecation; it will raise an error in pytest 8. #10396 : pytest no longer depends on the py library. pytest provides a vendored copy of py.error and py.path modules but will use the py library if it is installed. If you need other py.* modules, continue to install the deprecated py library separately, otherwise it can usually be removed as a dependency. #4562 : Deprecate configuring hook specs/impls using attributes/marks. Instead use pytest.hookimpl() and pytest.hookspec() . For more details, see the docs . #9886 : The functionality for running tests written for nose has been officially deprecated. This includes: Plain setup and teardown functions and methods: this might catch users by surprise, as setup() and teardown() are not pytest idioms, but part of the nose support. Setup/teardown using the @with_setup decorator. For more details, consult the deprecation docs . #7337 : A deprecation warning is now emitted if a test function returns something other than None . This prevents a common mistake among beginners that expect that returning a bool (for example return foo(a, b) == result ) would cause a test to pass or fail, instead of using assert . The plan is to make returning non- None from tests an error in the future.

# Features¶

#9897 : Added shell-style wildcard support to testpaths .

# Improvements¶

#10218 : @pytest.mark.parametrize() (and similar functions) now accepts any Sequence[str] for the argument names, instead of just list[str] and tuple[str, ...] . (Note that str , which is itself a Sequence[str] , is still treated as a comma-delimited name list, as before). #10381 : The --no-showlocals flag has been added. This can be passed directly to tests to override --showlocals declared through addopts . #3426 : Assertion failures with strings in NFC and NFD forms that normalize to the same string now have a dedicated error message detailing the issue, and their utf-8 representation is expressed instead. #8508 : Introduce multiline display for warning matching via pytest.warns() and enhance match comparison for pytest.ExceptionInfo.match() as returned by pytest.raises() . #8646 : Improve pytest.raises() . Previously passing an empty tuple would give a confusing error. We now raise immediately with a more helpful message. #9741 : On Python 3.11, use the standard library’s tomllib to parse TOML. tomli is no longer a dependency on Python 3.11. #9742 : Display assertion message without escaped newline characters with -vv . #9823 : Improved error message that is shown when no collector is found for a given file. #9873 : Some coloring has been added to the short test summary. #9883 : Normalize the help description of all command-line options. #9920 : Display full crash messages in short test summary info , when running in a CI environment. #9987 : Added support for hidden configuration file by allowing .pytest.ini as an alternative to pytest.ini .

# Bug Fixes¶

#10150 : sys.stdin now contains all expected methods of a file-like object when capture is enabled. #10382 : Do not break into pdb when raise unittest.SkipTest() appears top-level in a file. #7792 : Marks are now inherited according to the full MRO in test classes. Previously, if a test class inherited from two or more classes, only marks from the first super-class would apply. When inheriting marks from super-classes, marks from the sub-classes are now ordered before marks from the super-classes, in MRO order. Previously it was the reverse. When inheriting marks from super-classes, the pytestmark attribute of the sub-class now only contains the marks directly applied to it. Previously, it also contained marks from its super-classes. Please note that this attribute should not normally be accessed directly; use Node.iter_markers instead. #9159 : Showing inner exceptions by forcing native display in ExceptionGroups even when using display options other than --tb=native . A temporary step before full implementation of pytest-native display for inner exceptions in ExceptionGroups . #9877 : Ensure caplog.get_records(when) returns current/correct data after invoking caplog.clear() .

# Improved Documentation¶

#10344 : Update information on writing plugins to use pyproject.toml instead of setup.py . #9248 : The documentation is now built using Sphinx 5.x (up from 3.x previously). #9291 : Update documentation on how pytest.warns() affects DeprecationWarning .

# Trivial/Internal Changes¶

#10313 : Made _pytest.doctest.DoctestItem export pytest.DoctestItem for type check and runtime purposes. Made _pytest.doctest use internal APIs to avoid circular imports. #9906 : Made _pytest.compat re-export importlib_metadata in the eyes of type checkers. #9910 : Fix default encoding warning ( EncodingWarning ) in cacheprovider #9984 : Improve the error message when we attempt to access a fixture that has been torn down. Add an additional sentence to the docstring explaining when it’s not a good idea to call getfixturevalue .

# pytest 7.1.3 (2022-08-31)¶

# Bug Fixes¶

#10060 : When running with --pdb , TestCase.tearDown is no longer called for tests when the class has been skipped via unittest.skip or pytest.mark.skip . #10190 : Invalid XML characters in setup or teardown error messages are now properly escaped for JUnit XML reports. #10230 : Ignore .py files created by pyproject.toml -based editable builds introduced in pip 21.3 . #3396 : Doctests now respect the --import-mode flag. #9514 : Type-annotate FixtureRequest.param as Any as a stop gap measure until #8073 is fixed. #9791 : Fixed a path handling code in rewrite.py that seems to work fine, but was incorrect and fails in some systems. #9917 : Fixed string representation for pytest.approx() when used to compare tuples.

# Improved Documentation¶

#9937 : Explicit note that tmpdir fixture is discouraged in favour of tmp_path .

# Trivial/Internal Changes¶

#10114 : Replace atomicwrites dependency on windows with os.replace .

# pytest 7.1.2 (2022-04-23)¶

# Bug Fixes¶

#9726 : An unnecessary numpy import inside pytest.approx() was removed. #9820 : Fix comparison of dataclasses with InitVar . #9869 : Increase stacklevel for the NODE_CTOR_FSPATH_ARG deprecation to point to the user’s code, not pytest. #9871 : Fix a bizarre (and fortunately rare) bug where the temp_path fixture could raise an internal error while attempting to get the current user’s username.

# pytest 7.1.1 (2022-03-17)¶

# Bug Fixes¶

#9767 : Fixed a regression in pytest 7.1.0 where some conftest.py files outside of the source tree (e.g. in the site-packages directory) were not picked up.

# pytest 7.1.0 (2022-03-13)¶

# Breaking Changes¶

#8838 : As per our policy, the following features have been deprecated in the 6.X series and are now removed: pytest._fillfuncargs function. pytest_warning_captured hook - use pytest_warning_recorded instead. -k -foobar syntax - use -k 'not foobar' instead. -k foobar: syntax. pytest.collect module - import from pytest directly. For more information consult Deprecations and Removals in the docs. #9437 : Dropped support for Python 3.6, which reached end-of-life at 2021-12-23.

# Improvements¶

#5192 : Fixed test output for some data types where -v would show less information. Also, when showing diffs for sequences, -q would produce full diffs instead of the expected diff. #9362 : pytest now avoids specialized assert formatting when it is detected that the default __eq__ is overridden in attrs or dataclasses . #9536 : When -vv is given on command line, show skipping and xfail reasons in full instead of truncating them to fit the terminal width. #9644 : More information about the location of resources that led Python to raise ResourceWarning can now be obtained by enabling tracemalloc . See Resource Warnings for more information. #9678 : More types are now accepted in the ids argument to @pytest.mark.parametrize . Previously only str , float , int and bool were accepted; now bytes , complex , re.Pattern , Enum and anything with a __name__ are also accepted. #9692 : pytest.approx() now raises a TypeError when given an unordered sequence (such as set ). Note that this implies that custom classes which only implement __iter__ and __len__ are no longer supported as they don’t guarantee order.

# Bug Fixes¶

#8242 : The deprecation of raising unittest.SkipTest to skip collection of tests during the pytest collection phase is reverted - this is now a supported feature again. #9493 : Symbolic link components are no longer resolved in conftest paths. This means that if a conftest appears twice in collection tree, using symlinks, it will be executed twice. For example, given tests/real/conftest.py tests/real/test_it.py tests/link -> tests/real running pytest tests now imports the conftest twice, once as tests/real/conftest.py and once as tests/link/conftest.py . This is a fix to match a similar change made to test collection itself in pytest 6.0 (see #6523 for details). #9626 : Fixed count of selected tests on terminal collection summary when there were errors or skipped modules. If there were errors or skipped modules on collection, pytest would mistakenly subtract those from the selected count. #9645 : Fixed regression where --import-mode=importlib used together with PYTHONPATH or pythonpath would cause import errors in test suites. #9708 : pytester now requests a monkeypatch fixture instead of creating one internally. This solves some issues with tests that involve pytest environment variables. #9730 : Malformed pyproject.toml files now produce a clearer error message.

# pytest 7.0.1 (2022-02-11)¶

# Bug Fixes¶

#9608 : Fix invalid importing of importlib.readers in Python 3.9. #9610 : Restore UnitTestFunction.obj to return unbound rather than bound method. Fixes a crash during a failed teardown in unittest TestCases with non-default __init__ . Regressed in pytest 7.0.0. #9636 : The pythonpath plugin was renamed to python_path . This avoids a conflict with the pytest-pythonpath plugin. #9642 : Fix running tests by id with :: in the parametrize portion. #9643 : Delay issuing a PytestWarning about diamond inheritance involving Item and Collector so it can be filtered using standard warning filters .

# pytest 7.0.0 (2022-02-03)¶

( Please see the full set of changes for this release also in the 7.0.0rc1 notes below )

# Deprecations¶

#9488 : If custom subclasses of nodes like pytest.Item override the __init__ method, they should take **kwargs . See Constructors of custom Node subclasses should take **kwargs for details. Note that a deprecation warning is only emitted when there is a conflict in the arguments pytest expected to pass. This deprecation was already part of pytest 7.0.0rc1 but wasn’t documented.

# Bug Fixes¶

#9355 : Fixed error message prints function decorators when using assert in Python 3.8 and above. #9396 : Ensure pytest.Config.inifile is available during the pytest_cmdline_main hook (regression during 7.0.0rc1 ).

# Improved Documentation¶

#9404 : Added extra documentation on alternatives to common misuses of pytest.warns(None) ahead of its deprecation. #9505 : Clarify where the configuration files are located. To avoid confusions documentation mentions that configuration file is located in the root of the repository.

# Trivial/Internal Changes¶

#9521 : Add test coverage to assertion rewrite path.

# pytest 7.0.0rc1 (2021-12-06)¶

# Breaking Changes¶

#7259 : The Node.reportinfo() function first return value type has been expanded from py.path.local | str to os.PathLike[str] | str . Most plugins which refer to reportinfo() only define it as part of a custom pytest.Item implementation. Since py.path.local is an os.PathLike[str] , these plugins are unaffected. Plugins and users which call reportinfo() , use the first return value and interact with it as a py.path.local , would need to adjust by calling py.path.local(fspath) . Although preferably, avoid the legacy py.path.local and use pathlib.Path , or use item.location or item.path , instead. Note: pytest was not able to provide a deprecation period for this change. #8246 : --version now writes version information to stdout rather than stderr . #8733 : Drop a workaround for pyreadline that made it work with --pdb . The workaround was introduced in #1281 in 2015, however since then pyreadline seems to have gone unmaintained , is generating warnings , and will stop working on Python 3.10. #9061 : Using pytest.approx() in a boolean context now raises an error hinting at the proper usage. It is apparently common for users to mistakenly use pytest.approx like this:

```

assert
pytest
.
approx
(
actual
,
expected
)

```

While the correct usage is:

```

assert
actual
==
pytest
.
approx
(
expected
)

```

The new error message helps catch those mistakes. #9277 : The pytest.Instance collector type has been removed. Importing pytest.Instance or _pytest.python.Instance returns a dummy type and emits a deprecation warning. See The pytest.Instance collector for details. #9308 : PytestRemovedIn7Warning deprecation warnings are now errors by default. Following our plan to remove deprecated features with as little disruption as possible, all warnings of type PytestRemovedIn7Warning now generate errors instead of warning messages by default. The affected features will be effectively removed in pytest 7.1 , so please consult the Deprecations and Removals section in the docs for directions on how to update existing code. In the pytest 7.0.X series, it is possible to change the errors back into warnings as a stopgap measure by adding this to your pytest.ini file:

```

[pytest]
filterwarnings
=
ignore
:
:pytest.PytestRemovedIn7Warning

```

But this will stop working when pytest 7.1 is released. If you have concerns about the removal of a specific feature, please add a comment to #9308 .

# Deprecations¶

#7259 : py.path.local arguments for hooks have been deprecated. See the deprecation note for full details. py.path.local arguments to Node constructors have been deprecated. See the deprecation note for full details. Note The name of the Node arguments and attributes (the new attribute being path ) is the opposite of the situation for hooks (the old argument being path ). This is an unfortunate artifact due to historical reasons, which should be resolved in future versions as we slowly get rid of the py dependency (see #9283 for a longer discussion). #7469 : Directly constructing the following classes is now deprecated: _pytest.mark.structures.Mark _pytest.mark.structures.MarkDecorator _pytest.mark.structures.MarkGenerator _pytest.python.Metafunc _pytest.runner.CallInfo _pytest._code.ExceptionInfo _pytest.config.argparsing.Parser _pytest.config.argparsing.OptionGroup _pytest.pytester.HookRecorder These constructors have always been considered private, but now issue a deprecation warning, which may become a hard error in pytest 8. #8242 : Raising unittest.SkipTest to skip collection of tests during the pytest collection phase is deprecated. Use pytest.skip() instead. Note: This deprecation only relates to using unittest.SkipTest during test collection. You are probably not doing that. Ordinary usage of unittest.SkipTest / unittest.TestCase.skipTest() / unittest.skip() in unittest test cases is fully supported. Note This deprecation has been reverted in pytest 7.1.0. #8315 : Several behaviors of Parser.addoption are now scheduled for removal in pytest 8 (deprecated since pytest 2.4.0): parser.addoption(..., help=".. %default ..") - use %(default)s instead. parser.addoption(..., type="int/string/float/complex") - use type=int etc. instead. #8447 : Defining a custom pytest node type which is both an Item and a Collector (e.g. File ) now issues a warning. It was never sanely supported and triggers hard to debug errors. See the deprecation note for full details. #8592 : pytest_cmdline_preparse has been officially deprecated. It will be removed in a future release. Use pytest_load_initial_conftests instead. See the deprecation note for full details. #8645 : pytest.warns(None) is now deprecated because many people used it to mean “this code does not emit warnings”, but it actually had the effect of checking that the code emits at least one warning of any type - like pytest.warns() or pytest.warns(Warning) . #8948 : pytest.skip(msg=...) , pytest.fail(msg=...) and pytest.exit(msg=...) signatures now accept a reason argument instead of msg . Using msg still works, but is deprecated and will be removed in a future release. This was changed for consistency with pytest.mark.skip and pytest.mark.xfail which both accept reason as an argument. #8174 : The following changes have been made to types reachable through pytest.ExceptionInfo.traceback : The path property of _pytest.code.Code returns Path instead of py.path.local . The path property of _pytest.code.TracebackEntry returns Path instead of py.path.local . There was no deprecation period for this change (sorry!).

# Features¶

#5196 : Tests are now ordered by definition order in more cases. In a class hierarchy, tests from base classes are now consistently ordered before tests defined on their subclasses (reverse MRO order). #7132 : Added two environment variables PYTEST_THEME and PYTEST_THEME_MODE to let the users customize the pygments theme used. #7259 : Added cache.mkdir() , which is similar to the existing cache.makedir() , but returns a pathlib.Path instead of a legacy py.path.local . Added a paths type to parser.addini() , as in parser.addini("mypaths", "my paths", type="paths") , which is similar to the existing pathlist , but returns a list of pathlib.Path instead of legacy py.path.local . #7469 : The types of objects used in pytest’s API are now exported so they may be used in type annotations. The newly-exported types are: pytest.Config for Config . pytest.Mark for marks . pytest.MarkDecorator for mark decorators . pytest.MarkGenerator for the pytest.mark singleton. pytest.Metafunc for the metafunc argument to the pytest_generate_tests hook. pytest.CallInfo for the CallInfo type passed to various hooks. pytest.PytestPluginManager for PytestPluginManager . pytest.ExceptionInfo for the ExceptionInfo type returned from pytest.raises() and passed to various hooks. pytest.Parser for the Parser type passed to the pytest_addoption hook. pytest.OptionGroup for the OptionGroup type returned from the parser.addgroup method. pytest.HookRecorder for the HookRecorder type returned from Pytester . pytest.RecordedHookCall for the RecordedHookCall type returned from HookRecorder . pytest.RunResult for the RunResult type returned from Pytester . pytest.LineMatcher for the LineMatcher type used in RunResult and others. pytest.TestReport for the TestReport type used in various hooks. pytest.CollectReport for the CollectReport type used in various hooks. Constructing most of them directly is not supported; they are only meant for use in type annotations. Doing so will emit a deprecation warning, and may become a hard-error in pytest 8.0. Subclassing them is also not supported. This is not currently enforced at runtime, but is detected by type-checkers such as mypy. #7856 : –import-mode=importlib now works with features that depend on modules being on sys.modules , such as pickle and dataclasses . #8144 : The following hooks now receive an additional pathlib.Path argument, equivalent to an existing py.path.local argument: pytest_ignore_collect - The collection_path parameter (equivalent to existing path parameter). pytest_collect_file - The file_path parameter (equivalent to existing path parameter). pytest_pycollect_makemodule - The module_path parameter (equivalent to existing path parameter). pytest_report_header - The start_path parameter (equivalent to existing startdir parameter). pytest_report_collectionfinish - The start_path parameter (equivalent to existing startdir parameter). Note The name of the Node arguments and attributes (the new attribute being path ) is the opposite of the situation for hooks (the old argument being path ). This is an unfortunate artifact due to historical reasons, which should be resolved in future versions as we slowly get rid of the py dependency (see #9283 for a longer discussion). #8251 : Implement Node.path as a pathlib.Path . Both the old fspath and this new attribute gets set no matter whether path or fspath (deprecated) is passed to the constructor. It is a replacement for the fspath attribute (which represents the same path as py.path.local ). While fspath is not deprecated yet due to the ongoing migration of methods like reportinfo() , we expect to deprecate it in a future release. Note The name of the Node arguments and attributes (the new attribute being path ) is the opposite of the situation for hooks (the old argument being path ). This is an unfortunate artifact due to historical reasons, which should be resolved in future versions as we slowly get rid of the py dependency (see #9283 for a longer discussion). #8421 : pytest.approx() now works on Decimal within mappings/dicts and sequences/lists. #8606 : pytest invocations with --fixtures-per-test and --fixtures have been enriched with: Fixture location path printed with the fixture name. First section of the fixture’s docstring printed under the fixture name. Whole of fixture’s docstring printed under the fixture name using --verbose option. #8761 : New pytest.version_tuple attribute, which makes it simpler for users to do something depending on the pytest version (such as declaring hooks which are introduced in later versions). #8789 : Switch TOML parser from toml to tomli for TOML v1.0.0 support in pyproject.toml . #8920 : Added pytest.Stash , a facility for plugins to store their data on Config and Node s in a type-safe and conflict-free manner. See Storing data on items across hook functions for details. #8953 : RunResult method assert_outcomes() now accepts a warnings argument to assert the total number of warnings captured. #8954 : --debug flag now accepts a str file to route debug logs into, remains defaulted to pytestdebug.log . #9023 : Full diffs are now always shown for equality assertions of iterables when CI or BUILD_NUMBER is found in the environment, even when -v isn’t used. #9113 : RunResult method assert_outcomes() now accepts a deselected argument to assert the total number of deselected tests. #9114 : Added pythonpath setting that adds listed paths to sys.path for the duration of the test session. If you currently use the pytest-pythonpath or pytest-srcpaths plugins, you should be able to replace them with built-in pythonpath setting.

# Improvements¶

#7480 : A deprecation scheduled to be removed in a major version X (e.g. pytest 7, 8, 9, …) now uses warning category PytestRemovedInXWarning , a subclass of PytestDeprecationWarning , instead of PytestDeprecationWarning directly. See Backwards Compatibility Policy for more details. #7864 : Improved error messages when parsing warning filters. Previously pytest would show an internal traceback, which besides being ugly sometimes would hide the cause of the problem (for example an ImportError while importing a specific warning type). #8335 : Improved pytest.approx() assertion messages for sequences of numbers. The assertion messages now dumps a table with the index and the error of each diff. Example:

```

>
assert
[
1
,
2
,
3
,
4
]
==
pytest
.
approx
([
1
,
3
,
3
,
5
])
E
assert
comparison
failed
for
2
values
:
E
Index
|
Obtained
|
Expected
E
1
|
2
|
3
+-
3.0e-06
E
3
|
4
|
5
+-
5.0e-06

```

#8403 : By default, pytest will truncate long strings in assert errors so they don’t clutter the output too much, currently at 240 characters by default. However, in some cases the longer output helps, or is even crucial, to diagnose a failure. Using -v will now increase the truncation threshold to 2400 characters, and -vv or higher will disable truncation entirely. #8509 : Fixed issue where unittest.TestCase.setUpClass() is not called when a test has / in its name since pytest 6.2.0. This refers to the path part in pytest node IDs, e.g. TestClass::test_it in the node ID tests/test_file.py::TestClass::test_it . Now, instead of assuming that the test name does not contain / , it is assumed that test path does not contain :: . We plan to hopefully make both of these work in the future. #8803 : It is now possible to add colors to custom log levels on cli log. By using add_color_level from a pytest_configure hook, colors can be added:

```

logging_plugin
=
config
.
pluginmanager
.
get_plugin
(
'logging-plugin'
)
logging_plugin
.
log_cli_handler
.
formatter
.
add_color_level
(
logging
.
INFO
,
'cyan'
)
logging_plugin
.
log_cli_handler
.
formatter
.
add_color_level
(
logging
.
SPAM
,
'blue'
)

```

See Customizing Colors for more information. #8822 : When showing fixture paths in --fixtures or --fixtures-by-test , fixtures coming from pytest itself now display an elided path, rather than the full path to the file in the site-packages directory. #8898 : Complex numbers are now treated like floats and integers when generating parameterization IDs. #9062 : --stepwise-skip now implicitly enables --stepwise and can be used on its own. #9205 : pytest.Cache.set() now preserves key order when saving dicts.

# Bug Fixes¶

#7124 : Fixed an issue where __main__.py would raise an ImportError when --doctest-modules was provided. #8061 : Fixed failing staticmethod test cases if they are inherited from a parent test class. #8192 : testdir.makefile now silently accepts values which don’t start with . to maintain backward compatibility with older pytest versions. pytester.makefile now issues a clearer error if the . is missing in the ext argument. #8258 : Fixed issue where pytest’s faulthandler support would not dump traceback on crashes if the faulthandler module was already enabled during pytest startup (using python -X dev -m pytest for example). #8317 : Fixed an issue where illegal directory characters derived from getpass.getuser() raised an OSError . #8367 : Fix Class.from_parent so it forwards extra keyword arguments to the constructor. #8377 : The test selection options pytest -k and pytest -m now support matching names containing forward slash ( / ) characters. #8384 : The @pytest.mark.skip decorator now correctly handles its arguments. When the reason argument is accidentally given both positional and as a keyword (e.g. because it was confused with skipif ), a TypeError now occurs. Before, such tests were silently skipped, and the positional argument ignored. Additionally, reason is now documented correctly as positional or keyword (rather than keyword-only). #8394 : Use private names for internal fixtures that handle classic setup/teardown so that they don’t show up with the default --fixtures invocation (but they still show up with --fixtures -v ). #8456 : The required_plugins config option now works correctly when pre-releases of plugins are installed, rather than falsely claiming that those plugins aren’t installed at all. #8464 : -c <config file> now also properly defines rootdir as the directory that contains <config file> . #8503 : pytest.MonkeyPatch.syspath_prepend() no longer fails when setuptools is not installed. It now only calls pkg_resources.fixup_namespace_packages if pkg_resources was previously imported, because it is not needed otherwise. #8548 : Introduce fix to handle precision width in log-cli-format in turn to fix output coloring for certain formats. #8796 : Fixed internal error when skipping doctests. #8983 : The test selection options pytest -k and pytest -m now support matching names containing backslash ( \ ) characters. Backslashes are treated literally, not as escape characters (the values being matched against are already escaped). #8990 : Fix pytest -vv crashing with an internal exception AttributeError: 'str' object has no attribute 'relative_to' in some cases. #9077 : Fixed confusing error message when request.fspath / request.path was accessed from a session-scoped fixture. #9131 : Fixed the URL used by --pastebin to use bpa.st . #9163 : The end line number and end column offset are now properly set for rewritten assert statements. #9169 : Support for the files API from importlib.resources within rewritten files. #9272 : The nose compatibility module-level fixtures setup() and teardown() are now only called once per module, instead of for each test function. They are now called even if object-level setup / teardown is defined.

# Improved Documentation¶

#4320 : Improved docs for pytester.copy_example . #5105 : Add automatically generated Pytest Plugin List . The list is updated on a periodic schedule. #8337 : Recommend numpy.testing module on pytest.approx() documentation. #8655 : Help text for --pdbcls more accurately reflects the option’s behavior. #9210 : Remove incorrect docs about confcutdir being a configuration option: it can only be set through the --confcutdir command-line option. #9242 : Upgrade readthedocs configuration to use a newer Ubuntu version <https://blog.readthedocs.com/new-build-specification/>`__ with better unicode support for PDF docs. #9341 : Various methods commonly used for Working with non-python tests are now correctly documented in the reference docs. They were undocumented previously.

# Trivial/Internal Changes¶

#8133 : Migrate to setuptools_scm 6.x to use SETUPTOOLS_SCM_PRETEND_VERSION_FOR_PYTEST for more robust release tooling. #8174 : The following changes have been made to internal pytest types/functions: The _pytest.code.getfslineno() function returns Path instead of py.path.local . The _pytest.python.path_matches_patterns() function takes Path instead of py.path.local . The _pytest._code.Traceback.cut() function accepts any os.PathLike[str] , not just py.path.local . #8248 : Internal Restructure: let python.PyObjMixin inherit from nodes.Node to carry over typing information. #8432 : Improve error message when pytest.skip() is used at module level without passing allow_module_level=True . #8818 : Ensure regendoc opts out of TOX_ENV cachedir selection to ensure independent example test runs. #8913 : The private CallSpec2._arg2scopenum attribute has been removed after an internal refactoring. #8967 : pytest_assertion_pass is no longer considered experimental and future changes to it will be considered more carefully. #9202 : Add github action to upload coverage report to codecov instead of bash uploader. #9225 : Changed the command used to create sdist and wheel artifacts: using the build package instead of setup.py. #9351 : Correct minor typos in doc/en/example/special.rst.

# pytest 6.2.5 (2021-08-29)¶

# Trivial/Internal Changes¶

#8494 : Python 3.10 is now supported. #9040 : Enable compatibility with pluggy 1.0 or later.

# pytest 6.2.4 (2021-05-04)¶

# Bug Fixes¶

#8539 : Fixed assertion rewriting on Python 3.10.

# pytest 6.2.3 (2021-04-03)¶

# Bug Fixes¶

#8414 : pytest used to create directories under /tmp with world-readable permissions. This means that any user in the system was able to read information written by tests in temporary directories (such as those created by the tmp_path / tmpdir fixture). Now the directories are created with private permissions. pytest used to silently use a preexisting /tmp/pytest-of-<username> directory, even if owned by another user. This means another user could pre-create such a directory and gain control of another user’s temporary directory. Now such a condition results in an error.

# pytest 6.2.2 (2021-01-25)¶

# Bug Fixes¶

#8152 : Fixed “(<Skipped instance>)” being shown as a skip reason in the verbose test summary line when the reason is empty. #8249 : Fix the faulthandler plugin for occasions when running with twisted.logger and using pytest --capture=no .

# pytest 6.2.1 (2020-12-15)¶

# Bug Fixes¶

#7678 : Fixed bug where ImportPathMismatchError would be raised for files compiled in the host and loaded later from an UNC mounted path (Windows). #8132 : Fixed regression in approx : in 6.2.0 approx no longer raises TypeError when dealing with non-numeric types, falling back to normal comparison. Before 6.2.0, array types like tf.DeviceArray fell through to the scalar case, and happened to compare correctly to a scalar if they had only one element. After 6.2.0, these types began failing, because they inherited neither from standard Python number hierarchy nor from numpy.ndarray . approx now converts arguments to numpy.ndarray if they expose the array protocol and are not scalars. This treats array-like objects like numpy arrays, regardless of size.

# pytest 6.2.0 (2020-12-12)¶

# Breaking Changes¶

#7808 : pytest now supports python3.6+ only.

# Deprecations¶

#7469 : Directly constructing/calling the following classes/functions is now deprecated: _pytest.cacheprovider.Cache _pytest.cacheprovider.Cache.for_config() _pytest.cacheprovider.Cache.clear_cache() _pytest.cacheprovider.Cache.cache_dir_from_config() _pytest.capture.CaptureFixture _pytest.fixtures.FixtureRequest _pytest.fixtures.SubRequest _pytest.logging.LogCaptureFixture _pytest.pytester.Pytester _pytest.pytester.Testdir _pytest.recwarn.WarningsRecorder _pytest.recwarn.WarningsChecker _pytest.tmpdir.TempPathFactory _pytest.tmpdir.TempdirFactory These have always been considered private, but now issue a deprecation warning, which may become a hard error in pytest 8.0.0. #7530 : The --strict command-line option has been deprecated, use --strict-markers instead. We have plans to maybe in the future to reintroduce --strict and make it an encompassing flag for all strictness related options ( --strict-markers and --strict-config at the moment, more might be introduced in the future). #7988 : The @pytest.yield_fixture decorator/function is now deprecated. Use pytest.fixture() instead. yield_fixture has been an alias for fixture for a very long time, so can be search/replaced safely.

# Features¶

#5299 : pytest now warns about unraisable exceptions and unhandled thread exceptions that occur in tests on Python>=3.8. See Warning about unraisable exceptions and unhandled thread exceptions for more information. #7425 : New pytester fixture, which is identical to testdir but its methods return pathlib.Path when appropriate instead of py.path.local . This is part of the movement to use pathlib.Path objects internally, in order to remove the dependency to py in the future. Internally, the old pytest.Testdir is now a thin wrapper around Pytester , preserving the old interface. #7695 : A new hook was added, pytest_markeval_namespace which should return a dictionary. This dictionary will be used to augment the “global” variables available to evaluate skipif/xfail/xpass markers. Pseudo example conftest.py :

```

def
pytest_markeval_namespace
():
return
{
"color"
:
"red"
}

```

test_func.py :

```

@pytest
.
mark
.
skipif
(
"color == 'blue'"
,
reason
=
"Color is not red"
)
def
test_func
():
assert
False

```

#8006 : It is now possible to construct a MonkeyPatch object directly as pytest.MonkeyPatch() , in cases when the monkeypatch fixture cannot be used. Previously some users imported it from the private _pytest.monkeypatch.MonkeyPatch namespace. Additionally, MonkeyPatch.context is now a classmethod, and can be used as with MonkeyPatch.context() as mp: ... . This is the recommended way to use MonkeyPatch directly, since unlike the monkeypatch fixture, an instance created directly is not undo() -ed automatically.

# Improvements¶

#1265 : Added an __str__ implementation to the LineMatcher class which is returned from pytester.run_pytest().stdout and similar. It returns the entire output, like the existing str() method. #2044 : Verbose mode now shows the reason that a test was skipped in the test’s terminal line after the “SKIPPED”, “XFAIL” or “XPASS”. #7469 The types of builtin pytest fixtures are now exported so they may be used in type annotations of test functions. The newly-exported types are: pytest.FixtureRequest for the request fixture. pytest.Cache for the cache fixture. pytest.CaptureFixture[str] for the capfd and capsys fixtures. pytest.CaptureFixture[bytes] for the capfdbinary and capsysbinary fixtures. pytest.LogCaptureFixture for the caplog fixture. pytest.Pytester for the pytester fixture. pytest.Testdir for the testdir fixture. pytest.TempdirFactory for the tmpdir_factory fixture. pytest.TempPathFactory for the tmp_path_factory fixture. pytest.MonkeyPatch for the monkeypatch fixture. pytest.WarningsRecorder for the recwarn fixture. Constructing them is not supported (except for MonkeyPatch ); they are only meant for use in type annotations. Doing so will emit a deprecation warning, and may become a hard-error in pytest 8.0. Subclassing them is also not supported. This is not currently enforced at runtime, but is detected by type-checkers such as mypy. #7527 : When a comparison between namedtuple instances of the same type fails, pytest now shows the differing field names (possibly nested) instead of their indexes. #7615 : Node.warn now permits any subclass of Warning , not just PytestWarning . #7701 : Improved reporting when using --collected-only . It will now show the number of collected tests in the summary stats. #7710 : Use strict equality comparison for non-numeric types in pytest.approx() instead of raising TypeError . This was the undocumented behavior before 3.7, but is now officially a supported feature. #7938 : New --sw-skip argument which is a shorthand for --stepwise-skip . #8023 : Added 'node_modules' to default value for norecursedirs . #8032 : doClassCleanups (introduced in unittest in Python and 3.8) is now called appropriately.

# Bug Fixes¶

#4824 : Fixed quadratic behavior and improved performance of collection of items using autouse fixtures and xunit fixtures. #7758 : Fixed an issue where some files in packages are getting lost from --lf even though they contain tests that failed. Regressed in pytest 5.4.0. #7911 : Directories created by by tmp_path and tmpdir are now considered stale after 3 days without modification (previous value was 3 hours) to avoid deleting directories still in use in long running test suites. #7913 : Fixed a crash or hang in pytester.spawn when the readline module is involved. #7951 : Fixed handling of recursive symlinks when collecting tests. #7981 : Fixed symlinked directories not being followed during collection. Regressed in pytest 6.1.0. #8016 : Fixed only one doctest being collected when using pytest --doctest-modules path/to/an/__init__.py .

# Improved Documentation¶

#7429 : Add more information and use cases about skipping doctests. #7780 : Classes which should not be inherited from are now marked final class in the API reference. #7872 : _pytest.config.argparsing.Parser.addini() accepts explicit None and "string" . #7878 : In pull request section, ask to commit after editing changelog and authors file.

# Trivial/Internal Changes¶

#7802 : The attrs dependency requirement is now >=19.2.0 instead of >=17.4.0. #8014 : .pyc files created by pytest’s assertion rewriting now conform to the newer PEP 552 format on Python>=3.7. (These files are internal and only interpreted by pytest itself.)

# pytest 6.1.2 (2020-10-28)¶

# Bug Fixes¶

#7758 : Fixed an issue where some files in packages are getting lost from --lf even though they contain tests that failed. Regressed in pytest 5.4.0. #7911 : Directories created by tmpdir are now considered stale after 3 days without modification (previous value was 3 hours) to avoid deleting directories still in use in long running test suites.

# Improved Documentation¶

#7815 : Improve deprecation warning message for pytest._fillfuncargs() .

# pytest 6.1.1 (2020-10-03)¶

# Bug Fixes¶

#7807 : Fixed regression in pytest 6.1.0 causing incorrect rootdir to be determined in some non-trivial cases where parent directories have config files as well. #7814 : Fixed crash in header reporting when testpaths is used and contains absolute paths (regression in 6.1.0).

# pytest 6.1.0 (2020-09-26)¶

# Breaking Changes¶

#5585 : As per our policy, the following features which have been deprecated in the 5.X series are now removed: The funcargnames read-only property of FixtureRequest , Metafunc , and Function classes. Use fixturenames attribute. @pytest.fixture no longer supports positional arguments, pass all arguments by keyword instead. Direct construction of Node subclasses now raise an error, use from_parent instead. The default value for junit_family has changed to xunit2 . If you require the old format, add junit_family=xunit1 to your configuration file. The TerminalReporter no longer has a writer attribute. Plugin authors may use the public functions of the TerminalReporter instead of accessing the TerminalWriter object directly. The --result-log option has been removed. Users are recommended to use the pytest-reportlog plugin instead. For more information consult Deprecations and Removals in the docs.

# Deprecations¶

#6981 : The pytest.collect module is deprecated: all its names can be imported from pytest directly. #7097 : The pytest._fillfuncargs function is deprecated. This function was kept for backward compatibility with an older plugin. It’s functionality is not meant to be used directly, but if you must replace it, use function._request._fillfixtures() instead, though note this is not a public API and may break in the future. #7210 : The special -k '-expr' syntax to -k is deprecated. Use -k 'not expr' instead. The special -k 'expr:' syntax to -k is deprecated. Please open an issue if you use this and want a replacement. #7255 : The pytest_warning_captured hook is deprecated in favor of pytest_warning_recorded , and will be removed in a future version. #7648 : The gethookproxy() and isinitpath() methods of FSCollector and Package are deprecated; use self.session.gethookproxy() and self.session.isinitpath() instead. This should work on all pytest versions.

# Features¶

#7667 : New --durations-min command-line flag controls the minimal duration for inclusion in the slowest list of tests shown by --durations . Previously this was hard-coded to 0.005s .

# Improvements¶

#6681 : Internal pytest warnings issued during the early stages of initialization are now properly handled and can filtered through filterwarnings or --pythonwarnings/-W . This also fixes a number of long standing issues: #2891 , #7620 , #7426 . #7572 : When a plugin listed in required_plugins is missing or an unknown config key is used with --strict-config , a simple error message is now shown instead of a stacktrace. #7685 : Added two new attributes rootpath and inipath to Config . These attributes are pathlib.Path versions of the existing rootdir and inifile attributes, and should be preferred over them when possible. #7780 : Public classes which are not designed to be inherited from are now marked @final . Code which inherits from these classes will trigger a type-checking (e.g. mypy) error, but will still work in runtime. Currently the final designation does not appear in the API Reference but hopefully will in the future.

# Bug Fixes¶

#1953 : Fixed error when overwriting a parametrized fixture, while also reusing the super fixture value.

```

# conftest.py
import
pytest
@pytest
.
fixture
(
params
=
[
1
,
2
])
def
foo
(
request
):
return
request
.
param
# test_foo.py
import
pytest
@pytest
.
fixture
def
foo
(
foo
):
return
foo
*
2

```

#4984 : Fixed an internal error crash with IndexError: list index out of range when collecting a module which starts with a decorated function, the decorator raises, and assertion rewriting is enabled. #7591 : pylint shouldn’t complain anymore about unimplemented abstract methods when inheriting from File . #7628 : Fixed test collection when a full path without a drive letter was passed to pytest on Windows (for example \projects\tests\test.py instead of c:\projects\tests\pytest.py ). #7638 : Fix handling of command-line options that appear as paths but trigger an OS-level syntax error on Windows, such as the options used internally by pytest-xdist . #7742 : Fixed INTERNALERROR when accessing locals / globals with faulty exec .

# Improved Documentation¶

#1477 : Removed faq.rst and its reference in contents.rst.

# Trivial/Internal Changes¶

#7536 : The internal junitxml plugin has rewritten to use xml.etree.ElementTree . The order of attributes in XML elements might differ. Some unneeded escaping is no longer performed. #7587 : The dependency on the more-itertools package has been removed. #7631 : The result type of capfd.readouterr() (and similar) is no longer a namedtuple, but should behave like one in all respects. This was done for technical reasons. #7671 : When collecting tests, pytest finds test classes and functions by examining the attributes of python objects (modules, classes and instances). To speed up this process, pytest now ignores builtin attributes (like __class__ , __delattr__ and __new__ ) without consulting the python_classes and python_functions configuration options and without passing them to plugins using the pytest_pycollect_makeitem hook.

# pytest 6.0.2 (2020-09-04)¶

# Bug Fixes¶

#7148 : Fixed --log-cli potentially causing unrelated print output to be swallowed. #7672 : Fixed log-capturing level restored incorrectly if caplog.set_level is called more than once. #7686 : Fixed NotSetType.token being used as the parameter ID when the parametrization list is empty. Regressed in pytest 6.0.0. #7707 : Fix internal error when handling some exceptions that contain multiple lines or the style uses multiple lines ( --tb=line for example).

# pytest 6.0.1 (2020-07-30)¶

# Bug Fixes¶

#7394 : Passing an empty help value to Parser.add_option is now accepted instead of crashing when running pytest --help . Passing None raises a more informative TypeError . #7558 : Fix pylint not-callable lint on pytest.mark.parametrize() and the other builtin marks: skip , skipif , xfail , usefixtures , filterwarnings . #7559 : Fix regression in plugins using TestReport.longreprtext (such as pytest-html ) when TestReport.longrepr is not a string. #7569 : Fix logging capture handler’s level not reset on teardown after a call to caplog.set_level() .

# pytest 6.0.0 (2020-07-28)¶

( Please see the full set of changes for this release also in the 6.0.0rc1 notes below )

# Breaking Changes¶

#5584 : PytestDeprecationWarning are now errors by default. Following our plan to remove deprecated features with as little disruption as possible, all warnings of type PytestDeprecationWarning now generate errors instead of warning messages. The affected features will be effectively removed in pytest 6.1 , so please consult the Deprecations and Removals section in the docs for directions on how to update existing code. In the pytest 6.0.X series, it is possible to change the errors back into warnings as a stopgap measure by adding this to your pytest.ini file:

```

[pytest]
filterwarnings
=
ignore
:
:pytest.PytestDeprecationWarning

```

But this will stop working when pytest 6.1 is released. If you have concerns about the removal of a specific feature, please add a comment to #5584 . #7472 : The exec_() and is_true() methods of _pytest._code.Frame have been removed.

# Features¶

#7464 : Added support for NO_COLOR and FORCE_COLOR environment variables to control colored output.

# Improvements¶

#7467 : --log-file CLI option and log_file ini marker now create subdirectories if needed. #7489 : The pytest.raises() function has a clearer error message when match equals the obtained string but is not a regex match. In this case it is suggested to escape the regex.

# Bug Fixes¶

#7392 : Fix the reported location of tests skipped with @pytest.mark.skip when --runxfail is used. #7491 : tmpdir and tmp_path no longer raise an error if the lock to check for stale temporary directories is not accessible. #7517 : Preserve line endings when captured via capfd . #7534 : Restored the previous formatting of TracebackEntry.__str__ which was changed by accident.

# Improved Documentation¶

#7422 : Clarified when the usefixtures mark can apply fixtures to test. #7441 : Add a note about -q option used in getting started guide.

# Trivial/Internal Changes¶

#7389 : Fixture scope package is no longer considered experimental.

# pytest 6.0.0rc1 (2020-07-08)¶

# Breaking Changes¶

#1316 : TestReport.longrepr is now always an instance of ReprExceptionInfo . Previously it was a str when a test failed with pytest.fail(..., pytrace=False) . #5965 : symlinks are no longer resolved during collection and matching conftest.py files with test file paths. Resolving symlinks for the current directory and during collection was introduced as a bugfix in 3.9.0, but it actually is a new feature which had unfortunate consequences in Windows and surprising results in other platforms. The team decided to step back on resolving symlinks at all, planning to review this in the future with a more solid solution (see discussion in #6523 for details). This might break test suites which made use of this feature; the fix is to create a symlink for the entire test tree, and not only to partial files/tress as it was possible previously. #6505 : Testdir.run().parseoutcomes() now always returns the parsed nouns in plural form. Originally parseoutcomes() would always returns the nouns in plural form, but a change meant to improve the terminal summary by using singular form single items ( 1 warning or 1 error ) caused an unintended regression by changing the keys returned by parseoutcomes() . Now the API guarantees to always return the plural form, so calls like this:

```

result
=
testdir
.
runpytest
()
result
.
assert_outcomes
(
error
=
1
)

```

Need to be changed to:

```

result
=
testdir
.
runpytest
()
result
.
assert_outcomes
(
errors
=
1
)

```

#6903 : The os.dup() function is now assumed to exist. We are not aware of any supported Python 3 implementations which do not provide it. #7040 : -k no longer matches against the names of the directories outside the test session root. Also, pytest.Package.name is now just the name of the directory containing the package’s __init__.py file, instead of the full path. This is consistent with how the other nodes are named, and also one of the reasons why -k would match against any directory containing the test suite. #7122 : Expressions given to the -m and -k options are no longer evaluated using Python’s eval() . The format supports or , and , not , parenthesis and general identifiers to match against. Python constants, keywords or other operators are no longer evaluated differently. #7135 : Pytest now uses its own TerminalWriter class instead of using the one from the py library. Plugins generally access this class through TerminalReporter.writer , TerminalReporter.write() (and similar methods), or _pytest.config.create_terminal_writer() . The following breaking changes were made: Output ( write() method and others) no longer flush implicitly; the flushing behavior of the underlying file is respected. To flush explicitly (for example, if you want output to be shown before an end-of-line is printed), use write(flush=True) or terminal_writer.flush() . Explicit Windows console support was removed, delegated to the colorama library. Support for writing bytes was removed. The reline method and chars_on_current_line property were removed. The stringio and encoding arguments was removed. Support for passing a callable instead of a file was removed. #7224 : The item.catch_log_handler and item.catch_log_handlers attributes, set by the logging plugin and never meant to be public, are no longer available. The deprecated --no-print-logs option and log_print ini option are removed. Use --show-capture instead. #7226 : Removed the unused args parameter from pytest.Function.__init__ . #7418 : Removed the pytest_doctest_prepare_content hook specification. This hook hasn’t been triggered by pytest for at least 10 years. #7438 : Some changes were made to the internal _pytest._code.source , listed here for the benefit of plugin authors who may be using it: The deindent argument to Source() has been removed, now it is always true. Support for zero or multiple arguments to Source() has been removed. Support for comparing Source with an str has been removed. The methods Source.isparseable() and Source.putaround() have been removed. The method Source.compile() and function _pytest._code.compile() have been removed; use plain compile() instead. The function _pytest._code.source.getsource() has been removed; use Source() directly instead.

# Deprecations¶

#7210 : The special -k '-expr' syntax to -k is deprecated. Use -k 'not expr' instead. The special -k 'expr:' syntax to -k is deprecated. Please open an issue if you use this and want a replacement. #4049 : pytest_warning_captured is deprecated in favor of the pytest_warning_recorded hook.

# Features¶

#1556 : pytest now supports pyproject.toml files for configuration. The configuration options is similar to the one available in other formats, but must be defined in a [tool.pytest.ini_options] table to be picked up by pytest:

```

# pyproject.toml
[tool.pytest.ini_options]
minversion
=
"6.0"
addopts
=
"-ra -q"
testpaths
=
[
"tests"
,
"integration"
,
]

```

More information can be found in the docs . #3342 : pytest now includes inline type annotations and exposes them to user programs. Most of the user-facing API is covered, as well as internal code. If you are running a type checker such as mypy on your tests, you may start noticing type errors indicating incorrect usage. If you run into an error that you believe to be incorrect, please let us know in an issue. The types were developed against mypy version 0.780. Versions before 0.750 are known not to work. We recommend using the latest version. Other type checkers may work as well, but they are not officially verified to work by pytest yet. #4049 : Introduced a new hook named pytest_warning_recorded to convey information about warnings captured by the internal pytest warnings plugin. This hook is meant to replace pytest_warning_captured , which is deprecated and will be removed in a future release. #6471 : New command-line flags: --no-header : disables the initial header, including platform, version, and plugins. --no-summary : disables the final test summary, including warnings. #6856 : A warning is now shown when an unknown key is read from a config INI file. The --strict-config flag has been added to treat these warnings as errors. #6906 : Added --code-highlight command line option to enable/disable code highlighting in terminal output. #7245 : New --import-mode=importlib option that uses importlib to import test modules. Traditionally pytest used __import__ while changing sys.path to import test modules (which also changes sys.modules as a side-effect), which works but has a number of drawbacks, like requiring test modules that don’t live in packages to have unique names (as they need to reside under a unique name in sys.modules ). --import-mode=importlib uses more fine-grained import mechanisms from importlib which don’t require pytest to change sys.path or sys.modules at all, eliminating much of the drawbacks of the previous mode. We intend to make --import-mode=importlib the default in future versions, so users are encouraged to try the new mode and provide feedback (both positive or negative) in issue #7245 . You can read more about this option in the documentation . #7305 : New required_plugins configuration option allows the user to specify a list of plugins, including version information, that are required for pytest to run. An error is raised if any required plugins are not found when running pytest.

# Improvements¶

#4375 : The pytest command now suppresses the BrokenPipeError error message that is printed to stderr when the output of pytest is piped and the pipe is closed by the piped-to program (common examples are less and head ). #4391 : Improved precision of test durations measurement. CallInfo items now have a new <CallInfo>.duration attribute, created using time.perf_counter() . This attribute is used to fill the <TestReport>.duration attribute, which is more accurate than the previous <CallInfo>.stop - <CallInfo>.start (as these are based on time.time() ). #4675 : Rich comparison for dataclasses and attrs -classes is now recursive. #6285 : Exposed the pytest.FixtureLookupError exception which is raised by request.getfixturevalue() (where request is a FixtureRequest fixture) when a fixture with the given name cannot be returned. #6433 : If an error is encountered while formatting the message in a logging call, for example logging.warning("oh no!: %s: %s", "first") (a second argument is missing), pytest now propagates the error, likely causing the test to fail. Previously, such a mistake would cause an error to be printed to stderr, which is not displayed by default for passing tests. This change makes the mistake visible during testing. You may suppress this behavior temporarily or permanently by setting logging.raiseExceptions = False . #6817 : Explicit new-lines in help texts of command-line options are preserved, allowing plugins better control of the help displayed to users. #6940 : When using the --duration option, the terminal message output is now more precise about the number and duration of hidden items. #6991 : Collected files are displayed after any reports from hooks, e.g. the status from --lf . #7091 : When fd capturing is used, through --capture=fd or the capfd and capfdbinary fixtures, and the file descriptor (0, 1, 2) cannot be duplicated, FD capturing is still performed. Previously, direct writes to the file descriptors would fail or be lost in this case. #7119 : Exit with an error if the --basetemp argument is empty, is the current working directory or is one of the parent directories. This is done to protect against accidental data loss, as any directory passed to this argument is cleared. #7128 : pytest --version now displays just the pytest version, while pytest --version --version displays more verbose information including plugins. This is more consistent with how other tools show --version . #7133 : caplog.set_level() will now override any log_level set via the CLI or configuration file. #7159 : caplog.set_level() and caplog.at_level() no longer affect the level of logs that are shown in the Captured log report report section. #7348 : Improve recursive diff report for comparison asserts on dataclasses / attrs. #7385 : --junitxml now includes the exception cause in the message XML attribute for failures during setup and teardown. Previously:

```

<error
message=
"test setup failure"
>

```

Now:

```

<error
message=
"failed on setup with &quot;ValueError: Some error during setup&quot;"
>

```

# Bug Fixes¶

#1120 : Fix issue where directories from tmpdir are not removed properly when multiple instances of pytest are running in parallel. #4583 : Prevent crashing and provide a user-friendly error when a marker expression ( -m ) invoking of eval() raises any exception. #4677 : The path shown in the summary report for SKIPPED tests is now always relative. Previously it was sometimes absolute. #5456 : Fix a possible race condition when trying to remove lock files used to control access to folders created by tmp_path and tmpdir . #6240 : Fixes an issue where logging during collection step caused duplication of log messages to stderr. #6428 : Paths appearing in error messages are now correct in case the current working directory has changed since the start of the session. #6755 : Support deleting paths longer than 260 characters on windows created inside tmpdir . #6871 : Fix crash with captured output when using capsysbinary . #6909 : Revert the change introduced by #6330 , which required all arguments to @pytest.mark.parametrize to be explicitly defined in the function signature. The intention of the original change was to remove what was expected to be an unintended/surprising behavior, but it turns out many people relied on it, so the restriction has been reverted. #6910 : Fix crash when plugins return an unknown stats while using the --reportlog option. #6924 : Ensure a unittest.IsolatedAsyncioTestCase is actually awaited. #6925 : Fix TerminalRepr instances to be hashable again. #6947 : Fix regression where functions registered with unittest.TestCase.addCleanup() were not being called on test failures. #6951 : Allow users to still set the deprecated TerminalReporter.writer attribute. #6956 : Prevent pytest from printing ConftestImportFailure traceback to stdout. #6991 : Fix regressions with --lf filtering too much since pytest 5.4. #6992 : Revert “tmpdir: clean up indirection via config for factories” #6767 as it breaks pytest-xdist. #7061 : When a yielding fixture fails to yield a value, report a test setup error instead of crashing. #7076 : The path of file skipped by @pytest.mark.skip in the SKIPPED report is now relative to invocation directory. Previously it was relative to root directory. #7110 : Fixed regression: asyncbase.TestCase tests are executed correctly again. #7126 : --setup-show now doesn’t raise an error when a bytes value is used as a parametrize parameter when Python is called with the -bb flag. #7143 : Fix pytest.File.from_parent so it forwards extra keyword arguments to the constructor. #7145 : Classes with broken __getattribute__ methods are displayed correctly during failures. #7150 : Prevent hiding the underlying exception when ConfTestImportFailure is raised. #7180 : Fix _is_setup_py for files encoded differently than locale. #7215 : Fix regression where running with --pdb would call unittest.TestCase.tearDown() for skipped tests. #7253 : When using pytest.fixture on a function directly, as in pytest.fixture(func) , if the autouse or params arguments are also passed, the function is no longer ignored, but is marked as a fixture. #7360 : Fix possibly incorrect evaluation of string expressions passed to pytest.mark.skipif and pytest.mark.xfail , in rare circumstances where the exact same string is used but refers to different global values. #7383 : Fixed exception causes all over the codebase, i.e. use raise new_exception from old_exception when wrapping an exception.

# Improved Documentation¶

#7202 : The development guide now links to the contributing section of the docs and RELEASING.rst on GitHub. #7233 : Add a note about --strict and --strict-markers and the preference for the latter one. #7345 : Explain indirect parametrization and markers for fixtures.

# Trivial/Internal Changes¶

#7035 : The originalname attribute of _pytest.python.Function now defaults to name if not provided explicitly, and is always set. #7264 : The dependency on the wcwidth package has been removed. #7291 : Replaced py.iniconfig with iniconfig . #7295 : src/_pytest/config/__init__.py now uses the warnings module to report warnings instead of sys.stderr.write . #7356 : Remove last internal uses of deprecated slave term from old pytest-xdist . #7357 : py >=1.8.2 is now required.

# pytest 5.4.3 (2020-06-02)¶

# Bug Fixes¶

#6428 : Paths appearing in error messages are now correct in case the current working directory has changed since the start of the session. #6755 : Support deleting paths longer than 260 characters on windows created inside tmpdir. #6956 : Prevent pytest from printing ConftestImportFailure traceback to stdout. #7150 : Prevent hiding the underlying exception when ConfTestImportFailure is raised. #7215 : Fix regression where running with --pdb would call the tearDown methods of unittest.TestCase subclasses for skipped tests.

# pytest 5.4.2 (2020-05-08)¶

# Bug Fixes¶

#6871 : Fix crash with captured output when using the capsysbinary fixture . #6924 : Ensure a unittest.IsolatedAsyncioTestCase is actually awaited. #6925 : Fix TerminalRepr instances to be hashable again. #6947 : Fix regression where functions registered with TestCase.addCleanup were not being called on test failures. #6951 : Allow users to still set the deprecated TerminalReporter.writer attribute. #6992 : Revert “tmpdir: clean up indirection via config for factories” #6767 as it breaks pytest-xdist. #7110 : Fixed regression: asyncbase.TestCase tests are executed correctly again. #7143 : Fix File.from_parent so it forwards extra keyword arguments to the constructor. #7145 : Classes with broken __getattribute__ methods are displayed correctly during failures. #7180 : Fix _is_setup_py for files encoded differently than locale.

# pytest 5.4.1 (2020-03-13)¶

# Bug Fixes¶

#6909 : Revert the change introduced by #6330 , which required all arguments to @pytest.mark.parametrize to be explicitly defined in the function signature. The intention of the original change was to remove what was expected to be an unintended/surprising behavior, but it turns out many people relied on it, so the restriction has been reverted. #6910 : Fix crash when plugins return an unknown stats while using the --reportlog option.

# pytest 5.4.0 (2020-03-12)¶

# Breaking Changes¶

#6316 : Matching of -k EXPRESSION to test names is now case-insensitive. #6443 : Plugins specified with -p are now loaded after internal plugins, which results in their hooks being called before the internal ones. This makes the -p behavior consistent with PYTEST_PLUGINS . #6637 : Removed the long-deprecated pytest_itemstart hook. This hook has been marked as deprecated and not been even called by pytest for over 10 years now. #6673 : Reversed / fix meaning of “+/-” in error diffs. “-” means that something expected is missing in the result and “+” means that there are unexpected extras in the result. #6737 : The cached_result attribute of FixtureDef is now set to None when the result is unavailable, instead of being deleted. If your plugin performs checks like hasattr(fixturedef, 'cached_result') , for example in a pytest_fixture_post_finalizer hook implementation, replace it with fixturedef.cached_result is not None . If you del the attribute, set it to None instead.

# Deprecations¶

#3238 : Option --no-print-logs is deprecated and meant to be removed in a future release. If you use --no-print-logs , please try out --show-capture and provide feedback. --show-capture command-line option was added in pytest 3.5.0 and allows to specify how to display captured output when tests fail: no , stdout , stderr , log or all (the default). #571 : Deprecate the unused/broken pytest_collect_directory hook. It was misaligned since the removal of the Directory collector in 2010 and incorrect/unusable as soon as collection was split from test execution. #5975 : Deprecate using direct constructors for Nodes . Instead they are now constructed via Node.from_parent . This transitional mechanism enables us to untangle the very intensely entangled Node relationships by enforcing more controlled creation/configuration patterns. As part of this change, session/config are already disallowed parameters and as we work on the details we might need disallow a few more as well. Subclasses are expected to use super().from_parent if they intend to expand the creation of Nodes . #6779 : The TerminalReporter.writer attribute has been deprecated and should no longer be used. This was inadvertently exposed as part of the public API of that plugin and ties it too much with py.io.TerminalWriter .

# Features¶

#4597 : New –capture=tee-sys option to allow both live printing and capturing of test output. #5712 : Now all arguments to @pytest.mark.parametrize need to be explicitly declared in the function signature or via indirect . Previously it was possible to omit an argument if a fixture with the same name existed, which was just an accident of implementation and was not meant to be a part of the API. #6454 : Changed default for -r to fE , which displays failures and errors in the short test summary . -rN can be used to disable it (the old behavior). #6469 : New options have been added to the junit_logging option: log , out-err , and all . #6834 : Excess warning summaries are now collapsed per file to ensure readable display of warning summaries.

# Improvements¶

#1857 : pytest.mark.parametrize accepts integers for ids again, converting it to strings. #449 : Use “yellow” main color with any XPASSED tests. #4639 : Revert “A warning is now issued when assertions are made for None ”. The warning proved to be less useful than initially expected and had quite a few false positive cases. #5686 : tmpdir_factory.mktemp now fails when given absolute and non-normalized paths. #5984 : The pytest_warning_captured hook now receives a location parameter with the code location that generated the warning. #6213 : pytester: the testdir fixture respects environment settings from the monkeypatch fixture for inner runs. #6247 : --fulltrace is honored with collection errors. #6384 : Make --showlocals work also with --tb=short . #6653 : Add support for matching lines consecutively with LineMatcher ’s fnmatch_lines() and re_match_lines() . #6658 : Code is now highlighted in tracebacks when pygments is installed. Users are encouraged to install pygments into their environment and provide feedback, because the plan is to make pygments a regular dependency in the future. #6795 : Import usage error message with invalid -o option. #759 : pytest.mark.parametrize supports iterators and generators for ids .

# Bug Fixes¶

#310 : Add support for calling pytest.xfail() and pytest.importorskip() with doctests. #3823 : --trace now works with unittests. #4445 : Fixed some warning reports produced by pytest to point to the correct location of the warning in the user’s code. #5301 : Fix --last-failed to collect new tests from files with known failures. #5928 : Report PytestUnknownMarkWarning at the level of the user’s code, not pytest ’s. #5991 : Fix interaction with --pdb and unittests: do not use unittest’s TestCase.debug() . #6334 : Fix summary entries appearing twice when f/F and s/S report chars were used at the same time in the -r command-line option (for example -rFf ). The upper case variants were never documented and the preferred form should be the lower case. #6409 : Fallback to green (instead of yellow) for non-last items without previous passes with colored terminal progress indicator. #6454 : --disable-warnings is honored with -ra and -rA . #6497 : Fix bug in the comparison of request key with cached key in fixture. A construct if key == cached_key: can fail either because == is explicitly disallowed, or for, e.g., NumPy arrays, where the result of a == b cannot generally be converted to bool . The implemented fix replaces == with is . #6557 : Make capture output streams .write() method return the same return value from original streams. #6566 : Fix EncodedFile.writelines to call the underlying buffer’s writelines method. #6575 : Fix internal crash when faulthandler starts initialized (for example with PYTHONFAULTHANDLER=1 environment variable set) and faulthandler_timeout defined in the configuration file. #6597 : Fix node ids which contain a parametrized empty-string variable. #6646 : Assertion rewriting hooks are (re)stored for the current item, which fixes them being still used after e.g. pytester’s testdir.runpytest etc. #6660 : pytest.exit() is handled when emitted from the pytest_sessionfinish hook. This includes quitting from a debugger. #6752 : When pytest.raises() is used as a function (as opposed to a context manager), a match keyword argument is now passed through to the tested function. Previously it was swallowed and ignored (regression in pytest 5.1.0). #6801 : Do not display empty lines in between traceback for unexpected exceptions with doctests. #6802 : The testdir fixture works within doctests now.

# Improved Documentation¶

#6696 : Add list of fixtures to start of fixture chapter. #6742 : Expand first sentence on fixtures into a paragraph.

# Trivial/Internal Changes¶

#6404 : Remove usage of parser module, deprecated in Python 3.9.

# pytest 5.3.5 (2020-01-29)¶

# Bug Fixes¶

#6517 : Fix regression in pytest 5.3.4 causing an INTERNALERROR due to a wrong assertion.

# pytest 5.3.4 (2020-01-20)¶

# Bug Fixes¶

#6496 : Revert #6436 : unfortunately this change has caused a number of regressions in many suites, so the team decided to revert this change and make a new release while we continue to look for a solution.

# pytest 5.3.3 (2020-01-16)¶

# Bug Fixes¶

#2780 : Captured output during teardown is shown with -rP . #5971 : Fix a pytest-xdist crash when dealing with exceptions raised in subprocesses created by the multiprocessing module. #6436 : FixtureDef objects now properly register their finalizers with autouse and parameterized fixtures that execute before them in the fixture stack so they are torn down at the right times, and in the right order. #6532 : Fix parsing of outcomes containing multiple errors with testdir results (regression in 5.3.0).

# Trivial/Internal Changes¶

#6350 : Optimized automatic renaming of test parameter IDs.

# pytest 5.3.2 (2019-12-13)¶

# Improvements¶

#4639 : Revert “A warning is now issued when assertions are made for None ”. The warning proved to be less useful than initially expected and had quite a few false positive cases.

# Bug Fixes¶

#5430 : junitxml: Logs for failed test are now passed to junit report in case the test fails during call phase. #6290 : The supporting files in the .pytest_cache directory are kept with --cache-clear , which only clears cached values now. #6301 : Fix assertion rewriting for egg-based distributions and editable installs ( pip install --editable ).

# pytest 5.3.1 (2019-11-25)¶

# Improvements¶

#6231 : Improve check for misspelling of pytest.mark.parametrize . #6257 : Handle pytest.exit() being used via pytest_internalerror , e.g. when quitting pdb from post mortem.

# Bug Fixes¶

#5914 : pytester: fix no_fnmatch_line() when used after positive matching. #6082 : Fix line detection for doctest samples inside property docstrings, as a workaround to python/cpython#61648 . #6254 : Fix compatibility with pytest-parallel (regression in pytest 5.3.0). #6255 : Clear the sys.last_traceback , sys.last_type and sys.last_value attributes by deleting them instead of setting them to None . This better matches the behaviour of the Python standard library.

# pytest 5.3.0 (2019-11-19)¶

# Deprecations¶

#6179 : The default value of junit_family option will change to "xunit2" in pytest 6.0, given that this is the version supported by default in modern tools that manipulate this type of file. In order to smooth the transition, pytest will issue a warning in case the --junitxml option is given in the command line but junit_family is not explicitly configured in pytest.ini . For more information, see the docs .

# Features¶

#4488 : The pytest team has created the pytest-reportlog plugin, which provides a new --report-log=FILE option that writes report logs into a file as the test session executes. Each line of the report log contains a self contained JSON object corresponding to a testing event, such as a collection or a test result report. The file is guaranteed to be flushed after writing each line, so systems can read and process events in real-time. The plugin is meant to replace the --resultlog option, which is deprecated and meant to be removed in a future release. If you use --resultlog , please try out pytest-reportlog and provide feedback. #4730 : When sys.pycache_prefix (Python 3.8+) is set, it will be used by pytest to cache test files changed by the assertion rewriting mechanism. This makes it easier to benefit of cached .pyc files even on file systems without permissions. #5515 : Allow selective auto-indentation of multiline log messages. Adds command line option --log-auto-indent , config option log_auto_indent and support for per-entry configuration of indentation behavior on calls to logging.log() . Alters the default for auto-indention from "on" to "off" . This restores the older behavior that existed prior to v4.6.0. This reversion to earlier behavior was done because it is better to activate new features that may lead to broken tests explicitly rather than implicitly. #5914 : testdir learned two new functions, no_fnmatch_line() and no_re_match_line() . The functions are used to ensure the captured text does not match the given pattern. The previous idiom was to use re.match() :

```

result
=
testdir
.
runpytest
()
assert
re
.
match
(
pat
,
result
.
stdout
.
str
())
is
None

```

Or the in operator:

```

result
=
testdir
.
runpytest
()
assert
text
in
result
.
stdout
.
str
()

```

But the new functions produce best output on failure. #6057 : Added tolerances to complex values when printing pytest.approx . For example, repr(pytest.approx(3+4j)) returns (3+4j) ± 5e-06 ∠ ±180° . This is polar notation indicating a circle around the expected value, with a radius of 5e-06. For approx comparisons to return True , the actual value should fall within this circle. #6061 : Added the pluginmanager as an argument to pytest_addoption so that hooks can be invoked when setting up command line options. This is useful for having one plugin communicate things to another plugin, such as default values or which set of command line options to add.

# Improvements¶

#5061 : Use multiple colors with terminal summary statistics. #5630 : Quitting from debuggers is now properly handled in doctest items. #5924 : Improved verbose diff output with sequences. Before:

```

E
AssertionError
:
assert
[
'version'
,
'...version_info'
]
==
[
'version'
,
'...version'
,
...
]
E
Right
contains
3
more
items
,
first
extra
item
:
' '
E
Full
diff
:
E
-
[
'version'
,
'version_info'
,
'sys.version'
,
'sys.version_info'
]
E
+
[
'version'
,
E
+
'version_info'
,
E
+
'sys.version'
,
E
+
'sys.version_info'
,
E
+
' '
,
E
+
'sys.version'
,
E
+
'sys.version_info'
]

```

After:

```

E
AssertionError
:
assert
[
'version'
,
'...version_info'
]
==
[
'version'
,
'...version'
,
...
]
E
Right
contains
3
more
items
,
first
extra
item
:
' '
E
Full
diff
:
E
[
E
'version'
,
E
'version_info'
,
E
'sys.version'
,
E
'sys.version_info'
,
E
+
' '
,
E
+
'sys.version'
,
E
+
'sys.version_info'
,
E
]

```

#5934 : repr of ExceptionInfo objects has been improved to honor the __repr__ method of the underlying exception. #5936 : Display untruncated assertion message with -vv . #5990 : Fixed plurality mismatch in test summary (e.g. display “1 error” instead of “1 errors”). #6008 : Config.InvocationParams.args is now always a tuple to better convey that it should be immutable and avoid accidental modifications. #6023 : pytest.main returns a pytest.ExitCode instance now, except for when custom exit codes are used (where it returns int then still). #6026 : Align prefixes in output of pytester’s LineMatcher . #6059 : Collection errors are reported as errors (and not failures like before) in the terminal’s short test summary. #6069 : pytester.spawn does not skip/xfail tests on FreeBSD anymore unconditionally. #6097 : The “[…%]” indicator in the test summary is now colored according to the final (new) multi-colored line’s main color. #6116 : Added --co as a synonym to --collect-only . #6148 : atomicwrites is now only used on Windows, fixing a performance regression with assertion rewriting on Unix. #6152 : Now parametrization will use the __name__ attribute of any object for the id, if present. Previously it would only use __name__ for functions and classes. #6176 : Improved failure reporting with pytester’s Hookrecorder.assertoutcome . #6181 : The reason for a stopped session, e.g. with --maxfail / -x , now gets reported in the test summary. #6206 : Improved cache.set robustness and performance.

# Bug Fixes¶

#2049 : Fixed --setup-plan showing inaccurate information about fixture lifetimes. #2548 : Fixed line offset mismatch of skipped tests in terminal summary. #6039 : The PytestDoctestRunner is now properly invalidated when unconfiguring the doctest plugin. This is important when used with pytester ’s runpytest_inprocess . #6047 : BaseExceptions are now handled in saferepr , which includes pytest.fail.Exception etc. #6074 : pytester: fixed order of arguments in rm_rf warning when cleaning up temporary directories, and do not emit warnings for errors with os.open . #6189 : Fixed result of getmodpath method.

# Trivial/Internal Changes¶

#4901 : RunResult from pytester now displays the mnemonic of the ret attribute when it is a valid pytest.ExitCode value.

# pytest 5.2.4 (2019-11-15)¶

# Bug Fixes¶

#6194 : Fix incorrect discovery of non-test __init__.py files. #6197 : Revert “The first test in a package ( __init__.py ) marked with @pytest.mark.skip is now correctly skipped.”.

# pytest 5.2.3 (2019-11-14)¶

# Bug Fixes¶

#5830 : The first test in a package ( __init__.py ) marked with @pytest.mark.skip is now correctly skipped. #6099 : Fix --trace when used with parametrized functions. #6183 : Using request as a parameter name in @pytest.mark.parametrize now produces a more user-friendly error.

# pytest 5.2.2 (2019-10-24)¶

# Bug Fixes¶

#5206 : Fix --nf to not forget about known nodeids with partial test selection. #5906 : Fix crash with KeyboardInterrupt during --setup-show . #5946 : Fixed issue when parametrizing fixtures with numpy arrays (and possibly other sequence-like types). #6044 : Properly ignore FileNotFoundError exceptions when trying to remove old temporary directories, for instance when multiple processes try to remove the same directory (common with pytest-xdist for example).

# pytest 5.2.1 (2019-10-06)¶

# Bug Fixes¶

#5902 : Fix warnings about deprecated cmp attribute in attrs>=19.2 .

# pytest 5.2.0 (2019-09-28)¶

# Deprecations¶

#1682 : Passing arguments to pytest.fixture() as positional arguments is deprecated - pass them as a keyword argument instead.

# Features¶

#1682 : The scope parameter of @pytest.fixture can now be a callable that receives the fixture name and the config object as keyword-only parameters. See the docs for more information. #5764 : New behavior of the --pastebin option: failures to connect to the pastebin server are reported, without failing the pytest run

# Bug Fixes¶

#5806 : Fix “lexer” being used when uploading to bpaste.net from --pastebin to “text”. #5884 : Fix --setup-only and --setup-show for custom pytest items.

# Trivial/Internal Changes¶

#5056 : The HelpFormatter uses py.io.get_terminal_width for better width detection.

# pytest 5.1.3 (2019-09-18)¶

# Bug Fixes¶

#5807 : Fix pypy3.6 (nightly) on windows. #5811 : Handle --fulltrace correctly with pytest.raises . #5819 : Windows: Fix regression with conftest whose qualified name contains uppercase characters (introduced by #5792).

# pytest 5.1.2 (2019-08-30)¶

# Bug Fixes¶

#2270 : Fixed self reference in function-scoped fixtures defined plugin classes: previously self would be a reference to a test class, not the plugin class. #570 : Fixed long standing issue where fixture scope was not respected when indirect fixtures were used during parametrization. #5782 : Fix decoding error when printing an error response from --pastebin . #5786 : Chained exceptions in test and collection reports are now correctly serialized, allowing plugins like pytest-xdist to display them properly. #5792 : Windows: Fix error that occurs in certain circumstances when loading conftest.py from a working directory that has casing other than the one stored in the filesystem (e.g., c:\test instead of C:\test ).

# pytest 5.1.1 (2019-08-20)¶

# Bug Fixes¶

#5751 : Fixed TypeError when importing pytest on Python 3.5.0 and 3.5.1.

# pytest 5.1.0 (2019-08-15)¶

# Removals¶

#5180 : As per our policy, the following features have been deprecated in the 4.X series and are now removed: Request.getfuncargvalue : use Request.getfixturevalue instead. pytest.raises and pytest.warns no longer support strings as the second argument. message parameter of pytest.raises . pytest.raises , pytest.warns and ParameterSet.param now use native keyword-only syntax. This might change the exception message from previous versions, but they still raise TypeError on unknown keyword arguments as before. pytest.config global variable. tmpdir_factory.ensuretemp method. pytest_logwarning hook. RemovedInPytest4Warning warning type. request is now a reserved name for fixtures. For more information consult Deprecations and Removals in the docs. #5565 : Removed unused support code for unittest2 . The unittest2 backport module is no longer necessary since Python 3.3+, and the small amount of code in pytest to support it also doesn’t seem to be used: after removed, all tests still pass unchanged. Although our policy is to introduce a deprecation period before removing any features or support for third party libraries, because this code is apparently not used at all (even if unittest2 is used by a test suite executed by pytest), it was decided to remove it in this release. If you experience a regression because of this, please file an issue . #5615 : pytest.fail , pytest.xfail and pytest.skip no longer support bytes for the message argument. This was supported for Python 2 where it was tempting to use "message" instead of u"message" . Python 3 code is unlikely to pass bytes to these functions. If you do, please decode it to an str beforehand.

# Features¶

#5564 : New Config.invocation_args attribute containing the unchanged arguments passed to pytest.main() . #5576 : New NUMBER option for doctests to ignore irrelevant differences in floating-point numbers. Inspired by Sébastien Boisgérault’s numtest extension for doctest.

# Improvements¶

#5471 : JUnit XML now includes a timestamp and hostname in the testsuite tag. #5707 : Time taken to run the test suite now includes a human-readable representation when it takes over 60 seconds, for example:

```

=====
2
failed
in
102.70
s
(
0
:
01
:
42
)
=====

```

# Bug Fixes¶

#4344 : Fix RuntimeError/StopIteration when trying to collect package with “__init__.py” only. #5115 : Warnings issued during pytest_configure are explicitly not treated as errors, even if configured as such, because it otherwise completely breaks pytest. #5477 : The XML file produced by --junitxml now correctly contain a <testsuites> root element. #5524 : Fix issue where tmp_path and tmpdir would not remove directories containing files marked as read-only, which could lead to pytest crashing when executed a second time with the --basetemp option. #5537 : Replace importlib_metadata backport with importlib.metadata from the standard library on Python 3.8+. #5578 : Improve type checking for some exception-raising functions ( pytest.xfail , pytest.skip , etc) so they provide better error messages when users meant to use marks (for example @pytest.xfail instead of @pytest.mark.xfail ). #5606 : Fixed internal error when test functions were patched with objects that cannot be compared for truth values against others, like numpy arrays. #5634 : pytest.exit is now correctly handled in unittest cases. This makes unittest cases handle quit from pytest’s pdb correctly. #5650 : Improved output when parsing an ini configuration file fails. #5701 : Fix collection of staticmethod objects defined with functools.partial . #5734 : Skip async generator test functions, and update the warning message to refer to async def functions.

# Improved Documentation¶

#5669 : Add docstring for Testdir.copy_example .

# Trivial/Internal Changes¶

#5095 : XML files of the xunit2 family are now validated against the schema by pytest’s own test suite to avoid future regressions. #5516 : Cache node splitting function which can improve collection performance in very large test suites. #5603 : Simplified internal SafeRepr class and removed some dead code. #5664 : When invoking pytest’s own testsuite with PYTHONDONTWRITEBYTECODE=1 , the test_xfail_handling test no longer fails. #5684 : Replace manual handling of OSError.errno in the codebase by new OSError subclasses ( PermissionError , FileNotFoundError , etc.).

# pytest 5.0.1 (2019-07-04)¶

# Bug Fixes¶

#5479 : Improve quoting in raises match failure message. #5523 : Fixed using multiple short options together in the command-line (for example -vs ) in Python 3.8+. #5547 : --step-wise now handles xfail(strict=True) markers properly.

# Improved Documentation¶

#5517 : Improve “Declaring new hooks” section in chapter “Writing Plugins”

# pytest 5.0.0 (2019-06-28)¶

# Important¶

This release is a Python3.5+ only release. For more details, see our Python 2.7 and 3.4 support plan .

# Removals¶

#1149 : Pytest no longer accepts prefixes of command-line arguments, for example typing pytest --doctest-mod inplace of --doctest-modules . This was previously allowed where the ArgumentParser thought it was unambiguous, but this could be incorrect due to delayed parsing of options for plugins. See for example issues #1149 , #3413 , and #4009 . #5402 : PytestDeprecationWarning are now errors by default. Following our plan to remove deprecated features with as little disruption as possible, all warnings of type PytestDeprecationWarning now generate errors instead of warning messages. The affected features will be effectively removed in pytest 5.1 , so please consult the Deprecations and Removals section in the docs for directions on how to update existing code. In the pytest 5.0.X series, it is possible to change the errors back into warnings as a stop gap measure by adding this to your pytest.ini file:

```

[pytest]
filterwarnings
=
ignore
:
:pytest.PytestDeprecationWarning

```

But this will stop working when pytest 5.1 is released. If you have concerns about the removal of a specific feature, please add a comment to #5402 . #5412 : ExceptionInfo objects (returned by pytest.raises ) now have the same str representation as repr , which avoids some confusion when users use print(e) to inspect the object. This means code like:

```

with
pytest
.
raises
(
SomeException
)
as
e
:
...
assert
"some message"
in
str
(
e
)

```

Needs to be changed to:

```

with
pytest
.
raises
(
SomeException
)
as
e
:
...
assert
"some message"
in
str
(
e
.
value
)

```

# Deprecations¶

#4488 : The removal of the --result-log option and module has been postponed to (tentatively) pytest 6.0 as the team has not yet got around to implement a good alternative for it. #466 : The funcargnames attribute has been an alias for fixturenames since pytest 2.3, and is now deprecated in code too.

# Features¶

#3457 : New pytest_assertion_pass hook, called with context information when an assertion passes . This hook is still experimental so use it with caution. #5440 : The faulthandler standard library module is now enabled by default to help users diagnose crashes in C modules. This functionality was provided by integrating the external pytest-faulthandler plugin into the core, so users should remove that plugin from their requirements if used. For more information see the docs: Fault Handler . #5452 : When warnings are configured as errors, pytest warnings now appear as originating from pytest. instead of the internal _pytest.warning_types. module. #5125 : Session.exitcode values are now coded in pytest.ExitCode , an IntEnum . This makes the exit code available for consumer code and are more explicit other than just documentation. User defined exit codes are still valid, but should be used with caution. The team doesn’t expect this change to break test suites or plugins in general, except in esoteric/specific scenarios. pytest-xdist users should upgrade to 1.29.0 or later, as pytest-xdist required a compatibility fix because of this change.

# Bug Fixes¶

#1403 : Switch from imp to importlib . #1671 : The name of the .pyc files cached by the assertion writer now includes the pytest version to avoid stale caches. #2761 : Honor PEP 235 on case-insensitive file systems. #5078 : Test module is no longer double-imported when using --pyargs . #5260 : Improved comparison of byte strings. When comparing bytes, the assertion message used to show the byte numeric value when showing the differences:

```

def
test
():
>
assert
b
'spam'
==
b
'eggs'
E
AssertionError
:
assert
b
'spam'
==
b
'eggs'
E
At
index
0
diff
:
115
!=
101
E
Use
-
v
to
get
the
full
diff

```

It now shows the actual ascii representation instead, which is often more useful:

```

def
test
():
>
assert
b
'spam'
==
b
'eggs'
E
AssertionError
:
assert
b
'spam'
==
b
'eggs'
E
At
index
0
diff
:
b
's'
!=
b
'e'
E
Use
-
v
to
get
the
full
diff

```

#5335 : Colorize level names when the level in the logging format is formatted using ‘%(levelname).Xs’ (truncated fixed width alignment), where X is an integer. #5354 : Fix pytest.mark.parametrize when the argvalues is an iterator. #5370 : Revert unrolling of all() to fix NameError on nested comprehensions. #5371 : Revert unrolling of all() to fix incorrect handling of generators with if . #5372 : Revert unrolling of all() to fix incorrect assertion when using all() in an expression. #5383 : -q has again an impact on the style of the collected items ( --collect-only ) when --log-cli-level is used. #5389 : Fix regressions of #5063 for importlib_metadata.PathDistribution which have their files attribute being None . #5390 : Fix regression where the obj attribute of TestCase items was no longer bound to methods. #5404 : Emit a warning when attempting to unwrap a broken object raises an exception, for easier debugging ( #5080 ). #5432 : Prevent “already imported” warnings from assertion rewriter when invoking pytest in-process multiple times. #5433 : Fix assertion rewriting in packages ( __init__.py ). #5444 : Fix --stepwise mode when the first file passed on the command-line fails to collect. #5482 : Fix bug introduced in 4.6.0 causing collection errors when passing more than 2 positional arguments to pytest.mark.parametrize . #5505 : Fix crash when discovery fails while using -p no:terminal .

# Improved Documentation¶

#5315 : Expand docs on mocking classes and dictionaries with monkeypatch . #5416 : Fix PytestUnknownMarkWarning in run/skip example.

# pytest 4.6.11 (2020-06-04)¶

# Bug Fixes¶

#6334 : Fix summary entries appearing twice when f/F and s/S report chars were used at the same time in the -r command-line option (for example -rFf ). The upper case variants were never documented and the preferred form should be the lower case. #7310 : Fix UnboundLocalError: local variable 'letter' referenced before assignment in _pytest.terminal.pytest_report_teststatus() when plugins return report objects in an unconventional state. This was making pytest_report_teststatus() skip entering if-block branches that declare the letter variable. The fix was to set the initial value of the letter before the if-block cascade so that it always has a value.

# pytest 4.6.10 (2020-05-08)¶

# Features¶

#6870 : New Config.invocation_args attribute containing the unchanged arguments passed to pytest.main() . Remark: while this is technically a new feature and according to our policy it should not have been backported, we have opened an exception in this particular case because it fixes a serious interaction with pytest-xdist , so it can also be considered a bugfix.

# Trivial/Internal Changes¶

#6404 : Remove usage of parser module, deprecated in Python 3.9.

# pytest 4.6.9 (2020-01-04)¶

# Bug Fixes¶

#6301 : Fix assertion rewriting for egg-based distributions and editable installs ( pip install --editable ).

# pytest 4.6.8 (2019-12-19)¶

# Features¶

#5471 : JUnit XML now includes a timestamp and hostname in the testsuite tag.

# Bug Fixes¶

#5430 : junitxml: Logs for failed test are now passed to junit report in case the test fails during call phase.

# Trivial/Internal Changes¶

#6345 : Pin colorama to 0.4.1 only for Python 3.4 so newer Python versions can still receive colorama updates.

# pytest 4.6.7 (2019-12-05)¶

# Bug Fixes¶

#5477 : The XML file produced by --junitxml now correctly contain a <testsuites> root element. #6044 : Properly ignore FileNotFoundError ( OSError.errno == NOENT in Python 2) exceptions when trying to remove old temporary directories, for instance when multiple processes try to remove the same directory (common with pytest-xdist for example).

# pytest 4.6.6 (2019-10-11)¶

# Bug Fixes¶

#5523 : Fixed using multiple short options together in the command-line (for example -vs ) in Python 3.8+. #5537 : Replace importlib_metadata backport with importlib.metadata from the standard library on Python 3.8+. #5806 : Fix “lexer” being used when uploading to bpaste.net from --pastebin to “text”. #5902 : Fix warnings about deprecated cmp attribute in attrs>=19.2 .

# Trivial/Internal Changes¶

#5801 : Fixes python version checks (detected by flake8-2020 ) in case python4 becomes a thing.

# pytest 4.6.5 (2019-08-05)¶

# Bug Fixes¶

#4344 : Fix RuntimeError/StopIteration when trying to collect package with “__init__.py” only. #5478 : Fix encode error when using unicode strings in exceptions with pytest.raises . #5524 : Fix issue where tmp_path and tmpdir would not remove directories containing files marked as read-only, which could lead to pytest crashing when executed a second time with the --basetemp option. #5547 : --step-wise now handles xfail(strict=True) markers properly. #5650 : Improved output when parsing an ini configuration file fails.

# pytest 4.6.4 (2019-06-28)¶

# Bug Fixes¶

#5404 : Emit a warning when attempting to unwrap a broken object raises an exception, for easier debugging ( #5080 ). #5444 : Fix --stepwise mode when the first file passed on the command-line fails to collect. #5482 : Fix bug introduced in 4.6.0 causing collection errors when passing more than 2 positional arguments to pytest.mark.parametrize . #5505 : Fix crash when discovery fails while using -p no:terminal .

# pytest 4.6.3 (2019-06-11)¶

# Bug Fixes¶

#5383 : -q has again an impact on the style of the collected items ( --collect-only ) when --log-cli-level is used. #5389 : Fix regressions of #5063 for importlib_metadata.PathDistribution which have their files attribute being None . #5390 : Fix regression where the obj attribute of TestCase items was no longer bound to methods.

# pytest 4.6.2 (2019-06-03)¶

# Bug Fixes¶

#5370 : Revert unrolling of all() to fix NameError on nested comprehensions. #5371 : Revert unrolling of all() to fix incorrect handling of generators with if . #5372 : Revert unrolling of all() to fix incorrect assertion when using all() in an expression.

# pytest 4.6.1 (2019-06-02)¶

# Bug Fixes¶

#5354 : Fix pytest.mark.parametrize when the argvalues is an iterator. #5358 : Fix assertion rewriting of all() calls to deal with non-generators.

# pytest 4.6.0 (2019-05-31)¶

# Important¶

The 4.6.X series will be the last series to support Python 2 and Python 3.4 . For more details, see our Python 2.7 and 3.4 support plan .

# Features¶

#4559 : Added the junit_log_passing_tests ini value which can be used to enable or disable logging of passing test output in the Junit XML file. #4956 : pytester’s testdir.spawn uses tmpdir as HOME/USERPROFILE directory. #5062 : Unroll calls to all to full for-loops with assertion rewriting for better failure messages, especially when using Generator Expressions. #5063 : Switch from pkg_resources to importlib-metadata for entrypoint detection for improved performance and import time. #5091 : The output for ini options in --help has been improved. #5269 : pytest.importorskip includes the ImportError now in the default reason . #5311 : Captured logs that are output for each failing test are formatted using the ColoredLevelFormatter. #5312 : Improved formatting of multiline log messages in Python 3.

# Bug Fixes¶

#2064 : The debugging plugin imports the wrapped Pdb class ( --pdbcls ) on-demand now. #4908 : The pytest_enter_pdb hook gets called with post-mortem ( --pdb ). #5036 : Fix issue where fixtures dependent on other parametrized fixtures would be erroneously parametrized. #5256 : Handle internal error due to a lone surrogate unicode character not being representable in Jython. #5257 : Ensure that sys.stdout.mode does not include 'b' as it is a text stream. #5278 : Pytest’s internal python plugin can be disabled using -p no:python again. #5286 : Fix issue with disable_test_id_escaping_and_forfeit_all_rights_to_community_support option not working when using a list of test IDs in parametrized tests. #5330 : Show the test module being collected when emitting PytestCollectionWarning messages for test classes with __init__ and __new__ methods to make it easier to pin down the problem. #5333 : Fix regression in 4.5.0 with --lf not re-running all tests with known failures from non-selected tests.

# Improved Documentation¶

#5250 : Expand docs on use of setenv and delenv with monkeypatch .

# pytest 4.5.0 (2019-05-11)¶

# Features¶

#4826 : A warning is now emitted when unknown marks are used as a decorator. This is often due to a typo, which can lead to silently broken tests. #4907 : Show XFail reason as part of JUnitXML message field. #5013 : Messages from crash reports are displayed within test summaries now, truncated to the terminal width. #5023 : New flag --strict-markers that triggers an error when unknown markers (e.g. those not registered using the markers option in the configuration file) are used in the test suite. The existing --strict option has the same behavior currently, but can be augmented in the future for additional checks. #5026 : Assertion failure messages for sequences and dicts contain the number of different items now. #5034 : Improve reporting with --lf and --ff (run-last-failure). #5035 : The --cache-show option/action accepts an optional glob to show only matching cache entries. #5059 : Standard input (stdin) can be given to pytester’s Testdir.run() and Testdir.popen() . #5068 : The -r option learnt about A to display all reports (including passed ones) in the short test summary. #5108 : The short test summary is displayed after passes with output ( -rP ). #5172 : The --last-failed ( --lf ) option got smarter and will now skip entire files if all tests of that test file have passed in previous runs, greatly speeding up collection. #5177 : Introduce new specific warning PytestWarning subclasses to make it easier to filter warnings based on the class, rather than on the message. The new subclasses are: PytestAssertRewriteWarning PytestCacheWarning PytestCollectionWarning PytestConfigWarning PytestUnhandledCoroutineWarning PytestUnknownMarkWarning #5202 : New record_testsuite_property session-scoped fixture allows users to log <property> tags at the testsuite level with the junitxml plugin. The generated XML is compatible with the latest xunit standard, contrary to the properties recorded by record_property and record_xml_attribute . #5214 : The default logging format has been changed to improve readability. Here is an example of a previous logging message:

```

test_log_cli_enabled_disabled
.
py
3
CRITICAL
critical
message
logged
by
test

```

This has now become:

```

CRITICAL
root
:
test_log_cli_enabled_disabled
.
py
:
3
critical
message
logged
by
test

```

The formatting can be changed through the log_format configuration option. #5220 : --fixtures now also shows fixture scope for scopes other than "function" .

# Bug Fixes¶

#5113 : Deselected items from plugins using pytest_collect_modifyitems as a hookwrapper are correctly reported now. #5144 : With usage errors exitstatus is set to EXIT_USAGEERROR in the pytest_sessionfinish hook now as expected. #5235 : outcome.exit is not used with EOF in the pdb wrapper anymore, but only with quit .

# Improved Documentation¶

#4935 : Expand docs on registering marks and the effect of --strict .

# Trivial/Internal Changes¶

#4942 : logging.raiseExceptions is not set to False anymore. #5013 : pytest now depends on wcwidth to properly track unicode character sizes for more precise terminal output. #5059 : pytester’s Testdir.popen() uses stdout and stderr via keyword arguments with defaults now ( subprocess.PIPE ). #5069 : The code for the short test summary in the terminal was moved to the terminal plugin. #5082 : Improved validation of kwargs for various methods in the pytester plugin. #5202 : record_property now emits a PytestWarning when used with junit_family=xunit2 : the fixture generates property tags as children of testcase , which is not permitted according to the most recent schema . #5239 : Pin pluggy to < 1.0 so we don’t update to 1.0 automatically when it gets released: there are planned breaking changes, and we want to ensure pytest properly supports pluggy 1.0 .

# pytest 4.4.2 (2019-05-08)¶

# Bug Fixes¶

#5089 : Fix crash caused by error in __repr__ function with both showlocals and verbose output enabled. #5139 : Eliminate core dependency on ‘terminal’ plugin. #5229 : Require pluggy>=0.11.0 which reverts a dependency to importlib-metadata added in 0.10.0 . The importlib-metadata package cannot be imported when installed as an egg and causes issues when relying on setup.py to install test dependencies.

# Improved Documentation¶

#5171 : Doc: pytest_ignore_collect , pytest_collect_directory , pytest_collect_file and pytest_pycollect_makemodule hooks’s ‘path’ parameter documented type is now py.path.local #5188 : Improve help for --runxfail flag.

# Trivial/Internal Changes¶

#5182 : Removed internal and unused _pytest.deprecated.MARK_INFO_ATTRIBUTE .

# pytest 4.4.1 (2019-04-15)¶

# Bug Fixes¶

#5031 : Environment variables are properly restored when using pytester’s testdir fixture. #5039 : Fix regression with --pdbcls , which stopped working with local modules in 4.0.0. #5092 : Produce a warning when unknown keywords are passed to pytest.param(...) . #5098 : Invalidate import caches with monkeypatch.syspath_prepend , which is required with namespace packages being used.

# pytest 4.4.0 (2019-03-29)¶

# Features¶

#2224 : async test functions are skipped and a warning is emitted when a suitable async plugin is not installed (such as pytest-asyncio or pytest-trio ). Previously async functions would not execute at all but still be marked as “passed”. #2482 : Include new disable_test_id_escaping_and_forfeit_all_rights_to_community_support option to disable ascii-escaping in parametrized values. This may cause a series of problems and as the name makes clear, use at your own risk. #4718 : The -p option can now be used to early-load plugins also by entry-point name, instead of just by module name. This makes it possible to early load external plugins like pytest-cov in the command-line:

```

pytest
-
p
pytest_cov

```

#4855 : The --pdbcls option handles classes via module attributes now (e.g. pdb:pdb.Pdb with pdbpp ), and its validation was improved. #4875 : The testpaths configuration option is now displayed next to the rootdir and inifile lines in the pytest header if the option is in effect, i.e., directories or file names were not explicitly passed in the command line. Also, inifile is only displayed if there’s a configuration file, instead of an empty inifile: string. #4911 : Doctests can be skipped now dynamically using pytest.skip() . #4920 : Internal refactorings have been made in order to make the implementation of the pytest-subtests plugin possible, which adds unittest sub-test support and a new subtests fixture as discussed in #1367 . For details on the internal refactorings, please see the details on the related PR. #4931 : pytester’s LineMatcher asserts that the passed lines are a sequence. #4936 : Handle -p plug after -p no:plug . This can be used to override a blocked plugin (e.g. in “addopts”) from the command line etc. #4951 : Output capturing is handled correctly when only capturing via fixtures (capsys, capfs) with pdb.set_trace() . #4956 : pytester sets $HOME and $USERPROFILE to the temporary directory during test runs. This ensures to not load configuration files from the real user’s home directory. #4980 : Namespace packages are handled better with monkeypatch.syspath_prepend and testdir.syspathinsert (via pkg_resources.fixup_namespace_packages ). #4993 : The stepwise plugin reports status information now. #5008 : If a setup.cfg file contains [tool:pytest] and also the no longer supported [pytest] section, pytest will use [tool:pytest] ignoring [pytest] . Previously it would unconditionally error out. This makes it simpler for plugins to support old pytest versions.

# Bug Fixes¶

#1895 : Fix bug where fixtures requested dynamically via request.getfixturevalue() might be teardown before the requesting fixture. #4851 : pytester unsets PYTEST_ADDOPTS now to not use outer options with testdir.runpytest() . #4903 : Use the correct modified time for years after 2038 in rewritten .pyc files. #4928 : Fix line offsets with ScopeMismatch errors. #4957 : -p no:plugin is handled correctly for default (internal) plugins now, e.g. with -p no:capture . Previously they were loaded (imported) always, making e.g. the capfd fixture available. #4968 : The pdb quit command is handled properly when used after the debug command with pdbpp . #4975 : Fix the interpretation of -qq option where it was being considered as -v instead. #4978 : outcomes.Exit is not swallowed in assertrepr_compare anymore. #4988 : Close logging’s file handler explicitly when the session finishes. #5003 : Fix line offset with mark collection error (off by one).

# Improved Documentation¶

#4974 : Update docs for pytest_cmdline_parse hook to note availability limitations

# Trivial/Internal Changes¶

#4718 : pluggy>=0.9 is now required. #4815 : funcsigs>=1.0 is now required for Python 2.7. #4829 : Some left-over internal code related to yield tests has been removed. #4890 : Remove internally unused anypython fixture from the pytester plugin. #4912 : Remove deprecated Sphinx directive, add_description_unit() , pin sphinx-removed-in to >= 0.2.0 to support Sphinx 2.0. #4913 : Fix pytest tests invocation with custom PYTHONPATH . #4965 : New pytest_report_to_serializable and pytest_report_from_serializable experimental hooks. These hooks will be used by pytest-xdist , pytest-subtests , and the replacement for resultlog to serialize and customize reports. They are experimental, meaning that their details might change or even be removed completely in future patch releases without warning. Feedback is welcome from plugin authors and users alike. #4987 : Collector.repr_failure respects the --tb option, but only defaults to short now (with auto ).

# pytest 4.3.1 (2019-03-11)¶

# Bug Fixes¶

#4810 : Logging messages inside pytest_runtest_logreport() are now properly captured and displayed. #4861 : Improve validation of contents written to captured output so it behaves the same as when capture is disabled. #4898 : Fix AttributeError: FixtureRequest has no 'confg' attribute bug in testdir.copy_example .

# Trivial/Internal Changes¶

#4768 : Avoid pkg_resources import at the top-level.

# pytest 4.3.0 (2019-02-16)¶

# Deprecations¶

#4724 : pytest.warns() now emits a warning when it receives unknown keyword arguments. This will be changed into an error in the future.

# Features¶

#2753 : Usage errors from argparse are mapped to pytest’s UsageError . #3711 : Add the --ignore-glob parameter to exclude test-modules with Unix shell-style wildcards. Add the collect_ignore_glob for conftest.py to exclude test-modules with Unix shell-style wildcards. #4698 : The warning about Python 2.7 and 3.4 not being supported in pytest 5.0 has been removed. In the end it was considered to be more of a nuisance than actual utility and users of those Python versions shouldn’t have problems as pip will not install pytest 5.0 on those interpreters. #4707 : With the help of new set_log_path() method there is a way to set log_file paths from hooks.

# Bug Fixes¶

#4651 : --help and --version are handled with UsageError . #4782 : Fix AssertionError with collection of broken symlinks with packages.

# pytest 4.2.1 (2019-02-12)¶

# Bug Fixes¶

#2895 : The pytest_report_collectionfinish hook now is also called with --collect-only . #3899 : Do not raise UsageError when an imported package has a pytest_plugins.py child module. #4347 : Fix output capturing when using pdb++ with recursive debugging. #4592 : Fix handling of collect_ignore via parent conftest.py . #4700 : Fix regression where setUpClass would always be called in subclasses even if all tests were skipped by a unittest.skip() decorator applied in the subclass. #4739 : Fix parametrize(... ids=<function>) when the function returns non-strings. #4745 : Fix/improve collection of args when passing in __init__.py and a test file. #4770 : more_itertools is now constrained to <6.0.0 when required for Python 2.7 compatibility. #526 : Fix “ValueError: Plugin already registered” exceptions when running in build directories that symlink to actual source.

# Improved Documentation¶

#3899 : Add note to plugins.rst that pytest_plugins should not be used as a name for a user module containing plugins. #4324 : Document how to use raises and does_not_raise to write parametrized tests with conditional raises. #4709 : Document how to customize test failure messages when using pytest.warns .

# Trivial/Internal Changes¶

#4741 : Some verbosity related attributes of the TerminalReporter plugin are now read only properties.

# pytest 4.2.0 (2019-01-30)¶

# Features¶

#3094 : Classic xunit-style functions and methods now obey the scope of autouse fixtures. This fixes a number of surprising issues like setup_method being called before session-scoped autouse fixtures (see #517 for an example). #4627 : Display a message at the end of the test session when running under Python 2.7 and 3.4 that pytest 5.0 will no longer support those Python versions. #4660 : The number of selected tests now are also displayed when the -k or -m flags are used. #4688 : pytest_report_teststatus hook now can also receive a config parameter. #4691 : pytest_terminal_summary hook now can also receive a config parameter.

# Bug Fixes¶

#3547 : --junitxml can emit XML compatible with Jenkins xUnit. junit_family INI option accepts legacy|xunit1 , which produces old style output, and xunit2 that conforms more strictly to https://github.com/jenkinsci/xunit-plugin/blob/xunit-2.3.2/src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd #4280 : Improve quitting from pdb, especially with --trace . Using q[quit] after pdb.set_trace() will quit pytest also. #4402 : Warning summary now groups warnings by message instead of by test id. This makes the output more compact and better conveys the general idea of how much code is actually generating warnings, instead of how many tests call that code. #4536 : monkeypatch.delattr handles class descriptors like staticmethod / classmethod . #4649 : Restore marks being considered keywords for keyword expressions. #4653 : tmp_path fixture and other related ones provides resolved path (a.k.a real path) #4667 : pytest_terminal_summary uses result from pytest_report_teststatus hook, rather than hardcoded strings. #4669 : Correctly handle unittest.SkipTest exception containing non-ascii characters on Python 2. #4680 : Ensure the tmpdir and the tmp_path fixtures are the same folder. #4681 : Ensure tmp_path is always a real path.

# Trivial/Internal Changes¶

#4643 : Use a.item() instead of the deprecated np.asscalar(a) in pytest.approx . np.asscalar has been deprecated in numpy 1.16. . #4657 : Copy saferepr from pylib #4668 : The verbose word for expected failures in the teststatus report changes from xfail to XFAIL to be consistent with other test outcomes.

# pytest 4.1.1 (2019-01-12)¶

# Bug Fixes¶

#2256 : Show full repr with assert a==b and -vv . #3456 : Extend Doctest-modules to ignore mock objects. #4617 : Fixed pytest.warns bug when context manager is reused (e.g. multiple parametrization). #4631 : Don’t rewrite assertion when __getattr__ is broken

# Improved Documentation¶

#3375 : Document that using setup.cfg may crash other tools or cause hard to track down problems because it uses a different parser than pytest.ini or tox.ini files.

# Trivial/Internal Changes¶

#4602 : Uninstall hypothesis in regen tox env.

# pytest 4.1.0 (2019-01-05)¶

# Removals¶

#2169 : pytest.mark.parametrize : in previous versions, errors raised by id functions were suppressed and changed into warnings. Now the exceptions are propagated, along with a pytest message informing the node, parameter value and index where the exception occurred. #3078 : Remove legacy internal warnings system: config.warn , Node.warn . The pytest_logwarning now issues a warning when implemented. See our docs on information on how to update your code. #3079 : Removed support for yield tests - they are fundamentally broken because they don’t support fixtures properly since collection and test execution were separated. See our docs on information on how to update your code. #3082 : Removed support for applying marks directly to values in @pytest.mark.parametrize . Use pytest.param instead. See our docs on information on how to update your code. #3083 : Removed Metafunc.addcall . This was the predecessor mechanism to @pytest.mark.parametrize . See our docs on information on how to update your code. #3085 : Removed support for passing strings to pytest.main . Now, always pass a list of strings instead. See our docs on information on how to update your code. #3086 : [pytest] section in setup.cfg files is no longer supported, use [tool:pytest] instead. setup.cfg files are meant for use with distutils , and a section named pytest has notoriously been a source of conflicts and bugs. Note that for pytest.ini and tox.ini files the section remains [pytest] . #3616 : Removed the deprecated compat properties for node.Class/Function/Module - use pytest.Class/Function/Module now. See our docs on information on how to update your code. #4421 : Removed the implementation of the pytest_namespace hook. See our docs on information on how to update your code. #4489 : Removed request.cached_setup . This was the predecessor mechanism to modern fixtures. See our docs on information on how to update your code. #4535 : Removed the deprecated PyCollector.makeitem method. This method was made public by mistake a long time ago. #4543 : Removed support to define fixtures using the pytest_funcarg__ prefix. Use the @pytest.fixture decorator instead. See our docs on information on how to update your code. #4545 : Calling fixtures directly is now always an error instead of a warning. See our docs on information on how to update your code. #4546 : Remove Node.get_marker(name) the return value was not usable for more than an existence check. Use Node.get_closest_marker(name) as a replacement. #4547 : The deprecated record_xml_property fixture has been removed, use the more generic record_property instead. See our docs for more information. #4548 : An error is now raised if the pytest_plugins variable is defined in a non-top-level conftest.py file (i.e., not residing in the rootdir ). See our docs for more information. #891 : Remove testfunction.markername attributes - use Node.iter_markers(name=None) to iterate them.

# Deprecations¶

#3050 : Deprecated the pytest.config global. See pytest.config global for rationale. #3974 : Passing the message parameter of pytest.raises now issues a DeprecationWarning . It is a common mistake to think this parameter will match the exception message, while in fact it only serves to provide a custom message in case the pytest.raises check fails. To avoid this mistake and because it is believed to be little used, pytest is deprecating it without providing an alternative for the moment. If you have concerns about this, please comment on #3974 . #4435 : Deprecated raises(..., 'code(as_a_string)') and warns(..., 'code(as_a_string)') . See raises / warns with a string as the second argument for rationale and examples.

# Features¶

#3191 : A warning is now issued when assertions are made for None . This is a common source of confusion among new users, which write:

```

assert
mocked_object
.
assert_called_with
(
3
,
4
,
5
,
key
=
"value"
)

```

When they should write:

```

mocked_object
.
assert_called_with
(
3
,
4
,
5
,
key
=
"value"
)

```

Because the assert_called_with method of mock objects already executes an assertion. This warning will not be issued when None is explicitly checked. An assertion like:

```

assert
variable
is
None

```

will not issue the warning. #3632 : Richer equality comparison introspection on AssertionError for objects created using attrs or dataclasses (Python 3.7+, backported to 3.6 ). #4278 : CACHEDIR.TAG files are now created inside cache directories. Those files are part of the Cache Directory Tagging Standard , and can be used by backup or synchronization programs to identify pytest’s cache directory as such. #4292 : pytest.outcomes.Exit is derived from SystemExit instead of KeyboardInterrupt . This allows us to better handle pdb exiting. #4371 : Updated the --collect-only option to display test descriptions when ran using --verbose . #4386 : Restructured ExceptionInfo object construction and ensure incomplete instances have a repr / str . #4416 : pdb: added support for keyword arguments with pdb.set_trace . It handles header similar to Python 3.7 does it, and forwards any other keyword arguments to the Pdb constructor. This allows for __import__("pdb").set_trace(skip=["foo.*"]) . #4483 : Added ini parameter junit_duration_report to optionally report test call durations, excluding setup and teardown times. The JUnit XML specification and the default pytest behavior is to include setup and teardown times in the test duration report. You can include just the call durations instead (excluding setup and teardown) by adding this to your pytest.ini file:

```

[pytest]
junit_duration_report
=
call

```

#4532 : -ra now will show errors and failures last, instead of as the first items in the summary. This makes it easier to obtain a list of errors and failures to run tests selectively. #4599 : pytest.importorskip now supports a reason parameter, which will be shown when the requested module cannot be imported.

# Bug Fixes¶

#3532 : -p now accepts its argument without a space between the value, for example -pmyplugin . #4327 : approx again works with more generic containers, more precisely instances of Iterable and Sized instead of more restrictive Sequence . #4397 : Ensure that node ids are printable. #4435 : Fixed raises(..., 'code(string)') frame filename. #4458 : Display actual test ids in --collect-only .

# Improved Documentation¶

#4557 : Markers example documentation page updated to support latest pytest version. #4558 : Update cache documentation example to correctly show cache hit and miss. #4580 : Improved detailed summary report documentation.

# Trivial/Internal Changes¶

#4447 : Changed the deprecation type of --result-log to PytestDeprecationWarning . It was decided to remove this feature at the next major revision.

# pytest 4.0.2 (2018-12-13)¶

# Bug Fixes¶

#4265 : Validate arguments from the PYTEST_ADDOPTS environment variable and the addopts ini option separately. #4435 : Fix raises(..., 'code(string)') frame filename. #4500 : When a fixture yields and a log call is made after the test runs, and, if the test is interrupted, capture attributes are None . #4538 : Raise TypeError for with raises(..., match=<non-None falsey value>) .

# Improved Documentation¶

#1495 : Document common doctest fixture directory tree structure pitfalls

# pytest 4.0.1 (2018-11-23)¶

# Bug Fixes¶

#3952 : Display warnings before “short test summary info” again, but still later warnings in the end. #4386 : Handle uninitialized exceptioninfo in repr/str. #4393 : Do not create .gitignore / README.md files in existing cache directories. #4400 : Rearrange warning handling for the yield test errors so the opt-out in 4.0.x correctly works. #4405 : Fix collection of testpaths with --pyargs . #4412 : Fix assertion rewriting involving Starred + side-effects. #4425 : Ensure we resolve the absolute path when the given --basetemp is a relative path.

# Trivial/Internal Changes¶

#4315 : Use pkg_resources.parse_version instead of LooseVersion in minversion check. #4440 : Adjust the stack level of some internal pytest warnings.

# pytest 4.0.0 (2018-11-13)¶

# Removals¶

#3737 : RemovedInPytest4Warnings are now errors by default. Following our plan to remove deprecated features with as little disruption as possible, all warnings of type RemovedInPytest4Warnings now generate errors instead of warning messages. The affected features will be effectively removed in pytest 4.1 , so please consult the Deprecations and Removals section in the docs for directions on how to update existing code. In the pytest 4.0.X series, it is possible to change the errors back into warnings as a stop gap measure by adding this to your pytest.ini file:

```

[pytest]
filterwarnings
=
ignore
:
:pytest.RemovedInPytest4Warning

```

But this will stop working when pytest 4.1 is released. If you have concerns about the removal of a specific feature, please add a comment to #4348 . #4358 : Remove the ::() notation to denote a test class instance in node ids. Previously, node ids that contain test instances would use ::() to denote the instance like this:

```

test_foo
.
py
::
Test
::()::
test_bar

```

The extra ::() was puzzling to most users and has been removed, so that the test id becomes now:

```

test_foo
.
py
::
Test
::
test_bar

```

This change could not accompany a deprecation period as is usual when user-facing functionality changes because it was not really possible to detect when the functionality was being used explicitly. The extra ::() might have been removed in some places internally already, which then led to confusion in places where it was expected, e.g. with --deselect ( #4127 ). Test class instances are also not listed with --collect-only anymore.

# Features¶

#4270 : The cache_dir option uses $TOX_ENV_DIR as prefix (if set in the environment). This uses a different cache per tox environment by default.

# Bug Fixes¶

#3554 : Fix CallInfo.__repr__ for when the call is not finished yet.

# pytest 3.10.1 (2018-11-11)¶

# Bug Fixes¶

#4287 : Fix nested usage of debugging plugin (pdb), e.g. with pytester’s testdir.runpytest . #4304 : Block the stepwise plugin if cacheprovider is also blocked, as one depends on the other. #4306 : Parse minversion as an actual version and not as dot-separated strings. #4310 : Fix duplicate collection due to multiple args matching the same packages. #4321 : Fix item.nodeid with resolved symlinks. #4325 : Fix collection of direct symlinked files, where the target does not match python_files . #4329 : Fix TypeError in report_collect with _collect_report_last_write.

# Trivial/Internal Changes¶

#4305 : Replace byte/unicode helpers in test_capture with python level syntax.

# pytest 3.10.0 (2018-11-03)¶

# Features¶

#2619 : Resume capturing output after continue with __import__("pdb").set_trace() . This also adds a new pytest_leave_pdb hook, and passes in pdb to the existing pytest_enter_pdb hook. #4147 : Add --sw , --stepwise as an alternative to --lf -x for stopping at the first failure, but starting the next test invocation from that test. See the documentation for more info. #4188 : Make --color emit colorful dots when not running in verbose mode. Earlier, it would only colorize the test-by-test output if --verbose was also passed. #4225 : Improve performance with collection reporting in non-quiet mode with terminals. The “collecting …” message is only printed/updated every 0.5s.

# Bug Fixes¶

#2701 : Fix false RemovedInPytest4Warning: usage of Session... is deprecated, please use pytest warnings. #4046 : Fix problems with running tests in package __init__.py files. #4260 : Swallow warnings during anonymous compilation of source. #4262 : Fix access denied error when deleting stale directories created by tmpdir / tmp_path . #611 : Naming a fixture request will now raise a warning: the request fixture is internal and should not be overwritten as it will lead to internal errors. #4266 : Handle (ignore) exceptions raised during collection, e.g. with Django’s LazySettings proxy class.

# Improved Documentation¶

#4255 : Added missing documentation about the fact that module names passed to filter warnings are not regex-escaped.

# Trivial/Internal Changes¶

#4272 : Display cachedir also in non-verbose mode if non-default. #4277 : pdb: improve message about output capturing with set_trace . Do not display “IO-capturing turned off/on” when -s is used to avoid confusion. #4279 : Improve message and stack level of warnings issued by monkeypatch.setenv when the value of the environment variable is not a str .

# pytest 3.9.3 (2018-10-27)¶

# Bug Fixes¶

#4174 : Fix “ValueError: Plugin already registered” with conftest plugins via symlink. #4181 : Handle race condition between creation and deletion of temporary folders. #4221 : Fix bug where the warning summary at the end of the test session was not showing the test where the warning was originated. #4243 : Fix regression when stacklevel for warnings was passed as positional argument on python2.

# Improved Documentation¶

#3851 : Add reference to empty_parameter_set_mark ini option in documentation of @pytest.mark.parametrize

# Trivial/Internal Changes¶

#4028 : Revert patching of sys.breakpointhook since it appears to do nothing. #4233 : Apply an import sorter ( reorder-python-imports ) to the codebase. #4248 : Remove use of unnecessary compat shim, six.binary_type

# pytest 3.9.2 (2018-10-22)¶

# Bug Fixes¶

#2909 : Improve error message when a recursive dependency between fixtures is detected. #3340 : Fix logging messages not shown in hooks pytest_sessionstart() and pytest_sessionfinish() . #3533 : Fix unescaped XML raw objects in JUnit report for skipped tests #3691 : Python 2: safely format warning message about passing unicode strings to warnings.warn , which may cause surprising MemoryError exception when monkey patching warnings.warn itself. #4026 : Improve error message when it is not possible to determine a function’s signature. #4177 : Pin setuptools>=40.0 to support py_modules in setup.cfg #4179 : Restore the tmpdir behaviour of symlinking the current test run. #4192 : Fix filename reported by warnings.warn when using recwarn under python2.

# pytest 3.9.1 (2018-10-16)¶

# Features¶

#4159 : For test-suites containing test classes, the information about the subclassed module is now output only if a higher verbosity level is specified (at least “-vv”).

# pytest 3.9.0 (2018-10-15 - not published due to a release automation bug)¶

# Deprecations¶

#3616 : The following accesses have been documented as deprecated for years, but are now actually emitting deprecation warnings. Access of Module , Function , Class , Instance , File and Item through Node instances. Now users will this warning:

```

usage
of
Function
.
Module
is
deprecated
,
please
use
pytest
.
Module
instead

```

Users should just import pytest and access those objects using the pytest module. request.cached_setup , this was the precursor of the setup/teardown mechanism available to fixtures. You can consult funcarg comparison section in the docs . Using objects named "Class" as a way to customize the type of nodes that are collected in Collector subclasses has been deprecated. Users instead should use pytest_collect_make_item to customize node types during collection. This issue should affect only advanced plugins who create new collection types, so if you see this warning message please contact the authors so they can change the code. The warning that produces the message below has changed to RemovedInPytest4Warning :

```

getfuncargvalue
is
deprecated
,
use
getfixturevalue

```

#3988 : Add a Deprecation warning for pytest.ensuretemp as it was deprecated since a while.

# Features¶

#2293 : Improve usage errors messages by hiding internal details which can be distracting and noisy. This has the side effect that some error conditions that previously raised generic errors (such as ValueError for unregistered marks) are now raising Failed exceptions. #3332 : Improve the error displayed when a conftest.py file could not be imported. In order to implement this, a new chain parameter was added to ExceptionInfo.getrepr to show or hide chained tracebacks in Python 3 (defaults to True ). #3849 : Add empty_parameter_set_mark=fail_at_collect ini option for raising an exception when parametrize collects an empty set. #3964 : Log messages generated in the collection phase are shown when live-logging is enabled and/or when they are logged to a file. #3985 : Introduce tmp_path as a fixture providing a Path object. Also introduce tmp_path_factory as a session-scoped fixture for creating arbitrary temporary directories from any other fixture or test. #4013 : Deprecation warnings are now shown even if you customize the warnings filters yourself. In the previous version any customization would override pytest’s filters and deprecation warnings would fall back to being hidden by default. #4073 : Allow specification of timeout for Testdir.runpytest_subprocess() and Testdir.run() . #4098 : Add returncode argument to pytest.exit() to exit pytest with a specific return code. #4102 : Reimplement pytest.deprecated_call using pytest.warns so it supports the match='...' keyword argument. This has the side effect that pytest.deprecated_call now raises pytest.fail.Exception instead of AssertionError . #4149 : Require setuptools>=30.3 and move most of the metadata to setup.cfg .

# Bug Fixes¶

#2535 : Improve error message when test functions of unittest.TestCase subclasses use a parametrized fixture. #3057 : request.fixturenames now correctly returns the name of fixtures created by request.getfixturevalue() . #3946 : Warning filters passed as command line options using -W now take precedence over filters defined in ini configuration files. #4066 : Fix source reindenting by using textwrap.dedent directly. #4102 : pytest.warn will capture previously-warned warnings in Python 2. Previously they were never raised. #4108 : Resolve symbolic links for args. This fixes running pytest tests/test_foo.py::test_bar , where tests is a symlink to project/app/tests : previously project/app/conftest.py would be ignored for fixtures then. #4132 : Fix duplicate printing of internal errors when using --pdb . #4135 : pathlib based tmpdir cleanup now correctly handles symlinks in the folder. #4152 : Display the filename when encountering SyntaxWarning .

# Improved Documentation¶

#3713 : Update usefixtures documentation to clarify that it can’t be used with fixture functions. #4058 : Update fixture documentation to specify that a fixture can be invoked twice in the scope it’s defined for. #4064 : According to unittest.rst, setUpModule and tearDownModule were not implemented, but it turns out they are. So updated the documentation for unittest. #4151 : Add tempir testing example to CONTRIBUTING.rst guide

# Trivial/Internal Changes¶

#2293 : The internal MarkerError exception has been removed. #3988 : Port the implementation of tmpdir to pathlib. #4063 : Exclude 0.00 second entries from --duration output unless -vv is passed on the command-line. #4093 : Fixed formatting of string literals in internal tests.

# pytest 3.8.2 (2018-10-02)¶

# Deprecations and Removals¶

#4036 : The item parameter of pytest_warning_captured hook is now documented as deprecated. We realized only after the 3.8 release that this parameter is incompatible with pytest-xdist . Our policy is to not deprecate features during bug-fix releases, but in this case we believe it makes sense as we are only documenting it as deprecated, without issuing warnings which might potentially break test suites. This will get the word out that hook implementers should not use this parameter at all. In a future release item will always be None and will emit a proper warning when a hook implementation makes use of it.

# Bug Fixes¶

#3539 : Fix reload on assertion rewritten modules. #4034 : The .user_properties attribute of TestReport objects is a list of (name, value) tuples, but could sometimes be instantiated as a tuple of tuples. It is now always a list. #4039 : No longer issue warnings about using pytest_plugins in non-top-level directories when using --pyargs : the current --pyargs mechanism is not reliable and might give false negatives. #4040 : Exclude empty reports for passed tests when -rP option is used. #4051 : Improve error message when an invalid Python expression is passed to the -m option. #4056 : MonkeyPatch.setenv and MonkeyPatch.delenv issue a warning if the environment variable name is not str on Python 2. In Python 2, adding unicode keys to os.environ causes problems with subprocess (and possible other modules), making this a subtle bug specially susceptible when used with from __future__ import unicode_literals .

# Improved Documentation¶

#3928 : Add possible values for fixture scope to docs.

# pytest 3.8.1 (2018-09-22)¶

# Bug Fixes¶

#3286 : .pytest_cache directory is now automatically ignored by Git. Users who would like to contribute a solution for other SCMs please consult/comment on this issue. #3749 : Fix the following error during collection of tests inside packages:

```

TypeError
:
object
of
type
'Package'
has
no
len
()

```

#3941 : Fix bug where indirect parametrization would consider the scope of all fixtures used by the test function to determine the parametrization scope, and not only the scope of the fixtures being parametrized. #3973 : Fix crash of the assertion rewriter if a test changed the current working directory without restoring it afterwards. #3998 : Fix issue that prevented some caplog properties (for example record_tuples ) from being available when entering the debugger with --pdb . #3999 : Fix UnicodeDecodeError in python2.x when a class returns a non-ascii binary __repr__ in an assertion which also contains non-ascii text.

# Improved Documentation¶

#3996 : New Deprecations and Removals page shows all currently deprecated features, the rationale to do so, and alternatives to update your code. It also list features removed from pytest in past major releases to help those with ancient pytest versions to upgrade.

# Trivial/Internal Changes¶

#3955 : Improve pre-commit detection for changelog filenames #3975 : Remove legacy code around im_func as that was python2 only

# pytest 3.8.0 (2018-09-05)¶

# Deprecations and Removals¶

#2452 : Config.warn and Node.warn have been deprecated, see Config.warn and Node.warn for rationale and examples. #3936 : @pytest.mark.filterwarnings second parameter is no longer regex-escaped, making it possible to actually use regular expressions to check the warning message. Note : regex-escaping the match string was an implementation oversight that might break test suites which depend on the old behavior.

# Features¶

#2452 : Internal pytest warnings are now issued using the standard warnings module, making it possible to use the standard warnings filters to manage those warnings. This introduces PytestWarning , PytestDeprecationWarning and RemovedInPytest4Warning warning types as part of the public API. Consult the documentation for more info. #2908 : DeprecationWarning and PendingDeprecationWarning are now shown by default if no other warning filter is configured. This makes pytest more compliant with PEP 506#recommended-filter-settings-for-test-runners . See the docs for more info. #3251 : Warnings are now captured and displayed during test collection. #3784 : PYTEST_DISABLE_PLUGIN_AUTOLOAD environment variable disables plugin auto-loading when set. #3829 : Added the count option to console_output_style to enable displaying the progress as a count instead of a percentage. #3837 : Added support for ‘xfailed’ and ‘xpassed’ outcomes to the pytester.RunResult.assert_outcomes signature.

# Bug Fixes¶

#3911 : Terminal writer now takes into account unicode character width when writing out progress. #3913 : Pytest now returns with correct exit code (EXIT_USAGEERROR, 4) when called with unknown arguments. #3918 : Improve performance of assertion rewriting.

# Improved Documentation¶

#3566 : Added a blurb in usage.rst for the usage of -r flag which is used to show an extra test summary info. #3907 : Corrected type of the exceptions collection passed to xfail : raises argument accepts a tuple instead of list .

# Trivial/Internal Changes¶

#3853 : Removed "run all (no recorded failures)" message printed with --failed-first and --last-failed when there are no failed tests.

# pytest 3.7.4 (2018-08-29)¶

# Bug Fixes¶

#3506 : Fix possible infinite recursion when writing .pyc files. #3853 : Cache plugin now obeys the -q flag when --last-failed and --failed-first flags are used. #3883 : Fix bad console output when using console_output_style=classic . #3888 : Fix macOS specific code using capturemanager plugin in doctests.

# Improved Documentation¶

#3902 : Fix pytest.org links

# pytest 3.7.3 (2018-08-26)¶

# Bug Fixes¶

#3033 : Fixtures during teardown can again use capsys and capfd to inspect output captured during tests. #3773 : Fix collection of tests from __init__.py files if they match the python_files configuration option. #3796 : Fix issue where teardown of fixtures of consecutive sub-packages were executed once, at the end of the outer package. #3816 : Fix bug where --show-capture=no option would still show logs printed during fixture teardown. #3819 : Fix stdout/stderr not getting captured when real-time cli logging is active. #3843 : Fix collection error when specifying test functions directly in the command line using test.py::test syntax together with --doctest-modules . #3848 : Fix bugs where unicode arguments could not be passed to testdir.runpytest on Python 2. #3854 : Fix double collection of tests within packages when the filename starts with a capital letter.

# Improved Documentation¶

#3824 : Added example for multiple glob pattern matches in python_files . #3833 : Added missing docs for pytester.Testdir . #3870 : Correct documentation for setuptools integration.

# Trivial/Internal Changes¶

#3826 : Replace broken type annotations with type comments. #3845 : Remove a reference to issue #568 from the documentation, which has since been fixed.

# pytest 3.7.2 (2018-08-16)¶

# Bug Fixes¶

#3671 : Fix filterwarnings not being registered as a builtin mark. #3768 , #3789 : Fix test collection from packages mixed with normal directories. #3771 : Fix infinite recursion during collection if a pytest_ignore_collect hook returns False instead of None . #3774 : Fix bug where decorated fixtures would lose functionality (for example @mock.patch ). #3775 : Fix bug where importing modules or other objects with prefix pytest_ prefix would raise a PluginValidationError . #3788 : Fix AttributeError during teardown of TestCase subclasses which raise an exception during __init__ . #3804 : Fix traceback reporting for exceptions with __cause__ cycles.

# Improved Documentation¶

#3746 : Add documentation for metafunc.config that had been mistakenly hidden.

# pytest 3.7.1 (2018-08-02)¶

# Bug Fixes¶

#3473 : Raise immediately if approx() is given an expected value of a type it doesn’t understand (e.g. strings, nested dicts, etc.). #3712 : Correctly represent the dimensions of a numpy array when calling repr() on approx() . #3742 : Fix incompatibility with third party plugins during collection, which produced the error object has no attribute '_collectfile' . #3745 : Display the absolute path if cache_dir is not relative to the rootdir instead of failing. #3747 : Fix compatibility problem with plugins and the warning code issued by fixture functions when they are called directly. #3748 : Fix infinite recursion in pytest.approx with arrays in numpy<1.13 . #3757 : Pin pathlib2 to >=2.2.0 as we require __fspath__ support. #3763 : Fix TypeError when the assertion message is bytes in python 3.

# pytest 3.7.0 (2018-07-30)¶

# Deprecations and Removals¶

#2639 : pytest_namespace has been deprecated . #3661 : Calling a fixture function directly, as opposed to request them in a test function, now issues a RemovedInPytest4Warning . See the documentation for rationale and examples .

# Features¶

#2283 : New package fixture scope: fixtures are finalized when the last test of a package finishes. This feature is considered experimental , so use it sparingly. #3576 : Node.add_marker now supports an append=True/False parameter to determine whether the mark comes last (default) or first. #3579 : Fixture caplog now has a messages property, providing convenient access to the format-interpolated log messages without the extra data provided by the formatter/handler. #3610 : New --trace option to enter the debugger at the start of a test. #3623 : Introduce pytester.copy_example as helper to do acceptance tests against examples from the project.

# Bug Fixes¶

#2220 : Fix a bug where fixtures overridden by direct parameters (for example parametrization) were being instantiated even if they were not being used by a test. #3695 : Fix ApproxNumpy initialisation argument mixup, abs and rel tolerances were flipped causing strange comparison results. Add tests to check abs and rel tolerances for np.array and test for expecting nan with np.array() #980 : Fix truncated locals output in verbose mode.

# Improved Documentation¶

#3295 : Correct the usage documentation of --last-failed-no-failures by adding the missing --last-failed argument in the presented examples, because they are misleading and lead to think that the missing argument is not needed.

# Trivial/Internal Changes¶

#3519 : Now a README.md file is created in .pytest_cache to make it clear why the directory exists.

# pytest 3.6.4 (2018-07-28)¶

# Bug Fixes¶

Invoke pytest using -mpytest so sys.path does not get polluted by packages installed in site-packages . ( #742 )

# Improved Documentation¶

Use smtp_connection instead of smtp in fixtures documentation to avoid possible confusion. ( #3592 )

# Trivial/Internal Changes¶

Remove obsolete __future__ imports. ( #2319 ) Add CITATION to provide information on how to formally cite pytest. ( #3402 ) Replace broken type annotations with type comments. ( #3635 ) Pin pluggy to <0.8 . ( #3727 )

# pytest 3.6.3 (2018-07-04)¶

# Bug Fixes¶

Fix ImportWarning triggered by explicit relative imports in assertion-rewritten package modules. ( #3061 ) Fix error in pytest.approx when dealing with 0-dimension numpy arrays. ( #3593 ) No longer raise ValueError when using the get_marker API. ( #3605 ) Fix problem where log messages with non-ascii characters would not appear in the output log file. ( #3630 ) No longer raise AttributeError when legacy marks can’t be stored in functions. ( #3631 )

# Improved Documentation¶

The description above the example for @pytest.mark.skipif now better matches the code. ( #3611 )

# Trivial/Internal Changes¶

Internal refactoring: removed unused CallSpec2tox ._globalid_args attribute and metafunc parameter from CallSpec2.copy() . ( #3598 ) Silence usage of reduce warning in Python 2 ( #3609 ) Fix usage of attr.ib deprecated convert parameter. ( #3653 )

# pytest 3.6.2 (2018-06-20)¶

# Bug Fixes¶

Fix regression in Node.add_marker by extracting the mark object of a MarkDecorator . ( #3555 ) Warnings without location were reported as None . This is corrected to now report <undetermined location> . ( #3563 ) Continue to call finalizers in the stack when a finalizer in a former scope raises an exception. ( #3569 ) Fix encoding error with print statements in doctests ( #3583 )

# Improved Documentation¶

Add documentation for the --strict flag. ( #3549 )

# Trivial/Internal Changes¶

Update old quotation style to parens in fixture.rst documentation. ( #3525 ) Improve display of hint about --fulltrace with KeyboardInterrupt . ( #3545 ) pytest’s testsuite is no longer runnable through python setup.py test – instead invoke pytest or tox directly. ( #3552 ) Fix typo in documentation ( #3567 )

# pytest 3.6.1 (2018-06-05)¶

# Bug Fixes¶

Fixed a bug where stdout and stderr were logged twice by junitxml when a test was marked xfail. ( #3491 ) Fix usefixtures mark applied to unittest tests by correctly instantiating FixtureInfo . ( #3498 ) Fix assertion rewriter compatibility with libraries that monkey patch file objects. ( #3503 )

# Improved Documentation¶

Added a section on how to use fixtures as factories to the fixture documentation. ( #3461 )

# Trivial/Internal Changes¶

Enable caching for pip/pre-commit in order to reduce build time on travis/appveyor. ( #3502 ) Switch pytest to the src/ layout as we already suggested it for good practice - now we implement it as well. ( #3513 ) Fix if in tests to support 3.7.0b5, where a docstring handling in AST got reverted. ( #3530 ) Remove some python2.5 compatibility code. ( #3529 )

# pytest 3.6.0 (2018-05-23)¶

# Features¶

Revamp the internals of the pytest.mark implementation with correct per node handling which fixes a number of long standing bugs caused by the old design. This introduces new Node.iter_markers(name) and Node.get_closest_marker(name) APIs. Users are strongly encouraged to read the reasons for the revamp in the docs , or jump over to details about updating existing code to use the new APIs . ( #3317 ) Now when @pytest.fixture is applied more than once to the same function a ValueError is raised. This buggy behavior would cause surprising problems and if was working for a test suite it was mostly by accident. ( #2334 ) Support for Python 3.7’s builtin breakpoint() method, see Using the builtin breakpoint function for details. ( #3180 ) monkeypatch now supports a context() function which acts as a context manager which undoes all patching done within the with block. ( #3290 ) The --pdb option now causes KeyboardInterrupt to enter the debugger, instead of stopping the test session. On python 2.7, hitting CTRL+C again exits the debugger. On python 3.2 and higher, use CTRL+D. ( #3299 ) pytest no longer changes the log level of the root logger when the log-level parameter has greater numeric value than that of the level of the root logger, which makes it play better with custom logging configuration in user code. ( #3307 )

# Bug Fixes¶

A rare race-condition which might result in corrupted .pyc files on Windows has been hopefully solved. ( #3008 ) Also use iter_marker for discovering the marks applying for marker expressions from the cli to avoid the bad data from the legacy mark storage. ( #3441 ) When showing diffs of failed assertions where the contents contain only whitespace, escape them using repr() first to make it easy to spot the differences. ( #3443 )

# Improved Documentation¶

Change documentation copyright year to a range which auto-updates itself each time it is published. ( #3303 )

# Trivial/Internal Changes¶

pytest now depends on the python-atomicwrites library. ( #3008 ) Update all pypi.python.org URLs to pypi.org. ( #3431 ) Detect pytest_ prefixed hooks using the internal plugin manager since pluggy is deprecating the implprefix argument to PluginManager . ( #3487 ) Import Mapping and Sequence from _pytest.compat instead of directly from collections in python_api.py::approx . Add Mapping to _pytest.compat , import it from collections on python 2, but from collections.abc on Python 3 to avoid a DeprecationWarning on Python 3.7 or newer. ( #3497 )

# pytest 3.5.1 (2018-04-23)¶

# Bug Fixes¶

Reset sys.last_type , sys.last_value and sys.last_traceback before each test executes. Those attributes are added by pytest during the test run to aid debugging, but were never reset so they would create a leaking reference to the last failing test’s frame which in turn could never be reclaimed by the garbage collector. ( #2798 ) pytest.raises now raises TypeError when receiving an unknown keyword argument. ( #3348 ) pytest.raises now works with exception classes that look like iterables. ( #3372 )

# Improved Documentation¶

Fix typo in caplog fixture documentation, which incorrectly identified certain attributes as methods. ( #3406 )

# Trivial/Internal Changes¶

Added a more indicative error message when parametrizing a function whose argument takes a default value. ( #3221 ) Remove internal _pytest.terminal.flatten function in favor of more_itertools.collapse . ( #3330 ) Import some modules from collections.abc instead of collections as the former modules trigger DeprecationWarning in Python 3.7. ( #3339 ) record_property is no longer experimental, removing the warnings was forgotten. ( #3360 ) Mention in documentation and CLI help that fixtures with leading _ are printed by pytest --fixtures only if the -v option is added. ( #3398 )

# pytest 3.5.0 (2018-03-21)¶

# Deprecations and Removals¶

record_xml_property fixture is now deprecated in favor of the more generic record_property . ( #2770 ) Defining pytest_plugins is now deprecated in non-top-level conftest.py files, because they “leak” to the entire directory tree. See the docs for the rationale behind this decision ( #3084 )

# Features¶

New --show-capture command-line option that allows to specify how to display captured output when tests fail: no , stdout , stderr , log or all (the default). ( #1478 ) New --rootdir command-line option to override the rules for discovering the root directory. See customize in the documentation for details. ( #1642 ) Fixtures are now instantiated based on their scopes, with higher-scoped fixtures (such as session ) being instantiated first than lower-scoped fixtures (such as function ). The relative order of fixtures of the same scope is kept unchanged, based in their declaration order and their dependencies. ( #2405 ) record_xml_property renamed to record_property and is now compatible with xdist, markers and any reporter. record_xml_property name is now deprecated. ( #2770 ) New --nf , --new-first options: run new tests first followed by the rest of the tests, in both cases tests are also sorted by the file modified time, with more recent files coming first. ( #3034 ) New --last-failed-no-failures command-line option that allows to specify the behavior of the cache plugin’s `--last-failed feature when no tests failed in the last run (or no cache was found): none or all (the default). ( #3139 ) New --doctest-continue-on-failure command-line option to enable doctests to show multiple failures for each snippet, instead of stopping at the first failure. ( #3149 ) Captured log messages are added to the <system-out> tag in the generated junit xml file if the junit_logging ini option is set to system-out . If the value of this ini option is system-err , the logs are written to <system-err> . The default value for junit_logging is no , meaning captured logs are not written to the output file. ( #3156 ) Allow the logging plugin to handle pytest_runtest_logstart and pytest_runtest_logfinish hooks when live logs are enabled. ( #3189 ) Passing --log-cli-level in the command-line now automatically activates live logging. ( #3190 ) Add command line option --deselect to allow deselection of individual tests at collection time. ( #3198 ) Captured logs are printed before entering pdb. ( #3204 ) Deselected item count is now shown before tests are run, e.g. collected X items / Y deselected . ( #3213 ) The builtin module platform is now available for use in expressions in pytest.mark . ( #3236 ) The short test summary info section now is displayed after tracebacks and warnings in the terminal. ( #3255 ) New --verbosity flag to set verbosity level explicitly. ( #3296 ) pytest.approx now accepts comparing a numpy array with a scalar. ( #3312 )

# Bug Fixes¶

Suppress IOError when closing the temporary file used for capturing streams in Python 2.7. ( #2370 ) Fixed clear() method on caplog fixture which cleared records , but not the text property. ( #3297 ) During test collection, when stdin is not allowed to be read, the DontReadFromStdin object still allow itself to be iterable and resolved to an iterator without crashing. ( #3314 )

# Improved Documentation¶

Added a reference page to the docs. ( #1713 )

# Trivial/Internal Changes¶

Change minimum requirement of attrs to 17.4.0 . ( #3228 ) Renamed example directories so all tests pass when ran from the base directory. ( #3245 ) Internal mark.py module has been turned into a package. ( #3250 ) pytest now depends on the more-itertools package. ( #3265 ) Added warning when [pytest] section is used in a .cfg file passed with -c ( #3268 ) nodeids can now be passed explicitly to FSCollector and Node constructors. ( #3291 ) Internal refactoring of FormattedExcinfo to use attrs facilities and remove old support code for legacy Python versions. ( #3292 ) Refactoring to unify how verbosity is handled internally. ( #3296 ) Internal refactoring to better integrate with argparse. ( #3304 ) Fix a python example when calling a fixture in doc/en/usage.rst ( #3308 )

# pytest 3.4.2 (2018-03-04)¶

# Bug Fixes¶

Removed progress information when capture option is no . ( #3203 ) Refactor check of bindir from exists to isdir . ( #3241 ) Fix TypeError issue when using approx with a Decimal value. ( #3247 ) Fix reference cycle generated when using the request fixture. ( #3249 ) [tool:pytest] sections in *.cfg files passed by the -c option are now properly recognized. ( #3260 )

# Improved Documentation¶

Add logging plugin to plugins list. ( #3209 )

# Trivial/Internal Changes¶

Fix minor typo in fixture.rst ( #3259 )

# pytest 3.4.1 (2018-02-20)¶

# Bug Fixes¶

Move import of doctest.UnexpectedException to top-level to avoid possible errors when using --pdb . ( #1810 ) Added printing of captured stdout/stderr before entering pdb, and improved a test which was giving false negatives about output capturing. ( #3052 ) Fix ordering of tests using parametrized fixtures which can lead to fixtures being created more than necessary. ( #3161 ) Fix bug where logging happening at hooks outside of “test run” hooks would cause an internal error. ( #3184 ) Detect arguments injected by unittest.mock.patch decorator correctly when pypi mock.patch is installed and imported. ( #3206 ) Errors shown when a pytest.raises() with match= fails are now cleaner on what happened: When no exception was raised, the “matching ‘…’” part got removed as it falsely implies that an exception was raised but it didn’t match. When a wrong exception was raised, it’s now thrown (like pytest.raised() without match= would) instead of complaining about the unmatched text. ( #3222 ) Fixed output capture handling in doctests on macOS. ( #985 )

# Improved Documentation¶

Add Sphinx parameter docs for match and message args to pytest.raises . ( #3202 )

# Trivial/Internal Changes¶

pytest has changed the publication procedure and is now being published to PyPI directly from Travis. ( #3060 ) Rename ParameterSet._for_parameterize() to _for_parametrize() in order to comply with the naming convention. ( #3166 ) Skip failing pdb/doctest test on mac. ( #985 )

# pytest 3.4.0 (2018-01-30)¶

# Deprecations and Removals¶

All pytest classes now subclass object for better Python 2/3 compatibility. This should not affect user code except in very rare edge cases. ( #2147 )

# Features¶

Introduce empty_parameter_set_mark ini option to select which mark to apply when @pytest.mark.parametrize is given an empty set of parameters. Valid options are skip (default) and xfail . Note that it is planned to change the default to xfail in future releases as this is considered less error prone. ( #2527 ) Incompatible change : after community feedback the logging functionality has undergone some changes. Please consult the logging documentation for details. ( #3013 ) Console output falls back to “classic” mode when capturing is disabled ( -s ), otherwise the output gets garbled to the point of being useless. ( #3038 ) New pytest_runtest_logfinish hook which is called when a test item has finished executing, analogous to pytest_runtest_logstart . ( #3101 ) Improve performance when collecting tests using many fixtures. ( #3107 ) New caplog.get_records(when) method which provides access to the captured records for the "setup" , "call" and "teardown" testing stages. ( #3117 ) New fixture record_xml_attribute that allows modifying and inserting attributes on the <testcase> xml node in JUnit reports. ( #3130 ) The default cache directory has been renamed from .cache to .pytest_cache after community feedback that the name .cache did not make it clear that it was used by pytest. ( #3138 ) Colorize the levelname column in the live-log output. ( #3142 )

# Bug Fixes¶

Fix hanging pexpect test on macOS by using flush() instead of wait(). ( #2022 ) Fix restoring Python state after in-process pytest runs with the pytester plugin; this may break tests using multiple inprocess pytest runs if later ones depend on earlier ones leaking global interpreter changes. ( #3016 ) Fix skipping plugin reporting hook when test aborted before plugin setup hook. ( #3074 ) Fix progress percentage reported when tests fail during teardown. ( #3088 ) Incompatible change : -o/--override option no longer eats all the remaining options, which can lead to surprising behavior: for example, pytest -o foo=1 /path/to/test.py would fail because /path/to/test.py would be considered as part of the -o command-line argument. One consequence of this is that now multiple configuration overrides need multiple -o flags: pytest -o foo=1 -o bar=2 . ( #3103 )

# Improved Documentation¶

Document hooks (defined with historic=True ) which cannot be used with hookwrapper=True . ( #2423 ) Clarify that warning capturing doesn’t change the warning filter by default. ( #2457 ) Clarify a possible confusion when using pytest_fixture_setup with fixture functions that return None. ( #2698 ) Fix the wording of a sentence on doctest flags used in pytest. ( #3076 ) Prefer https://*.readthedocs.io over http://*.rtfd.org for links in the documentation. ( #3092 ) Improve readability (wording, grammar) of Getting Started guide ( #3131 ) Added note that calling pytest.main multiple times from the same process is not recommended because of import caching. ( #3143 )

# Trivial/Internal Changes¶

Show a simple and easy error when keyword expressions trigger a syntax error (for example, "-k foo and import" will show an error that you cannot use the import keyword in expressions). ( #2953 ) Change parametrized automatic test id generation to use the __name__ attribute of functions instead of the fallback argument name plus counter. ( #2976 ) Replace py.std with stdlib imports. ( #3067 ) Corrected ‘you’ to ‘your’ in logging docs. ( #3129 )

# pytest 3.3.2 (2017-12-25)¶

# Bug Fixes¶

pytester: ignore files used to obtain current user metadata in the fd leak detector. ( #2784 ) Fix memory leak where objects returned by fixtures were never destructed by the garbage collector. ( #2981 ) Fix conversion of pyargs to filename to not convert symlinks on Python 2. ( #2985 ) PYTEST_DONT_REWRITE is now checked for plugins too rather than only for test modules. ( #2995 )

# Improved Documentation¶

Add clarifying note about behavior of multiple parametrized arguments ( #3001 )

# Trivial/Internal Changes¶

Code cleanup. ( #3015 , #3021 ) Clean up code by replacing imports and references of _ast to ast . ( #3018 )

# pytest 3.3.1 (2017-12-05)¶

# Bug Fixes¶

Fix issue about -p no:<plugin> having no effect. ( #2920 ) Fix regression with warnings that contained non-strings in their arguments in Python 2. ( #2956 ) Always escape null bytes when setting PYTEST_CURRENT_TEST . ( #2957 ) Fix ZeroDivisionError when using the testmon plugin when no tests were actually collected. ( #2971 ) Bring back TerminalReporter.writer as an alias to TerminalReporter._tw . This alias was removed by accident in the 3.3.0 release. ( #2984 ) The pytest-capturelog plugin is now also blacklisted, avoiding errors when running pytest with it still installed. ( #3004 )

# Improved Documentation¶

Fix broken link to plugin pytest-localserver . ( #2963 )

# Trivial/Internal Changes¶

Update github “bugs” link in CONTRIBUTING.rst ( #2949 )

# pytest 3.3.0 (2017-11-23)¶

# Deprecations and Removals¶

pytest no longer supports Python 2.6 and 3.3 . Those Python versions are EOL for some time now and incur maintenance and compatibility costs on the pytest core team, and following up with the rest of the community we decided that they will no longer be supported starting on this version. Users which still require those versions should pin pytest to <3.3 . ( #2812 ) Remove internal _preloadplugins() function. This removal is part of the pytest_namespace() hook deprecation. ( #2636 ) Internally change CallSpec2 to have a list of marks instead of a broken mapping of keywords. This removes the keywords attribute of the internal CallSpec2 class. ( #2672 ) Remove ParameterSet.deprecated_arg_dict - its not a public api and the lack of the underscore was a naming error. ( #2675 ) Remove the internal multi-typed attribute Node._evalskip and replace it with the boolean Node._skipped_by_mark . ( #2767 ) The params list passed to pytest.fixture is now for all effects considered immutable and frozen at the moment of the pytest.fixture call. Previously the list could be changed before the first invocation of the fixture allowing for a form of dynamic parametrization (for example, updated from command-line options), but this was an unwanted implementation detail which complicated the internals and prevented some internal cleanup. See issue #2959 for details and a recommended workaround.

# Features¶

pytest_fixture_post_finalizer hook can now receive a request argument. ( #2124 ) Replace the old introspection code in compat.py that determines the available arguments of fixtures with inspect.signature on Python 3 and funcsigs.signature on Python 2. This should respect __signature__ declarations on functions. ( #2267 ) Report tests with global pytestmark variable only once. ( #2549 ) Now pytest displays the total progress percentage while running tests. The previous output style can be set by configuring the console_output_style setting to classic . ( #2657 ) Match warns signature to raises by adding match keyword. ( #2708 ) pytest now captures and displays output from the standard logging module. The user can control the logging level to be captured by specifying options in pytest.ini , the command line and also during individual tests using markers. Also, a caplog fixture is available that enables users to test the captured log during specific tests (similar to capsys for example). For more information, please see the logging docs . This feature was introduced by merging the popular pytest-catchlog plugin, thanks to @thisch . Be advised that during the merging the backward compatibility interface with the defunct pytest-capturelog has been dropped. ( #2794 ) Add allow_module_level kwarg to pytest.skip() , enabling to skip the whole module. ( #2808 ) Allow setting file_or_dir , -c , and -o in PYTEST_ADDOPTS. ( #2824 ) Return stdout/stderr capture results as a namedtuple , so out and err can be accessed by attribute. ( #2879 ) Add capfdbinary , a version of capfd which returns bytes from readouterr() . ( #2923 ) Add capsysbinary a version of capsys which returns bytes from readouterr() . ( #2934 ) Implement feature to skip setup.py files when run with --doctest-modules . ( #502 )

# Bug Fixes¶

Resume output capturing after capsys/capfd.disabled() context manager. ( #1993 ) pytest_fixture_setup and pytest_fixture_post_finalizer hooks are now called for all conftest.py files. ( #2124 ) If an exception happens while loading a plugin, pytest no longer hides the original traceback. In Python 2 it will show the original traceback with a new message that explains in which plugin. In Python 3 it will show 2 canonized exceptions, the original exception while loading the plugin in addition to an exception that pytest throws about loading a plugin. ( #2491 ) capsys and capfd can now be used by other fixtures. ( #2709 ) Internal pytester plugin properly encodes bytes arguments to utf-8 . ( #2738 ) testdir now uses use the same method used by tmpdir to create its temporary directory. This changes the final structure of the testdir directory slightly, but should not affect usage in normal scenarios and avoids a number of potential problems. ( #2751 ) pytest no longer complains about warnings with unicode messages being non-ascii compatible even for ascii-compatible messages. As a result of this, warnings with unicode messages are converted first to an ascii representation for safety. ( #2809 ) Change return value of pytest command when --maxfail is reached from 2 (interrupted) to 1 (failed). ( #2845 ) Fix issue in assertion rewriting which could lead it to rewrite modules which should not be rewritten. ( #2939 ) Handle marks without description in pytest.ini . ( #2942 )

# Trivial/Internal Changes¶

pytest now depends on attrs for internal structures to ease code maintainability. ( #2641 ) Refactored internal Python 2/3 compatibility code to use six . ( #2642 ) Stop vendoring pluggy - we’re missing out on its latest changes for not much benefit ( #2719 ) Internal refactor: simplify ascii string escaping by using the backslashreplace error handler in newer Python 3 versions. ( #2734 ) Remove unnecessary mark evaluator in unittest plugin ( #2767 ) Calls to Metafunc.addcall now emit a deprecation warning. This function is scheduled to be removed in pytest-4.0 . ( #2876 ) Internal move of the parameterset extraction to a more maintainable place. ( #2877 ) Internal refactoring to simplify scope node lookup. ( #2910 ) Configure pytest to prevent pip from installing pytest in unsupported Python versions. ( #2922 )

# pytest 3.2.5 (2017-11-15)¶

# Bug Fixes¶

Remove py<1.5 restriction from pytest as this can cause version conflicts in some installations. ( #2926 )

# pytest 3.2.4 (2017-11-13)¶

# Bug Fixes¶

Fix the bug where running with --pyargs will result in items with empty parent.nodeid if run from a different root directory. ( #2775 ) Fix issue with @pytest.parametrize if argnames was specified as keyword arguments. ( #2819 ) Strip whitespace from marker names when reading them from INI config. ( #2856 ) Show full context of doctest source in the pytest output, if the line number of failed example in the docstring is < 9. ( #2882 ) Match fixture paths against actual path segments in order to avoid matching folders which share a prefix. ( #2836 )

# Improved Documentation¶

Introduce a dedicated section about conftest.py. ( #1505 ) Explicitly mention xpass in the documentation of xfail . ( #1997 ) Append example for pytest.param in the example/parametrize document. ( #2658 ) Clarify language of proposal for fixtures parameters ( #2893 ) List python 3.6 in the documented supported versions in the getting started document. ( #2903 ) Clarify the documentation of available fixture scopes. ( #538 ) Add documentation about the python -m pytest invocation adding the current directory to sys.path. ( #911 )

# pytest 3.2.3 (2017-10-03)¶

# Bug Fixes¶

Fix crash in tab completion when no prefix is given. ( #2748 ) The equality checking function ( __eq__ ) of MarkDecorator returns False if one object is not an instance of MarkDecorator . ( #2758 ) When running pytest --fixtures-per-test : don’t crash if an item has no _fixtureinfo attribute (e.g. doctests) ( #2788 )

# Improved Documentation¶

In help text of -k option, add example of using not to not select certain tests whose names match the provided expression. ( #1442 ) Add note in parametrize.rst about calling metafunc.parametrize multiple times. ( #1548 )

# Trivial/Internal Changes¶

Set xfail_strict=True in pytest’s own test suite to catch expected failures as soon as they start to pass. ( #2722 ) Fix typo in example of passing a callable to markers (in example/markers.rst) ( #2765 )

# pytest 3.2.2 (2017-09-06)¶

# Bug Fixes¶

Calling the deprecated request.getfuncargvalue() now shows the source of the call. ( #2681 ) Allow tests declared as @staticmethod to use fixtures. ( #2699 ) Fixed edge-case during collection: attributes which raised pytest.fail when accessed would abort the entire collection. ( #2707 ) Fix ReprFuncArgs with mixed unicode and UTF-8 args. ( #2731 )

# Improved Documentation¶

In examples on working with custom markers, add examples demonstrating the usage of pytest.mark.MARKER_NAME.with_args in comparison with pytest.mark.MARKER_NAME.__call__ ( #2604 ) In one of the simple examples, use pytest_collection_modifyitems() to skip tests based on a command-line option, allowing its sharing while preventing a user error when accessing pytest.config before the argument parsing. ( #2653 )

# Trivial/Internal Changes¶

Fixed minor error in ‘Good Practices/Manual Integration’ code snippet. ( #2691 ) Fixed typo in goodpractices.rst. ( #2721 ) Improve user guidance regarding --resultlog deprecation. ( #2739 )

# pytest 3.2.1 (2017-08-08)¶

# Bug Fixes¶

Fixed small terminal glitch when collecting a single test item. ( #2579 ) Correctly consider / as the file separator to automatically mark plugin files for rewrite on Windows. ( #2591 ) Properly escape test names when setting PYTEST_CURRENT_TEST environment variable. ( #2644 ) Fix error on Windows and Python 3.6+ when sys.stdout has been replaced with a stream-like object which does not implement the full io module buffer protocol. In particular this affects pytest-xdist users on the aforementioned platform. ( #2666 )

# Improved Documentation¶

Explicitly document which pytest features work with unittest . ( #2626 )

# pytest 3.2.0 (2017-07-30)¶

# Deprecations and Removals¶

pytest.approx no longer supports > , >= , < and <= operators to avoid surprising/inconsistent behavior. See the approx() docs for more information. ( #2003 ) All old-style specific behavior in current classes in the pytest’s API is considered deprecated at this point and will be removed in a future release. This affects Python 2 users only and in rare situations. ( #2147 ) A deprecation warning is now raised when using marks for parameters in pytest.mark.parametrize . Use pytest.param to apply marks to parameters instead. ( #2427 )

# Features¶

Add support for numpy arrays (and dicts) to approx. ( #1994 ) Now test function objects have a pytestmark attribute containing a list of marks applied directly to the test function, as opposed to marks inherited from parent classes or modules. ( #2516 ) Collection ignores local virtualenvs by default; --collect-in-virtualenv overrides this behavior. ( #2518 ) Allow class methods decorated as @staticmethod to be candidates for collection as a test function. (Only for Python 2.7 and above. Python 2.6 will still ignore static methods.) ( #2528 ) Introduce mark.with_args in order to allow passing functions/classes as sole argument to marks. ( #2540 ) New cache_dir ini option: sets the directory where the contents of the cache plugin are stored. Directory may be relative or absolute path: if relative path, then directory is created relative to rootdir , otherwise it is used as is. Additionally path may contain environment variables which are expanded during runtime. ( #2543 ) Introduce the PYTEST_CURRENT_TEST environment variable that is set with the nodeid and stage ( setup , call and teardown ) of the test being currently executed. See the documentation for more info. ( #2583 ) Introduced @pytest.mark.filterwarnings mark which allows overwriting the warnings filter on a per test, class or module level. See the docs for more information. ( #2598 ) --last-failed now remembers forever when a test has failed and only forgets it if it passes again. This makes it easy to fix a test suite by selectively running files and fixing tests incrementally. ( #2621 ) New pytest_report_collectionfinish hook which allows plugins to add messages to the terminal reporting after collection has been finished successfully. ( #2622 ) Added support for PEP 415 's Exception.__suppress_context__ . Now if a raise exception from None is caught by pytest, pytest will no longer chain the context in the test report. The behavior now matches Python’s traceback behavior. ( #2631 ) Exceptions raised by pytest.fail , pytest.skip and pytest.xfail now subclass BaseException, making them harder to be caught unintentionally by normal code. ( #580 )

# Bug Fixes¶

Set stdin to a closed PIPE in pytester.py.Testdir.popen() for avoid unwanted interactive pdb ( #2023 ) Add missing encoding attribute to sys.std* streams when using capsys capture mode. ( #2375 ) Fix terminal color changing to black on Windows if colorama is imported in a conftest.py file. ( #2510 ) Fix line number when reporting summary of skipped tests. ( #2548 ) capture: ensure that EncodedFile.name is a string. ( #2555 ) The options --fixtures and --fixtures-per-test will now keep indentation within docstrings. ( #2574 ) doctests line numbers are now reported correctly, fixing pytest-sugar#122 . ( #2610 ) Fix non-determinism in order of fixture collection. Adds new dependency (ordereddict) for Python 2.6. ( #920 )

# Improved Documentation¶

Clarify pytest_configure hook call order. ( #2539 ) Extend documentation for testing plugin code with the pytester plugin. ( #971 )

# Trivial/Internal Changes¶

Update help message for --strict to make it clear it only deals with unregistered markers, not warnings. ( #2444 ) Internal code move: move code for pytest.approx/pytest.raises to own files in order to cut down the size of python.py ( #2489 ) Renamed the utility function _pytest.compat._escape_strings to _ascii_escaped to better communicate the function’s purpose. ( #2533 ) Improve error message for CollectError with skip/skipif. ( #2546 ) Emit warning about yield tests being deprecated only once per generator. ( #2562 ) Ensure final collected line doesn’t include artifacts of previous write. ( #2571 ) Fixed all flake8 errors and warnings. ( #2581 ) Added fix-lint tox environment to run automatic pep8 fixes on the code. ( #2582 ) Turn warnings into errors in pytest’s own test suite in order to catch regressions due to deprecations more promptly. ( #2588 ) Show multiple issue links in CHANGELOG entries. ( #2620 )

# pytest 3.1.3 (2017-07-03)¶

# Bug Fixes¶

Fix decode error in Python 2 for doctests in docstrings. ( #2434 ) Exceptions raised during teardown by finalizers are now suppressed until all finalizers are called, with the initial exception reraised. ( #2440 ) Fix incorrect “collected items” report when specifying tests on the command- line. ( #2464 ) deprecated_call in context-manager form now captures deprecation warnings even if the same warning has already been raised. Also, deprecated_call will always produce the same error message (previously it would produce different messages in context-manager vs. function-call mode). ( #2469 ) Fix issue where paths collected by pytest could have triple leading / characters. ( #2475 ) Fix internal error when trying to detect the start of a recursive traceback. ( #2486 )

# Improved Documentation¶

Explicitly state for which hooks the calls stop after the first non-None result. ( #2493 )

# Trivial/Internal Changes¶

Create invoke tasks for updating the vendored packages. ( #2474 ) Update copyright dates in LICENSE, README.rst and in the documentation. ( #2499 )

# pytest 3.1.2 (2017-06-08)¶

# Bug Fixes¶

Required options added via pytest_addoption will no longer prevent using –help without passing them. (#1999) Respect python_files in assertion rewriting. (#2121) Fix recursion error detection when frames in the traceback contain objects that can’t be compared (like numpy arrays). (#2459) UnicodeWarning is issued from the internal pytest warnings plugin only when the message contains non-ascii unicode (Python 2 only). (#2463) Added a workaround for Python 3.6 WindowsConsoleIO breaking due to Pytests’s FDCapture . Other code using console handles might still be affected by the very same issue and might require further workarounds/fixes, i.e. colorama . (#2467)

# Improved Documentation¶

Fix internal API links to pluggy objects. (#2331) Make it clear that pytest.xfail stops test execution at the calling point and improve overall flow of the skipping docs. (#810)

# pytest 3.1.1 (2017-05-30)¶

# Bug Fixes¶

pytest warning capture no longer overrides existing warning filters. The previous behaviour would override all filters and caused regressions in test suites which configure warning filters to match their needs. Note that as a side-effect of this is that DeprecationWarning and PendingDeprecationWarning are no longer shown by default. (#2430) Fix issue with non-ascii contents in doctest text files. (#2434) Fix encoding errors for unicode warnings in Python 2. (#2436) pytest.deprecated_call now captures PendingDeprecationWarning in context manager form. (#2441)

# Improved Documentation¶

Addition of towncrier for changelog management. (#2390)

# 3.1.0 (2017-05-22)¶

# New Features¶

The pytest-warnings plugin has been integrated into the core and now pytest automatically captures and displays warnings at the end of the test session. Warning This feature may disrupt test suites which apply and treat warnings themselves, and can be disabled in your pytest.ini :

```

[pytest]
addopts
=
-p no:warnings

```

See the warnings documentation page for more information. Thanks @nicoddemus for the PR. Added junit_suite_name ini option to specify root <testsuite> name for JUnit XML reports ( #533 ). Added an ini option doctest_encoding to specify which encoding to use for doctest files. Thanks @wheerd for the PR ( #2101 ). pytest.warns now checks for subclass relationship rather than class equality. Thanks @lesteve for the PR ( #2166 ) pytest.raises now asserts that the error message matches a text or regex with the match keyword argument. Thanks @Kriechi for the PR. pytest.param can be used to declare test parameter sets with marks and test ids. Thanks @RonnyPfannschmidt for the PR.

# Changes¶

remove all internal uses of pytest_namespace hooks, this is to prepare the removal of preloadconfig in pytest 4.0 Thanks to @RonnyPfannschmidt for the PR. pytest now warns when a callable ids raises in a parametrized test. Thanks @fogo for the PR. It is now possible to skip test classes from being collected by setting a __test__ attribute to False in the class body ( #2007 ). Thanks to @syre for the report and @lwm for the PR. Change junitxml.py to produce reports that comply with Junitxml schema. If the same test fails with failure in call and then errors in teardown we split testcase element into two, one containing the error and the other the failure. ( #2228 ) Thanks to @kkoukiou for the PR. Testcase reports with a url attribute will now properly write this to junitxml. Thanks @fushi for the PR ( #1874 ). Remove common items from dict comparison output when verbosity=1. Also update the truncation message to make it clearer that pytest truncates all assertion messages if verbosity < 2 ( #1512 ). Thanks @mattduck for the PR --pdbcls no longer implies --pdb . This makes it possible to use addopts=--pdbcls=module.SomeClass on pytest.ini . Thanks @davidszotten for the PR ( #1952 ). fix #2013 : turn RecordedWarning into namedtuple , to give it a comprehensible repr while preventing unwarranted modification. fix #2208 : ensure an iteration limit for _pytest.compat.get_real_func . Thanks @RonnyPfannschmidt for the report and PR. Hooks are now verified after collection is complete, rather than right after loading installed plugins. This makes it easy to write hooks for plugins which will be loaded during collection, for example using the pytest_plugins special variable ( #1821 ). Thanks @nicoddemus for the PR. Modify pytest_make_parametrize_id() hook to accept argname as an additional parameter. Thanks @unsignedint for the PR. Add venv to the default norecursedirs setting. Thanks @The-Compiler for the PR. PluginManager.import_plugin now accepts unicode plugin names in Python 2. Thanks @reutsharabani for the PR. fix #2308 : When using both --lf and --ff , only the last failed tests are run. Thanks @ojii for the PR. Replace minor/patch level version numbers in the documentation with placeholders. This significantly reduces change-noise as different contributors regenerate the documentation on different platforms. Thanks @RonnyPfannschmidt for the PR. fix #2391 : consider pytest_plugins on all plugin modules Thanks @RonnyPfannschmidt for the PR.

# Bug Fixes¶

Fix AttributeError on sys.stdout.buffer / sys.stderr.buffer while using capsys fixture in python 3. ( #1407 ). Thanks to @asottile . Change capture.py’s DontReadFromInput class to throw io.UnsupportedOperation errors rather than ValueErrors in the fileno method ( #2276 ). Thanks @metasyn and @vlad-dragos for the PR. Fix exception formatting while importing modules when the exception message contains non-ascii characters ( #2336 ). Thanks @fabioz for the report and @nicoddemus for the PR. Added documentation related to issue ( #1937 ) Thanks @skylarjhdownes for the PR. Allow collecting files with any file extension as Python modules ( #2369 ). Thanks @Kodiologist for the PR. Show the correct error message when collect “parametrize” func with wrong args ( #2383 ). Thanks @The-Compiler for the report and @robin0371 for the PR.

# 3.0.7 (2017-03-14)¶

Fix issue in assertion rewriting breaking due to modules silently discarding other modules when importing fails Notably, importing the anydbm module is fixed. ( #2248 ). Thanks @pfhayes for the PR. junitxml: Fix problematic case where system-out tag occurred twice per testcase element in the XML report. Thanks @kkoukiou for the PR. Fix regression, pytest now skips unittest correctly if run with --pdb ( #2137 ). Thanks to @gst for the report and @mbyt for the PR. Ignore exceptions raised from descriptors (e.g. properties) during Python test collection ( #2234 ). Thanks to @bluetech . --override-ini now correctly overrides some fundamental options like python_files ( #2238 ). Thanks @sirex for the report and @nicoddemus for the PR. Replace raise StopIteration usages in the code by simple returns to finish generators, in accordance to PEP 479 ( #2160 ). Thanks to @nicoddemus for the PR. Fix internal errors when an unprintable AssertionError is raised inside a test. Thanks @omerhadari for the PR. Skipping plugin now also works with test items generated by custom collectors ( #2231 ). Thanks to @vidartf . Fix trailing whitespace in console output if no .ini file presented ( #2281 ). Thanks @fbjorn for the PR. Conditionless xfail markers no longer rely on the underlying test item being an instance of PyobjMixin , and can therefore apply to tests not collected by the built-in python test collector. Thanks @barneygale for the PR.

# 3.0.6 (2017-01-22)¶

pytest no longer generates PendingDeprecationWarning from its own operations, which was introduced by mistake in version 3.0.5 ( #2118 ). Thanks to @nicoddemus for the report and @RonnyPfannschmidt for the PR. pytest no longer recognizes coroutine functions as yield tests ( #2129 ). Thanks to @malinoff for the PR. Plugins loaded by the PYTEST_PLUGINS environment variable are now automatically considered for assertion rewriting ( #2185 ). Thanks @nicoddemus for the PR. Improve error message when pytest.warns fails ( #2150 ). The type(s) of the expected warnings and the list of caught warnings is added to the error message. Thanks @lesteve for the PR. Fix pytester internal plugin to work correctly with latest versions of zope.interface ( #1989 ). Thanks @nicoddemus for the PR. Assert statements of the pytester plugin again benefit from assertion rewriting ( #1920 ). Thanks @RonnyPfannschmidt for the report and @nicoddemus for the PR. Specifying tests with colons like test_foo.py::test_bar for tests in subdirectories with ini configuration files now uses the correct ini file ( #2148 ). Thanks @pelme . Fail testdir.runpytest().assert_outcomes() explicitly if the pytest terminal output it relies on is missing. Thanks to @eli-b for the PR.

# 3.0.5 (2016-12-05)¶

Add warning when not passing option=value correctly to -o/--override-ini ( #2105 ). Also improved the help documentation. Thanks to @mbukatov for the report and @lwm for the PR. Now --confcutdir and --junit-xml are properly validated if they are directories and filenames, respectively ( #2089 and #2078 ). Thanks to @lwm for the PR. Add hint to error message hinting possible missing __init__.py ( #478 ). Thanks @DuncanBetts . More accurately describe when fixture finalization occurs in documentation ( #687 ). Thanks @DuncanBetts . Provide :ref: targets for recwarn.rst so we can use intersphinx referencing. Thanks to @dupuy for the report and @lwm for the PR. In Python 2, use a simple +- ASCII string in the string representation of pytest.approx (for example "4 +- 4.0e-06" ) because it is brittle to handle that in different contexts and representations internally in pytest which can result in bugs such as #2111 . In Python 3, the representation still uses ± (for example 4 ± 4.0e-06 ). Thanks @kerrick-lyft for the report and @nicoddemus for the PR. Using item.Function , item.Module , etc., is now issuing deprecation warnings, prefer pytest.Function , pytest.Module , etc., instead ( #2034 ). Thanks @nmundar for the PR. Fix error message using approx with complex numbers ( #2082 ). Thanks @adler-j for the report and @nicoddemus for the PR. Fixed false-positives warnings from assertion rewrite hook for modules imported more than once by the pytest_plugins mechanism. Thanks @nicoddemus for the PR. Remove an internal cache which could cause hooks from conftest.py files in sub-directories to be called in other directories incorrectly ( #2016 ). Thanks @d-b-w for the report and @nicoddemus for the PR. Remove internal code meant to support earlier Python 3 versions that produced the side effect of leaving None in sys.modules when expressions were evaluated by pytest (for example passing a condition as a string to pytest.mark.skipif )( #2103 ). Thanks @jaraco for the report and @nicoddemus for the PR. Cope gracefully with a .pyc file with no matching .py file ( #2038 ). Thanks @nedbat .

# 3.0.4 (2016-11-09)¶

Import errors when collecting test modules now display the full traceback ( #1976 ). Thanks @cwitty for the report and @nicoddemus for the PR. Fix confusing command-line help message for custom options with two or more metavar properties ( #2004 ). Thanks @okulynyak and @davehunt for the report and @nicoddemus for the PR. When loading plugins, import errors which contain non-ascii messages are now properly handled in Python 2 ( #1998 ). Thanks @nicoddemus for the PR. Fixed cyclic reference when pytest.raises is used in context-manager form ( #1965 ). Also as a result of this fix, sys.exc_info() is left empty in both context-manager and function call usages. Previously, sys.exc_info would contain the exception caught by the context manager, even when the expected exception occurred. Thanks @MSeifert04 for the report and the PR. Fixed false-positives warnings from assertion rewrite hook for modules that were rewritten but were later marked explicitly by pytest.register_assert_rewrite or implicitly as a plugin ( #2005 ). Thanks @RonnyPfannschmidt for the report and @nicoddemus for the PR. Report teardown output on test failure ( #442 ). Thanks @matclab for the PR. Fix teardown error message in generated xUnit XML. Thanks @gdyuldin for the PR. Properly handle exceptions in multiprocessing tasks ( #1984 ). Thanks @adborden for the report and @nicoddemus for the PR. Clean up unittest TestCase objects after tests are complete ( #1649 ). Thanks @d-b-w for the report and PR.

# 3.0.3 (2016-09-28)¶

The ids argument to parametrize again accepts unicode strings in Python 2 ( #1905 ). Thanks @philpep for the report and @nicoddemus for the PR. Assertions are now being rewritten for plugins in development mode ( pip install -e ) ( #1934 ). Thanks @nicoddemus for the PR. Fix pkg_resources import error in Jython projects ( #1853 ). Thanks @raquelalegre for the PR. Got rid of AttributeError: 'Module' object has no attribute '_obj' exception in Python 3 ( #1944 ). Thanks @axil for the PR. Explain a bad scope value passed to @fixture declarations or a MetaFunc.parametrize() call. This version includes pluggy-0.4.0 , which correctly handles VersionConflict errors in plugins ( #704 ). Thanks @nicoddemus for the PR.

# 3.0.2 (2016-09-01)¶

Improve error message when passing non-string ids to pytest.mark.parametrize ( #1857 ). Thanks @okken for the report and @nicoddemus for the PR. Add buffer attribute to stdin stub class pytest.capture.DontReadFromInput Thanks @joguSD for the PR. Fix UnicodeEncodeError when string comparison with unicode has failed. ( #1864 ) Thanks @AiOO for the PR. pytest_plugins is now handled correctly if defined as a string (as opposed as a sequence of strings) when modules are considered for assertion rewriting. Due to this bug, much more modules were being rewritten than necessary if a test suite uses pytest_plugins to load internal plugins ( #1888 ). Thanks @jaraco for the report and @nicoddemus for the PR ( #1891 ). Do not call tearDown and cleanups when running tests from unittest.TestCase subclasses with --pdb enabled. This allows proper post mortem debugging for all applications which have significant logic in their tearDown machinery ( #1890 ). Thanks @mbyt for the PR. Fix use of deprecated getfuncargvalue method in the internal doctest plugin. Thanks @ViviCoder for the report ( #1898 ).

# 3.0.1 (2016-08-23)¶

Fix regression when importorskip is used at module level ( #1822 ). Thanks @jaraco and @The-Compiler for the report and @nicoddemus for the PR. Fix parametrization scope when session fixtures are used in conjunction with normal parameters in the same call ( #1832 ). Thanks @The-Compiler for the report, @Kingdread and @nicoddemus for the PR. Fix internal error when parametrizing tests or fixtures using an empty ids argument ( #1849 ). Thanks @OPpuolitaival for the report and @nicoddemus for the PR. Fix loader error when running pytest embedded in a zipfile. Thanks @mbachry for the PR.

# 3.0.0 (2016-08-18)¶

Incompatible changes A number of incompatible changes were made in this release, with the intent of removing features deprecated for a long time or change existing behaviors in order to make them less surprising/more useful. Reinterpretation mode has now been removed. Only plain and rewrite mode are available, consequently the --assert=reinterp option is no longer available. This also means files imported from plugins or conftest.py will not benefit from improved assertions by default, you should use pytest.register_assert_rewrite() to explicitly turn on assertion rewriting for those files. Thanks @flub for the PR. The following deprecated commandline options were removed: --genscript : no longer supported; --no-assert : use --assert=plain instead; --nomagic : use --assert=plain instead; --report : use -r instead; Thanks to @RedBeardCode for the PR ( #1664 ). ImportErrors in plugins now are a fatal error instead of issuing a pytest warning ( #1479 ). Thanks to @The-Compiler for the PR. Removed support code for Python 3 versions < 3.3 ( #1627 ). Removed all py.test-X* entry points. The versioned, suffixed entry points were never documented and a leftover from a pre-virtualenv era. These entry points also created broken entry points in wheels, so removing them also removes a source of confusion for users ( #1632 ). Thanks @obestwalter for the PR. pytest.skip() now raises an error when used to decorate a test function, as opposed to its original intent (to imperatively skip a test inside a test function). Previously this usage would cause the entire module to be skipped ( #607 ). Thanks @omarkohl for the complete PR ( #1519 ). Exit tests if a collection error occurs. A poll indicated most users will hit CTRL-C anyway as soon as they see collection errors, so pytest might as well make that the default behavior ( #1421 ). A --continue-on-collection-errors option has been added to restore the previous behaviour. Thanks @olegpidsadnyi and @omarkohl for the complete PR ( #1628 ). Renamed the pytest pdb module (plugin) into debugging to avoid clashes with the builtin pdb module. Raise a helpful failure message when requesting a parametrized fixture at runtime, e.g. with request.getfixturevalue . Previously these parameters were simply never defined, so a fixture decorated like @pytest.fixture(params=[0, 1, 2]) only ran once ( #460 ). Thanks to @nikratio for the bug report, @RedBeardCode and @tomviner for the PR. _pytest.monkeypatch.monkeypatch class has been renamed to _pytest.monkeypatch.MonkeyPatch so it doesn’t conflict with the monkeypatch fixture. --exitfirst / -x can now be overridden by a following --maxfail=N and is just a synonym for --maxfail=1 . New Features Support nose-style __test__ attribute on methods of classes, including unittest-style Classes. If set to False , the test will not be collected. New doctest_namespace fixture for injecting names into the namespace in which doctests run. Thanks @milliams for the complete PR ( #1428 ). New --doctest-report option available to change the output format of diffs when running (failing) doctests (implements #1749 ). Thanks @hartym for the PR. New name argument to pytest.fixture decorator which allows a custom name for a fixture (to solve the funcarg-shadowing-fixture problem). Thanks @novas0x2a for the complete PR ( #1444 ). New approx() function for easily comparing floating-point numbers in tests. Thanks @kalekundert for the complete PR ( #1441 ). Ability to add global properties in the final xunit output file by accessing the internal junitxml plugin (experimental). Thanks @tareqalayan for the complete PR #1454 ). New ExceptionInfo.match() method to match a regular expression on the string representation of an exception ( #372 ). Thanks @omarkohl for the complete PR ( #1502 ). __tracebackhide__ can now also be set to a callable which then can decide whether to filter the traceback based on the ExceptionInfo object passed to it. Thanks @The-Compiler for the complete PR ( #1526 ). New pytest_make_parametrize_id(config, val) hook which can be used by plugins to provide friendly strings for custom types. Thanks @palaviv for the PR. capsys and capfd now have a disabled() context-manager method, which can be used to temporarily disable capture within a test. Thanks @nicoddemus for the PR. New cli flag --fixtures-per-test : shows which fixtures are being used for each selected test item. Features doc strings of fixtures by default. Can also show where fixtures are defined if combined with -v . Thanks @hackebrot for the PR. Introduce pytest command as recommended entry point. Note that py.test still works and is not scheduled for removal. Closes proposal #1629 . Thanks @obestwalter and @davehunt for the complete PR ( #1633 ). New cli flags: --setup-plan : performs normal collection and reports the potential setup and teardown and does not execute any fixtures and tests; --setup-only : performs normal collection, executes setup and teardown of fixtures and reports them; --setup-show : performs normal test execution and additionally shows setup and teardown of fixtures; --keep-duplicates : py.test now ignores duplicated paths given in the command line. To retain the previous behavior where the same test could be run multiple times by specifying it in the command-line multiple times, pass the --keep-duplicates argument ( #1609 ); Thanks @d6e , @kvas-it , @sallner , @ioggstream and @omarkohl for the PRs. New CLI flag --override-ini / -o : overrides values from the ini file. For example: "-o xfail_strict=True" ’. Thanks @blueyed and @fengxx for the PR. New hooks: pytest_fixture_setup(fixturedef, request) : executes fixture setup; pytest_fixture_post_finalizer(fixturedef) : called after the fixture’s finalizer and has access to the fixture’s result cache. Thanks @d6e , @sallner . Issue warnings for asserts whose test is a tuple literal. Such asserts will never fail because tuples are always truthy and are usually a mistake (see #1562 ). Thanks @kvas-it , for the PR. Allow passing a custom debugger class (e.g. --pdbcls=IPython.core.debugger:Pdb ). Thanks to @anntzer for the PR. Changes Plugins now benefit from assertion rewriting. Thanks @sober7 , @nicoddemus and @flub for the PR. Change report.outcome for xpassed tests to "passed" in non-strict mode and "failed" in strict mode. Thanks to @hackebrot for the PR ( #1795 ) and @gprasad84 for report ( #1546 ). Tests marked with xfail(strict=False) (the default) now appear in JUnitXML reports as passing tests instead of skipped. Thanks to @hackebrot for the PR ( #1795 ). Highlight path of the file location in the error report to make it easier to copy/paste. Thanks @suzaku for the PR ( #1778 ). Fixtures marked with @pytest.fixture can now use yield statements exactly like those marked with the @pytest.yield_fixture decorator. This change renders @pytest.yield_fixture deprecated and makes @pytest.fixture with yield statements the preferred way to write teardown code ( #1461 ). Thanks @csaftoiu for bringing this to attention and @nicoddemus for the PR. Explicitly passed parametrize ids do not get escaped to ascii ( #1351 ). Thanks @ceridwen for the PR. Fixtures are now sorted in the error message displayed when an unknown fixture is declared in a test function. Thanks @nicoddemus for the PR. pytest_terminal_summary hook now receives the exitstatus of the test session as argument. Thanks @blueyed for the PR ( #1809 ). Parametrize ids can accept None as specific test id, in which case the automatically generated id for that argument will be used. Thanks @palaviv for the complete PR ( #1468 ). The parameter to xunit-style setup/teardown methods ( setup_method , setup_module , etc.) is now optional and may be omitted. Thanks @okken for bringing this to attention and @nicoddemus for the PR. Improved automatic id generation selection in case of duplicate ids in parametrize. Thanks @palaviv for the complete PR ( #1474 ). Now pytest warnings summary is shown up by default. Added a new flag --disable-pytest-warnings to explicitly disable the warnings summary ( #1668 ). Make ImportError during collection more explicit by reminding the user to check the name of the test module/package(s) ( #1426 ). Thanks @omarkohl for the complete PR ( #1520 ). Add build/ and dist/ to the default --norecursedirs list. Thanks @mikofski for the report and @tomviner for the PR ( #1544 ). pytest.raises in the context manager form accepts a custom message to raise when no exception occurred. Thanks @palaviv for the complete PR ( #1616 ). conftest.py files now benefit from assertion rewriting; previously it was only available for test modules. Thanks @flub , @sober7 and @nicoddemus for the PR ( #1619 ). Text documents without any doctests no longer appear as “skipped”. Thanks @graingert for reporting and providing a full PR ( #1580 ). Ensure that a module within a namespace package can be found when it is specified on the command line together with the --pyargs option. Thanks to @taschini for the PR ( #1597 ). Always include full assertion explanation during assertion rewriting. The previous behaviour was hiding sub-expressions that happened to be False , assuming this was redundant information. Thanks @bagerard for reporting ( #1503 ). Thanks to @davehunt and @tomviner for the PR. OptionGroup.addoption() now checks if option names were already added before, to make it easier to track down issues like #1618 . Before, you only got exceptions later from argparse library, giving no clue about the actual reason for double-added options. yield -based tests are considered deprecated and will be removed in pytest-4.0. Thanks @nicoddemus for the PR. [pytest] sections in setup.cfg files should now be named [tool:pytest] to avoid conflicts with other distutils commands (see #567 ). [pytest] sections in pytest.ini or tox.ini files are supported and unchanged. Thanks @nicoddemus for the PR. Using pytest_funcarg__ prefix to declare fixtures is considered deprecated and will be removed in pytest-4.0 ( #1684 ). Thanks @nicoddemus for the PR. Passing a command-line string to pytest.main() is considered deprecated and scheduled for removal in pytest-4.0. It is recommended to pass a list of arguments instead ( #1723 ). Rename getfuncargvalue to getfixturevalue . getfuncargvalue is still present but is now considered deprecated. Thanks to @RedBeardCode and @tomviner for the PR ( #1626 ). optparse type usage now triggers DeprecationWarnings ( #1740 ). optparse backward compatibility supports float/complex types ( #457 ). Refined logic for determining the rootdir , considering only valid paths which fixes a number of issues: #1594 , #1435 and #1471 . Updated the documentation according to current behavior. Thanks to @blueyed , @davehunt and @matthiasha for the PR. Always include full assertion explanation. The previous behaviour was hiding sub-expressions that happened to be False, assuming this was redundant information. Thanks @bagerard for reporting ( #1503 ). Thanks to @davehunt and @tomviner for PR. Better message in case of not using parametrized variable (see #1539 ). Thanks to @tramwaj29 for the PR. Updated docstrings with a more uniform style. Add stderr write for pytest.exit(msg) during startup. Previously the message was never shown. Thanks @BeyondEvil for reporting #1210 . Thanks to @jgsonesen and @tomviner for the PR. No longer display the incorrect test deselection reason ( #1372 ). Thanks @ronnypfannschmidt for the PR. The --resultlog command line option has been deprecated: it is little used and there are more modern and better alternatives (see #830 ). Thanks @nicoddemus for the PR. Improve error message with fixture lookup errors: add an ‘E’ to the first line and ‘>’ to the rest. Fixes #717 . Thanks @blueyed for reporting and a PR, @eolo999 for the initial PR and @tomviner for his guidance during EuroPython2016 sprint. Bug Fixes Parametrize now correctly handles duplicated test ids. Fix internal error issue when the method argument is missing for teardown_method() ( #1605 ). Fix exception visualization in case the current working directory (CWD) gets deleted during testing ( #1235 ). Thanks @bukzor for reporting. PR by @marscher . Improve test output for logical expression with brackets ( #925 ). Thanks @DRMacIver for reporting and @RedBeardCode for the PR. Create correct diff for strings ending with newlines ( #1553 ). Thanks @Vogtinator for reporting and @RedBeardCode and @tomviner for the PR. ConftestImportFailure now shows the traceback making it easier to identify bugs in conftest.py files ( #1516 ). Thanks @txomon for the PR. Text documents without any doctests no longer appear as “skipped”. Thanks @graingert for reporting and providing a full PR ( #1580 ). Fixed collection of classes with custom __new__ method. Fixes #1579 . Thanks to @Stranger6667 for the PR. Fixed scope overriding inside metafunc.parametrize ( #634 ). Thanks to @Stranger6667 for the PR. Fixed the total tests tally in junit xml output ( #1798 ). Thanks to @cboelsen for the PR. Fixed off-by-one error with lines from request.node.warn . Thanks to @blueyed for the PR.

# 2.9.2 (2016-05-31)¶

Bug Fixes fix #510 : skip tests where one parameterize dimension was empty thanks Alex Stapleton for the Report and @RonnyPfannschmidt for the PR Fix Xfail does not work with condition keyword argument. Thanks @astraw38 for reporting the issue ( #1496 ) and @tomviner for PR the ( #1524 ). Fix win32 path issue when putting custom config file with absolute path in pytest.main("-c your_absolute_path") . Fix maximum recursion depth detection when raised error class is not aware of unicode/encoded bytes. Thanks @prusse-martin for the PR ( #1506 ). Fix pytest.mark.skip mark when used in strict mode. Thanks @pquentin for the PR and @RonnyPfannschmidt for showing how to fix the bug. Minor improvements and fixes to the documentation. Thanks @omarkohl for the PR. Fix --fixtures to show all fixture definitions as opposed to just one per fixture name. Thanks to @hackebrot for the PR.

# 2.9.1 (2016-03-17)¶

Bug Fixes Improve error message when a plugin fails to load. Thanks @nicoddemus for the PR. Fix ( #1178 ): pytest.fail with non-ascii characters raises an internal pytest error. Thanks @nicoddemus for the PR. Fix ( #469 ): junit parses report.nodeid incorrectly, when params IDs contain :: . Thanks @tomviner for the PR ( #1431 ). Fix ( #578 ): SyntaxErrors containing non-ascii lines at the point of failure generated an internal py.test error. Thanks @asottile for the report and @nicoddemus for the PR. Fix ( #1437 ): When passing in a bytestring regex pattern to parameterize attempt to decode it as utf-8 ignoring errors. Fix ( #649 ): parametrized test nodes cannot be specified to run on the command line. Fix ( #138 ): better reporting for python 3.3+ chained exceptions

# 2.9.0 (2016-02-29)¶

New Features New pytest.mark.skip mark, which unconditionally skips marked tests. Thanks @MichaelAquilina for the complete PR ( #1040 ). --doctest-glob may now be passed multiple times in the command-line. Thanks @jab and @nicoddemus for the PR. New -rp and -rP reporting options give the summary and full output of passing tests, respectively. Thanks to @codewarrior0 for the PR. pytest.mark.xfail now has a strict option, which makes XPASS tests to fail the test suite (defaulting to False ). There’s also a xfail_strict ini option that can be used to configure it project-wise. Thanks @rabbbit for the request and @nicoddemus for the PR ( #1355 ). Parser.addini now supports options of type bool . Thanks @nicoddemus for the PR. New ALLOW_BYTES doctest option. This strips b prefixes from byte strings in doctest output (similar to ALLOW_UNICODE ). Thanks @jaraco for the request and @nicoddemus for the PR ( #1287 ). Give a hint on KeyboardInterrupt to use the --fulltrace option to show the errors. Fixes #1366 . Thanks to @hpk42 for the report and @RonnyPfannschmidt for the PR. Catch IndexError exceptions when getting exception source location. Fixes a pytest internal error for dynamically generated code (fixtures and tests) where source lines are fake by intention. Changes Important : py.code has been merged into the pytest repository as pytest._code . This decision was made because py.code had very few uses outside pytest and the fact that it was in a different repository made it difficult to fix bugs on its code in a timely manner. The team hopes with this to be able to better refactor out and improve that code. This change shouldn’t affect users, but it is useful to let users aware if they encounter any strange behavior. Keep in mind that the code for pytest._code is private and experimental , so you definitely should not import it explicitly! Please note that the original py.code is still available in pylib . pytest_enter_pdb now optionally receives the pytest config object. Thanks @nicoddemus for the PR. Removed code and documentation for Python 2.5 or lower versions, including removal of the obsolete _pytest.assertion.oldinterpret module. Thanks @nicoddemus for the PR ( #1226 ). Comparisons now always show up in full when CI or BUILD_NUMBER is found in the environment, even when -vv isn’t used. Thanks @The-Compiler for the PR. --lf and --ff now support long names: --last-failed and --failed-first respectively. Thanks @MichaelAquilina for the PR. Added expected exceptions to pytest.raises fail message. Collection only displays progress (“collecting X items”) when in a terminal. This avoids cluttering the output when using --color=yes to obtain colors in CI integrations systems ( #1397 ). Bug Fixes The -s and -c options should now work under xdist ; Config.fromdictargs now represents its input much more faithfully. Thanks to @bukzor for the complete PR ( #680 ). Fix ( #1290 ): support Python 3.5’s @ operator in assertion rewriting. Thanks @Shinkenjoe for report with test case and @tomviner for the PR. Fix formatting utf-8 explanation messages ( #1379 ). Thanks @biern for the PR. Fix traceback style docs to describe all of the available options (auto/long/short/line/native/no), with auto being the default since v2.6. Thanks @hackebrot for the PR. Fix ( #1422 ): junit record_xml_property doesn’t allow multiple records with same name.

# 2.8.7 (2016-01-24)¶

fix #1338: use predictable object resolution for monkeypatch

# 2.8.6 (2016-01-21)¶

fix #1259: allow for double nodeids in junitxml, this was a regression failing plugins combinations like pytest-pep8 + pytest-flakes Workaround for exception that occurs in pyreadline when using --pdb with standard I/O capture enabled. Thanks Erik M. Bray for the PR. fix #900: Better error message in case the target of a monkeypatch call raises an ImportError . fix #1292: monkeypatch calls (setattr, setenv, etc.) are now O(1). Thanks David R. MacIver for the report and Bruno Oliveira for the PR. fix #1223: captured stdout and stderr are now properly displayed before entering pdb when --pdb is used instead of being thrown away. Thanks Cal Leeming for the PR. fix #1305: pytest warnings emitted during pytest_terminal_summary are now properly displayed. Thanks Ionel Maries Cristian for the report and Bruno Oliveira for the PR. fix #628: fixed internal UnicodeDecodeError when doctests contain unicode. Thanks Jason R. Coombs for the report and Bruno Oliveira for the PR. fix #1334: Add captured stdout to jUnit XML report on setup error. Thanks Georgy Dyuldin for the PR.

# 2.8.5 (2015-12-11)¶

fix #1243: fixed issue where class attributes injected during collection could break pytest. PR by Alexei Kozlenok, thanks Ronny Pfannschmidt and Bruno Oliveira for the review and help. fix #1074: precompute junitxml chunks instead of storing the whole tree in objects Thanks Bruno Oliveira for the report and Ronny Pfannschmidt for the PR fix #1238: fix pytest.deprecated_call() receiving multiple arguments (Regression introduced in 2.8.4). Thanks Alex Gaynor for the report and Bruno Oliveira for the PR.

# 2.8.4 (2015-12-06)¶

fix #1190: deprecated_call() now works when the deprecated function has been already called by another test in the same module. Thanks Mikhail Chernykh for the report and Bruno Oliveira for the PR. fix #1198: --pastebin option now works on Python 3. Thanks Mehdy Khoshnoody for the PR. fix #1219: --pastebin now works correctly when captured output contains non-ascii characters. Thanks Bruno Oliveira for the PR. fix #1204: another error when collecting with a nasty __getattr__(). Thanks Florian Bruhin for the PR. fix the summary printed when no tests did run. Thanks Florian Bruhin for the PR. fix #1185 - ensure MANIFEST.in exactly matches what should go to a sdist a number of documentation modernizations wrt good practices. Thanks Bruno Oliveira for the PR.

# 2.8.3 (2015-11-18)¶

fix #1169: add __name__ attribute to testcases in TestCaseFunction to support the @unittest.skip decorator on functions and methods. Thanks Lee Kamentsky for the PR. fix #1035: collecting tests if test module level obj has __getattr__(). Thanks Suor for the report and Bruno Oliveira / Tom Viner for the PR. fix #331: don’t collect tests if their failure cannot be reported correctly e.g. they are a callable instance of a class. fix #1133: fixed internal error when filtering tracebacks where one entry belongs to a file which is no longer available. Thanks Bruno Oliveira for the PR. enhancement made to highlight in red the name of the failing tests so they stand out in the output. Thanks Gabriel Reis for the PR. add more talks to the documentation extend documentation on the –ignore cli option use pytest-runner for setuptools integration minor fixes for interaction with OS X El Capitan system integrity protection (thanks Florian)

# 2.8.2 (2015-10-07)¶

fix #1085: proper handling of encoding errors when passing encoded byte strings to pytest.parametrize in Python 2. Thanks Themanwithoutaplan for the report and Bruno Oliveira for the PR. fix #1087: handling SystemError when passing empty byte strings to pytest.parametrize in Python 3. Thanks Paul Kehrer for the report and Bruno Oliveira for the PR. fix #995: fixed internal error when filtering tracebacks where one entry was generated by an exec() statement. Thanks Daniel Hahler, Ashley C Straw, Philippe Gauthier and Pavel Savchenko for contributing and Bruno Oliveira for the PR. fix #1100 and #1057: errors when using autouse fixtures and doctest modules. Thanks Sergey B Kirpichev and Vital Kudzelka for contributing and Bruno Oliveira for the PR.

# 2.8.1 (2015-09-29)¶

fix #1034: Add missing nodeid on pytest_logwarning call in addhook. Thanks Simon Gomizelj for the PR. ‘deprecated_call’ is now only satisfied with a DeprecationWarning or PendingDeprecationWarning. Before 2.8.0, it accepted any warning, and 2.8.0 made it accept only DeprecationWarning (but not PendingDeprecationWarning). Thanks Alex Gaynor for the issue and Eric Hunsberger for the PR. fix issue #1073: avoid calling __getattr__ on potential plugin objects. This fixes an incompatibility with pytest-django. Thanks Andreas Pelme, Bruno Oliveira and Ronny Pfannschmidt for contributing and Holger Krekel for the fix. Fix issue #704: handle versionconflict during plugin loading more gracefully. Thanks Bruno Oliveira for the PR. Fix issue #1064: “”–junitxml” regression when used with the “pytest-xdist” plugin, with test reports being assigned to the wrong tests. Thanks Daniel Grunwald for the report and Bruno Oliveira for the PR. (experimental) adapt more SEMVER style versioning and change meaning of master branch in git repo: “master” branch now keeps the bug fixes, changes aimed for micro releases. “features” branch will only be released with minor or major pytest releases. Fix issue #766 by removing documentation references to distutils. Thanks Russel Winder. Fix issue #1030: now byte-strings are escaped to produce item node ids to make them always serializable. Thanks Andy Freeland for the report and Bruno Oliveira for the PR. Python 2: if unicode parametrized values are convertible to ascii, their ascii representation is used for the node id. Fix issue #411: Add __eq__ method to assertion comparison example. Thanks Ben Webb. Fix issue #653: deprecated_call can be used as context manager. fix issue 877: properly handle assertion explanations with non-ascii repr Thanks Mathieu Agopian for the report and Ronny Pfannschmidt for the PR. fix issue 1029: transform errors when writing cache values into pytest-warnings

# 2.8.0 (2015-09-18)¶

new --lf and -ff options to run only the last failing tests or “failing tests first” from the last run. This functionality is provided through porting the formerly external pytest-cache plugin into pytest core. BACKWARD INCOMPAT: if you used pytest-cache’s functionality to persist data between test runs be aware that we don’t serialize sets anymore. Thanks Ronny Pfannschmidt for most of the merging work. “-r” option now accepts “a” to include all possible reports, similar to passing “fEsxXw” explicitly (issue960). Thanks Abhijeet Kasurde for the PR. avoid python3.5 deprecation warnings by introducing version specific inspection helpers, thanks Michael Droettboom. fix issue562: @nose.tools.istest now fully respected. fix issue934: when string comparison fails and a diff is too large to display without passing -vv, still show a few lines of the diff. Thanks Florian Bruhin for the report and Bruno Oliveira for the PR. fix issue736: Fix a bug where fixture params would be discarded when combined with parametrization markers. Thanks to Markus Unterwaditzer for the PR. fix issue710: introduce ALLOW_UNICODE doctest option: when enabled, the u prefix is stripped from unicode strings in expected doctest output. This allows doctests which use unicode to run in Python 2 and 3 unchanged. Thanks Jason R. Coombs for the report and Bruno Oliveira for the PR. parametrize now also generates meaningful test IDs for enum, regex and class objects (as opposed to class instances). Thanks to Florian Bruhin for the PR. Add ‘warns’ to assert that warnings are thrown (like ‘raises’). Thanks to Eric Hunsberger for the PR. Fix issue683: Do not apply an already applied mark. Thanks ojake for the PR. Deal with capturing failures better so fewer exceptions get lost to /dev/null. Thanks David Szotten for the PR. fix issue730: deprecate and warn about the –genscript option. Thanks Ronny Pfannschmidt for the report and Christian Pommranz for the PR. fix issue751: multiple parametrize with ids bug if it parametrizes class with two or more test methods. Thanks Sergey Chipiga for reporting and Jan Bednarik for PR. fix issue82: avoid loading conftest files from setup.cfg/pytest.ini/tox.ini files and upwards by default (–confcutdir can still be set to override this). Thanks Bruno Oliveira for the PR. fix issue768: docstrings found in python modules were not setting up session fixtures. Thanks Jason R. Coombs for reporting and Bruno Oliveira for the PR. added tmpdir_factory , a session-scoped fixture that can be used to create directories under the base temporary directory. Previously this object was installed as a _tmpdirhandler attribute of the config object, but now it is part of the official API and using config._tmpdirhandler is deprecated. Thanks Bruno Oliveira for the PR. fix issue808: pytest’s internal assertion rewrite hook now implements the optional PEP 302 get_data API so tests can access data files next to them. Thanks xmo-odoo for request and example and Bruno Oliveira for the PR. rootdir and inifile are now displayed during usage errors to help users diagnose problems such as unexpected ini files which add unknown options being picked up by pytest. Thanks to Pavel Savchenko for bringing the problem to attention in #821 and Bruno Oliveira for the PR. Summary bar now is colored yellow for warning situations such as: all tests either were skipped or xpass/xfailed, or no tests were run at all (this is a partial fix for issue500). fix issue812: pytest now exits with status code 5 in situations where no tests were run at all, such as the directory given in the command line does not contain any tests or as result of a command line option filters all out all tests (-k for example). Thanks Eric Siegerman (issue812) and Bruno Oliveira for the PR. Summary bar now is colored yellow for warning situations such as: all tests either were skipped or xpass/xfailed, or no tests were run at all (related to issue500). Thanks Eric Siegerman. New testpaths ini option: list of directories to search for tests when executing pytest from the root directory. This can be used to speed up test collection when a project has well specified directories for tests, being usually more practical than configuring norecursedirs for all directories that do not contain tests. Thanks to Adrian for idea (#694) and Bruno Oliveira for the PR. fix issue713: JUnit XML reports for doctest failures. Thanks Punyashloka Biswal. fix issue970: internal pytest warnings now appear as “pytest-warnings” in the terminal instead of “warnings”, so it is clear for users that those warnings are from pytest and not from the builtin “warnings” module. Thanks Bruno Oliveira. Include setup and teardown in junitxml test durations. Thanks Janne Vanhala. fix issue735: assertion failures on debug versions of Python 3.4+ new option --import-mode to allow to change test module importing behaviour to append to sys.path instead of prepending. This better allows to run test modules against installed versions of a package even if the package under test has the same import root. In this example:

```

testing
/
__init__
.
py
testing
/
test_pkg_under_test
.
py
pkg_under_test
/

```

the tests will run against the installed version of pkg_under_test when --import-mode=append is used whereas by default they would always pick up the local version. Thanks Holger Krekel. pytester: add method TmpTestdir.delete_loaded_modules() , and call it from inline_run() to allow temporary modules to be reloaded. Thanks Eduardo Schettino. internally refactor pluginmanager API and code so that there is a clear distinction between a pytest-agnostic rather simple pluginmanager and the PytestPluginManager which adds a lot of behaviour, among it handling of the local conftest files. In terms of documented methods this is a backward compatible change but it might still break 3rd party plugins which relied on details like especially the pluginmanager.add_shutdown() API. Thanks Holger Krekel. pluginmanagement: introduce pytest.hookimpl and pytest.hookspec decorators for setting impl/spec specific parameters. This substitutes the previous now deprecated use of pytest.mark which is meant to contain markers for test functions only. write/refine docs for “writing plugins” which now have their own page and are separate from the “using/installing plugins`` page. fix issue732: properly unregister plugins from any hook calling sites allowing to have temporary plugins during test execution. deprecate and warn about __multicall__ argument in hook implementations. Use the hookwrapper mechanism instead already introduced with pytest-2.7. speed up pytest’s own test suite considerably by using inprocess tests by default (testrun can be modified with –runpytest=subprocess to create subprocesses in many places instead). The main APIs to run pytest in a test is “runpytest()” or “runpytest_subprocess” and “runpytest_inprocess” if you need a particular way of running the test. In all cases you get back a RunResult but the inprocess one will also have a “reprec” attribute with the recorded events/reports. fix monkeypatch.setattr(“x.y”, raising=False) to actually not raise if “y” is not a preexisting attribute. Thanks Florian Bruhin. fix issue741: make running output from testdir.run copy/pasteable Thanks Bruno Oliveira. add a new --noconftest argument which ignores all conftest.py files. add file and line attributes to JUnit-XML output. fix issue890: changed extension of all documentation files from txt to rst . Thanks to Abhijeet for the PR. fix issue714: add ability to apply indirect=True parameter on particular argnames. Thanks Elizaveta239. fix issue890: changed extension of all documentation files from txt to rst . Thanks to Abhijeet for the PR. fix issue957: “# doctest: SKIP” option will now register doctests as SKIPPED rather than PASSED. Thanks Thomas Grainger for the report and Bruno Oliveira for the PR. issue951: add new record_xml_property fixture, that supports logging additional information on xml output. Thanks David Diaz for the PR. issue949: paths after normal options (for example -s , -v , etc) are now properly used to discover rootdir and ini files. Thanks Peter Lauri for the report and Bruno Oliveira for the PR.

# 2.7.3 (2015-09-15)¶

Allow ‘dev’, ‘rc’, or other non-integer version strings in importorskip . Thanks to Eric Hunsberger for the PR. fix issue856: consider –color parameter in all outputs (for example –fixtures). Thanks Barney Gale for the report and Bruno Oliveira for the PR. fix issue855: passing str objects as plugins argument to pytest.main is now interpreted as a module name to be imported and registered as a plugin, instead of silently having no effect. Thanks xmo-odoo for the report and Bruno Oliveira for the PR. fix issue744: fix for ast.Call changes in Python 3.5+. Thanks Guido van Rossum, Matthias Bussonnier, Stefan Zimmermann and Thomas Kluyver. fix issue842: applying markers in classes no longer propagate this markers to superclasses which also have markers. Thanks xmo-odoo for the report and Bruno Oliveira for the PR. preserve warning functions after call to pytest.deprecated_call. Thanks Pieter Mulder for PR. fix issue854: autouse yield_fixtures defined as class members of unittest.TestCase subclasses now work as expected. Thanks xmo-odoo for the report and Bruno Oliveira for the PR. fix issue833: –fixtures now shows all fixtures of collected test files, instead of just the fixtures declared on the first one. Thanks Florian Bruhin for reporting and Bruno Oliveira for the PR. fix issue863: skipped tests now report the correct reason when a skip/xfail condition is met when using multiple markers. Thanks Raphael Pierzina for reporting and Bruno Oliveira for the PR. optimized tmpdir fixture initialization, which should make test sessions faster (specially when using pytest-xdist). The only visible effect is that now pytest uses a subdirectory in the $TEMP directory for all directories created by this fixture (defaults to $TEMP/pytest-$USER). Thanks Bruno Oliveira for the PR.

# 2.7.2 (2015-06-23)¶

fix issue767: pytest.raises value attribute does not contain the exception instance on Python 2.6. Thanks Eric Siegerman for providing the test case and Bruno Oliveira for PR. Automatically create directory for junitxml and results log. Thanks Aron Curzon. fix issue713: JUnit XML reports for doctest failures. Thanks Punyashloka Biswal. fix issue735: assertion failures on debug versions of Python 3.4+ Thanks Benjamin Peterson. fix issue114: skipif marker reports to internal skipping plugin; Thanks Floris Bruynooghe for reporting and Bruno Oliveira for the PR. fix issue748: unittest.SkipTest reports to internal pytest unittest plugin. Thanks Thomas De Schampheleire for reporting and Bruno Oliveira for the PR. fix issue718: failed to create representation of sets containing unsortable elements in python 2. Thanks Edison Gustavo Muenz. fix issue756, fix issue752 (and similar issues): depend on py-1.4.29 which has a refined algorithm for traceback generation.

# 2.7.1 (2015-05-19)¶

fix issue731: do not get confused by the braces which may be present and unbalanced in an object’s repr while collapsing False explanations. Thanks Carl Meyer for the report and test case. fix issue553: properly handling inspect.getsourcelines failures in FixtureLookupError which would lead to an internal error, obfuscating the original problem. Thanks talljosh for initial diagnose/patch and Bruno Oliveira for final patch. fix issue660: properly report scope-mismatch-access errors independently from ordering of fixture arguments. Also avoid the pytest internal traceback which does not provide information to the user. Thanks Holger Krekel. streamlined and documented release process. Also all versions (in setup.py and documentation generation) are now read from _pytest/__init__.py. Thanks Holger Krekel. fixed docs to remove the notion that yield-fixtures are experimental. They are here to stay :) Thanks Bruno Oliveira. Support building wheels by using environment markers for the requirements. Thanks Ionel Maries Cristian. fixed regression to 2.6.4 which surfaced e.g. in lost stdout capture printing when tests raised SystemExit. Thanks Holger Krekel. reintroduced _pytest fixture of the pytester plugin which is used at least by pytest-xdist.

# 2.7.0 (2015-03-26)¶

fix issue435: make reload() work when assert rewriting is active. Thanks Daniel Hahler. fix issue616: conftest.py files and their contained fixtures are now properly considered for visibility, independently from the exact current working directory and test arguments that are used. Many thanks to Eric Siegerman and his PR235 which contains systematic tests for conftest visibility and now passes. This change also introduces the concept of a rootdir which is printed as a new pytest header and documented in the pytest customize web page. change reporting of “diverted” tests, i.e. tests that are collected in one file but actually come from another (e.g. when tests in a test class come from a base class in a different file). We now show the nodeid and indicate via a postfix the other file. add ability to set command line options by environment variable PYTEST_ADDOPTS. added documentation on the new pytest-dev teams on bitbucket and github. See https://pytest.org/en/stable/contributing.html . Thanks to Anatoly for pushing and initial work on this. fix issue650: new option --doctest-ignore-import-errors which will turn import errors in doctests into skips. Thanks Charles Cloud for the complete PR. fix issue655: work around different ways that cause python2/3 to leak sys.exc_info into fixtures/tests causing failures in 3rd party code fix issue615: assertion rewriting did not correctly escape % signs when formatting boolean operations, which tripped over mixing booleans with modulo operators. Thanks to Tom Viner for the report, triaging and fix. implement issue351: add ability to specify parametrize ids as a callable to generate custom test ids. Thanks Brianna Laugher for the idea and implementation. introduce and document new hookwrapper mechanism useful for plugins which want to wrap the execution of certain hooks for their purposes. This supersedes the undocumented __multicall__ protocol which pytest itself and some external plugins use. Note that pytest-2.8 is scheduled to drop supporting the old __multicall__ and only support the hookwrapper protocol. majorly speed up invocation of plugin hooks use hookwrapper mechanism in builtin pytest plugins. add a doctest ini option for doctest flags, thanks Holger Peters. add note to docs that if you want to mark a parameter and the parameter is a callable, you also need to pass in a reason to disambiguate it from the “decorator” case. Thanks Tom Viner. “python_classes” and “python_functions” options now support glob-patterns for test discovery, as discussed in issue600. Thanks Ldiary Translations. allow to override parametrized fixtures with non-parametrized ones and vice versa (bubenkoff). fix issue463: raise specific error for ‘parameterize’ misspelling (pfctdayelise). On failure, the sys.last_value , sys.last_type and sys.last_traceback are set, so that a user can inspect the error via postmortem debugging (almarklein).

# 2.6.4 (2014-10-24)¶

Improve assertion failure reporting on iterables, by using ndiff and pprint. removed outdated japanese docs from source tree. docs for “pytest_addhooks” hook. Thanks Bruno Oliveira. updated plugin index docs. Thanks Bruno Oliveira. fix issue557: with “-k” we only allow the old style “-” for negation at the beginning of strings and even that is deprecated. Use “not” instead. This should allow to pick parametrized tests where “-” appeared in the parameter. fix issue604: Escape % character in the assertion message. fix issue620: add explanation in the –genscript target about what the binary blob means. Thanks Dinu Gherman. fix issue614: fixed pastebin support. fix issue620: add explanation in the –genscript target about what the binary blob means. Thanks Dinu Gherman. fix issue614: fixed pastebin support.

# 2.6.3 (2014-09-24)¶

fix issue575: xunit-xml was reporting collection errors as failures instead of errors, thanks Oleg Sinyavskiy. fix issue582: fix setuptools example, thanks Laszlo Papp and Ronny Pfannschmidt. Fix infinite recursion bug when pickling capture.EncodedFile, thanks Uwe Schmitt. fix issue589: fix bad interaction with numpy and others when showing exceptions. Check for precise “maximum recursion depth exceed” exception instead of presuming any RuntimeError is that one (implemented in py dep). Thanks Charles Cloud for analysing the issue. fix conftest related fixture visibility issue: when running with a CWD outside of a test package pytest would get fixture discovery wrong. Thanks to Wolfgang Schnerring for figuring out a reproducible example. Introduce pytest_enter_pdb hook (needed e.g. by pytest_timeout to cancel the timeout when interactively entering pdb). Thanks Wolfgang Schnerring. check xfail/skip also with non-python function test items. Thanks Floris Bruynooghe.

# 2.6.2 (2014-09-05)¶

Added function pytest.freeze_includes(), which makes it easy to embed pytest into executables using tools like cx_freeze. See docs for examples and rationale. Thanks Bruno Oliveira. Improve assertion rewriting cache invalidation precision. fixed issue561: adapt autouse fixture example for python3. fixed issue453: assertion rewriting issue with __repr__ containing “n{”, “n}” and “n~”. fix issue560: correctly display code if an “else:” or “finally:” is followed by statements on the same line. Fix example in monkeypatch documentation, thanks t-8ch. fix issue572: correct tmpdir doc example for python3. Do not mark as universal wheel because Python 2.6 is different from other builds due to the extra argparse dependency. Fixes issue566. Thanks sontek. Implement issue549: user-provided assertion messages now no longer replace the py.test introspection message but are shown in addition to them.

# 2.6.1 (2014-08-07)¶

No longer show line numbers in the –verbose output, the output is now purely the nodeid. The line number is still shown in failure reports. Thanks Floris Bruynooghe. fix issue437 where assertion rewriting could cause pytest-xdist worker nodes to collect different tests. Thanks Bruno Oliveira. fix issue555: add “errors” attribute to capture-streams to satisfy some distutils and possibly other code accessing sys.stdout.errors. fix issue547 capsys/capfd also work when output capturing (“-s”) is disabled. address issue170: allow pytest.mark.xfail(…) to specify expected exceptions via an optional “raises=EXC” argument where EXC can be a single exception or a tuple of exception classes. Thanks David Mohr for the complete PR. fix integration of pytest with unittest.mock.patch decorator when it uses the “new” argument. Thanks Nicolas Delaby for test and PR. fix issue with detecting conftest files if the arguments contain “::” node id specifications (copy pasted from “-v” output) fix issue544 by only removing “@NUM” at the end of “::” separated parts and if the part has a “.py” extension don’t use py.std import helper, rather import things directly. Thanks Bruno Oliveira.

# 2.6¶

Cache exceptions from fixtures according to their scope (issue 467). fix issue537: Avoid importing old assertion reinterpretation code by default. fix issue364: shorten and enhance tracebacks representation by default. The new “–tb=auto” option (default) will only display long tracebacks for the first and last entry. You can get the old behaviour of printing all entries as long entries with “–tb=long”. Also short entries by default are now printed very similarly to “–tb=native” ones. fix issue514: teach assertion reinterpretation about private class attributes change -v output to include full node IDs of tests. Users can copy a node ID from a test run, including line number, and use it as a positional argument in order to run only a single test. fix issue 475: fail early and comprehensible if calling pytest.raises with wrong exception type. fix issue516: tell in getting-started about current dependencies. cleanup setup.py a bit and specify supported versions. Thanks Jurko Gospodnetic for the PR. change XPASS colour to yellow rather than red when tests are run with -v. fix issue473: work around mock putting an unbound method into a class dict when double-patching. fix issue498: if a fixture finalizer fails, make sure that the fixture is still invalidated. fix issue453: the result of the pytest_assertrepr_compare hook now gets it’s newlines escaped so that format_exception does not blow up. internal new warning system: pytest will now produce warnings when it detects oddities in your test collection or execution. Warnings are ultimately sent to a new pytest_logwarning hook which is currently only implemented by the terminal plugin which displays warnings in the summary line and shows more details when -rw (report on warnings) is specified. change skips into warnings for test classes with an __init__ and callables in test modules which look like a test but are not functions. fix issue436: improved finding of initial conftest files from command line arguments by using the result of parse_known_args rather than the previous flaky heuristics. Thanks Marc Abramowitz for tests and initial fixing approaches in this area. fix issue #479: properly handle nose/unittest(2) SkipTest exceptions during collection/loading of test modules. Thanks to Marc Schlaich for the complete PR. fix issue490: include pytest_load_initial_conftests in documentation and improve docstring. fix issue472: clarify that pytest.config.getvalue() cannot work if it’s triggered ahead of command line parsing. merge PR123: improved integration with mock.patch decorator on tests. fix issue412: messing with stdout/stderr FD-level streams is now captured without crashes. fix issue483: trial/py33 works now properly. Thanks Daniel Grana for PR. improve example for pytest integration with “python setup.py test” which now has a generic “-a” or “–pytest-args” option where you can pass additional options as a quoted string. Thanks Trevor Bekolay. simplified internal capturing mechanism and made it more robust against tests or setups changing FD1/FD2, also better integrated now with pytest.pdb() in single tests. improvements to pytest’s own test-suite leakage detection, courtesy of PRs from Marc Abramowitz fix issue492: avoid leak in test_writeorg. Thanks Marc Abramowitz. fix issue493: don’t run tests in doc directory with python setup.py test (use tox -e doctesting for that) fix issue486: better reporting and handling of early conftest loading failures some cleanup and simplification of internal conftest handling. work a bit harder to break reference cycles when catching exceptions. Thanks Jurko Gospodnetic. fix issue443: fix skip examples to use proper comparison. Thanks Alex Groenholm. support nose-style __test__ attribute on modules, classes and functions, including unittest-style Classes. If set to False, the test will not be collected. fix issue512: show “<notset>” for arguments which might not be set in monkeypatch plugin. Improves output in documentation.

# 2.5.2 (2014-01-29)¶

fix issue409 – better interoperate with cx_freeze by not trying to import from collections.abc which causes problems for py27/cx_freeze. Thanks Wolfgang L. for reporting and tracking it down. fixed docs and code to use “pytest” instead of “py.test” almost everywhere. Thanks Jurko Gospodnetic for the complete PR. fix issue425: mention at end of “py.test -h” that –markers and –fixtures work according to specified test path (or current dir) fix issue413: exceptions with unicode attributes are now printed correctly also on python2 and with pytest-xdist runs. (the fix requires py-1.4.20) copy, cleanup and integrate py.io capture from pylib 1.4.20.dev2 (rev 13d9af95547e) address issue416: clarify docs as to conftest.py loading semantics fix issue429: comparing byte strings with non-ascii chars in assert expressions now work better. Thanks Floris Bruynooghe. make capfd/capsys.capture private, its unused and shouldn’t be exposed

# 2.5.1 (2013-12-17)¶

merge new documentation styling PR from Tobias Bieniek. fix issue403: allow parametrize of multiple same-name functions within a collection node. Thanks Andreas Kloeckner and Alex Gaynor for reporting and analysis. Allow parameterized fixtures to specify the ID of the parameters by adding an ids argument to pytest.fixture() and pytest.yield_fixture(). Thanks Floris Bruynooghe. fix issue404 by always using the binary xml escape in the junitxml plugin. Thanks Ronny Pfannschmidt. fix issue407: fix addoption docstring to point to argparse instead of optparse. Thanks Daniel D. Wright.

# 2.5.0 (2013-12-12)¶

dropped python2.5 from automated release testing of pytest itself which means it’s probably going to break soon (but still works with this release we believe). simplified and fixed implementation for calling finalizers when parametrized fixtures or function arguments are involved. finalization is now performed lazily at setup time instead of in the “teardown phase”. While this might sound odd at first, it helps to ensure that we are correctly handling setup/teardown even in complex code. User-level code should not be affected unless it’s implementing the pytest_runtest_teardown hook and expecting certain fixture instances are torn down within (very unlikely and would have been unreliable anyway). PR90: add –color=yes|no|auto option to force terminal coloring mode (“auto” is default). Thanks Marc Abramowitz. fix issue319 - correctly show unicode in assertion errors. Many thanks to Floris Bruynooghe for the complete PR. Also means we depend on py>=1.4.19 now. fix issue396 - correctly sort and finalize class-scoped parametrized tests independently from number of methods on the class. refix issue323 in a better way – parametrization should now never cause Runtime Recursion errors because the underlying algorithm for re-ordering tests per-scope/per-fixture is not recursive anymore (it was tail-call recursive before which could lead to problems for more than >966 non-function scoped parameters). fix issue290 - there is preliminary support now for parametrizing with repeated same values (sometimes useful to test if calling a second time works as with the first time). close issue240 - document precisely how pytest module importing works, discuss the two common test directory layouts, and how it interacts with PEP 420 -namespace packages. fix issue246 fix finalizer order to be LIFO on independent fixtures depending on a parametrized higher-than-function scoped fixture. (was quite some effort so please bear with the complexity of this sentence :) Thanks Ralph Schmitt for the precise failure example. fix issue244 by implementing special index for parameters to only use indices for parametrized test ids fix issue287 by running all finalizers but saving the exception from the first failing finalizer and re-raising it so teardown will still have failed. We reraise the first failing exception because it might be the cause for other finalizers to fail. fix ordering when mock.patch or other standard decorator-wrappings are used with test methods. This fixes issue346 and should help with random “xdist” collection failures. Thanks to Ronny Pfannschmidt and Donald Stufft for helping to isolate it. fix issue357 - special case “-k” expressions to allow for filtering with simple strings that are not valid python expressions. Examples: “-k 1.3” matches all tests parametrized with 1.3. “-k None” filters all tests that have “None” in their name and conversely “-k ‘not None’”. Previously these examples would raise syntax errors. fix issue384 by removing the trial support code since the unittest compat enhancements allow trial to handle it on its own don’t hide an ImportError when importing a plugin produces one. fixes issue375. fix issue275 - allow usefixtures and autouse fixtures for running doctest text files. fix issue380 by making –resultlog only rely on longrepr instead of the “reprcrash” attribute which only exists sometimes. address issue122: allow @pytest.fixture(params=iterator) by exploding into a list early on. fix pexpect-3.0 compatibility for pytest’s own tests. (fixes issue386) allow nested parametrize-value markers, thanks James Lan for the PR. fix unicode handling with new monkeypatch.setattr(import_path, value) API. Thanks Rob Dennis. Fixes issue371. fix unicode handling with junitxml, fixes issue368. In assertion rewriting mode on Python 2, fix the detection of coding cookies. See issue #330. make “–runxfail” turn imperative pytest.xfail calls into no ops (it already did neutralize pytest.mark.xfail markers) refine pytest / pkg_resources interactions: The AssertionRewritingHook PEP 302 compliant loader now registers itself with setuptools/pkg_resources properly so that the pkg_resources.resource_stream method works properly. Fixes issue366. Thanks for the investigations and full PR to Jason R. Coombs. pytestconfig fixture is now session-scoped as it is the same object during the whole test run. Fixes issue370. avoid one surprising case of marker malfunction/confusion:

```

@pytest
.
mark
.
some
(
lambda
arg
:
...
)
def
test_function
():

```

would not work correctly because pytest assumes @pytest.mark.some gets a function to be decorated already. We now at least detect if this arg is a lambda and thus the example will work. Thanks Alex Gaynor for bringing it up. xfail a test on pypy that checks wrong encoding/ascii (pypy does not error out). fixes issue385. internally make varnames() deal with classes’s __init__, although it’s not needed by pytest itself atm. Also fix caching. Fixes issue376. fix issue221 - handle importing of namespace-package with no __init__.py properly. refactor internal FixtureRequest handling to avoid monkeypatching. One of the positive user-facing effects is that the “request” object can now be used in closures. fixed version comparison in pytest.importskip(modname, minverstring) fix issue377 by clarifying in the nose-compat docs that pytest does not duplicate the unittest-API into the “plain” namespace. fix verbose reporting for @mock’d test functions

# 2.4.2 (2013-10-04)¶

on Windows require colorama and a newer py lib so that py.io.TerminalWriter() now uses colorama instead of its own ctypes hacks. (fixes issue365) thanks Paul Moore for bringing it up. fix “-k” matching of tests where “repr” and “attr” and other names would cause wrong matches because of an internal implementation quirk (don’t ask) which is now properly implemented. fixes issue345. avoid tmpdir fixture to create too long filenames especially when parametrization is used (issue354) fix pytest-pep8 and pytest-flakes / pytest interactions (collection names in mark plugin was assuming an item always has a function which is not true for those plugins etc.) Thanks Andi Zeidler. introduce node.get_marker/node.add_marker API for plugins like pytest-pep8 and pytest-flakes to avoid the messy details of the node.keywords pseudo-dicts. Adapted docs. remove attempt to “dup” stdout at startup as it’s icky. the normal capturing should catch enough possibilities of tests messing up standard FDs. add pluginmanager.do_configure(config) as a link to config.do_configure() for plugin-compatibility

# 2.4.1 (2013-10-02)¶

When using parser.addoption() unicode arguments to the “type” keyword should also be converted to the respective types. thanks Floris Bruynooghe, @dnozay. (fixes issue360 and issue362) fix dotted filename completion when using argcomplete thanks Anthon van der Neuth. (fixes issue361) fix regression when a 1-tuple (“arg”,) is used for specifying parametrization (the values of the parametrization were passed nested in a tuple). Thanks Donald Stufft. merge doc typo fixes, thanks Andy Dirnberger

# 2.4¶

known incompatibilities: if calling –genscript from python2.7 or above, you only get a standalone script which works on python2.7 or above. Use Python2.6 to also get a python2.5 compatible version. all xunit-style teardown methods (nose-style, pytest-style, unittest-style) will not be called if the corresponding setup method failed, see issue322 below. the pytest_plugin_unregister hook wasn’t ever properly called and there is no known implementation of the hook - so it got removed. pytest.fixture-decorated functions cannot be generators (i.e. use yield) anymore. This change might be reversed in 2.4.1 if it causes unforeseen real-life issues. However, you can always write and return an inner function/generator and change the fixture consumer to iterate over the returned generator. This change was done in lieu of the new pytest.yield_fixture decorator, see below. new features: experimentally introduce a new pytest.yield_fixture decorator which accepts exactly the same parameters as pytest.fixture but mandates a yield statement instead of a return statement from fixture functions. This allows direct integration with “with-style” context managers in fixture functions and generally avoids registering of finalization callbacks in favour of treating the “after-yield” as teardown code. Thanks Andreas Pelme, Vladimir Keleshev, Floris Bruynooghe, Ronny Pfannschmidt and many others for discussions. allow boolean expression directly with skipif/xfail if a “reason” is also specified. Rework skipping documentation to recommend “condition as booleans” because it prevents surprises when importing markers between modules. Specifying conditions as strings will remain fully supported. reporting: color the last line red or green depending if failures/errors occurred or everything passed. thanks Christian Theunert. make “import pdb ; pdb.set_trace()” work natively wrt capturing (no “-s” needed anymore), making pytest.set_trace() a mere shortcut. fix issue181: –pdb now also works on collect errors (and on internal errors) . This was implemented by a slight internal refactoring and the introduction of a new hook pytest_exception_interact hook (see next item). fix issue341: introduce new experimental hook for IDEs/terminals to intercept debugging: pytest_exception_interact(node, call, report) . new monkeypatch.setattr() variant to provide a shorter invocation for patching out classes/functions from modules: monkeypatch.setattr(“requests.get”, myfunc) will replace the “get” function of the “requests” module with myfunc . fix issue322: tearDownClass is not run if setUpClass failed. Thanks Mathieu Agopian for the initial fix. Also make all of pytest/nose finalizer mimic the same generic behaviour: if a setupX exists and fails, don’t run teardownX. This internally introduces a new method “node.addfinalizer()” helper which can only be called during the setup phase of a node. simplify pytest.mark.parametrize() signature: allow to pass a CSV-separated string to specify argnames. For example: pytest.mark.parametrize("input,expected", [(1,2), (2,3)]) works as well as the previous: pytest.mark.parametrize(("input", "expected"), ...) . add support for setUpModule/tearDownModule detection, thanks Brian Okken. integrate tab-completion on options through use of “argcomplete”. Thanks Anthon van der Neut for the PR. change option names to be hyphen-separated long options but keep the old spelling backward compatible. py.test -h will only show the hyphenated version, for example “–collect-only” but “–collectonly” will remain valid as well (for backward-compat reasons). Many thanks to Anthon van der Neut for the implementation and to Hynek Schlawack for pushing us. fix issue 308 - allow to mark/xfail/skip individual parameter sets when parametrizing. Thanks Brianna Laugher. call new experimental pytest_load_initial_conftests hook to allow 3rd party plugins to do something before a conftest is loaded. Bug fixes: fix issue358 - capturing options are now parsed more properly by using a new parser.parse_known_args method. pytest now uses argparse instead of optparse (thanks Anthon) which means that “argparse” is added as a dependency if installing into python2.6 environments or below. fix issue333: fix a case of bad unittest/pytest hook interaction. PR27: correctly handle nose.SkipTest during collection. Thanks Antonio Cuni, Ronny Pfannschmidt. fix issue355: junitxml puts name=”pytest” attribute to testsuite tag. fix issue336: autouse fixture in plugins should work again. fix issue279: improve object comparisons on assertion failure for standard datatypes and recognise collections.abc. Thanks to Brianna Laugher and Mathieu Agopian. fix issue317: assertion rewriter support for the is_package method fix issue335: document py.code.ExceptionInfo() object returned from pytest.raises(), thanks Mathieu Agopian. remove implicit distribute_setup support from setup.py. fix issue305: ignore any problems when writing pyc files. SO-17664702: call fixture finalizers even if the fixture function partially failed (finalizers would not always be called before) fix issue320 - fix class scope for fixtures when mixed with module-level functions. Thanks Anatoly Bubenkoff. you can specify “-q” or “-qq” to get different levels of “quieter” reporting (thanks Katarzyna Jachim) fix issue300 - Fix order of conftest loading when starting py.test in a subdirectory. fix issue323 - sorting of many module-scoped arg parametrizations make sessionfinish hooks execute with the same cwd-context as at session start (helps fix plugin behaviour which write output files with relative path such as pytest-cov) fix issue316 - properly reference collection hooks in docs fix issue 306 - cleanup of -k/-m options to only match markers/test names/keywords respectively. Thanks Wouter van Ackooy. improved doctest counting for doctests in python modules – files without any doctest items will not show up anymore and doctest examples are counted as separate test items. thanks Danilo Bellini. fix issue245 by depending on the released py-1.4.14 which fixes py.io.dupfile to work with files with no mode. Thanks Jason R. Coombs. fix junitxml generation when test output contains control characters, addressing issue267, thanks Jaap Broekhuizen fix issue338: honor –tb style for setup/teardown errors as well. Thanks Maho. fix issue307 - use yaml.safe_load in example, thanks Mark Eichin. better parametrize error messages, thanks Brianna Laugher pytest_terminal_summary(terminalreporter) hooks can now use “.section(title)” and “.line(msg)” methods to print extra information at the end of a test run.

# 2.3.5 (2013-04-30)¶

fix issue169: respect –tb=style with setup/teardown errors as well. never consider a fixture function for test function collection allow re-running of test items / helps to fix pytest-reruntests plugin and also help to keep less fixture/resource references alive put captured stdout/stderr into junitxml output even for passing tests (thanks Adam Goucher) Issue 265 - integrate nose setup/teardown with setupstate so it doesn’t try to teardown if it did not setup issue 271 - don’t write junitxml on worker nodes Issue 274 - don’t try to show full doctest example when doctest does not know the example location issue 280 - disable assertion rewriting on buggy CPython 2.6.0 inject “getfixture()” helper to retrieve fixtures from doctests, thanks Andreas Zeidler issue 259 - when assertion rewriting, be consistent with the default source encoding of ASCII on Python 2 issue 251 - report a skip instead of ignoring classes with init issue250 unicode/str mixes in parametrization names and values now works issue257, assertion-triggered compilation of source ending in a comment line doesn’t blow up in python2.5 (fixed through py>=1.4.13.dev6) fix –genscript option to generate standalone scripts that also work with python3.3 (importer ordering) issue171 - in assertion rewriting, show the repr of some global variables fix option help for “-k” move long description of distribution into README.rst improve docstring for metafunc.parametrize() fix bug where using capsys with pytest.set_trace() in a test function would break when looking at capsys.readouterr() allow to specify prefixes starting with “_” when customizing python_functions test discovery. (thanks Graham Horler) improve PYTEST_DEBUG tracing output by putting extra data on a new lines with additional indent ensure OutcomeExceptions like skip/fail have initialized exception attributes issue 260 - don’t use nose special setup on plain unittest cases fix issue134 - print the collect errors that prevent running specified test items fix issue266 - accept unicode in MarkEvaluator expressions

# 2.3.4 (2012-11-20)¶

yielded test functions will now have autouse-fixtures active but cannot accept fixtures as funcargs - it’s anyway recommended to rather use the post-2.0 parametrize features instead of yield, see: http://pytest.org/en/stable/example/how-to/parametrize.html fix autouse-issue where autouse-fixtures would not be discovered if defined in an a/conftest.py file and tests in a/tests/test_some.py fix issue226 - LIFO ordering for fixture teardowns fix issue224 - invocations with >256 char arguments now work fix issue91 - add/discuss package/directory level setups in example allow to dynamically define markers via item.keywords[…]=assignment integrating with “-m” option make “-k” accept an expressions the same as with “-m” so that one can write: -k “name1 or name2” etc. This is a slight incompatibility if you used special syntax like “TestClass.test_method” which you now need to write as -k “TestClass and test_method” to match a certain method in a certain test class.

# 2.3.3 (2012-11-06)¶

fix issue214 - parse modules that contain special objects like e. g. flask’s request object which blows up on getattr access if no request is active. thanks Thomas Waldmann. fix issue213 - allow to parametrize with values like numpy arrays that do not support an __eq__ operator fix issue215 - split test_python.org into multiple files fix issue148 - @unittest.skip on classes is now recognized and avoids calling setUpClass/tearDownClass, thanks Pavel Repin fix issue209 - reintroduce python2.4 support by depending on newer pylib which re-introduced statement-finding for pre-AST interpreters nose support: only call setup if it’s a callable, thanks Andrew Taumoefolau fix issue219 - add py2.4-3.3 classifiers to TROVE list in tracebacks ,* arg values are now shown next to normal arguments (thanks Manuel Jacob) fix issue217 - support mock.patch with pytest’s fixtures - note that you need either mock-1.0.1 or the python3.3 builtin unittest.mock. fix issue127 - improve documentation for pytest_addoption() and add a config.getoption(name) helper function for consistency.

# 2.3.2 (2012-10-25)¶

fix issue208 and fix issue29 use new py version to avoid long pauses when printing tracebacks in long modules fix issue205 - conftests in subdirs customizing pytest_pycollect_makemodule and pytest_pycollect_makeitem now work properly fix teardown-ordering for parametrized setups fix issue127 - better documentation for pytest_addoption and related objects. fix unittest behaviour: TestCase.runtest only called if there are test methods defined improve trial support: don’t collect its empty unittest.TestCase.runTest() method “python setup.py test” now works with pytest itself fix/improve internal/packaging related bits: exception message check of test_nose.py now passes on python33 as well issue206 - fix test_assertrewrite.py to work when a global PYTHONDONTWRITEBYTECODE=1 is present add tox.ini to pytest distribution so that ignore-dirs and others config bits are properly distributed for maintainers who run pytest-own tests

# 2.3.1 (2012-10-20)¶

fix issue202 - fix regression: using “self” from fixture functions now works as expected (it’s the same “self” instance that a test method which uses the fixture sees) skip pexpect using tests (test_pdb.py mostly) on freebsd* systems due to pexpect not supporting it properly (hanging) link to web pages from –markers output which provides help for pytest.mark.* usage.

# 2.3.0 (2012-10-19)¶

fix issue202 - better automatic names for parametrized test functions fix issue139 - introduce @pytest.fixture which allows direct scoping and parametrization of funcarg factories. fix issue198 - conftest fixtures were not found on windows32 in some circumstances with nested directory structures due to path manipulation issues fix issue193 skip test functions with were parametrized with empty parameter sets fix python3.3 compat, mostly reporting bits that previously depended on dict ordering introduce re-ordering of tests by resource and parametrization setup which takes precedence to the usual file-ordering fix issue185 monkeypatching time.time does not cause pytest to fail fix issue172 duplicate call of pytest.fixture decoratored setup_module functions fix junitxml=path construction so that if tests change the current working directory and the path is a relative path it is constructed correctly from the original current working dir. fix “python setup.py test” example to cause a proper “errno” return fix issue165 - fix broken doc links and mention stackoverflow for FAQ catch unicode-issues when writing failure representations to terminal to prevent the whole session from crashing fix xfail/skip confusion: a skip-mark or an imperative pytest.skip will now take precedence before xfail-markers because we can’t determine xfail/xpass status in case of a skip. see also: http://stackoverflow.com/questions/11105828/in-py-test-when-i-explicitly-skip-a-test-that-is-marked-as-xfail-how-can-i-get always report installed 3rd party plugins in the header of a test run fix issue160: a failing setup of an xfail-marked tests should be reported as xfail (not xpass) fix issue128: show captured output when capsys/capfd are used fix issue179: properly show the dependency chain of factories pluginmanager.register(…) now raises ValueError if the plugin has been already registered or the name is taken fix issue159: improve https://docs.pytest.org/en/6.0.1/faq.html especially with respect to the “magic” history, also mention pytest-django, trial and unittest integration. make request.keywords and node.keywords writable. All descendant collection nodes will see keyword values. Keywords are dictionaries containing markers and other info. fix issue 178: xml binary escapes are now wrapped in py.xml.raw fix issue 176: correctly catch the builtin AssertionError even when we replaced AssertionError with a subclass on the python level factory discovery no longer fails with magic global callables that provide no sane __code__ object (mock.call for example) fix issue 182: testdir.inprocess_run now considers passed plugins before calling into a test fix issue 191: add unittest TestCase runTest method support fix issue 156: monkeypatch correctly handles class level descriptors reporting refinements: pytest_report_header now receives a “startdir” so that you can use startdir.bestrelpath(yourpath) to show nice relative path allow plugins to implement both pytest_report_header and pytest_sessionstart (sessionstart is invoked first). don’t show deselected reason line if there is none py.test -vv will show all of assert comparisons instead of truncating

# 2.2.4 (2012-05-22)¶

fix error message for rewritten assertions involving the % operator fix issue 126: correctly match all invalid xml characters for junitxml binary escape fix issue with unittest: now @unittest.expectedFailure markers should be processed correctly (you can also use @pytest.mark markers) document integration with the extended distribute/setuptools test commands fix issue 140: properly get the real functions of bound classmethods for setup/teardown_class fix issue #141: switch from the deceased paste.pocoo.org to bpaste.net fix issue #143: call unconfigure/sessionfinish always when configure/sessionstart where called fix issue #144: better mangle test ids to junitxml classnames upgrade distribute_setup.py to 0.6.27

# 2.2.3 (2012-02-05)¶

fix uploaded package to only include necessary files

# 2.2.2 (2012-02-05)¶

fix issue101: wrong args to unittest.TestCase test function now produce better output fix issue102: report more useful errors and hints for when a test directory was renamed and some pyc/__pycache__ remain fix issue106: allow parametrize to be applied multiple times e.g. from module, class and at function level. fix issue107: actually perform session scope finalization don’t check in parametrize if indirect parameters are funcarg names add chdir method to monkeypatch funcarg fix crash resulting from calling monkeypatch undo a second time fix issue115: make –collectonly robust against early failure (missing files/directories) “-qq –collectonly” now shows only files and the number of tests in them “-q –collectonly” now shows test ids allow adding of attributes to test reports such that it also works with distributed testing (no upgrade of pytest-xdist needed)

# 2.2.1 (2011-12-16)¶

fix issue99 (in pytest and py) internallerrors with resultlog now produce better output - fixed by normalizing pytest_internalerror input arguments. fix issue97 / traceback issues (in pytest and py) improve traceback output in conjunction with jinja2 and cython which hack tracebacks fix issue93 (in pytest and pytest-xdist) avoid “delayed teardowns”: the final test in a test node will now run its teardown directly instead of waiting for the end of the session. Thanks Dave Hunt for the good reporting and feedback. The pytest_runtest_protocol as well as the pytest_runtest_teardown hooks now have “nextitem” available which will be None indicating the end of the test run. fix collection crash due to unknown-source collected items, thanks to Ralf Schmitt (fixed by depending on a more recent pylib)

# 2.2.0 (2011-11-18)¶

fix issue90: introduce eager tearing down of test items so that teardown function are called earlier. add an all-powerful metafunc.parametrize function which allows to parametrize test function arguments in multiple steps and therefore from independent plugins and places. add a @pytest.mark.parametrize helper which allows to easily call a test function with different argument values Add examples to the “parametrize” example page, including a quick port of Test scenarios and the new parametrize function and decorator. introduce registration for “pytest.mark.*” helpers via ini-files or through plugin hooks. Also introduce a “–strict” option which will treat unregistered markers as errors allowing to avoid typos and maintain a well described set of markers for your test suite. See examples at http://pytest.org/en/stable/how-to/mark.html and its links. issue50: introduce “-m marker” option to select tests based on markers (this is a stricter and more predictable version of ‘-k’ in that “-m” only matches complete markers and has more obvious rules for and/or semantics. new feature to help optimizing the speed of your tests: –durations=N option for displaying N slowest test calls and setup/teardown methods. fix issue87: –pastebin now works with python3 fix issue89: –pdb with unexpected exceptions in doctest work more sensibly fix and cleanup pytest’s own test suite to not leak FDs fix issue83: link to generated funcarg list fix issue74: pyarg module names are now checked against imp.find_module false positives fix compatibility with twisted/trial-11.1.0 use cases simplify Node.listchain simplify junitxml output code by relying on py.xml add support for skip properties on unittest classes and functions

# 2.1.3 (2011-10-18)¶

fix issue79: assertion rewriting failed on some comparisons in boolops correctly handle zero length arguments (a la pytest ‘’) fix issue67 / junitxml now contains correct test durations, thanks ronny fix issue75 / skipping test failure on jython fix issue77 / Allow assertrepr_compare hook to apply to a subset of tests

# 2.1.2 (2011-09-24)¶

fix assertion rewriting on files with windows newlines on some Python versions refine test discovery by package/module name (–pyargs), thanks Florian Mayer fix issue69 / assertion rewriting fixed on some boolean operations fix issue68 / packages now work with assertion rewriting fix issue66: use different assertion rewriting caches when the -O option is passed don’t try assertion rewriting on Jython, use reinterp

# 2.1.1¶

fix issue64 / pytest.set_trace now works within pytest_generate_tests hooks fix issue60 / fix error conditions involving the creation of __pycache__ fix issue63 / assertion rewriting on inserts involving strings containing ‘%’ fix assertion rewriting on calls with a ** arg don’t cache rewritten modules if bytecode generation is disabled fix assertion rewriting in read-only directories fix issue59: provide system-out/err tags for junitxml output fix issue61: assertion rewriting on boolean operations with 3 or more operands you can now build a man page with “cd doc ; make man”

# 2.1.0 (2011-07-09)¶

fix issue53 call nosestyle setup functions with correct ordering fix issue58 and issue59: new assertion code fixes merge Benjamin’s assertionrewrite branch: now assertions for test modules on python 2.6 and above are done by rewriting the AST and saving the pyc file before the test module is imported. see doc/assert.txt for more info. fix issue43: improve doctests with better traceback reporting on unexpected exceptions fix issue47: timing output in junitxml for test cases is now correct fix issue48: typo in MarkInfo repr leading to exception fix issue49: avoid confusing error when initialization partially fails fix issue44: env/username expansion for junitxml file path show releaselevel information in test runs for pypy reworked doc pages for better navigation and PDF generation report KeyboardInterrupt even if interrupted during session startup fix issue 35 - provide PDF doc version and download link from index page

# 2.0.3 (2011-05-11)¶

fix issue38: nicer tracebacks on calls to hooks, particularly early configure/sessionstart ones fix missing skip reason/meta information in junitxml files, reported via http://lists.idyll.org/pipermail/testing-in-python/2011-March/003928.html fix issue34: avoid collection failure with “test” prefixed classes deriving from object. don’t require zlib (and other libs) for genscript plugin without –genscript actually being used. speed up skips (by not doing a full traceback representation internally) fix issue37: avoid invalid characters in junitxml’s output

# 2.0.2 (2011-03-09)¶

tackle issue32 - speed up test runs of very quick test functions by reducing the relative overhead fix issue30 - extended xfail/skipif handling and improved reporting. If you have a syntax error in your skip/xfail expressions you now get nice error reports. Also you can now access module globals from xfail/skipif expressions so that this for example works now:

```

import
pytest
import
mymodule
@pytest
.
mark
.
skipif
(
"mymodule.__version__[0] == "
1
")
def
test_function
():
pass

```

This will not run the test function if the module’s version string does not start with a “1”. Note that specifying a string instead of a boolean expressions allows py.test to report meaningful information when summarizing a test run as to what conditions lead to skipping (or xfail-ing) tests. fix issue28 - setup_method and pytest_generate_tests work together The setup_method fixture method now gets called also for test function invocations generated from the pytest_generate_tests hook. fix issue27 - collectonly and keyword-selection (-k) now work together Also, if you do “py.test –collectonly -q” you now get a flat list of test ids that you can use to paste to the py.test commandline in order to execute a particular test. fix issue25 avoid reported problems with –pdb and python3.2/encodings output fix issue23 - tmpdir argument now works on Python3.2 and WindowsXP Starting with Python3.2 os.symlink may be supported. By requiring a newer py lib version the py.path.local() implementation acknowledges this. fixed typos in the docs (thanks Victor Garcia, Brianna Laugher) and particular thanks to Laura Creighton who also reviewed parts of the documentation. fix slightly wrong output of verbose progress reporting for classes (thanks Amaury) more precise (avoiding of) deprecation warnings for node.Class|Function accesses avoid std unittest assertion helper code in tracebacks (thanks Ronny)

# 2.0.1 (2011-02-07)¶

refine and unify initial capturing so that it works nicely even if the logging module is used on an early-loaded conftest.py file or plugin. allow to omit “()” in test ids to allow for uniform test ids as produced by Alfredo’s nice pytest.vim plugin. fix issue12 - show plugin versions with “–version” and “–traceconfig” and also document how to add extra information to reporting test header fix issue17 (import-* reporting issue on python3) by requiring py>1.4.0 (1.4.1 is going to include it) fix issue10 (numpy arrays truth checking) by refining assertion interpretation in py lib fix issue15: make nose compatibility tests compatible with python3 (now that nose-1.0 supports python3) remove somewhat surprising “same-conftest” detection because it ignores conftest.py when they appear in several subdirs. improve assertions (“not in”), thanks Floris Bruynooghe improve behaviour/warnings when running on top of “python -OO” (assertions and docstrings are turned off, leading to potential false positives) introduce a pytest_cmdline_processargs(args) hook to allow dynamic computation of command line arguments. This fixes a regression because py.test prior to 2.0 allowed to set command line options from conftest.py files which so far pytest-2.0 only allowed from ini-files now. fix issue7: assert failures in doctest modules. unexpected failures in doctests will not generally show nicer, i.e. within the doctest failing context. fix issue9: setup/teardown functions for an xfail-marked test will report as xfail if they fail but report as normally passing (not xpassing) if they succeed. This only is true for “direct” setup/teardown invocations because teardown_class/ teardown_module cannot closely relate to a single test. fix issue14: no logging errors at process exit refinements to “collecting” output on non-ttys refine internal plugin registration and –traceconfig output introduce a mechanism to prevent/unregister plugins from the command line, see http://pytest.org/en/stable/how-to/plugins.html#cmdunregister activate resultlog plugin by default fix regression wrt yielded tests which due to the collection-before-running semantics were not setup as with pytest 1.3.4. Note, however, that the recommended and much cleaner way to do test parameterization remains the “pytest_generate_tests” mechanism, see the docs.

# 2.0.0 (2010-11-25)¶

pytest-2.0 is now its own package and depends on pylib-2.0 new ability: python -m pytest / python -m pytest.main ability new python invocation: pytest.main(args, plugins) to load some custom plugins early. try harder to run unittest test suites in a more compatible manner by deferring setup/teardown semantics to the unittest package. also work harder to run twisted/trial and Django tests which should now basically work by default. introduce a new way to set config options via ini-style files, by default setup.cfg and tox.ini files are searched. The old ways (certain environment variables, dynamic conftest.py reading is removed). add a new “-q” option which decreases verbosity and prints a more nose/unittest-style “dot” output. fix issue135 - marks now work with unittest test cases as well fix issue126 - introduce py.test.set_trace() to trace execution via PDB during the running of tests even if capturing is ongoing. fix issue123 - new “python -m py.test” invocation for py.test (requires Python 2.5 or above) fix issue124 - make reporting more resilient against tests opening files on filedescriptor 1 (stdout). fix issue109 - sibling conftest.py files will not be loaded. (and Directory collectors cannot be customized anymore from a Directory’s conftest.py - this needs to happen at least one level up). introduce (customizable) assertion failure representations and enhance output on assertion failures for comparisons and other cases (Floris Bruynooghe) nose-plugin: pass through type-signature failures in setup/teardown functions instead of not calling them (Ed Singleton) remove py.test.collect.Directory (follows from a major refactoring and simplification of the collection process) majorly reduce py.test core code, shift function/python testing to own plugin fix issue88 (finding custom test nodes from command line arg) refine ‘tmpdir’ creation, will now create basenames better associated with test names (thanks Ronny) “xpass” (unexpected pass) tests don’t cause exitcode!=0 fix issue131 / issue60 - importing doctests in __init__ files used as namespace packages fix issue93 stdout/stderr is captured while importing conftest.py fix bug: unittest collected functions now also can have “pytestmark” applied at class/module level add ability to use “class” level for cached_setup helper fix strangeness: mark.* objects are now immutable, create new instances

# 1.3.4 (2010-09-14)¶

fix issue111: improve install documentation for windows fix issue119: fix custom collectability of __init__.py as a module fix issue116: –doctestmodules work with __init__.py files as well fix issue115: unify internal exception passthrough/catching/GeneratorExit fix issue118: new –tb=native for presenting cpython-standard exceptions

# 1.3.3 (2010-07-30)¶

fix issue113: assertion representation problem with triple-quoted strings (and possibly other cases) make conftest loading detect that a conftest file with the same content was already loaded, avoids surprises in nested directory structures which can be produced e.g. by Hudson. It probably removes the need to use –confcutdir in most cases. fix terminal coloring for win32 (thanks Michael Foord for reporting) fix weirdness: make terminal width detection work on stdout instead of stdin (thanks Armin Ronacher for reporting) remove trailing whitespace in all py/text distribution files

# 1.3.2 (2010-07-08)¶

New features fix issue103: introduce py.test.raises as context manager, examples:

```

with
py
.
test
.
raises
(
ZeroDivisionError
):
x
=
0
1
/
x
with
py
.
test
.
raises
(
RuntimeError
)
as
excinfo
:
call_something
()
# you may do extra checks on excinfo.value|type|traceback here

```

(thanks Ronny Pfannschmidt) Funcarg factories can now dynamically apply a marker to a test invocation. This is for example useful if a factory provides parameters to a test which are expected-to-fail:

```

def
pytest_funcarg__arg
(
request
):
request
.
applymarker
(
py
.
test
.
mark
.
xfail
(
reason
=
"flaky config"
))
...
def
test_function
(
arg
):
...

```

improved error reporting on collection and import errors. This makes use of a more general mechanism, namely that for custom test item/collect nodes node.repr_failure(excinfo) is now uniformly called so that you can override it to return a string error representation of your choice which is going to be reported as a (red) string. introduce ‘–junitprefix=STR’ option to prepend a prefix to all reports in the junitxml file. Bug fixes make tests and the pytest_recwarn plugin in particular fully compatible to Python2.7 (if you use the recwarn funcarg warnings will be enabled so that you can properly check for their existence in a cross-python manner). refine –pdb: ignore xfailed tests, unify its TB-reporting and don’t display failures again at the end. fix assertion interpretation with the ** operator (thanks Benjamin Peterson) fix issue105 assignment on the same line as a failing assertion (thanks Benjamin Peterson) fix issue104 proper escaping for test names in junitxml plugin (thanks anonymous) fix issue57 -f|–looponfail to work with xpassing tests (thanks Ronny) fix issue92 collectonly reporter and –pastebin (thanks Benjamin Peterson) fix py.code.compile(source) to generate unique filenames fix assertion re-interp problems on PyPy, by deferring code compilation to the (overridable) Frame.eval class. (thanks Amaury Forgeot) fix py.path.local.pyimport() to work with directories streamline py.path.local.mkdtemp implementation and usage don’t print empty lines when showing junitxml-filename add optional boolean ignore_errors parameter to py.path.local.remove fix terminal writing on win32/python2.4 py.process.cmdexec() now tries harder to return properly encoded unicode objects on all python versions install plain py.test/py.which scripts also for Jython, this helps to get canonical script paths in virtualenv situations make path.bestrelpath(path) return “.”, note that when calling X.bestrelpath the assumption is that X is a directory. make initial conftest discovery ignore “–” prefixed arguments fix resultlog plugin when used in a multicpu/multihost xdist situation (thanks Jakub Gustak) perform distributed testing related reporting in the xdist-plugin rather than having dist-related code in the generic py.test distribution fix homedir detection on Windows ship distribute_setup.py version 0.6.13

# 1.3.1 (2010-05-25)¶

New features issue91: introduce new py.test.xfail(reason) helper to imperatively mark a test as expected to fail. Can be used from within setup and test functions. This is useful especially for parametrized tests when certain configurations are expected-to-fail. In this case the declarative approach with the @py.test.mark.xfail cannot be used as it would mark all configurations as xfail. issue102: introduce new –maxfail=NUM option to stop test runs after NUM failures. This is a generalization of the ‘-x’ or ‘–exitfirst’ option which is now equivalent to ‘–maxfail=1’. Both ‘-x’ and ‘–maxfail’ will now also print a line near the end indicating the Interruption. issue89: allow py.test.mark decorators to be used on classes (class decorators were introduced with python2.6) and also allow to have multiple markers applied at class/module level by specifying a list. improve and refine letter reporting in the progress bar: . pass f failed test s skipped tests (reminder: use for dependency/platform mismatch only) x xfailed test (test that was expected to fail) X xpassed test (test that was expected to fail but passed) You can use any combination of ‘fsxX’ with the ‘-r’ extended reporting option. The xfail/xpass results will show up as skipped tests in the junitxml output - which also fixes issue99. make py.test.cmdline.main() return the exitstatus instead of raising SystemExit and also allow it to be called multiple times. This of course requires that your application and tests are properly teared down and don’t have global state. Bug Fixes improved traceback presentation: - improved and unified reporting for “–tb=short” option - Errors during test module imports are much shorter, (using –tb=short style) - raises shows shorter more relevant tracebacks - –fulltrace now more systematically makes traces longer / inhibits cutting improve support for raises and other dynamically compiled code by manipulating python’s linecache.cache instead of the previous rather hacky way of creating custom code objects. This makes it seamlessly work on Jython and PyPy where it previously didn’t. fix issue96: make capturing more resilient against Control-C interruptions (involved somewhat substantial refactoring to the underlying capturing functionality to avoid race conditions). fix chaining of conditional skipif/xfail decorators - so it works now as expected to use multiple @py.test.mark.skipif(condition) decorators, including specific reporting which of the conditions lead to skipping. fix issue95: late-import zlib so that it’s not required for general py.test startup. fix issue94: make reporting more robust against bogus source code (and internally be more careful when presenting unexpected byte sequences)

# 1.3.0 (2010-05-05)¶

deprecate –report option in favour of a new shorter and easier to remember -r option: it takes a string argument consisting of any combination of ‘xfsX’ characters. They relate to the single chars you see during the dotted progress printing and will print an extra line per test at the end of the test run. This extra line indicates the exact position or test ID that you directly paste to the py.test cmdline in order to re-run a particular test. allow external plugins to register new hooks via the new pytest_addhooks(pluginmanager) hook. The new release of the pytest-xdist plugin for distributed and looponfailing testing requires this feature. add a new pytest_ignore_collect(path, config) hook to allow projects and plugins to define exclusion behaviour for their directory structure - for example you may define in a conftest.py this method:

```

def
pytest_ignore_collect
(
path
):
return
path
.
check
(
link
=
1
)

```

to prevent even a collection try of any tests in symlinked dirs. new pytest_pycollect_makemodule(path, parent) hook for allowing customization of the Module collection object for a matching test module. extend and refine xfail mechanism: @py.test.mark.xfail(run=False) do not run the decorated test @py.test.mark.xfail(reason="...") prints the reason string in xfail summaries specifying --runxfail on command line virtually ignores xfail markers expose (previously internal) commonly useful methods: py.io.get_terminal_with() -> return terminal width py.io.ansi_print(…) -> print colored/bold text on linux/win32 py.io.saferepr(obj) -> return limited representation string expose test outcome related exceptions as py.test.skip.Exception, py.test.raises.Exception etc., useful mostly for plugins doing special outcome interpretation/tweaking (issue85) fix junitxml plugin to handle tests with non-ascii output fix/refine python3 compatibility (thanks Benjamin Peterson) fixes for making the jython/win32 combination work, note however: jython2.5.1/win32 does not provide a command line launcher, see https://bugs.jython.org/issue1491 . See pylib install documentation for how to work around. fixes for handling of unicode exception values and unprintable objects (issue87) fix unboundlocal error in assertionold code (issue86) improve documentation for looponfailing refine IO capturing: stdin-redirect pseudo-file now has a NOP close() method ship distribute_setup.py version 0.6.10 added links to the new capturelog and coverage plugins

# 1.2.0 (2010-01-18)¶

refined usage and options for “py.cleanup”:

```

py
.
cleanup
# remove "*.pyc" and "*$py.class" (jython) files
py
.
cleanup
-
e
.
swp
-
e
.
cache
# also remove files with these extensions
py
.
cleanup
-
s
# remove "build" and "dist" directory next to setup.py files
py
.
cleanup
-
d
# also remove empty directories
py
.
cleanup
-
a
# synonym for "-s -d -e 'pip-log.txt'"
py
.
cleanup
-
n
# dry run, only show what would be removed

```

add a new option “py.test –funcargs” which shows available funcargs and their help strings (docstrings on their respective factory function) for a given test path display a short and concise traceback if a funcarg lookup fails early-load “conftest.py” files in non-dot first-level sub directories. allows to conveniently keep and access test-related options in a test subdir and still add command line options. fix issue67: new super-short traceback-printing option: “–tb=line” will print a single line for each failing (python) test indicating its filename, lineno and the failure value fix issue78: always call python-level teardown functions even if the according setup failed. This includes refinements for calling setup_module/class functions which will now only be called once instead of the previous behaviour where they’d be called multiple times if they raise an exception (including a Skipped exception). Any exception will be re-corded and associated with all tests in the according module/class scope. fix issue63: assume <40 columns to be a bogus terminal width, default to 80 fix pdb debugging to be in the correct frame on raises-related errors update apipkg.py to fix an issue where recursive imports might unnecessarily break importing fix plugin links

# 1.1.1 (2009-11-24)¶

moved dist/looponfailing from py.test core into a new separately released pytest-xdist plugin. new junitxml plugin: –junitxml=path will generate a junit style xml file which is processable e.g. by the Hudson CI system. new option: –genscript=path will generate a standalone py.test script which will not need any libraries installed. thanks to Ralf Schmitt. new option: –ignore will prevent specified path from collection. Can be specified multiple times. new option: –confcutdir=dir will make py.test only consider conftest files that are relative to the specified dir. new funcarg: “pytestconfig” is the pytest config object for access to command line args and can now be easily used in a test. install py.test and py.which with a -$VERSION suffix to disambiguate between Python3, python2.X, Jython and PyPy installed versions. new “pytestconfig” funcarg allows access to test config object new “pytest_report_header” hook can return additional lines to be displayed at the header of a test run. (experimental) allow “py.test path::name1::name2::…” for pointing to a test within a test collection directly. This might eventually evolve as a full substitute to “-k” specifications. streamlined plugin loading: order is now as documented in customize.html: setuptools, ENV, commandline, conftest. also setuptools entry point names are turned to canonical names (“pytest_*”) automatically skip tests that need ‘capfd’ but have no os.dup allow pytest_generate_tests to be defined in classes as well deprecate usage of ‘disabled’ attribute in favour of pytestmark deprecate definition of Directory, Module, Class and Function nodes in conftest.py files. Use pytest collect hooks instead. collection/item node specific runtest/collect hooks are only called exactly on matching conftest.py files, i.e. ones which are exactly below the filesystem path of an item change: the first pytest_collect_directory hook to return something will now prevent further hooks to be called. change: figleaf plugin now requires –figleaf to run. Also change its long command line options to be a bit shorter (see py.test -h). change: pytest doctest plugin is now enabled by default and has a new option –doctest-glob to set a pattern for file matches. change: remove internal py._* helper vars, only keep py._pydir robustify capturing to survive if custom pytest_runtest_setup code failed and prevented the capturing setup code from running. make py.test.* helpers provided by default plugins visible early - works transparently both for pydoc and for interactive sessions which will regularly see e.g. py.test.mark and py.test.importorskip. simplify internal plugin manager machinery simplify internal collection tree by introducing a RootCollector node fix assert reinterpreation that sees a call containing “keyword=…” fix issue66: invoke pytest_sessionstart and pytest_sessionfinish hooks on worker nodes during dist-testing, report module/session teardown hooks correctly. fix issue65: properly handle dist-testing if no execnet/py lib installed remotely. skip some install-tests if no execnet is available fix docs, fix internal bin/ script generation

# 1.1.0 (2009-11-05)¶

introduce automatic plugin registration via ‘pytest11’ entrypoints via setuptools’ pkg_resources.iter_entry_points fix py.test dist-testing to work with execnet >= 1.0.0b4 re-introduce py.test.cmdline.main() for better backward compatibility svn paths: fix a bug with path.check(versioned=True) for svn paths, allow ‘%’ in svn paths, make svnwc.update() default to interactive mode like in 1.0.x and add svnwc.update(interactive=False) to inhibit interaction. refine distributed tarball to contain test and no pyc files try harder to have deprecation warnings for py.compat.* accesses report a correct location

# 1.0.3¶

adjust and improve docs remove py.rest tool and internal namespace - it was never really advertised and can still be used with the old release if needed. If there is interest it could be revived into its own tool i guess. fix issue48 and issue59: raise an Error if the module from an imported test file does not seem to come from the filepath - avoids “same-name” confusion that has been reported repeatedly merged Ronny’s nose-compatibility hacks: now nose-style setup_module() and setup() functions are supported introduce generalized py.test.mark function marking reshuffle / refine command line grouping deprecate parser.addgroup in favour of getgroup which creates option group add –report command line option that allows to control showing of skipped/xfailed sections generalized skipping: a new way to mark python functions with skipif or xfail at function, class and modules level based on platform or sys-module attributes. extend py.test.mark decorator to allow for positional args introduce and test “py.cleanup -d” to remove empty directories fix issue #59 - robustify unittest test collection make bpython/help interaction work by adding an __all__ attribute to ApiModule, cleanup initpkg use MIT license for pylib, add some contributors remove py.execnet code and substitute all usages with ‘execnet’ proper fix issue50 - cached_setup now caches more to expectations for test functions with multiple arguments. merge Jarko’s fixes, issue #45 and #46 add the ability to specify a path for py.lookup to search in fix a funcarg cached_setup bug probably only occurring in distributed testing and “module” scope with teardown. many fixes and changes for making the code base python3 compatible, many thanks to Benjamin Peterson for helping with this. consolidate builtins implementation to be compatible with >=2.3, add helpers to ease keeping 2 and 3k compatible code deprecate py.compat.doctest|subprocess|textwrap|optparse deprecate py.magic.autopath, remove py/magic directory move pytest assertion handling to py/code and a pytest_assertion plugin, add “–no-assert” option, deprecate py.magic namespaces in favour of (less) py.code ones. consolidate and cleanup py/code classes and files cleanup py/misc, move tests to bin-for-dist introduce delattr/delitem/delenv methods to py.test’s monkeypatch funcarg consolidate py.log implementation, remove old approach. introduce py.io.TextIO and py.io.BytesIO for distinguishing between text/unicode and byte-streams (uses underlying standard lib io.* if available) make py.unittest_convert helper script available which converts “unittest.py” style files into the simpler assert/direct-test-classes py.test/nosetests style. The script was written by Laura Creighton. simplified internal localpath implementation

# 1.0.2 (2009-08-27)¶

fixing packaging issues, triggered by fedora redhat packaging, also added doc, examples and contrib dirs to the tarball. added a documentation link to the new django plugin.

# 1.0.1 (2009-08-19)¶

added a ‘pytest_nose’ plugin which handles nose.SkipTest, nose-style function/method/generator setup/teardown and tries to report functions correctly. capturing of unicode writes or encoded strings to sys.stdout/err work better, also terminalwriting was adapted and somewhat unified between windows and linux. improved documentation layout and content a lot added a “–help-config” option to show conftest.py / ENV-var names for all longopt cmdline options, and some special conftest.py variables. renamed ‘conf_capture’ conftest setting to ‘option_capture’ accordingly. fix issue #27: better reporting on non-collectable items given on commandline (e.g. pyc files) fix issue #33: added –version flag (thanks Benjamin Peterson) fix issue #32: adding support for “incomplete” paths to wcpath.status() “Test” prefixed classes are not collected by default anymore if they have an __init__ method monkeypatch setenv() now accepts a “prepend” parameter improved reporting of collection error tracebacks simplified multicall mechanism and plugin architecture, renamed some internal methods and argnames

# 1.0.0 (2009-08-04)¶

more terse reporting try to show filesystem path relatively to current dir improve xfail output a bit

# 1.0.0b9 (2009-07-31)¶

cleanly handle and report final teardown of test setup fix svn-1.6 compat issue with py.path.svnwc().versioned() (thanks Wouter Vanden Hove) setup/teardown or collection problems now show as ERRORs or with big “E“‘s in the progress lines. they are reported and counted separately. dist-testing: properly handle test items that get locally collected but cannot be collected on the remote side - often due to platform/dependency reasons simplified py.test.mark API - see keyword plugin documentation integrate better with logging: capturing now by default captures test functions and their immediate setup/teardown in a single stream capsys and capfd funcargs now have a readouterr() and a close() method (underlyingly py.io.StdCapture/FD objects are used which grew a readouterr() method as well to return snapshots of captured out/err) make assert-reinterpretation work better with comparisons not returning bools (reported with numpy from thanks maciej fijalkowski) reworked per-test output capturing into the pytest_iocapture.py plugin and thus removed capturing code from config object item.repr_failure(excinfo) instead of item.repr_failure(excinfo, outerr)

# 1.0.0b8 (2009-07-22)¶

pytest_unittest-plugin is now enabled by default introduced pytest_keyboardinterrupt hook and refined pytest_sessionfinish hooked, added tests. workaround a buggy logging module interaction (“closing already closed files”). Thanks to Sridhar Ratnakumar for triggering. if plugins use “py.test.importorskip” for importing a dependency only a warning will be issued instead of exiting the testing process. many improvements to docs: - refined funcargs doc , use the term “factory” instead of “provider” - added a new talk/tutorial doc page - better download page - better plugin docstrings - added new plugins page and automatic doc generation script fixed teardown problem related to partially failing funcarg setups (thanks MrTopf for reporting), “pytest_runtest_teardown” is now always invoked even if the “pytest_runtest_setup” failed. tweaked doctest output for docstrings in py modules, thanks Radomir.

# 1.0.0b7¶

renamed py.test.xfail back to py.test.mark.xfail to avoid two ways to decorate for xfail re-added py.test.mark decorator for setting keywords on functions (it was actually documented so removing it was not nice) remove scope-argument from request.addfinalizer() because request.cached_setup has the scope arg. TOOWTDI. perform setup finalization before reporting failures apply modified patches from Andreas Kloeckner to allow test functions to have no func_code (#22) and to make “-k” and function keywords work (#20) apply patch from Daniel Peolzleithner (issue #23) resolve issue #18, multiprocessing.Manager() and redirection clash make __name__ == “__channelexec__” for remote_exec code

# 1.0.0b3 (2009-06-19)¶

plugin classes are removed: one now defines hooks directly in conftest.py or global pytest_*.py files. added new pytest_namespace(config) hook that allows to inject helpers directly to the py.test.* namespace. documented and refined many hooks added new style of generative tests via pytest_generate_tests hook that integrates well with function arguments.

# 1.0.0b1¶

introduced new “funcarg” setup method, see doc/test/funcarg.txt introduced plugin architecture and many new py.test plugins, see doc/test/plugins.txt teardown_method is now guaranteed to get called after a test method has run. new method: py.test.importorskip(mod,minversion) will either import or call py.test.skip() completely revised internal py.test architecture new py.process.ForkedFunc object allowing to fork execution of a function to a sub process and getting a result back. XXX lots of things missing here XXX

# 0.9.2¶

refined installation and metadata, created new setup.py, now based on setuptools/ez_setup (thanks to Ralf Schmitt for his support). improved the way of making py.* scripts available in windows environments, they are now added to the Scripts directory as “.cmd” files. py.path.svnwc.status() now is more complete and uses xml output from the ‘svn’ command if available (Guido Wesdorp) fix for py.path.svn* to work with svn 1.5 (Chris Lamb) fix path.relto(otherpath) method on windows to use normcase for checking if a path is relative. py.test’s traceback is better parseable from editors (follows the filenames:LINENO: MSG convention) (thanks to Osmo Salomaa) fix to javascript-generation, “py.test –runbrowser” should work more reliably now removed previously accidentally added py.test.broken and py.test.notimplemented helpers. there now is a py.__version__ attribute

# 0.9.1¶


---


# How to re-run failed tests and maintain state between test runs - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/cache.html


# How to re-run failed tests and maintain state between test runs¶

# Usage¶

The plugin provides two command line options to rerun failures from the last pytest invocation: --lf , --last-failed - to only re-run the failures. --ff , --failed-first - to run the failures first and then the rest of the tests. For cleanup (usually not needed), a --cache-clear option allows to remove all cross-session cache contents ahead of a test run. Other plugins may access the config.cache object to set/get json encodable values between pytest invocations. Note This plugin is enabled by default, but can be disabled if needed: see Deactivating / unregistering a plugin by name (the internal name for this plugin is cacheprovider ).

# Rerunning only failures or failures first¶

First, let’s create 50 test invocation of which only 2 fail:

```

# content of test_50.py
import
pytest
@pytest
.
mark
.
parametrize
(
"i"
,
range
(
50
))
def
test_num
(
i
):
if
i
in
(
17
,
25
):
pytest
.
fail
(
"bad luck"
)

```

If you run this for the first time you will see two failures:

```

$ pytest -q
.................
F
.......
F
........................
[100%]
================================= FAILURES =================================
_______________________________ test_num[17] _______________________________
i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
_______________________________ test_num[25] _______________________________
i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
========================= short test summary info ==========================
FAILED
test_50.py::
test_num[17]
- Failed: bad luck
FAILED
test_50.py::
test_num[25]
- Failed: bad luck
2 failed
,
48 passed
in 0.12s

```

If you then run it with --lf :

```

$ pytest --lf
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items
run-last-failure: rerun previous 2 failures

test_50.py
FF
[100%]
================================= FAILURES =================================
_______________________________ test_num[17] _______________________________
i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
_______________________________ test_num[25] _______________________________
i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
========================= short test summary info ==========================
FAILED
test_50.py::
test_num[17]
- Failed: bad luck
FAILED
test_50.py::
test_num[25]
- Failed: bad luck
============================
2 failed
in 0.12s =============================

```

You have run only the two failing tests from the last run, while the 48 passing tests have not been run (“deselected”). Now, if you run with the --ff option, all tests will be run but the first previous failures will be executed first (as can be seen from the series of FF and dots):

```

$ pytest --ff
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 50 items
run-last-failure: rerun previous 2 failures first

test_50.py
FF
................................................
[100%]
================================= FAILURES =================================
_______________________________ test_num[17] _______________________________
i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
_______________________________ test_num[25] _______________________________
i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
========================= short test summary info ==========================
FAILED
test_50.py::
test_num[17]
- Failed: bad luck
FAILED
test_50.py::
test_num[25]
- Failed: bad luck
=======================
2 failed
,
48 passed
in 0.12s =======================

```

New --nf , --new-first options: run new tests first followed by the rest of the tests, in both cases tests are also sorted by the file modified time, with more recent files coming first.

# Behavior when no tests failed in the last run¶

The --lfnf/--last-failed-no-failures option governs the behavior of --last-failed . Determines whether to execute tests when there are no previously (known) failures or when no cached lastfailed data was found. There are two options: all : when there are no known test failures, runs all tests (the full test suite). This is the default. none : when there are no known test failures, just emits a message stating this and exit successfully. Example:

```

pytest
--last-failed
--last-failed-no-failures
all
# runs the full test suite (default behavior)
pytest
--last-failed
--last-failed-no-failures
none
# runs no tests and exits successfully

```

# The new config.cache object¶

Plugins or conftest.py support code can get a cached value using the pytest config object. Here is a basic example plugin which implements a fixture which re-uses previously created state across pytest invocations:

```

# content of test_caching.py
import
pytest
def
expensive_computation
():
print
(
"running expensive computation..."
)
@pytest
.
fixture
def
mydata
(
pytestconfig
):
val
=
pytestconfig
.
cache
.
get
(
"example/value"
,
None
)
if
val
is
None
:
expensive_computation
()
val
=
42
pytestconfig
.
cache
.
set
(
"example/value"
,
val
)
return
val
def
test_function
(
mydata
):
assert
mydata
==
23

```

If you run this command for the first time, you can see the print statement:

```

$ pytest -q
F
[100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
mydata = 42

    def test_function(mydata):
>       assert mydata == 23
E       assert 42 == 23
test_caching.py
:19: AssertionError
-------------------------- Captured stdout setup ---------------------------
running expensive computation...
========================= short test summary info ==========================
FAILED
test_caching.py::
test_function
- assert 42 == 23
1 failed
in 0.12s

```

If you run it a second time, the value will be retrieved from the cache and nothing will be printed:

```

$ pytest -q
F
[100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
mydata = 42

    def test_function(mydata):
>       assert mydata == 23
E       assert 42 == 23
test_caching.py
:19: AssertionError
========================= short test summary info ==========================
FAILED
test_caching.py::
test_function
- assert 42 == 23
1 failed
in 0.12s

```

See the config.cache fixture for more details.

# Inspecting Cache content¶

You can always peek at the content of the cache using the --cache-show command line option:

```

$ pytest --cache-show
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
cachedir: /home/sweet/project/.pytest_cache
--------------------------- cache values for '*' ---------------------------
cache/lastfailed contains:
  {'test_caching.py::test_function': True}
cache/nodeids contains:
  ['test_caching.py::test_function']
cache/stepwise contains:
  []
example/value contains:
  42
========================== no tests ran in 0.12s ===========================

```

--cache-show takes an optional argument to specify a glob pattern for filtering:

```

$ pytest --cache-show example/*
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
cachedir: /home/sweet/project/.pytest_cache
----------------------- cache values for 'example/*' -----------------------
example/value contains:
  42
========================== no tests ran in 0.12s ===========================

```

# Clearing Cache content¶

You can instruct pytest to clear all cache files and values by adding the --cache-clear option like this:

```

pytest
--cache-clear

```

This is recommended for invocations from Continuous Integration servers where isolation and correctness is more important than speed.

# Stepwise¶


---


# CI Pipelines - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/ci.html


# CI Pipelines¶

# Rationale¶

The goal of testing in a CI pipeline is different from testing locally. Indeed, you can quickly edit some code and run your tests again on your computer, but it is not possible with CI pipeline. They run on a separate server and are triggered by specific actions. From that observation, pytest can detect when it is in a CI environment and adapt some of its behaviours.

# How CI is detected¶

Pytest knows it is in a CI environment when either one of these environment variables are set, regardless of their value: CI : used by many CI systems. BUILD_NUMBER : used by Jenkins.

# Effects on CI¶

For now, the effects on pytest of being in a CI environment are limited. When a CI environment is detected, the output of the short test summary info is no longer truncated to the terminal size i.e. the entire message will be shown.

```

# content of test_ci.py
import
pytest
def
test_db_initialized
():
pytest
.
fail
(
"deliberately failing for demo purpose, Lorem ipsum dolor sit amet, "
"consectetur adipiscing elit. Cras facilisis, massa in suscipit "
"dignissim, mauris lacus molestie nisi, quis varius metus nulla ut ipsum."
)

```

Running this locally, without any extra options, will output:

```

$ pytest test_ci.py
...
========================= short test summary info ==========================
FAILED
test_backends.py::
test_db_initialized[d2]
- Failed: deliberately f...

```

(Note the truncated text) While running this on CI will output:

```

$ export CI=true
$ pytest test_ci.py
...
========================= short test summary info ==========================
FAILED
test_backends.py::
test_db_initialized[d2]
- Failed: deliberately failing
for demo purpose, Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras
facilisis, massa in suscipit dignissim, mauris lacus molestie nisi, quis varius
metus nulla ut ipsum.

```


---


# Anatomy of a test - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/anatomy.html


# Anatomy of a test¶


---


# How to mark test functions with attributes - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/mark.html


# How to mark test functions with attributes¶

By using the pytest.mark helper you can easily set metadata on your test functions. You can find the full list of builtin markers in the API Reference . Or you can list all the markers, including builtin and custom, using the CLI - pytest --markers . Here are some of the builtin markers: usefixtures - use fixtures on a test function or class filterwarnings - filter certain warnings of a test function skip - always skip a test function skipif - skip a test function if a certain condition is met xfail - produce an “expected failure” outcome if a certain condition is met parametrize - perform multiple calls to the same test function. It’s easy to create custom markers or to apply markers to whole test classes or modules. Those markers can be used by plugins, and also are commonly used to select tests on the command-line with the -m option. See Working with custom markers for examples which also serve as documentation. Note Marks can only be applied to tests, having no effect on fixtures .

# Registering marks¶

You can register custom marks in your pytest.ini file like this:

```

[pytest]
markers
=
slow
:
marks tests as slow (deselect with '-m "not slow"')
serial

```

or in your pyproject.toml file like this:

```

[tool.pytest.ini_options]
markers
=
[
"slow: marks tests as slow (deselect with '-m
\"
not slow
\"
')"
,
"serial"
,
]

```

Note that everything past the : after the mark name is an optional description. Alternatively, you can register new markers programmatically in a pytest_configure hook:

```

def
pytest_configure
(
config
):
config
.
addinivalue_line
(
"markers"
,
"env(name): mark test to run only on named environment"
)

```

Registered marks appear in pytest’s help text and do not emit warnings (see the next section). It is recommended that third-party plugins always register their markers .

# Raising errors on unknown marks¶

Unregistered marks applied with the @pytest.mark.name_of_the_mark decorator will always emit a warning in order to avoid silently doing something surprising due to mistyped names. As described in the previous section, you can disable the warning for custom marks by registering them in your pytest.ini file or using a custom pytest_configure hook. When the --strict-markers command-line flag is passed, any unknown marks applied with the @pytest.mark.name_of_the_mark decorator will trigger an error. You can enforce this validation in your project by adding --strict-markers to addopts :

```

[pytest]
addopts
=
--strict-markers
markers
=
slow
:
marks tests as slow (deselect with '-m "not slow"')
serial

```


---


# Typing in pytest - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/types.html


# Typing in pytest¶

Note This page assumes the reader is familiar with Python’s typing system and its advantages. For more information, refer to Python’s Typing Documentation .

# Why type tests?¶

Typing tests provides significant advantages: Readability: Clearly defines expected inputs and outputs, improving readability, especially in complex or parameterized tests. Refactoring: This is the main benefit in typing tests, as it will greatly help with refactoring, letting the type checker point out the necessary changes in both production and tests, without needing to run the full test suite. For production code, typing also helps catching some bugs that might not be caught by tests at all (regardless of coverage), for example:

```

def
get_caption
(
target
:
int
,
items
:
list
[
tuple
[
int
,
str
]])
->
str
:
for
value
,
caption
in
items
:
if
value
==
target
:
return
caption

```

The type checker will correctly error out that the function might return None , however even a full coverage test suite might miss that case:

```

def
test_get_caption
()
->
None
:
assert
get_caption
(
10
,
[(
1
,
"foo"
),
(
10
,
"bar"
)])
==
"bar"

```

Note the code above has 100% coverage, but the bug is not caught (of course the example is “obvious”, but serves to illustrate the point).

# Using typing in test suites¶

To type fixtures in pytest, just add normal types to the fixture functions – there is nothing special that needs to be done just because of the fixture decorator.

```

import
pytest
@pytest
.
fixture
def
sample_fixture
()
->
int
:
return
38

```

In the same manner, the fixtures passed to test functions need be annotated with the fixture’s return type:

```

def
test_sample_fixture
(
sample_fixture
:
int
)
->
None
:
assert
sample_fixture
==
38

```

From the POV of the type checker, it does not matter that sample_fixture is actually a fixture managed by pytest, all it matters to it is that sample_fixture is a parameter of type int . The same logic applies to @pytest.mark.parametrize :

```

@pytest
.
mark
.
parametrize
(
"input_value, expected_output"
,
[(
1
,
2
),
(
5
,
6
),
(
10
,
11
)])
def
test_increment
(
input_value
:
int
,
expected_output
:
int
)
->
None
:
assert
input_value
+
1
==
expected_output

```

The same logic applies when typing fixture functions which receive other fixtures:

```

@pytest
.
fixture
def
mock_env_user
(
monkeypatch
:
pytest
.
MonkeyPatch
)
->
None
:
monkeypatch
.
setenv
(
"USER"
,
"TestingUser"
)

```

# Conclusion¶


---


# Configuration - pytest documentation

URL: https://docs.pytest.org/en/stable/reference/customize.html


# Configuration¶

# Command line options and configuration file settings¶

You can get help on command line options and values in INI-style configurations files by using the general help option:

```

pytest
-h
# prints options _and_ config file settings

```

This will display command line and configuration file settings which were registered by installed plugins.

# Configuration file formats¶

Many pytest settings can be set in a configuration file , which by convention resides in the root directory of your repository. A quick example of the configuration files supported by pytest:

# pytest.ini¶

pytest.ini files take precedence over other files, even when empty. Alternatively, the hidden version .pytest.ini can be used.

```

# pytest.ini or .pytest.ini
[pytest]
minversion
=
6.0
addopts
=
-ra -q
testpaths
=
tests
integration

```

# pyproject.toml¶

Added in version 6.0. pyproject.toml are considered for configuration when they contain a tool.pytest.ini_options table.

```

# pyproject.toml
[tool.pytest.ini_options]
minversion
=
"6.0"
addopts
=
"-ra -q"
testpaths
=
[
"tests"
,
"integration"
,
]

```

Note One might wonder why [tool.pytest.ini_options] instead of [tool.pytest] as is the case with other tools. The reason is that the pytest team intends to fully utilize the rich TOML data format for configuration in the future, reserving the [tool.pytest] table for that. The ini_options table is being used, for now, as a bridge between the existing .ini configuration system and the future configuration format.

# tox.ini¶

tox.ini files are the configuration files of the tox project, and can also be used to hold pytest configuration if they have a [pytest] section.

```

# tox.ini
[pytest]
minversion
=
6.0
addopts
=
-ra -q
testpaths
=
tests
integration

```

# setup.cfg¶

setup.cfg files are general purpose configuration files, used originally by distutils (now deprecated) and setuptools , and can also be used to hold pytest configuration if they have a [tool:pytest] section.

```

# setup.cfg
[tool:pytest]
minversion
=
6.0
addopts
=
-ra -q
testpaths
=
tests
integration

```

Warning Usage of setup.cfg is not recommended unless for very simple use cases. .cfg files use a different parser than pytest.ini and tox.ini which might cause hard to track down problems. When possible, it is recommended to use the latter files, or pyproject.toml , to hold your pytest configuration.

# Initialization: determining rootdir and configfile¶

pytest determines a rootdir for each test run which depends on the command line arguments (specified test files, paths) and on the existence of configuration files. The determined rootdir and configfile are printed as part of the pytest header during startup. Here’s a summary what pytest uses rootdir for: Construct nodeids during collection; each test is assigned a unique nodeid which is rooted at the rootdir and takes into account the full path, class name, function name and parametrization (if any). Is used by plugins as a stable location to store project/test run specific information; for example, the internal cache plugin creates a .pytest_cache subdirectory in rootdir to store its cross-test run state. rootdir is NOT used to modify sys.path / PYTHONPATH or influence how modules are imported. See pytest import mechanisms and sys.path/PYTHONPATH for more details. The --rootdir=path command-line option can be used to force a specific directory. Note that contrary to other command-line options, --rootdir cannot be used with addopts inside pytest.ini because the rootdir is used to find pytest.ini already.

# Finding therootdir¶

Here is the algorithm which finds the rootdir from args : If -c is passed in the command-line, use that as configuration file, and its directory as rootdir . Determine the common ancestor directory for the specified args that are recognised as paths that exist in the file system. If no such paths are found, the common ancestor directory is set to the current working directory. Look for pytest.ini , pyproject.toml , tox.ini , and setup.cfg files in the ancestor directory and upwards. If one is matched, it becomes the configfile and its directory becomes the rootdir . If no configuration file was found, look for setup.py upwards from the common ancestor directory to determine the rootdir . If no setup.py was found, look for pytest.ini , pyproject.toml , tox.ini , and setup.cfg in each of the specified args and upwards. If one is matched, it becomes the configfile and its directory becomes the rootdir . If no configfile was found and no configuration argument is passed, use the already determined common ancestor as root directory. This allows the use of pytest in structures that are not part of a package and don’t have any particular configuration file. If no args are given, pytest collects test below the current working directory and also starts determining the rootdir from there. Files will only be matched for configuration if: pytest.ini : will always match and take precedence, even if empty. pyproject.toml : contains a [tool.pytest.ini_options] table. tox.ini : contains a [pytest] section. setup.cfg : contains a [tool:pytest] section. Finally, a pyproject.toml file will be considered the configfile if no other match was found, in this case even if it does not contain a [tool.pytest.ini_options] table (this was added in 8.1 ). The files are considered in the order above. Options from multiple configfiles candidates are never merged - the first match wins. The configuration file also determines the value of the rootpath . The Config object (accessible via hooks or through the pytestconfig fixture) will subsequently carry these attributes: config.rootpath : the determined root directory, guaranteed to exist. It is used as a reference directory for constructing test addresses (“nodeids”) and can be used also by plugins for storing per-testrun information. config.inipath : the determined configfile , may be None (it is named inipath for historical reasons). Added in version 6.1: The config.rootpath and config.inipath properties. They are pathlib.Path versions of the older config.rootdir and config.inifile , which have type py.path.local , and still exist for backward compatibility. Example:

```

pytest
path/to/testdir
path/other/

```

will determine the common ancestor as path and then check for configuration files as follows:

```

# first look for pytest.ini files
path/pytest.ini
path/pyproject.toml  # must contain a [tool.pytest.ini_options] table to match
path/tox.ini         # must contain [pytest] section to match
path/setup.cfg       # must contain [tool:pytest] section to match
pytest.ini
... # all the way up to the root

# now look for setup.py
path/setup.py
setup.py
... # all the way up to the root

```

Warning Custom pytest plugin commandline arguments may include a path, as in pytest --log-output ../../test.log args . Then args is mandatory, otherwise pytest uses the folder of test.log for rootdir determination (see also #1435 ). A dot . for referencing to the current working directory is also possible.

# Builtin configuration file options¶

For the full list of options consult the reference documentation .

# Syntax highlighting theme customization¶


---


# How to capture warnings - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/capture-warnings.html


# How to capture warnings¶

Starting from version 3.1 , pytest now automatically catches warnings during test execution and displays them at the end of the session:

```

# content of test_show_warnings.py
import
warnings
def
api_v1
():
warnings
.
warn
(
UserWarning
(
"api v1, should use functions from v2"
))
return
1
def
test_one
():
assert
api_v1
()
==
1

```

Running pytest now produces this output:

```

$ pytest test_show_warnings.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_show_warnings.py
.
[100%]
============================= warnings summary =============================
test_show_warnings.py::test_one
  /home/sweet/project/test_show_warnings.py:5: UserWarning: api v1, should use functions from v2
    warnings.warn(UserWarning("api v1, should use functions from v2"))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=======================
1 passed
,
1 warning
in 0.12s =======================

```

# Controlling warnings¶

Similar to Python’s warning filter and -W option flag, pytest provides its own -W flag to control which warnings are ignored, displayed, or turned into errors. See the warning filter documentation for more advanced use-cases. This code sample shows how to treat any UserWarning category class of warning as an error:

```

$ pytest -q test_show_warnings.py -W error::UserWarning
F
[100%]
================================= FAILURES =================================
_________________________________ test_one _________________________________
def test_one():
>       assert api_v1() == 1
test_show_warnings.py
:10:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
def api_v1():
>       warnings.warn(UserWarning("api v1, should use functions from v2"))
E       UserWarning: api v1, should use functions from v2
test_show_warnings.py
:5: UserWarning
========================= short test summary info ==========================
FAILED
test_show_warnings.py::
test_one
- UserWarning: api v1, should use ...
1 failed
in 0.12s

```

The same option can be set in the pytest.ini or pyproject.toml file using the filterwarnings ini option. For example, the configuration below will ignore all user warnings and specific deprecation warnings matching a regex, but will transform all other warnings into errors.

```

# pytest.ini
[pytest]
filterwarnings
=
error
ignore
:
:UserWarning
ignore
:
function ham\(\) is deprecated:DeprecationWarning

```

```

# pyproject.toml
[tool.pytest.ini_options]
filterwarnings
=
[
"error"
,
"ignore::UserWarning"
,
# note the use of single quote below to denote "raw" strings in TOML
'ignore:function ham\(\) is deprecated:DeprecationWarning'
,
]

```

When a warning matches more than one option in the list, the action for the last matching option is performed. Note The -W flag and the filterwarnings ini option use warning filters that are similar in structure, but each configuration option interprets its filter differently. For example, message in filterwarnings is a string containing a regular expression that the start of the warning message must match, case-insensitively, while message in -W is a literal string that the start of the warning message must contain (case-insensitively), ignoring any whitespace at the start or end of message. Consult the warning filter documentation for more details.

# @pytest.mark.filterwarnings¶

You can use the @pytest.mark.filterwarnings mark to add warning filters to specific test items, allowing you to have finer control of which warnings should be captured at test, class or even module level:

```

import
warnings
def
api_v1
():
warnings
.
warn
(
UserWarning
(
"api v1, should use functions from v2"
))
return
1
@pytest
.
mark
.
filterwarnings
(
"ignore:api v1"
)
def
test_one
():
assert
api_v1
()
==
1

```

You can specify multiple filters with separate decorators:

```

# Ignore "api v1" warnings, but fail on all other warnings
@pytest
.
mark
.
filterwarnings
(
"ignore:api v1"
)
@pytest
.
mark
.
filterwarnings
(
"error"
)
def
test_one
():
assert
api_v1
()
==
1

```

Important Regarding decorator order and filter precedence: it’s important to remember that decorators are evaluated in reverse order, so you have to list the warning filters in the reverse order compared to traditional warnings.filterwarnings() and -W option usage. This means in practice that filters from earlier @pytest.mark.filterwarnings decorators take precedence over filters from later decorators, as illustrated in the example above. Filters applied using a mark take precedence over filters passed on the command line or configured by the filterwarnings ini option. You may apply a filter to all tests of a class by using the filterwarnings mark as a class decorator or to all tests in a module by setting the pytestmark variable:

```

# turns all warnings into errors for this module
pytestmark
=
pytest
.
mark
.
filterwarnings
(
"error"
)

```

Note If you want to apply multiple filters (by assigning a list of filterwarnings mark to pytestmark ), you must use the traditional warnings.filterwarnings() ordering approach (later filters take precedence), which is the reverse of the decorator approach mentioned above. Credits go to Florian Schulze for the reference implementation in the pytest-warnings plugin.

# Disabling warnings summary¶

Although not recommended, you can use the --disable-warnings command-line option to suppress the warning summary entirely from the test run output.

# Disabling warning capture entirely¶

This plugin is enabled by default but can be disabled entirely in your pytest.ini file with:

```

[pytest]
addopts
=
-p no:warnings

```

Or passing -p no:warnings in the command-line. This might be useful if your test suites handles warnings using an external system.

# DeprecationWarning and PendingDeprecationWarning¶

By default pytest will display DeprecationWarning and PendingDeprecationWarning warnings from user code and third-party libraries, as recommended by PEP 565 . This helps users keep their code modern and avoid breakages when deprecated warnings are effectively removed. However, in the specific case where users capture any type of warnings in their test, either with pytest.warns() , pytest.deprecated_call() or using the recwarn fixture, no warning will be displayed at all. Sometimes it is useful to hide some specific deprecation warnings that happen in code that you have no control over (such as third-party libraries), in which case you might use the warning filters options (ini or marks) to ignore those warnings. For example:

```

[pytest]
filterwarnings
=
ignore
:
.*U.*mode is deprecated:DeprecationWarning

```

This will ignore all warnings of type DeprecationWarning where the start of the message matches the regular expression ".*U.*mode is deprecated" . See @pytest.mark.filterwarnings and Controlling warnings for more examples. Note If warnings are configured at the interpreter level, using the PYTHONWARNINGS environment variable or the -W command-line option, pytest will not configure any filters by default. Also pytest doesn’t follow PEP 506 suggestion of resetting all warning filters because it might break test suites that configure warning filters themselves by calling warnings.simplefilter() (see #2430 for an example of that).

# Ensuring code triggers a deprecation warning¶

You can also use pytest.deprecated_call() for checking that a certain function call triggers a DeprecationWarning or PendingDeprecationWarning :

```

import
pytest
def
test_myfunction_deprecated
():
with
pytest
.
deprecated_call
():
myfunction
(
17
)

```

This test will fail if myfunction does not issue a deprecation warning when called with a 17 argument.

# Asserting warnings with the warns function¶

You can check that code raises a particular warning using pytest.warns() , which works in a similar manner to raises (except that raises does not capture all exceptions, only the expected_exception ):

```

import
warnings
import
pytest
def
test_warning
():
with
pytest
.
warns
(
UserWarning
):
warnings
.
warn
(
"my warning"
,
UserWarning
)

```

The test will fail if the warning in question is not raised. Use the keyword argument match to assert that the warning matches a text or regex. To match a literal string that may contain regular expression metacharacters like ( or . , the pattern can first be escaped with re.escape . Some examples:

```

>>>
with
warns
(
UserWarning
,
match
=
"must be 0 or None"
):
...
warnings
.
warn
(
"value must be 0 or None"
,
UserWarning
)
...
>>>
with
warns
(
UserWarning
,
match
=
r
"must be \d+$"
):
...
warnings
.
warn
(
"value must be 42"
,
UserWarning
)
...
>>>
with
warns
(
UserWarning
,
match
=
r
"must be \d+$"
):
...
warnings
.
warn
(
"this is not here"
,
UserWarning
)
...
Traceback (most recent call last):
...
Failed
:
DID NOT WARN. No warnings of type ...UserWarning... were emitted...
>>>
with
warns
(
UserWarning
,
match
=
re
.
escape
(
"issue with foo() func"
)):
...
warnings
.
warn
(
"issue with foo() func"
)
...

```

You can also call pytest.warns() on a function or code string:

```

pytest
.
warns
(
expected_warning
,
func
,
*
args
,
**
kwargs
)
pytest
.
warns
(
expected_warning
,
"func(*args, **kwargs)"
)

```

The function also returns a list of all raised warnings (as warnings.WarningMessage objects), which you can query for additional information:

```

with
pytest
.
warns
(
RuntimeWarning
)
as
record
:
warnings
.
warn
(
"another warning"
,
RuntimeWarning
)
# check that only one warning was raised
assert
len
(
record
)
==
1
# check that the message matches
assert
record
[
0
]
.
message
.
args
[
0
]
==
"another warning"

```

Alternatively, you can examine raised warnings in detail using the recwarn fixture (see below ). The recwarn fixture automatically ensures to reset the warnings filter at the end of the test, so no global state is leaked.

# Recording warnings¶

You can record raised warnings either using the pytest.warns() context manager or with the recwarn fixture. To record with pytest.warns() without asserting anything about the warnings, pass no arguments as the expected warning type and it will default to a generic Warning:

```

with
pytest
.
warns
()
as
record
:
warnings
.
warn
(
"user"
,
UserWarning
)
warnings
.
warn
(
"runtime"
,
RuntimeWarning
)
assert
len
(
record
)
==
2
assert
str
(
record
[
0
]
.
message
)
==
"user"
assert
str
(
record
[
1
]
.
message
)
==
"runtime"

```

The recwarn fixture will record warnings for the whole function:

```

import
warnings
def
test_hello
(
recwarn
):
warnings
.
warn
(
"hello"
,
UserWarning
)
assert
len
(
recwarn
)
==
1
w
=
recwarn
.
pop
(
UserWarning
)
assert
issubclass
(
w
.
category
,
UserWarning
)
assert
str
(
w
.
message
)
==
"hello"
assert
w
.
filename
assert
w
.
lineno

```

Both the recwarn fixture and the pytest.warns() context manager return the same interface for recorded warnings: a WarningsRecorder instance. To view the recorded warnings, you can iterate over this instance, call len on it to get the number of recorded warnings, or index into it to get a particular recorded warning.

# Additional use cases of warnings in tests¶

Here are some use cases involving warnings that often come up in tests, and suggestions on how to deal with them: To ensure that at least one of the indicated warnings is issued, use:

```

def
test_warning
():
with
pytest
.
warns
((
RuntimeWarning
,
UserWarning
)):
...

```

To ensure that only certain warnings are issued, use:

```

def
test_warning
(
recwarn
):
...
assert
len
(
recwarn
)
==
1
user_warning
=
recwarn
.
pop
(
UserWarning
)
assert
issubclass
(
user_warning
.
category
,
UserWarning
)

```

To ensure that no warnings are emitted, use:

```

def
test_warning
():
with
warnings
.
catch_warnings
():
warnings
.
simplefilter
(
"error"
)
...

```

To suppress warnings, use:

```

with
warnings
.
catch_warnings
():
warnings
.
simplefilter
(
"ignore"
)
...

```

# Custom failure messages¶

Recording warnings provides an opportunity to produce custom test failure messages for when no warnings are issued or other conditions are met.

```

def
test
():
with
pytest
.
warns
(
Warning
)
as
record
:
f
()
if
not
record
:
pytest
.
fail
(
"Expected a warning!"
)

```

If no warnings are issued when calling f , then not record will evaluate to True . You can then call pytest.fail() with a custom error message.

# Internal pytest warnings¶

pytest may generate its own warnings in some situations, such as improper usage or deprecated features. For example, pytest will emit a warning if it encounters a class that matches python_classes but also defines an __init__ constructor, as this prevents the class from being instantiated:

```

# content of test_pytest_warnings.py
class
Test
:
def
__init__
(
self
):
pass
def
test_foo
(
self
):
assert
1
==
1

```

```

$ pytest test_pytest_warnings.py -q
============================= warnings summary =============================
test_pytest_warnings.py:1
  /home/sweet/project/test_pytest_warnings.py:1: PytestCollectionWarning: cannot collect test class 'Test' because it has a __init__ constructor (from: test_pytest_warnings.py)
    class Test:

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
1 warning
in 0.12s

```

These warnings might be filtered using the same builtin mechanisms used to filter other types of warnings. Please read our Backwards Compatibility Policy to learn how we proceed about deprecating and eventually removing features. The full list of warnings is listed in the reference documentation .

# Resource Warnings¶


---


# Working with custom markers - pytest documentation

URL: https://docs.pytest.org/en/stable/example/markers.html


# Working with custom markers¶

Here are some examples using the How to mark test functions with attributes mechanism.

# Marking test functions and selecting them for a run¶

You can “mark” a test function with custom metadata like this:

```

# content of test_server.py
import
pytest
@pytest
.
mark
.
webtest
def
test_send_http
():
pass
# perform some webtest test for your app
@pytest
.
mark
.
device
(
serial
=
"123"
)
def
test_something_quick
():
pass
@pytest
.
mark
.
device
(
serial
=
"abc"
)
def
test_another
():
pass
class
TestClass
:
def
test_method
(
self
):
pass

```

You can then restrict a test run to only run tests marked with webtest :

```

$ pytest -v -m webtest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 4 items / 3 deselected / 1 selected

test_server.py::test_send_http
PASSED
[100%]
=====================
1 passed
,
3 deselected
in 0.12s ======================

```

Or the inverse, running all tests except the webtest ones:

```

$ pytest -v -m "not webtest"
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 4 items / 1 deselected / 3 selected

test_server.py::test_something_quick
PASSED
[ 33%]
test_server.py::test_another
PASSED
[ 66%]
test_server.py::TestClass::test_method
PASSED
[100%]
=====================
3 passed
,
1 deselected
in 0.12s ======================

```

Additionally, you can restrict a test run to only run tests matching one or multiple marker keyword arguments, e.g. to run only tests marked with device and the specific serial="123" :

```

$ pytest -v -m "device(serial='123')"
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 4 items / 3 deselected / 1 selected

test_server.py::test_something_quick
PASSED
[100%]
=====================
1 passed
,
3 deselected
in 0.12s ======================

```

Note Only keyword argument matching is supported in marker expressions. Note Only int , (unescaped) str , bool & None values are supported in marker expressions.

# Selecting tests based on their node ID¶

You can provide one or more node IDs as positional arguments to select only specified tests. This makes it easy to select tests based on their module, class, method, or function name:

```

$ pytest -v test_server.py::TestClass::test_method
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 1 item

test_server.py::TestClass::test_method
PASSED
[100%]
============================
1 passed
in 0.12s =============================

```

You can also select on the class:

```

$ pytest -v test_server.py::TestClass
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 1 item

test_server.py::TestClass::test_method
PASSED
[100%]
============================
1 passed
in 0.12s =============================

```

Or select multiple nodes:

```

$ pytest -v test_server.py::TestClass test_server.py::test_send_http
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 2 items

test_server.py::TestClass::test_method
PASSED
[ 50%]
test_server.py::test_send_http
PASSED
[100%]
============================
2 passed
in 0.12s =============================

```

Note Node IDs are of the form module.py::class::method or module.py::function . Node IDs control which tests are collected, so module.py::class will select all test methods on the class. Nodes are also created for each parameter of a parametrized fixture or test, so selecting a parametrized test must include the parameter value, e.g. module.py::function[param] . Node IDs for failing tests are displayed in the test summary info when running pytest with the -rf option. You can also construct Node IDs from the output of pytest --collect-only .

# Using-kexprto select tests based on their name¶

Added in version 2.0/2.3.4. You can use the -k command line option to specify an expression which implements a substring match on the test names instead of the exact match on markers that -m provides. This makes it easy to select tests based on their names: Changed in version 5.4. The expression matching is now case-insensitive.

```

$ pytest -v -k http  # running with the above defined example module
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 4 items / 3 deselected / 1 selected

test_server.py::test_send_http
PASSED
[100%]
=====================
1 passed
,
3 deselected
in 0.12s ======================

```

And you can also run all tests except the ones that match the keyword:

```

$ pytest -k "not send_http" -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 4 items / 1 deselected / 3 selected

test_server.py::test_something_quick
PASSED
[ 33%]
test_server.py::test_another
PASSED
[ 66%]
test_server.py::TestClass::test_method
PASSED
[100%]
=====================
3 passed
,
1 deselected
in 0.12s ======================

```

Or to select “http” and “quick” tests:

```

$ pytest -k "http or quick" -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 4 items / 2 deselected / 2 selected

test_server.py::test_send_http
PASSED
[ 50%]
test_server.py::test_something_quick
PASSED
[100%]
=====================
2 passed
,
2 deselected
in 0.12s ======================

```

You can use and , or , not and parentheses. In addition to the test’s name, -k also matches the names of the test’s parents (usually, the name of the file and class it’s in), attributes set on the test function, markers applied to it or its parents and any extra keywords explicitly added to it or its parents.

# Registering markers¶

Registering markers for your test suite is simple:

```

# content of pytest.ini
[pytest]
markers
=
webtest
:
mark a test as a webtest.
slow
:
mark test as slow.

```

Multiple custom markers can be registered, by defining each one in its own line, as shown in above example. You can ask which markers exist for your test suite - the list includes our just defined webtest and slow markers:

```

$ pytest --markers
@pytest.mark.webtest: mark a test as a webtest.

@pytest.mark.slow: mark test as slow.

@pytest.mark.filterwarnings(warning): add a warning filter to the given test. see https://docs.pytest.org/en/stable/how-to/capture-warnings.html#pytest-mark-filterwarnings

@pytest.mark.skip(reason=None): skip the given test function with an optional reason. Example: skip(reason="no way of currently testing this") skips the test.

@pytest.mark.skipif(condition, ..., *, reason=...): skip the given test function if any of the conditions evaluate to True. Example: skipif(sys.platform == 'win32') skips the test if we are on the win32 platform. See https://docs.pytest.org/en/stable/reference/reference.html#pytest-mark-skipif

@pytest.mark.xfail(condition, ..., *, reason=..., run=True, raises=None, strict=xfail_strict): mark the test function as an expected failure if any of the conditions evaluate to True. Optionally specify a reason for better reporting and run=False if you don't even want to execute the test function. If only specific exception(s) are expected, you can list them in raises, and if the test fails in other ways, it will be reported as a true failure. See https://docs.pytest.org/en/stable/reference/reference.html#pytest-mark-xfail

@pytest.mark.parametrize(argnames, argvalues): call a test function multiple times passing in different arguments in turn. argvalues generally needs to be a list of values if argnames specifies only one name or a list of tuples of values if argnames specifies multiple names. Example: @parametrize('arg1', [1,2]) would lead to two calls of the decorated test function, one with arg1=1 and another with arg1=2.see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info and examples.

@pytest.mark.usefixtures(fixturename1, fixturename2, ...): mark tests as needing all of the specified fixtures. see https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures

@pytest.mark.tryfirst: mark a hook implementation function such that the plugin machinery will try to call it first/as early as possible. DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead.

@pytest.mark.trylast: mark a hook implementation function such that the plugin machinery will try to call it last/as late as possible. DEPRECATED, use @pytest.hookimpl(trylast=True) instead.

```

For an example on how to add and work with markers from a plugin, see Custom marker and command line option to control test runs . Note It is recommended to explicitly register markers so that: There is one place in your test suite defining your markers Asking for existing markers via pytest --markers gives good output Typos in function markers are treated as an error if you use the --strict-markers option.

# Marking whole classes or modules¶

You may use pytest.mark decorators with classes to apply markers to all of its test methods:

```

# content of test_mark_classlevel.py
import
pytest
@pytest
.
mark
.
webtest
class
TestClass
:
def
test_startup
(
self
):
pass
def
test_startup_and_more
(
self
):
pass

```

This is equivalent to directly applying the decorator to the two test functions. To apply marks at the module level, use the pytestmark global variable:

```

import
pytest
pytestmark
=
pytest
.
mark
.
webtest

```

or multiple markers:

```

pytestmark
=
[
pytest
.
mark
.
webtest
,
pytest
.
mark
.
slowtest
]

```

Due to legacy reasons, before class decorators were introduced, it is possible to set the pytestmark attribute on a test class like this:

```

import
pytest
class
TestClass
:
pytestmark
=
pytest
.
mark
.
webtest

```

# Marking individual tests when using parametrize¶

When using parametrize, applying a mark will make it apply to each individual test. However it is also possible to apply a marker to an individual test instance:

```

import
pytest
@pytest
.
mark
.
foo
@pytest
.
mark
.
parametrize
(
(
"n"
,
"expected"
),
[(
1
,
2
),
pytest
.
param
(
1
,
3
,
marks
=
pytest
.
mark
.
bar
),
(
2
,
3
)]
)
def
test_increment
(
n
,
expected
):
assert
n
+
1
==
expected

```

In this example the mark “foo” will apply to each of the three tests, whereas the “bar” mark is only applied to the second test. Skip and xfail marks can also be applied in this way, see Skip/xfail with parametrize .

# Custom marker and command line option to control test runs¶

Plugins can provide custom markers and implement specific behaviour based on it. This is a self-contained example which adds a command line option and a parametrized test function marker to run tests specified via named environments:

```

# content of conftest.py
import
pytest
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"-E"
,
action
=
"store"
,
metavar
=
"NAME"
,
help
=
"only run tests matching the environment NAME."
,
)
def
pytest_configure
(
config
):
# register an additional marker
config
.
addinivalue_line
(
"markers"
,
"env(name): mark test to run only on named environment"
)
def
pytest_runtest_setup
(
item
):
envnames
=
[
mark
.
args
[
0
]
for
mark
in
item
.
iter_markers
(
name
=
"env"
)]
if
envnames
:
if
item
.
config
.
getoption
(
"-E"
)
not
in
envnames
:
pytest
.
skip
(
f
"test requires env in
{
envnames
!r}
"
)

```

A test file using this local plugin:

```

# content of test_someenv.py
import
pytest
@pytest
.
mark
.
env
(
"stage1"
)
def
test_basic_db_operation
():
pass

```

and an example invocations specifying a different environment than what the test needs:

```

$ pytest -E stage2
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_someenv.py
s
[100%]
============================
1 skipped
in 0.12s ============================

```

and here is one that specifies exactly the environment needed:

```

$ pytest -E stage1
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_someenv.py
.
[100%]
============================
1 passed
in 0.12s =============================

```

The --markers option always gives you a list of available markers:

```

$ pytest --markers
@pytest.mark.env(name): mark test to run only on named environment

@pytest.mark.filterwarnings(warning): add a warning filter to the given test. see https://docs.pytest.org/en/stable/how-to/capture-warnings.html#pytest-mark-filterwarnings

@pytest.mark.skip(reason=None): skip the given test function with an optional reason. Example: skip(reason="no way of currently testing this") skips the test.

@pytest.mark.skipif(condition, ..., *, reason=...): skip the given test function if any of the conditions evaluate to True. Example: skipif(sys.platform == 'win32') skips the test if we are on the win32 platform. See https://docs.pytest.org/en/stable/reference/reference.html#pytest-mark-skipif

@pytest.mark.xfail(condition, ..., *, reason=..., run=True, raises=None, strict=xfail_strict): mark the test function as an expected failure if any of the conditions evaluate to True. Optionally specify a reason for better reporting and run=False if you don't even want to execute the test function. If only specific exception(s) are expected, you can list them in raises, and if the test fails in other ways, it will be reported as a true failure. See https://docs.pytest.org/en/stable/reference/reference.html#pytest-mark-xfail

@pytest.mark.parametrize(argnames, argvalues): call a test function multiple times passing in different arguments in turn. argvalues generally needs to be a list of values if argnames specifies only one name or a list of tuples of values if argnames specifies multiple names. Example: @parametrize('arg1', [1,2]) would lead to two calls of the decorated test function, one with arg1=1 and another with arg1=2.see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info and examples.

@pytest.mark.usefixtures(fixturename1, fixturename2, ...): mark tests as needing all of the specified fixtures. see https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures

@pytest.mark.tryfirst: mark a hook implementation function such that the plugin machinery will try to call it first/as early as possible. DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead.

@pytest.mark.trylast: mark a hook implementation function such that the plugin machinery will try to call it last/as late as possible. DEPRECATED, use @pytest.hookimpl(trylast=True) instead.

```

# Passing a callable to custom markers¶

Below is the config file that will be used in the next examples:

```

# content of conftest.py
import
sys
def
pytest_runtest_setup
(
item
):
for
marker
in
item
.
iter_markers
(
name
=
"my_marker"
):
print
(
marker
)
sys
.
stdout
.
flush
()

```

A custom marker can have its argument set, i.e. args and kwargs properties, defined by either invoking it as a callable or using pytest.mark.MARKER_NAME.with_args . These two methods achieve the same effect most of the time. However, if there is a callable as the single positional argument with no keyword arguments, using the pytest.mark.MARKER_NAME(c) will not pass c as a positional argument but decorate c with the custom marker (see MarkDecorator ). Fortunately, pytest.mark.MARKER_NAME.with_args comes to the rescue:

```

# content of test_custom_marker.py
import
pytest
def
hello_world
(
*
args
,
**
kwargs
):
return
"Hello World"
@pytest
.
mark
.
my_marker
.
with_args
(
hello_world
)
def
test_with_args
():
pass

```

The output is as follows:

```

$ pytest -q -s
Mark(name='my_marker', args=(<function hello_world at 0xdeadbeef0001>,), kwargs={})
.
1 passed
in 0.12s

```

We can see that the custom marker has its argument set extended with the function hello_world . This is the key difference between creating a custom marker as a callable, which invokes __call__ behind the scenes, and using with_args .

# Reading markers which were set from multiple places¶

If you are heavily using markers in your test suite you may encounter the case where a marker is applied several times to a test function. From plugin code you can read over all such settings. Example:

```

# content of test_mark_three_times.py
import
pytest
pytestmark
=
pytest
.
mark
.
glob
(
"module"
,
x
=
1
)
@pytest
.
mark
.
glob
(
"class"
,
x
=
2
)
class
TestClass
:
@pytest
.
mark
.
glob
(
"function"
,
x
=
3
)
def
test_something
(
self
):
pass

```

Here we have the marker “glob” applied three times to the same test function. From a conftest file we can read it like this:

```

# content of conftest.py
import
sys
def
pytest_runtest_setup
(
item
):
for
mark
in
item
.
iter_markers
(
name
=
"glob"
):
print
(
f
"glob args=
{
mark
.
args
}
kwargs=
{
mark
.
kwargs
}
"
)
sys
.
stdout
.
flush
()

```

Let’s run this without capturing output and see what we get:

```

$ pytest -q -s
glob args=('function',) kwargs={'x': 3}
glob args=('class',) kwargs={'x': 2}
glob args=('module',) kwargs={'x': 1}
.
1 passed
in 0.12s

```

# Marking platform specific tests with pytest¶

Consider you have a test suite which marks tests for particular platforms, namely pytest.mark.darwin , pytest.mark.win32 etc. and you also have tests that run on all platforms and have no specific marker. If you now want to have a way to only run the tests for your particular platform, you could use the following plugin:

```

# content of conftest.py
#
import
sys
import
pytest
ALL
=
set
(
"darwin linux win32"
.
split
())
def
pytest_runtest_setup
(
item
):
supported_platforms
=
ALL
.
intersection
(
mark
.
name
for
mark
in
item
.
iter_markers
())
plat
=
sys
.
platform
if
supported_platforms
and
plat
not
in
supported_platforms
:
pytest
.
skip
(
f
"cannot run on platform
{
plat
}
"
)

```

then tests will be skipped if they were specified for a different platform. Let’s do a little test file to show how this looks like:

```

# content of test_plat.py
import
pytest
@pytest
.
mark
.
darwin
def
test_if_apple_is_evil
():
pass
@pytest
.
mark
.
linux
def
test_if_linux_works
():
pass
@pytest
.
mark
.
win32
def
test_if_win32_crashes
():
pass
def
test_runs_everywhere
():
pass

```

then you will see two tests skipped and two executed tests as expected:

```

$ pytest -rs # this option reports skip reasons
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items

test_plat.py
s
.
s
.
[100%]
========================= short test summary info ==========================
SKIPPED
[2] conftest.py:13: cannot run on platform linux
=======================
2 passed
,
2 skipped
in 0.12s =======================

```

Note that if you specify a platform via the marker-command line option like this:

```

$ pytest -m linux
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items / 3 deselected / 1 selected

test_plat.py
.
[100%]
=====================
1 passed
,
3 deselected
in 0.12s ======================

```

then the unmarked-tests will not be run. It is thus a way to restrict the run to the specific tests.

# Automatically adding markers based on test names¶

If you have a test suite where test function names indicate a certain type of test, you can implement a hook that automatically defines markers so that you can use the -m option with it. Let’s look at this test module:

```

# content of test_module.py
def
test_interface_simple
():
assert
0
def
test_interface_complex
():
assert
0
def
test_event_simple
():
assert
0
def
test_something_else
():
assert
0

```

We want to dynamically define two markers and can do it in a conftest.py plugin:

```

# content of conftest.py
import
pytest
def
pytest_collection_modifyitems
(
items
):
for
item
in
items
:
if
"interface"
in
item
.
nodeid
:
item
.
add_marker
(
pytest
.
mark
.
interface
)
elif
"event"
in
item
.
nodeid
:
item
.
add_marker
(
pytest
.
mark
.
event
)

```

We can now use the -m option to select one set:

```

$ pytest -m interface --tb=short
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items / 2 deselected / 2 selected

test_module.py
FF
[100%]
================================= FAILURES =================================
__________________________ test_interface_simple ___________________________
test_module.py
:4: in test_interface_simple
    assert 0
E   assert 0
__________________________ test_interface_complex __________________________
test_module.py
:8: in test_interface_complex
    assert 0
E   assert 0
========================= short test summary info ==========================
FAILED
test_module.py::
test_interface_simple
- assert 0
FAILED
test_module.py::
test_interface_complex
- assert 0
=====================
2 failed
,
2 deselected
in 0.12s ======================

```

or to select both “event” and “interface” tests:

```

$ pytest -m "interface or event" --tb=short
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 4 items / 1 deselected / 3 selected

test_module.py
FFF
[100%]
================================= FAILURES =================================
__________________________ test_interface_simple ___________________________
test_module.py
:4: in test_interface_simple
    assert 0
E   assert 0
__________________________ test_interface_complex __________________________
test_module.py
:8: in test_interface_complex
    assert 0
E   assert 0
____________________________ test_event_simple _____________________________
test_module.py
:12: in test_event_simple
    assert 0
E   assert 0
========================= short test summary info ==========================
FAILED
test_module.py::
test_interface_simple
- assert 0
FAILED
test_module.py::
test_interface_complex
- assert 0
FAILED
test_module.py::
test_event_simple
- assert 0
=====================
3 failed
,
1 deselected
in 0.12s ======================

```


---


# How to write and report assertions in tests - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/assert.html


# How to write and report assertions in tests¶

# Asserting with theassertstatement¶

pytest allows you to use the standard Python assert for verifying expectations and values in Python tests. For example, you can write the following:

```

# content of test_assert1.py
def
f
():
return
3
def
test_function
():
assert
f
()
==
4

```

to assert that your function returns a certain value. If this assertion fails you will see the return value of the function call:

```

$ pytest test_assert1.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_assert1.py
F
[100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
def test_function():
>       assert f() == 4
E       assert 3 == 4
E        +  where 3 = f()
test_assert1.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_assert1.py::
test_function
- assert 3 == 4
============================
1 failed
in 0.12s =============================

```

pytest has support for showing the values of the most common subexpressions including calls, attributes, comparisons, and binary and unary operators. (See Demo of Python failure reports with pytest ). This allows you to use the idiomatic python constructs without boilerplate code while not losing introspection information. If a message is specified with the assertion like this:

```

assert
a
%
2
==
0
,
"value was odd, should be even"

```

it is printed alongside the assertion introspection in the traceback. See Assertion introspection details for more information on assertion introspection.

# Assertions about expected exceptions¶

In order to write assertions about raised exceptions, you can use pytest.raises() as a context manager like this:

```

import
pytest
def
test_zero_division
():
with
pytest
.
raises
(
ZeroDivisionError
):
1
/
0

```

and if you need to have access to the actual exception info you may use:

```

def
test_recursion_depth
():
with
pytest
.
raises
(
RuntimeError
)
as
excinfo
:
def
f
():
f
()
f
()
assert
"maximum recursion"
in
str
(
excinfo
.
value
)

```

excinfo is an ExceptionInfo instance, which is a wrapper around the actual exception raised. The main attributes of interest are .type , .value and .traceback . Note that pytest.raises will match the exception type or any subclasses (like the standard except statement). If you want to check if a block of code is raising an exact exception type, you need to check that explicitly:

```

def
test_foo_not_implemented
():
def
foo
():
raise
NotImplementedError
with
pytest
.
raises
(
RuntimeError
)
as
excinfo
:
foo
()
assert
excinfo
.
type
is
RuntimeError

```

The pytest.raises() call will succeed, even though the function raises NotImplementedError , because NotImplementedError is a subclass of RuntimeError ; however the following assert statement will catch the problem.

# Matching exception messages¶

You can pass a match keyword parameter to the context-manager to test that a regular expression matches on the string representation of an exception (similar to the TestCase.assertRaisesRegex method from unittest ):

```

import
pytest
def
myfunc
():
raise
ValueError
(
"Exception 123 raised"
)
def
test_match
():
with
pytest
.
raises
(
ValueError
,
match
=
r
".* 123 .*"
):
myfunc
()

```

Notes: The match parameter is matched with the re.search() function, so in the above example match='123' would have worked as well. The match parameter also matches against PEP-678 __notes__ .

# Matching exception groups¶

You can also use the excinfo.group_contains() method to test for exceptions returned as part of an ExceptionGroup :

```

def
test_exception_in_group
():
with
pytest
.
raises
(
ExceptionGroup
)
as
excinfo
:
raise
ExceptionGroup
(
"Group message"
,
[
RuntimeError
(
"Exception 123 raised"
),
],
)
assert
excinfo
.
group_contains
(
RuntimeError
,
match
=
r
".* 123 .*"
)
assert
not
excinfo
.
group_contains
(
TypeError
)

```

The optional match keyword parameter works the same way as for pytest.raises() . By default group_contains() will recursively search for a matching exception at any level of nested ExceptionGroup instances. You can specify a depth keyword parameter if you only want to match an exception at a specific level; exceptions contained directly in the top ExceptionGroup would match depth=1 .

```

def
test_exception_in_group_at_given_depth
():
with
pytest
.
raises
(
ExceptionGroup
)
as
excinfo
:
raise
ExceptionGroup
(
"Group message"
,
[
RuntimeError
(),
ExceptionGroup
(
"Nested group"
,
[
TypeError
(),
],
),
],
)
assert
excinfo
.
group_contains
(
RuntimeError
,
depth
=
1
)
assert
excinfo
.
group_contains
(
TypeError
,
depth
=
2
)
assert
not
excinfo
.
group_contains
(
RuntimeError
,
depth
=
2
)
assert
not
excinfo
.
group_contains
(
TypeError
,
depth
=
1
)

```

# Alternate form (legacy)¶

There is an alternate form where you pass a function that will be executed, along *args and **kwargs , and pytest.raises() will execute the function with the arguments and assert that the given exception is raised:

```

def
func
(
x
):
if
x
<=
0
:
raise
ValueError
(
"x needs to be larger than zero"
)
pytest
.
raises
(
ValueError
,
func
,
x
=-
1
)

```

The reporter will provide you with helpful output in case of failures such as no exception or wrong exception . This form was the original pytest.raises() API, developed before the with statement was added to the Python language. Nowadays, this form is rarely used, with the context-manager form (using with ) being considered more readable. Nonetheless, this form is fully supported and not deprecated in any way.

# xfail mark and pytest.raises¶

It is also possible to specify a raises argument to pytest.mark.xfail , which checks that the test is failing in a more specific way than just having any exception raised:

```

def
f
():
raise
IndexError
()
@pytest
.
mark
.
xfail
(
raises
=
IndexError
)
def
test_f
():
f
()

```

This will only “xfail” if the test fails by raising IndexError or subclasses. Using pytest.mark.xfail with the raises parameter is probably better for something like documenting unfixed bugs (where the test describes what “should” happen) or bugs in dependencies. Using pytest.raises() is likely to be better for cases where you are testing exceptions your own code is deliberately raising, which is the majority of cases.

# Assertions about expected warnings¶

You can check that code raises a particular warning using pytest.warns .

# Making use of context-sensitive comparisons¶

pytest has rich support for providing context-sensitive information when it encounters comparisons. For example:

```

# content of test_assert2.py
def
test_set_comparison
():
set1
=
set
(
"1308"
)
set2
=
set
(
"8035"
)
assert
set1
==
set2

```

if you run this module:

```

$ pytest test_assert2.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_assert2.py
F
[100%]
================================= FAILURES =================================
___________________________ test_set_comparison ____________________________
def test_set_comparison():
        set1 = set("1308")
        set2 = set("8035")
>       assert set1 == set2
E       AssertionError: assert {'0', '1', '3', '8'} == {'0', '3', '5', '8'}
E
E         Extra items in the left set:
E         '1'
E         Extra items in the right set:
E         '5'
E         Use -v to get more diff
test_assert2.py
:4: AssertionError
========================= short test summary info ==========================
FAILED
test_assert2.py::
test_set_comparison
- AssertionError: assert {'0'...
============================
1 failed
in 0.12s =============================

```

Special comparisons are done for a number of cases: comparing long strings: a context diff is shown comparing long sequences: first failing indices comparing dicts: different entries See the reporting demo for many more examples.

# Defining your own explanation for failed assertions¶

It is possible to add your own detailed explanations by implementing the pytest_assertrepr_compare hook. Return explanation for comparisons in failing assert expressions. Return None for no custom explanation, otherwise return a list of strings. The strings will be joined by newlines but any newlines in a string will be escaped. Note that all but the first line will be indented slightly, the intention is for the first line to be a summary. config ( Config ) – The pytest config object. op ( str ) – The operator, e.g. "==" , "!=" , "not in" . left ( object ) – The left operand. right ( object ) – The right operand.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. As an example consider adding the following hook in a conftest.py file which provides an alternative explanation for Foo objects:

```

# content of conftest.py
from
test_foocompare
import
Foo
def
pytest_assertrepr_compare
(
op
,
left
,
right
):
if
isinstance
(
left
,
Foo
)
and
isinstance
(
right
,
Foo
)
and
op
==
"=="
:
return
[
"Comparing Foo instances:"
,
f
"   vals:
{
left
.
val
}
!=
{
right
.
val
}
"
,
]

```

now, given this test module:

```

# content of test_foocompare.py
class
Foo
:
def
__init__
(
self
,
val
):
self
.
val
=
val
def
__eq__
(
self
,
other
):
return
self
.
val
==
other
.
val
def
test_compare
():
f1
=
Foo
(
1
)
f2
=
Foo
(
2
)
assert
f1
==
f2

```

you can run the test module and get the custom output defined in the conftest file:

```

$ pytest -q test_foocompare.py
F
[100%]
================================= FAILURES =================================
_______________________________ test_compare _______________________________
def test_compare():
        f1 = Foo(1)
        f2 = Foo(2)
>       assert f1 == f2
E       assert Comparing Foo instances:
E            vals: 1 != 2
test_foocompare.py
:12: AssertionError
========================= short test summary info ==========================
FAILED
test_foocompare.py::
test_compare
- assert Comparing Foo instances:
1 failed
in 0.12s

```

# Assertion introspection details¶

Reporting details about a failing assertion is achieved by rewriting assert statements before they are run. Rewritten assert statements put introspection information into the assertion failure message. pytest only rewrites test modules directly discovered by its test collection process, so asserts in supporting modules which are not themselves test modules will not be rewritten . You can manually enable assertion rewriting for an imported module by calling register_assert_rewrite before you import it (a good place to do that is in your root conftest.py ). For further information, Benjamin Peterson wrote up Behind the scenes of pytest’s new assertion rewriting .

# Assertion rewriting caches files on disk¶

pytest will write back the rewritten modules to disk for caching. You can disable this behavior (for example to avoid leaving stale .pyc files around in projects that move files around a lot) by adding this to the top of your conftest.py file:

```

import
sys
sys
.
dont_write_bytecode
=
True

```

Note that you still get the benefits of assertion introspection, the only change is that the .pyc files won’t be cached on disk. Additionally, rewriting will silently skip caching if it cannot write new .pyc files, i.e. in a read-only filesystem or a zipfile.

# Disabling assert rewriting¶


---


# License - pytest documentation

URL: https://docs.pytest.org/en/stable/license.html


# License¶

Distributed under the terms of the MIT license, pytest is free and open source software.

```

The MIT License (MIT)

Copyright (c) 2004 Holger Krekel and others

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```


---


# How to manage logging - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/logging.html


# How to manage logging¶

pytest captures log messages of level WARNING or above automatically and displays them in their own section for each failed test in the same manner as captured stdout and stderr. Running without options:

```

pytest

```

Shows failed tests like so:

```

----------------------- Captured stdlog call ----------------------
test_reporting.py    26 WARNING  text going to logger
----------------------- Captured stdout call ----------------------
text going to stdout
----------------------- Captured stderr call ----------------------
text going to stderr
==================== 2 failed in 0.02 seconds =====================

```

By default each captured log message shows the module, line number, log level and message. If desired the log and date format can be specified to anything that the logging module supports by passing specific formatting options:

```

pytest
--log-format
=
"%(asctime)s %(levelname)s %(message)s"
\
--log-date-format
=
"%Y-%m-%d %H:%M:%S"

```

Shows failed tests like so:

```

----------------------- Captured stdlog call ----------------------
2010-04-10 14:48:44 WARNING text going to logger
----------------------- Captured stdout call ----------------------
text going to stdout
----------------------- Captured stderr call ----------------------
text going to stderr
==================== 2 failed in 0.02 seconds =====================

```

These options can also be customized through pytest.ini file:

```

[pytest]
log_format
=
%(asctime)s %(levelname)s %(message)s
log_date_format
=
%Y-%m-%d %H:%M:%S

```

Specific loggers can be disabled via --log-disable={logger_name} . This argument can be passed multiple times:

```

pytest
--log-disable
=
main
--log-disable
=
testing

```

Further it is possible to disable reporting of captured content (stdout, stderr and logs) on failed tests completely with:

```

pytest
--show-capture
=
no

```

# caplog fixture¶

Inside tests it is possible to change the log level for the captured log messages. This is supported by the caplog fixture:

```

def
test_foo
(
caplog
):
caplog
.
set_level
(
logging
.
INFO
)

```

By default the level is set on the root logger, however as a convenience it is also possible to set the log level of any logger:

```

def
test_foo
(
caplog
):
caplog
.
set_level
(
logging
.
CRITICAL
,
logger
=
"root.baz"
)

```

The log levels set are restored automatically at the end of the test. It is also possible to use a context manager to temporarily change the log level inside a with block:

```

def
test_bar
(
caplog
):
with
caplog
.
at_level
(
logging
.
INFO
):
pass

```

Again, by default the level of the root logger is affected but the level of any logger can be changed instead with:

```

def
test_bar
(
caplog
):
with
caplog
.
at_level
(
logging
.
CRITICAL
,
logger
=
"root.baz"
):
pass

```

Lastly all the logs sent to the logger during the test run are made available on the fixture in the form of both the logging.LogRecord instances and the final log text. This is useful for when you want to assert on the contents of a message:

```

def
test_baz
(
caplog
):
func_under_test
()
for
record
in
caplog
.
records
:
assert
record
.
levelname
!=
"CRITICAL"
assert
"wally"
not
in
caplog
.
text

```

For all the available attributes of the log records see the logging.LogRecord class. You can also resort to record_tuples if all you want to do is to ensure, that certain messages have been logged under a given logger name with a given severity and message:

```

def
test_foo
(
caplog
):
logging
.
getLogger
()
.
info
(
"boo
%s
"
,
"arg"
)
assert
caplog
.
record_tuples
==
[(
"root"
,
logging
.
INFO
,
"boo arg"
)]

```

You can call caplog.clear() to reset the captured log records in a test:

```

def
test_something_with_clearing_records
(
caplog
):
some_method_that_creates_log_records
()
caplog
.
clear
()
your_test_method
()
assert
[
"Foo"
]
==
[
rec
.
message
for
rec
in
caplog
.
records
]

```

The caplog.records attribute contains records from the current stage only, so inside the setup phase it contains only setup logs, same with the call and teardown phases. To access logs from other stages, use the caplog.get_records(when) method. As an example, if you want to make sure that tests which use a certain fixture never log any warnings, you can inspect the records for the setup and call stages during teardown like so:

```

@pytest
.
fixture
def
window
(
caplog
):
window
=
create_window
()
yield
window
for
when
in
(
"setup"
,
"call"
):
messages
=
[
x
.
message
for
x
in
caplog
.
get_records
(
when
)
if
x
.
levelno
==
logging
.
WARNING
]
if
messages
:
pytest
.
fail
(
f
"warning messages encountered during testing:
{
messages
}
"
)

```

The full API is available at pytest.LogCaptureFixture . Warning The caplog fixture adds a handler to the root logger to capture logs. If the root logger is modified during a test, for example with logging.config.dictConfig , this handler may be removed and cause no logs to be captured. To avoid this, ensure that any root logger configuration only adds to the existing handlers.

# Live Logs¶

By setting the log_cli configuration option to true , pytest will output logging records as they are emitted directly into the console. You can specify the logging level for which log records with equal or higher level are printed to the console by passing --log-cli-level . This setting accepts the logging level names or numeric values as seen in logging’s documentation . Additionally, you can also specify --log-cli-format and --log-cli-date-format which mirror and default to --log-format and --log-date-format if not provided, but are applied only to the console logging handler. All of the CLI log options can also be set in the configuration INI file. The option names are: log_cli_level log_cli_format log_cli_date_format If you need to record the whole test suite logging calls to a file, you can pass --log-file=/path/to/log/file . This log file is opened in write mode by default which means that it will be overwritten at each run tests session. If you’d like the file opened in append mode instead, then you can pass --log-file-mode=a . Note that relative paths for the log-file location, whether passed on the CLI or declared in a config file, are always resolved relative to the current working directory. You can also specify the logging level for the log file by passing --log-file-level . This setting accepts the logging level names or numeric values as seen in logging’s documentation . Additionally, you can also specify --log-file-format and --log-file-date-format which are equal to --log-format and --log-date-format but are applied to the log file logging handler. All of the log file options can also be set in the configuration INI file. The option names are: log_file log_file_mode log_file_level log_file_format log_file_date_format You can call set_log_path() to customize the log_file path dynamically. This functionality is considered experimental . Note that set_log_path() respects the log_file_mode option.

# Customizing Colors¶

Log levels are colored if colored terminal output is enabled. Changing from default colors or putting color on custom log levels is supported through add_color_level() . Example:

```

@pytest
.
hookimpl
(
trylast
=
True
)
def
pytest_configure
(
config
):
logging_plugin
=
config
.
pluginmanager
.
get_plugin
(
"logging-plugin"
)
# Change color on existing log level
logging_plugin
.
log_cli_handler
.
formatter
.
add_color_level
(
logging
.
INFO
,
"cyan"
)
# Add color to a custom log level (a custom log level `SPAM` is already set up)
logging_plugin
.
log_cli_handler
.
formatter
.
add_color_level
(
logging
.
SPAM
,
"blue"
)

```

Warning This feature and its API are considered experimental and might change between releases without a deprecation notice.

# Release notes¶

This feature was introduced as a drop-in replacement for the pytest-catchlog plugin and they conflict with each other. The backward compatibility API with pytest-capturelog has been dropped when this feature was introduced, so if for that reason you still need pytest-catchlog you can disable the internal feature by adding to your pytest.ini :

```

[pytest]
addopts
=
-p no:logging

```

# Incompatible changes in pytest 3.4¶

This feature was introduced in 3.3 and some incompatible changes have been made in 3.4 after community feedback: Log levels are no longer changed unless explicitly requested by the log_level configuration or --log-level command-line options. This allows users to configure logger objects themselves. Setting log_level will set the level that is captured globally so if a specific test requires a lower level than this, use the caplog.set_level() functionality otherwise that test will be prone to failure. Live Logs is now disabled by default and can be enabled setting the log_cli configuration option to true . When enabled, the verbosity is increased so logging for each test is visible. Live Logs are now sent to sys.stdout and no longer require the -s command-line option to work. If you want to partially restore the logging behavior of version 3.3 , you can add this options to your ini file:

```

[pytest]
log_cli
=
true
log_level
=
NOTSET

```


---


# Explanation - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/index.html


# Explanation¶


---


# How to use temporary directories and files in tests - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/tmp_path.html


# How to use temporary directories and files in tests¶

# Thetmp_pathfixture¶

You can use the tmp_path fixture which will provide a temporary directory unique to each test function. tmp_path is a pathlib.Path object. Here is an example test usage:

```

# content of test_tmp_path.py
CONTENT
=
"content"
def
test_create_file
(
tmp_path
):
d
=
tmp_path
/
"sub"
d
.
mkdir
()
p
=
d
/
"hello.txt"
p
.
write_text
(
CONTENT
,
encoding
=
"utf-8"
)
assert
p
.
read_text
(
encoding
=
"utf-8"
)
==
CONTENT
assert
len
(
list
(
tmp_path
.
iterdir
()))
==
1
assert
0

```

Running this would result in a passed test except for the last assert 0 line which we use to look at values:

```

$ pytest test_tmp_path.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_tmp_path.py
F
[100%]
================================= FAILURES =================================
_____________________________ test_create_file _____________________________
tmp_path = PosixPath('PYTEST_TMPDIR/test_create_file0')

    def test_create_file(tmp_path):
        d = tmp_path / "sub"
        d.mkdir()
        p = d / "hello.txt"
        p.write_text(CONTENT, encoding="utf-8")
        assert p.read_text(encoding="utf-8") == CONTENT
        assert len(list(tmp_path.iterdir())) == 1
>       assert 0
E       assert 0
test_tmp_path.py
:11: AssertionError
========================= short test summary info ==========================
FAILED
test_tmp_path.py::
test_create_file
- assert 0
============================
1 failed
in 0.12s =============================

```

By default, pytest retains the temporary directory for the last 3 pytest invocations. Concurrent invocations of the same test function are supported by configuring the base temporary directory to be unique for each concurrent run. See temporary directory location and retention for details.

# Thetmp_path_factoryfixture¶

The tmp_path_factory is a session-scoped fixture which can be used to create arbitrary temporary directories from any other fixture or test. For example, suppose your test suite needs a large image on disk, which is generated procedurally. Instead of computing the same image for each test that uses it into its own tmp_path , you can generate it once per-session to save time:

```

# contents of conftest.py
import
pytest
@pytest
.
fixture
(
scope
=
"session"
)
def
image_file
(
tmp_path_factory
):
img
=
compute_expensive_image
()
fn
=
tmp_path_factory
.
mktemp
(
"data"
)
/
"img.png"
img
.
save
(
fn
)
return
fn
# contents of test_image.py
def
test_histogram
(
image_file
):
img
=
load_image
(
image_file
)
# compute and test histogram

```

See tmp_path_factory API for details.

# Thetmpdirandtmpdir_factoryfixtures¶

The tmpdir and tmpdir_factory fixtures are similar to tmp_path and tmp_path_factory , but use/return legacy py.path.local objects rather than standard pathlib.Path objects. Note These days, it is preferred to use tmp_path and tmp_path_factory . In order to help modernize old code bases, one can run pytest with the legacypath plugin disabled:

```

pytest
-p
no:legacypath

```

This will trigger errors on tests using the legacy paths. It can also be permanently set as part of the addopts parameter in the config file. See tmpdir tmpdir_factory API for details.

# Temporary directory location and retention¶

The temporary directories, as returned by the tmp_path and (now deprecated) tmpdir fixtures, are automatically created under a base temporary directory, in a structure that depends on the --basetemp option: By default (when the --basetemp option is not set), the temporary directories will follow this template:

```

{temproot}/pytest-of-{user}/pytest-{num}/{testname}/

```

where: {temproot} is the system temporary directory as determined by tempfile.gettempdir() . It can be overridden by the PYTEST_DEBUG_TEMPROOT environment variable. {user} is the user name running the tests, {num} is a number that is incremented with each test suite run {testname} is a sanitized version of the name of the current test . The auto-incrementing {num} placeholder provides a basic retention feature and avoids that existing results of previous test runs are blindly removed. By default, the last 3 temporary directories are kept, but this behavior can be configured with tmp_path_retention_count and tmp_path_retention_policy . When the --basetemp option is used (e.g. pytest --basetemp=mydir ), it will be used directly as base temporary directory:

```

{basetemp}/{testname}/

```


---


# pytest import mechanisms and sys.path/PYTHONPATH - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/pythonpath.html


# pytest import mechanisms andsys.path/PYTHONPATH¶

# Import modes¶

pytest as a testing framework needs to import test modules and conftest.py files for execution. Importing files in Python is a non-trivial process, so aspects of the import process can be controlled through the --import-mode command-line flag, which can assume these values: prepend (default): The directory path containing each module will be inserted into the beginning of sys.path if not already there, and then imported with the importlib.import_module function. It is highly recommended to arrange your test modules as packages by adding __init__.py files to your directories containing tests. This will make the tests part of a proper Python package, allowing pytest to resolve their full name (for example tests.core.test_core for test_core.py inside the tests.core package). If the test directory tree is not arranged as packages, then each test file needs to have a unique name compared to the other test files, otherwise pytest will raise an error if it finds two tests with the same name. This is the classic mechanism, dating back from the time Python 2 was still supported. append : the directory containing each module is appended to the end of sys.path if not already there, and imported with importlib.import_module . This better allows users to run test modules against installed versions of a package even if the package under test has the same import root. For example:

```

testing
/
__init__
.
py
testing
/
test_pkg_under_test
.
py
pkg_under_test
/

```

the tests will run against the installed version of pkg_under_test when --import-mode=append is used whereas with prepend , they would pick up the local version. This kind of confusion is why we advocate for using src-layouts . Same as prepend , requires test module names to be unique when the test directory tree is not arranged in packages, because the modules will put in sys.modules after importing. importlib : this mode uses more fine control mechanisms provided by importlib to import test modules, without changing sys.path . Advantages of this mode: pytest will not change sys.path at all. Test module names do not need to be unique – pytest will generate a unique name automatically based on the rootdir . Disadvantages: Test modules can’t import each other. Testing utility modules in the tests directories (for example a tests.helpers module containing test-related functions/classes) are not importable. The recommendation in this case it to place testing utility modules together with the application/library code, for example app.testing.helpers . Important: by “test utility modules”, we mean functions/classes which are imported by other tests directly; this does not include fixtures, which should be placed in conftest.py files, along with the test modules, and are discovered automatically by pytest. It works like this: Given a certain module path, for example tests/core/test_models.py , derives a canonical name like tests.core.test_models and tries to import it. For non-test modules, this will work if they are accessible via sys.path . So for example, .env/lib/site-packages/app/core.py will be importable as app.core . This happens when plugins import non-test modules (for example doctesting). If this step succeeds, the module is returned. For test modules, unless they are reachable from sys.path , this step will fail. If the previous step fails, we import the module directly using importlib facilities, which lets us import it without changing sys.path . Because Python requires the module to also be available in sys.modules , pytest derives a unique name for it based on its relative location from the rootdir , and adds the module to sys.modules . For example, tests/core/test_models.py will end up being imported as the module tests.core.test_models . Added in version 6.0. Note Initially we intended to make importlib the default in future releases, however it is clear now that it has its own set of drawbacks so the default will remain prepend for the foreseeable future. Note By default, pytest will not attempt to resolve namespace packages automatically, but that can be changed via the consider_namespace_packages configuration variable. See also The pythonpath configuration variable. The consider_namespace_packages configuration variable. Choosing a test layout .

# prependandappendimport modes scenarios¶

Here’s a list of scenarios when using prepend or append import modes where pytest needs to change sys.path in order to import test modules or conftest.py files, and the issues users might encounter because of that.

# Test modules /conftest.pyfiles inside packages¶

Consider this file and directory layout:

```

root
/
|-
foo
/
|-
__init__
.
py
|-
conftest
.
py
|-
bar
/
|-
__init__
.
py
|-
tests
/
|-
__init__
.
py
|-
test_foo
.
py

```

When executing:

```

pytest
root/

```

pytest will find foo/bar/tests/test_foo.py and realize it is part of a package given that there’s an __init__.py file in the same folder. It will then search upwards until it can find the last folder which still contains an __init__.py file in order to find the package root (in this case foo/ ). To load the module, it will insert root/ to the front of sys.path (if not there already) in order to load test_foo.py as the module foo.bar.tests.test_foo . The same logic applies to the conftest.py file: it will be imported as foo.conftest module. Preserving the full package name is important when tests live in a package to avoid problems and allow test modules to have duplicated names. This is also discussed in details in Conventions for Python test discovery .

# Standalone test modules /conftest.pyfiles¶

Consider this file and directory layout:

```

root
/
|-
foo
/
|-
conftest
.
py
|-
bar
/
|-
tests
/
|-
test_foo
.
py

```

When executing:

```

pytest
root/

```

pytest will find foo/bar/tests/test_foo.py and realize it is NOT part of a package given that there’s no __init__.py file in the same folder. It will then add root/foo/bar/tests to sys.path in order to import test_foo.py as the module test_foo . The same is done with the conftest.py file by adding root/foo to sys.path to import it as conftest . For this reason this layout cannot have test modules with the same name, as they all will be imported in the global import namespace. This is also discussed in details in Conventions for Python test discovery .

# Invokingpytestversuspython-mpytest¶


---


# Flaky tests - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/flaky.html


# Flaky tests¶

A “flaky” test is one that exhibits intermittent or sporadic failure, that seems to have non-deterministic behaviour. Sometimes it passes, sometimes it fails, and it’s not clear why. This page discusses pytest features that can help and other general strategies for identifying, fixing or mitigating them.

# Why flaky tests are a problem¶

Flaky tests are particularly troublesome when a continuous integration (CI) server is being used, so that all tests must pass before a new code change can be merged. If the test result is not a reliable signal – that a test failure means the code change broke the test – developers can become mistrustful of the test results, which can lead to overlooking genuine failures. It is also a source of wasted time as developers must re-run test suites and investigate spurious failures.

# Potential root causes¶

# System state¶

Broadly speaking, a flaky test indicates that the test relies on some system state that is not being appropriately controlled - the test environment is not sufficiently isolated. Higher level tests are more likely to be flaky as they rely on more state. Flaky tests sometimes appear when a test suite is run in parallel (such as use of pytest-xdist ). This can indicate a test is reliant on test ordering. Perhaps a different test is failing to clean up after itself and leaving behind data which causes the flaky test to fail. The flaky test is reliant on data from a previous test that doesn’t clean up after itself, and in parallel runs that previous test is not always present Tests that modify global state typically cannot be run in parallel.

# Overly strict assertion¶

Overly strict assertions can cause problems with floating point comparison as well as timing issues. pytest.approx() is useful here.

# Thread safety¶

pytest is single-threaded, executing its tests always in the same thread, sequentially, never spawning any threads itself. Even in case of plugins which run tests in parallel, for example pytest-xdist , usually work by spawning multiple processes and running tests in batches, without using multiple threads. It is of course possible (and common) for tests and fixtures to spawn threads themselves as part of their testing workflow (for example, a fixture that starts a server thread in the background, or a test which executes production code that spawns threads), but some care must be taken: Make sure to eventually wait on any spawned threads – for example at the end of a test, or during the teardown of a fixture. Avoid using primitives provided by pytest ( pytest.warns() , pytest.raises() , etc) from multiple threads, as they are not thread-safe. If your test suite uses threads and your are seeing flaky test results, do not discount the possibility that the test is implicitly using global state in pytest itself.

# Related features¶

# Xfail strict¶

pytest.mark.xfail with strict=False can be used to mark a test so that its failure does not cause the whole build to break. This could be considered like a manual quarantine, and is rather dangerous to use permanently.

# PYTEST_CURRENT_TEST¶

PYTEST_CURRENT_TEST may be useful for figuring out “which test got stuck”. See PYTEST_CURRENT_TEST environment variable for more details.

# Plugins¶

Rerunning any failed tests can mitigate the negative effects of flaky tests by giving them additional chances to pass, so that the overall build does not fail. Several pytest plugins support this: pytest-rerunfailures pytest-replay : This plugin helps to reproduce locally crashes or flaky tests observed during CI runs. pytest-flakefinder - blog post Plugins to deliberately randomize tests can help expose tests with state problems: pytest-random-order pytest-randomly

# Other general strategies¶

# Split up test suites¶

It can be common to split a single test suite into two, such as unit vs integration, and only use the unit test suite as a CI gate. This also helps keep build times manageable as high level tests tend to be slower. However, it means it does become possible for code that breaks the build to be merged, so extra vigilance is needed for monitoring the integration test results.

# Video/screenshot on failure¶

For UI tests these are important for understanding what the state of the UI was when the test failed. pytest-splinter can be used with plugins like pytest-bdd and can save a screenshot on test failure , which can help to isolate the cause.

# Delete or rewrite the test¶

If the functionality is covered by other tests, perhaps the test can be removed. If not, perhaps it can be rewritten at a lower level which will remove the flakiness or make its source more apparent.

# Quarantine¶

Mark Lapierre discusses the Pros and Cons of Quarantined Tests in a post from 2018.

# CI tools that rerun on failure¶

Azure Pipelines (the Azure cloud CI/CD tool, formerly Visual Studio Team Services or VSTS) has a feature to identify flaky tests and rerun failed tests.

# Research¶

This is a limited list, please submit an issue or pull request to expand it! Gao, Zebao, Yalan Liang, Myra B. Cohen, Atif M. Memon, and Zhen Wang. “Making system user interactive tests repeatable: When and what should we control?.” In Software Engineering (ICSE), 2015 IEEE/ACM 37th IEEE International Conference on , vol. 1, pp. 55-65. IEEE, 2015. PDF Palomba, Fabio, and Andy Zaidman. “Does refactoring of test smells induce fixing flaky tests?.” In Software Maintenance and Evolution (ICSME), 2017 IEEE International Conference on , pp. 1-12. IEEE, 2017. PDF in Google Drive Bell, Jonathan, Owolabi Legunsen, Michael Hilton, Lamyaa Eloussi, Tifany Yung, and Darko Marinov. “DeFlaker: Automatically detecting flaky tests.” In Proceedings of the 2018 International Conference on Software Engineering . 2018. PDF Dutta, Saikat and Shi, August and Choudhary, Rutvik and Zhang, Zhekun and Jain, Aryaman and Misailovic, Sasa. “Detecting flaky tests in probabilistic and machine learning applications.” In Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA) , pp. 211-224. ACM, 2020. PDF Habchi, Sarra and Haben, Guillaume and Sohn, Jeongju and Franci, Adriano and Papadakis, Mike and Cordy, Maxime and Le Traon, Yves. “What Made This Test Flake? Pinpointing Classes Responsible for Test Flakiness.” In Proceedings of the 38th IEEE International Conference on Software Maintenance and Evolution (ICSME), IEEE, 2022. PDF Lamprou, Sokrates. “Non-deterministic tests and where to find them: Empirically investigating the relationship between flaky tests and test smells by examining test order dependency.” Bachelor thesis, Department of Computer and Information Science, Linköping University, 2022. LIU-IDA/LITH-EX-G–19/056–SE. PDF Leinen, Fabian and Elsner, Daniel and Pretschner, Alexander and Stahlbauer, Andreas and Sailer, Michael and Jürgens, Elmar. “Cost of Flaky Tests in Continuous Integration: An Industrial Case Study.” Technical University of Munich and CQSE GmbH, Munich, Germany, 2023. PDF

# Resources¶


---


# Working with non-python tests - pytest documentation

URL: https://docs.pytest.org/en/stable/example/nonpython.html


# Working with non-python tests¶

# A basic example for specifying tests in Yaml files¶

Here is an example conftest.py (extracted from Ali Afshar’s special purpose pytest-yamlwsgi plugin). This conftest.py will collect test*.yaml files and will execute the yaml-formatted content as custom tests:

```

# content of conftest.py
from
__future__
import
annotations
import
pytest
def
pytest_collect_file
(
parent
,
file_path
):
if
file_path
.
suffix
==
".yaml"
and
file_path
.
name
.
startswith
(
"test"
):
return
YamlFile
.
from_parent
(
parent
,
path
=
file_path
)
class
YamlFile
(
pytest
.
File
):
def
collect
(
self
):
# We need a yaml parser, e.g. PyYAML.
import
yaml
raw
=
yaml
.
safe_load
(
self
.
path
.
open
(
encoding
=
"utf-8"
))
for
name
,
spec
in
sorted
(
raw
.
items
()):
yield
YamlItem
.
from_parent
(
self
,
name
=
name
,
spec
=
spec
)
class
YamlItem
(
pytest
.
Item
):
def
__init__
(
self
,
*
,
spec
,
**
kwargs
):
super
()
.
__init__
(
**
kwargs
)
self
.
spec
=
spec
def
runtest
(
self
):
for
name
,
value
in
sorted
(
self
.
spec
.
items
()):
# Some custom test execution (dumb example follows).
if
name
!=
value
:
raise
YamlException
(
self
,
name
,
value
)
def
repr_failure
(
self
,
excinfo
):
"""Called when self.runtest() raises an exception."""
if
isinstance
(
excinfo
.
value
,
YamlException
):
return
"
\n
"
.
join
(
[
"usecase execution failed"
,
"   spec failed:
{1!r}
:
{2!r}
"
.
format
(
*
excinfo
.
value
.
args
),
"   no further details known at this point."
,
]
)
return
super
()
.
repr_failure
(
excinfo
)
def
reportinfo
(
self
):
return
self
.
path
,
0
,
f
"usecase:
{
self
.
name
}
"
class
YamlException
(
Exception
):
"""Custom exception for error reporting."""

```

You can create a simple example file:

```

# test_simple.yaml
ok
:
sub1
:
sub1
hello
:
world
:
world
some
:
other

```

and if you installed PyYAML or a compatible YAML-parser you can now execute the test specification:

```

nonpython $ pytest test_simple.yaml
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project/nonpython
collected 2 items

test_simple.yaml
F
.
[100%]
================================= FAILURES =================================
______________________________ usecase: hello ______________________________
usecase execution failed
   spec failed: 'some': 'other'
   no further details known at this point.
========================= short test summary info ==========================
FAILED
test_simple.yaml::hello
=======================
1 failed
,
1 passed
in 0.12s ========================

```

You get one dot for the passing sub1: sub1 check and one failure. Obviously in the above conftest.py you’ll want to implement a more interesting interpretation of the yaml-values. You can easily write your own domain specific testing language this way. Note repr_failure(excinfo) is called for representing test failures. If you create custom collection nodes you can return an error representation string of your choice. It will be reported as a (red) string. reportinfo() is used for representing the test location and is also consulted when reporting in verbose mode:

```

nonpython $ pytest -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project/nonpython
collecting ...
collected 2 items

test_simple.yaml::hello
FAILED
[ 50%]
test_simple.yaml::ok
PASSED
[100%]
================================= FAILURES =================================
______________________________ usecase: hello ______________________________
usecase execution failed
   spec failed: 'some': 'other'
   no further details known at this point.
========================= short test summary info ==========================
FAILED
test_simple.yaml::hello
=======================
1 failed
,
1 passed
in 0.12s ========================

```

While developing your custom test collection and execution it’s also interesting to just look at the collection tree:

```

nonpython $ pytest --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project/nonpython
collected 2 items

<Package nonpython>
  <YamlFile test_simple.yaml>
    <YamlItem hello>
    <YamlItem ok>

======================== 2 tests collected in 0.12s ========================

```


---


# Backwards Compatibility Policy - pytest documentation

URL: https://docs.pytest.org/en/stable/backwards-compatibility.html


# Backwards Compatibility Policy¶

Pytest is an actively evolving project that has been decades in the making. We keep learning about new and better structures to express different details about testing. While we implement those modifications, we try to ensure an easy transition and don’t want to impose unnecessary churn on our users and community/plugin authors. As of now, pytest considers multiple types of backward compatibility transitions: trivial: APIs that trivially translate to the new mechanism and do not cause problematic changes. We try to support those indefinitely while encouraging users to switch to newer or better mechanisms through documentation. transitional: the old and new APIs don’t conflict, and we can help users transition by using warnings while supporting both for a prolonged period of time. We will only start the removal of deprecated functionality in major releases (e.g., if we deprecate something in 3.0, we will start to remove it in 4.0), and keep it around for at least two minor releases (e.g., if we deprecate something in 3.9 and 4.0 is the next release, we start to remove it in 5.0, not in 4.0). A deprecated feature scheduled to be removed in major version X will use the warning class PytestRemovedInXWarning (a subclass of PytestDeprecationWarning ). When the deprecation expires (e.g., 4.0 is released), we won’t remove the deprecated functionality immediately but will use the standard warning filters to turn PytestRemovedInXWarning (e.g., PytestRemovedIn4Warning ) into errors by default. This approach makes it explicit that removal is imminent and still gives you time to turn the deprecated feature into a warning instead of an error so it can be dealt with in your own time. In the next minor release (e.g., 4.1), the feature will be effectively removed. True breakage should only be considered when a normal transition is unreasonably unsustainable and would offset important developments or features by years. In addition, they should be limited to APIs where the number of actual users is very small (for example, only impacting some plugins) and can be coordinated with the community in advance. Examples for such upcoming changes: removal of pytest_runtest_protocol/nextitem - #895 rearranging of the node tree to include FunctionDefinition rearranging of SetupState #895 True breakages must be announced first in an issue containing: Detailed description of the change Rationale Expected impact on users and plugin authors (example in #895 ) After there’s no hard -1 on the issue it should be followed up by an initial proof-of-concept Pull Request. This POC serves as both a coordination point to assess impact and potential inspiration to come up with a transitional solution after all. After a reasonable amount of time the PR can be merged to base a new major release. For the PR to mature from POC to acceptance, it must contain: * Setup of deprecation errors/warnings that help users fix and port their code. If it is possible to introduce a deprecation period under the current series, before the true breakage, it should be introduced in a separate PR and be part of the current release stream. * Detailed description of the rationale and examples on how to port code in doc/en/deprecations.rst .

# History¶

# Focus primary on smooth transition - stance (pre 6.0)¶

Keeping backwards compatibility has a very high priority in the pytest project. Although we have deprecated functionality over the years, most of it is still supported. All deprecations in pytest were done because simpler or more efficient ways of accomplishing the same tasks have emerged, making the old way of doing things unnecessary. With the pytest 3.0 release, we introduced a clear communication scheme for when we will actually remove the old busted joint and politely ask you to use the new hotness instead, while giving you enough time to adjust your tests or raise concerns if there are valid reasons to keep deprecated functionality around. To communicate changes, we issue deprecation warnings using a custom warning hierarchy (see Internal pytest warnings ). These warnings may be suppressed using the standard means: -W command-line flag or filterwarnings ini options (see How to capture warnings ), but we suggest to use these sparingly and temporarily, and heed the warnings when possible. We will only start the removal of deprecated functionality in major releases (e.g. if we deprecate something in 3.0, we will start to remove it in 4.0), and keep it around for at least two minor releases (e.g. if we deprecate something in 3.9 and 4.0 is the next release, we start to remove it in 5.0, not in 4.0). When the deprecation expires (e.g. 4.0 is released), we won’t remove the deprecated functionality immediately, but will use the standard warning filters to turn them into errors by default. This approach makes it explicit that removal is imminent, and still gives you time to turn the deprecated feature into a warning instead of an error so it can be dealt with in your own time. In the next minor release (e.g. 4.1), the feature will be effectively removed.

# Deprecation Roadmap¶

Features currently deprecated and removed in previous releases can be found in Deprecations and Removals . We track future deprecation and removal of features using milestones and the deprecation and removal labels on GitHub.

# Python version support¶


---


# Talks and Tutorials - pytest documentation

URL: https://docs.pytest.org/en/stable/talks.html


# Talks and Tutorials¶

# Books¶

pytest Quick Start Guide, by Bruno Oliveira (2018) . Python Testing with pytest, by Brian Okken (2017) . Python Testing with pytest, Second Edition, by Brian Okken (2022) .

# Talks and blog postings¶


---


# How to use skip and xfail to deal with tests that cannot succeed - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/skipping.html


# How to use skip and xfail to deal with tests that cannot succeed¶

You can mark test functions that cannot be run on certain platforms or that you expect to fail so pytest can deal with them accordingly and present a summary of the test session, while keeping the test suite green . A skip means that you expect your test to pass only if some conditions are met, otherwise pytest should skip running the test altogether. Common examples are skipping windows-only tests on non-windows platforms, or skipping tests that depend on an external resource which is not available at the moment (for example a database). An xfail means that you expect a test to fail for some reason. A common example is a test for a feature not yet implemented, or a bug not yet fixed. When a test passes despite being expected to fail (marked with pytest.mark.xfail ), it’s an xpass and will be reported in the test summary. pytest counts and lists skip and xfail tests separately. Detailed information about skipped/xfailed tests is not shown by default to avoid cluttering the output. You can use the -r option to see details corresponding to the “short” letters shown in the test progress:

```

pytest
-rxXs
# show extra info on xfailed, xpassed, and skipped tests

```

More details on the -r option can be found by running pytest -h . (See Builtin configuration file options )

# Skipping test functions¶

The simplest way to skip a test function is to mark it with the skip decorator which may be passed an optional reason :

```

@pytest
.
mark
.
skip
(
reason
=
"no way of currently testing this"
)
def
test_the_unknown
():
...

```

Alternatively, it is also possible to skip imperatively during test execution or setup by calling the pytest.skip(reason) function:

```

def
test_function
():
if
not
valid_config
():
pytest
.
skip
(
"unsupported configuration"
)

```

The imperative method is useful when it is not possible to evaluate the skip condition during import time. It is also possible to skip the whole module using pytest.skip(reason, allow_module_level=True) at the module level:

```

import
sys
import
pytest
if
not
sys
.
platform
.
startswith
(
"win"
):
pytest
.
skip
(
"skipping windows-only tests"
,
allow_module_level
=
True
)

```

Reference : pytest.mark.skip

# skipif¶

If you wish to skip something conditionally then you can use skipif instead. Here is an example of marking a test function to be skipped when run on an interpreter earlier than Python3.10:

```

import
sys
@pytest
.
mark
.
skipif
(
sys
.
version_info
<
(
3
,
10
),
reason
=
"requires python3.10 or higher"
)
def
test_function
():
...

```

If the condition evaluates to True during collection, the test function will be skipped, with the specified reason appearing in the summary when using -rs . You can share skipif markers between modules. Consider this test module:

```

# content of test_mymodule.py
import
mymodule
minversion
=
pytest
.
mark
.
skipif
(
mymodule
.
__versioninfo__
<
(
1
,
1
),
reason
=
"at least mymodule-1.1 required"
)
@minversion
def
test_function
():
...

```

You can import the marker and reuse it in another test module:

```

# test_myothermodule.py
from
test_mymodule
import
minversion
@minversion
def
test_anotherfunction
():
...

```

For larger test suites it’s usually a good idea to have one file where you define the markers which you then consistently apply throughout your test suite. Alternatively, you can use condition strings instead of booleans, but they can’t be shared between modules easily so they are supported mainly for backward compatibility reasons. Reference : pytest.mark.skipif

# Skip all test functions of a class or module¶

You can use the skipif marker (as any other marker) on classes:

```

@pytest
.
mark
.
skipif
(
sys
.
platform
==
"win32"
,
reason
=
"does not run on windows"
)
class
TestPosixCalls
:
def
test_function
(
self
):
"will not be setup or run under 'win32' platform"

```

If the condition is True , this marker will produce a skip result for each of the test methods of that class. If you want to skip all test functions of a module, you may use the pytestmark global:

```

# test_module.py
pytestmark
=
pytest
.
mark
.
skipif
(
...
)

```

If multiple skipif decorators are applied to a test function, it will be skipped if any of the skip conditions is true.

# Skipping files or directories¶

Sometimes you may need to skip an entire file or directory, for example if the tests rely on Python version-specific features or contain code that you do not wish pytest to run. In this case, you must exclude the files and directories from collection. Refer to Customizing test collection for more information.

# Skipping on a missing import dependency¶

You can skip tests on a missing import by using pytest.importorskip at module level, within a test, or test setup function.

```

docutils
=
pytest
.
importorskip
(
"docutils"
)

```

If docutils cannot be imported here, this will lead to a skip outcome of the test. You can also skip based on the version number of a library:

```

docutils
=
pytest
.
importorskip
(
"docutils"
,
minversion
=
"0.3"
)

```

The version will be read from the specified module’s __version__ attribute.

# Summary¶

Here’s a quick guide on how to skip tests in a module in different situations: Skip all tests in a module unconditionally:

```

pytestmark
=
pytest
.
mark
.
skip
(
"all tests still WIP"
)

```

Skip all tests in a module based on some condition:

```

pytestmark
=
pytest
.
mark
.
skipif
(
sys
.
platform
==
"win32"
,
reason
=
"tests for linux only"
)

```

Skip all tests in a module if some import is missing:

```

pexpect
=
pytest
.
importorskip
(
"pexpect"
)

```

# XFail: mark test functions as expected to fail¶

You can use the xfail marker to indicate that you expect a test to fail:

```

@pytest
.
mark
.
xfail
def
test_function
():
...

```

This test will run but no traceback will be reported when it fails. Instead, terminal reporting will list it in the “expected to fail” ( XFAIL ) or “unexpectedly passing” ( XPASS ) sections. Alternatively, you can also mark a test as XFAIL from within the test or its setup function imperatively:

```

def
test_function
():
if
not
valid_config
():
pytest
.
xfail
(
"failing configuration (but should work)"
)

```

```

def
test_function2
():
import
slow_module
if
slow_module
.
slow_function
():
pytest
.
xfail
(
"slow_module taking too long"
)

```

These two examples illustrate situations where you don’t want to check for a condition at the module level, which is when a condition would otherwise be evaluated for marks. This will make test_function XFAIL . Note that no other code is executed after the pytest.xfail() call, differently from the marker. That’s because it is implemented internally by raising a known exception. Reference : pytest.mark.xfail

# conditionparameter¶

If a test is only expected to fail under a certain condition, you can pass that condition as the first parameter:

```

@pytest
.
mark
.
xfail
(
sys
.
platform
==
"win32"
,
reason
=
"bug in a 3rd party library"
)
def
test_function
():
...

```

Note that you have to pass a reason as well (see the parameter description at pytest.mark.xfail ).

# reasonparameter¶

You can specify the motive of an expected failure with the reason parameter:

```

@pytest
.
mark
.
xfail
(
reason
=
"known parser issue"
)
def
test_function
():
...

```

# raisesparameter¶

If you want to be more specific as to why the test is failing, you can specify a single exception, or a tuple of exceptions, in the raises argument.

```

@pytest
.
mark
.
xfail
(
raises
=
RuntimeError
)
def
test_function
():
...

```

Then the test will be reported as a regular failure if it fails with an exception not mentioned in raises .

# runparameter¶

If a test should be marked as xfail and reported as such but should not be even executed, use the run parameter as False :

```

@pytest
.
mark
.
xfail
(
run
=
False
)
def
test_function
():
...

```

This is specially useful for xfailing tests that are crashing the interpreter and should be investigated later.

# strictparameter¶

Both XFAIL and XPASS don’t fail the test suite by default. You can change this by setting the strict keyword-only parameter to True :

```

@pytest
.
mark
.
xfail
(
strict
=
True
)
def
test_function
():
...

```

This will make XPASS (“unexpectedly passing”) results from this test to fail the test suite. You can change the default value of the strict parameter using the xfail_strict ini option:

```

[pytest]
xfail_strict
=
true

```

# Ignoring xfail¶

By specifying on the commandline:

```

pytest
--runxfail

```

you can force the running and reporting of an xfail marked test as if it weren’t marked at all. This also causes pytest.xfail() to produce no effect.

# Examples¶

Here is a simple test file with the several usages:

```

from
__future__
import
annotations
import
pytest
xfail
=
pytest
.
mark
.
xfail
@xfail
def
test_hello
():
assert
0
@xfail
(
run
=
False
)
def
test_hello2
():
assert
0
@xfail
(
"hasattr(os, 'sep')"
)
def
test_hello3
():
assert
0
@xfail
(
reason
=
"bug 110"
)
def
test_hello4
():
assert
0
@xfail
(
'pytest.__version__[0] != "17"'
)
def
test_hello5
():
assert
0
def
test_hello6
():
pytest
.
xfail
(
"reason"
)
@xfail
(
raises
=
IndexError
)
def
test_hello7
():
x
=
[]
x
[
1
]
=
1

```

Running it with the report-on-xfail option gives this output:

```

! pytest -rx xfail_demo.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR/example
collected 7 items

xfail_demo.py
xxxxxxx
[100%]
========================= short test summary info ==========================
XFAIL xfail_demo.py::test_hello
XFAIL xfail_demo.py::test_hello2
  reason: [NOTRUN]
XFAIL xfail_demo.py::test_hello3
  condition: hasattr(os, 'sep')
XFAIL xfail_demo.py::test_hello4
  bug 110
XFAIL xfail_demo.py::test_hello5
  condition: pytest.__version__[0] != "17"
XFAIL xfail_demo.py::test_hello6
  reason: reason
XFAIL xfail_demo.py::test_hello7
============================
7 xfailed
in 0.12s ============================

```

# Skip/xfail with parametrize¶

It is possible to apply markers like skip and xfail to individual test instances when using parametrize:

```

import
sys
import
pytest
@pytest
.
mark
.
parametrize
(
(
"n"
,
"expected"
),
[
(
1
,
2
),
pytest
.
param
(
1
,
0
,
marks
=
pytest
.
mark
.
xfail
),
pytest
.
param
(
1
,
3
,
marks
=
pytest
.
mark
.
xfail
(
reason
=
"some bug"
)),
(
2
,
3
),
(
3
,
4
),
(
4
,
5
),
pytest
.
param
(
10
,
11
,
marks
=
pytest
.
mark
.
skipif
(
sys
.
version_info
>=
(
3
,
0
),
reason
=
"py2k"
)
),
],
)
def
test_increment
(
n
,
expected
):
assert
n
+
1
==
expected

```


---


# Get Started - pytest documentation

URL: https://docs.pytest.org/en/stable/getting-started.html


# Get Started¶

# Installpytest¶

pytest requires: Python 3.8+ or PyPy3. Run the following command in your command line:

```

pip
install
-U
pytest

```

Check that you installed the correct version:

```

$
pytest
--version
pytest
8
.3.5

```

# Create your first test¶

Create a new file called test_sample.py , containing a function, and a test:

```

# content of test_sample.py
def
func
(
x
):
return
x
+
1
def
test_answer
():
assert
func
(
3
)
==
5

```

The test

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_sample.py
F
[100%]
================================= FAILURES =================================
_______________________________ test_answer ________________________________
def test_answer():
>       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)
test_sample.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_sample.py::
test_answer
- assert 4 == 5
============================
1 failed
in 0.12s =============================

```

The [100%] refers to the overall progress of running all test cases. After it finishes, pytest then shows a failure report because func(3) does not return 5 . Note You can use the assert statement to verify test expectations. pytest’s Advanced assertion introspection will intelligently report intermediate values of the assert expression so you can avoid the many names of JUnit legacy methods .

# Run multiple tests¶

pytest will run all files of the form test_*.py or *_test.py in the current directory and its subdirectories. More generally, it follows standard test discovery rules .

# Assert that a certain exception is raised¶

Use the raises helper to assert that some code raises an exception:

```

# content of test_sysexit.py
import
pytest
def
f
():
raise
SystemExit
(
1
)
def
test_mytest
():
with
pytest
.
raises
(
SystemExit
):
f
()

```

You can also use the context provided by raises to assert that an expected exception is part of a raised ExceptionGroup :

```

# content of test_exceptiongroup.py
import
pytest
def
f
():
raise
ExceptionGroup
(
"Group message"
,
[
RuntimeError
(),
],
)
def
test_exception_in_group
():
with
pytest
.
raises
(
ExceptionGroup
)
as
excinfo
:
f
()
assert
excinfo
.
group_contains
(
RuntimeError
)
assert
not
excinfo
.
group_contains
(
TypeError
)

```

Execute the test function with “quiet” reporting mode:

```

$ pytest -q test_sysexit.py
.
[100%]
1 passed
in 0.12s

```

Note The -q/--quiet flag keeps the output brief in this and following examples.

# Group multiple tests in a class¶

Once you develop multiple tests, you may want to group them into a class. pytest makes it easy to create a class containing more than one test:

```

# content of test_class.py
class
TestClass
:
def
test_one
(
self
):
x
=
"this"
assert
"h"
in
x
def
test_two
(
self
):
x
=
"hello"
assert
hasattr
(
x
,
"check"
)

```

pytest discovers all tests following its Conventions for Python test discovery , so it finds both test_ prefixed functions. There is no need to subclass anything, but make sure to prefix your class with Test otherwise the class will be skipped. We can simply run the module by passing its filename:

```

$ pytest -q test_class.py
.
F
[100%]
================================= FAILURES =================================
____________________________ TestClass.test_two ____________________________
self = <test_class.TestClass object at 0xdeadbeef0001>

    def test_two(self):
        x = "hello"
>       assert hasattr(x, "check")
E       AssertionError: assert False
E        +  where False = hasattr('hello', 'check')
test_class.py
:8: AssertionError
========================= short test summary info ==========================
FAILED
test_class.py::
TestClass::test_two
- AssertionError: assert False
1 failed
,
1 passed
in 0.12s

```

The first test passed and the second failed. You can easily see the intermediate values in the assertion to help you understand the reason for the failure. Grouping tests in classes can be beneficial for the following reasons: Test organization Sharing fixtures for tests only in that particular class Applying marks at the class level and having them implicitly apply to all tests Something to be aware of when grouping tests inside classes is that each test has a unique instance of the class. Having each test share the same class instance would be very detrimental to test isolation and would promote poor test practices. This is outlined below:

```

# content of test_class_demo.py
class
TestClassDemoInstance
:
value
=
0
def
test_one
(
self
):
self
.
value
=
1
assert
self
.
value
==
1
def
test_two
(
self
):
assert
self
.
value
==
1

```

```

$ pytest -k TestClassDemoInstance -q
.
F
[100%]
================================= FAILURES =================================
______________________ TestClassDemoInstance.test_two ______________________
self = <test_class_demo.TestClassDemoInstance object at 0xdeadbeef0002>

    def test_two(self):
>       assert self.value == 1
E       assert 0 == 1
E        +  where 0 = <test_class_demo.TestClassDemoInstance object at 0xdeadbeef0002>.value
test_class_demo.py
:9: AssertionError
========================= short test summary info ==========================
FAILED
test_class_demo.py::
TestClassDemoInstance::test_two
- assert 0 == 1
1 failed
,
1 passed
in 0.12s

```

Note that attributes added at class level are class attributes , so they will be shared between tests.

# Request a unique temporary directory for functional tests¶

pytest provides Builtin fixtures/function arguments to request arbitrary resources, like a unique temporary directory:

```

# content of test_tmp_path.py
def
test_needsfiles
(
tmp_path
):
print
(
tmp_path
)
assert
0

```

List the name tmp_path in the test function signature and pytest will lookup and call a fixture factory to create the resource before performing the test function call. Before the test runs, pytest creates a unique-per-test-invocation temporary directory:

```

$ pytest -q test_tmp_path.py
F
[100%]
================================= FAILURES =================================
_____________________________ test_needsfiles ______________________________
tmp_path = PosixPath('PYTEST_TMPDIR/test_needsfiles0')

    def test_needsfiles(tmp_path):
        print(tmp_path)
>       assert 0
E       assert 0
test_tmp_path.py
:3: AssertionError
--------------------------- Captured stdout call ---------------------------
PYTEST_TMPDIR/test_needsfiles0
========================= short test summary info ==========================
FAILED
test_tmp_path.py::
test_needsfiles
- assert 0
1 failed
in 0.12s

```

More info on temporary directory handling is available at Temporary directories and files . Find out what kind of builtin pytest fixtures exist with the command:

```

pytest
--fixtures
# shows builtin and custom fixtures

```

Note that this command omits fixtures with leading _ unless the -v option is added.

# Continue reading¶


---


# Pytest Plugin List - pytest documentation

URL: https://docs.pytest.org/en/stable/reference/plugin_list.html


# Pytest Plugin List¶


---


# Changing standard (Python) test discovery - pytest documentation

URL: https://docs.pytest.org/en/stable/example/pythoncollection.html


# Changing standard (Python) test discovery¶

# Ignore paths during test collection¶

You can easily ignore certain test directories and modules during collection by passing the --ignore=path option on the cli. pytest allows multiple --ignore options. Example:

```

tests/
|-- example
|   |-- test_example_01.py
|   |-- test_example_02.py
|   '-- test_example_03.py
|-- foobar
|   |-- test_foobar_01.py
|   |-- test_foobar_02.py
|   '-- test_foobar_03.py
'-- hello
    '-- world
        |-- test_world_01.py
        |-- test_world_02.py
        '-- test_world_03.py

```

Now if you invoke pytest with --ignore=tests/foobar/test_foobar_03.py --ignore=tests/hello/ , you will see that pytest only collects test-modules, which do not match the patterns specified:

```

=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-5.x.y, py-1.x.y, pluggy-0.x.y
rootdir: $REGENDOC_TMPDIR, inifile:
collected 5 items

tests/example/test_example_01.py
.
[ 20%]
tests/example/test_example_02.py
.
[ 40%]
tests/example/test_example_03.py
.
[ 60%]
tests/foobar/test_foobar_01.py
.
[ 80%]
tests/foobar/test_foobar_02.py
.
[100%]
========================= 5 passed in 0.02 seconds =========================

```

The --ignore-glob option allows to ignore test file paths based on Unix shell-style wildcards. If you want to exclude test-modules that end with _01.py , execute pytest with --ignore-glob='*_01.py' .

# Deselect tests during test collection¶

Tests can individually be deselected during collection by passing the --deselect=item option. For example, say tests/foobar/test_foobar_01.py contains test_a and test_b . You can run all of the tests within tests/ except for tests/foobar/test_foobar_01.py::test_a by invoking pytest with --deselect tests/foobar/test_foobar_01.py::test_a . pytest allows multiple --deselect options.

# Keeping duplicate paths specified from command line¶

Default behavior of pytest is to ignore duplicate paths specified from the command line. Example:

```

pytest path_a path_a

...
collected 1 item
...

```

Just collect tests once. To collect duplicate tests, use the --keep-duplicates option on the cli. Example:

```

pytest --keep-duplicates path_a path_a

...
collected 2 items
...

```

As the collector just works on directories, if you specify twice a single test file, pytest will still collect it twice, no matter if the --keep-duplicates is not specified. Example:

```

pytest test_a.py test_a.py

...
collected 2 items
...

```

# Changing directory recursion¶

You can set the norecursedirs option in an ini-file, for example your pytest.ini in the project root directory:

```

# content of pytest.ini
[pytest]
norecursedirs
=
.svn _build tmp*

```

This would tell pytest to not recurse into typical subversion or sphinx-build directories or into any tmp prefixed directory.

# Changing naming conventions¶

You can configure different naming conventions by setting the python_files , python_classes and python_functions in your configuration file . Here is an example:

```

# content of pytest.ini
# Example 1: have pytest look for "check" instead of "test"
[pytest]
python_files
=
check_*.py
python_classes
=
Check
python_functions
=
*_check

```

This would make pytest look for tests in files that match the check_* .py glob-pattern, Check prefixes in classes, and functions and methods that match *_check . For example, if we have:

```

# content of check_myapp.py
class
CheckMyApp
:
def
simple_check
(
self
):
pass
def
complex_check
(
self
):
pass

```

The test collection would look like this:

```

$ pytest --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
configfile: pytest.ini
collected 2 items

<Dir pythoncollection.rst-207>
  <Module check_myapp.py>
    <Class CheckMyApp>
      <Function simple_check>
      <Function complex_check>

======================== 2 tests collected in 0.12s ========================

```

You can check for multiple glob patterns by adding a space between the patterns:

```

# Example 2: have pytest look for files with "test" and "example"
# content of pytest.ini
[pytest]
python_files
=
test_*.py example_*.py

```

Note the python_functions and python_classes options has no effect for unittest.TestCase test discovery because pytest delegates discovery of test case methods to unittest code.

# Interpreting cmdline arguments as Python packages¶

You can use the --pyargs option to make pytest try interpreting arguments as python package names, deriving their file system path and then running the test. For example if you have unittest2 installed you can type:

```

pytest
--pyargs
unittest2.test.test_skipping
-q

```

which would run the respective test module. Like with other options, through an ini-file and the addopts option you can make this change more permanently:

```

# content of pytest.ini
[pytest]
addopts
=
--pyargs

```

Now a simple invocation of pytest NAME will check if NAME exists as an importable package/module and otherwise treat it as a filesystem path.

# Finding out what is collected¶

You can always peek at the collection tree without running tests like this:

```

. $ pytest --collect-only pythoncollection.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
configfile: pytest.ini
collected 3 items

<Dir pythoncollection.rst-207>
  <Dir CWD>
    <Module pythoncollection.py>
      <Function test_function>
      <Class TestClass>
        <Function test_method>
        <Function test_anothermethod>

======================== 3 tests collected in 0.12s ========================

```

# Customizing test collection¶

You can easily instruct pytest to discover tests from every Python file:

```

# content of pytest.ini
[pytest]
python_files
=
*.py

```

However, many projects will have a setup.py which they don’t want to be imported. Moreover, there may files only importable by a specific python version. For such cases you can dynamically define files to be ignored by listing them in a conftest.py file:

```

# content of conftest.py
import
sys
collect_ignore
=
[
"setup.py"
]
if
sys
.
version_info
[
0
]
>
2
:
collect_ignore
.
append
(
"pkg/module_py2.py"
)

```

and then if you have a module file like this:

```

# content of pkg/module_py2.py
def
test_only_on_python2
():
try
:
assert
0
except
Exception
,
e
:
pass

```

and a setup.py dummy file like this:

```

# content of setup.py
0
/
0
# will raise exception if imported

```

If you run with a Python 2 interpreter then you will find the one test and will leave out the setup.py file:

```

#$ pytest --collect-only
====== test session starts ======
platform linux2 -- Python 2.7.10, pytest-2.9.1, py-1.4.31, pluggy-0.3.1
rootdir: $REGENDOC_TMPDIR, inifile: pytest.ini
collected 1 items
<Module 'pkg/module_py2.py'>
  <Function 'test_only_on_python2'>

====== 1 tests found in 0.04 seconds ======

```

If you run with a Python 3 interpreter both the one test and the setup.py file will be left out:

```

$ pytest --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
configfile: pytest.ini
collected 0 items

======================= no tests collected in 0.12s ========================

```

It’s also possible to ignore files based on Unix shell-style wildcards by adding patterns to collect_ignore_glob . The following example conftest.py ignores the file setup.py and in addition all files that end with *_py2.py when executed with a Python 3 interpreter:

```

# content of conftest.py
import
sys
collect_ignore
=
[
"setup.py"
]
if
sys
.
version_info
[
0
]
>
2
:
collect_ignore_glob
=
[
"*_py2.py"
]

```

Since Pytest 2.6, users can prevent pytest from discovering classes that start with Test by setting a boolean __test__ attribute to False .

```

# Will not be discovered as a test
class
TestClass
:
__test__
=
False

```


---


# A session-fixture which can look at all collected tests - pytest documentation

URL: https://docs.pytest.org/en/stable/example/special.html


# A session-fixture which can look at all collected tests¶

A session-scoped fixture effectively has access to all collected test items. Here is an example of a fixture function which walks all collected tests and looks if their test class defines a callme method and calls it:

```

# content of conftest.py
import
pytest
@pytest
.
fixture
(
scope
=
"session"
,
autouse
=
True
)
def
callattr_ahead_of_alltests
(
request
):
print
(
"callattr_ahead_of_alltests called"
)
seen
=
{
None
}
session
=
request
.
node
for
item
in
session
.
items
:
cls
=
item
.
getparent
(
pytest
.
Class
)
if
cls
not
in
seen
:
if
hasattr
(
cls
.
obj
,
"callme"
):
cls
.
obj
.
callme
()
seen
.
add
(
cls
)

```

test classes may now define a callme method which will be called ahead of running any tests:

```

# content of test_module.py
class
TestHello
:
@classmethod
def
callme
(
cls
):
print
(
"callme called!"
)
def
test_method1
(
self
):
print
(
"test_method1 called"
)
def
test_method2
(
self
):
print
(
"test_method2 called"
)
class
TestOther
:
@classmethod
def
callme
(
cls
):
print
(
"callme other called"
)
def
test_other
(
self
):
print
(
"test other"
)
# works with unittest as well ...
import
unittest
class
SomeTest
(
unittest
.
TestCase
):
@classmethod
def
callme
(
self
):
print
(
"SomeTest callme called"
)
def
test_unit1
(
self
):
print
(
"test_unit1 method called"
)

```

If you run this without output capturing:

```

$ pytest -q -s test_module.py
callattr_ahead_of_alltests called
callme called!
callme other called
SomeTest callme called
test_method1 called
.test_method2 called
.test other
.test_unit1 method called
.
4 passed
in 0.12s

```


---


# How to parametrize fixtures and test functions - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/parametrize.html


# How to parametrize fixtures and test functions¶

pytest enables test parametrization at several levels: pytest.fixture() allows one to parametrize fixture functions . @pytest.mark.parametrize allows one to define multiple sets of arguments and fixtures at the test function or class. pytest_generate_tests allows one to define custom parametrization schemes or extensions.

# @pytest.mark.parametrize: parametrizing test functions¶

The builtin pytest.mark.parametrize decorator enables parametrization of arguments for a test function. Here is a typical example of a test function that implements checking that a certain input leads to an expected output:

```

# content of test_expectation.py
import
pytest
@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[(
"3+5"
,
8
),
(
"2+4"
,
6
),
(
"6*9"
,
42
)])
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

Here, the @parametrize decorator defines three different (test_input,expected) tuples so that the test_eval function will run three times using them in turn:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 3 items

test_expectation.py
..
F
[100%]
================================= FAILURES =================================
____________________________ test_eval[6*9-42] _____________________________
test_input = '6*9', expected = 42

    @pytest.mark.parametrize("test_input,expected", [("3+5", 8), ("2+4", 6), ("6*9", 42)])
    def test_eval(test_input, expected):
>       assert eval(test_input) == expected
E       AssertionError: assert 54 == 42
E        +  where 54 = eval('6*9')
test_expectation.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_expectation.py::
test_eval[6*9-42]
- AssertionError: assert 54...
=======================
1 failed
,
2 passed
in 0.12s ========================

```

Note Parameter values are passed as-is to tests (no copy whatsoever). For example, if you pass a list or a dict as a parameter value, and the test case code mutates it, the mutations will be reflected in subsequent test case calls. Note pytest by default escapes any non-ascii characters used in unicode strings for the parametrization because it has several downsides. If however you would like to use unicode strings in parametrization and see them in the terminal as is (non-escaped), use this option in your pytest.ini :

```

[pytest]
disable_test_id_escaping_and_forfeit_all_rights_to_community_support
=
True

```

Keep in mind however that this might cause unwanted side effects and even bugs depending on the OS used and plugins currently installed, so use it at your own risk. As designed in this example, only one pair of input/output values fails the simple test function. And as usual with test function arguments, you can see the input and output values in the traceback. Note that you could also use the parametrize marker on a class or a module (see How to mark test functions with attributes ) which would invoke several functions with the argument sets, for instance:

```

import
pytest
@pytest
.
mark
.
parametrize
(
"n,expected"
,
[(
1
,
2
),
(
3
,
4
)])
class
TestClass
:
def
test_simple_case
(
self
,
n
,
expected
):
assert
n
+
1
==
expected
def
test_weird_simple_case
(
self
,
n
,
expected
):
assert
(
n
*
1
)
+
1
==
expected

```

To parametrize all tests in a module, you can assign to the pytestmark global variable:

```

import
pytest
pytestmark
=
pytest
.
mark
.
parametrize
(
"n,expected"
,
[(
1
,
2
),
(
3
,
4
)])
class
TestClass
:
def
test_simple_case
(
self
,
n
,
expected
):
assert
n
+
1
==
expected
def
test_weird_simple_case
(
self
,
n
,
expected
):
assert
(
n
*
1
)
+
1
==
expected

```

It is also possible to mark individual test instances within parametrize, for example with the builtin mark.xfail :

```

# content of test_expectation.py
import
pytest
@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[(
"3+5"
,
8
),
(
"2+4"
,
6
),
pytest
.
param
(
"6*9"
,
42
,
marks
=
pytest
.
mark
.
xfail
)],
)
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

Let’s run this:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 3 items

test_expectation.py
..
x
[100%]
=======================
2 passed
,
1 xfailed
in 0.12s =======================

```

The one parameter set which caused a failure previously now shows up as an “xfailed” (expected to fail) test. In case the values provided to parametrize result in an empty list - for example, if they’re dynamically generated by some function - the behaviour of pytest is defined by the empty_parameter_set_mark option. To get all combinations of multiple parametrized arguments you can stack parametrize decorators:

```

import
pytest
@pytest
.
mark
.
parametrize
(
"x"
,
[
0
,
1
])
@pytest
.
mark
.
parametrize
(
"y"
,
[
2
,
3
])
def
test_foo
(
x
,
y
):
pass

```

This will run the test with the arguments set to x=0/y=2 , x=1/y=2 , x=0/y=3 , and x=1/y=3 exhausting parameters in the order of the decorators.

# Basicpytest_generate_testsexample¶

Sometimes you may want to implement your own parametrization scheme or implement some dynamism for determining the parameters or scope of a fixture. For this, you can use the pytest_generate_tests hook which is called when collecting a test function. Through the passed in metafunc object you can inspect the requesting test context and, most importantly, you can call metafunc.parametrize() to cause parametrization. For example, let’s say we want to run a test taking string inputs which we want to set via a new pytest command line option. Let’s first write a simple test accepting a stringinput fixture function argument:

```

# content of test_strings.py
def
test_valid_string
(
stringinput
):
assert
stringinput
.
isalpha
()

```

Now we add a conftest.py file containing the addition of a command line option and the parametrization of our test function:

```

# content of conftest.py
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--stringinput"
,
action
=
"append"
,
default
=
[],
help
=
"list of stringinputs to pass to test functions"
,
)
def
pytest_generate_tests
(
metafunc
):
if
"stringinput"
in
metafunc
.
fixturenames
:
metafunc
.
parametrize
(
"stringinput"
,
metafunc
.
config
.
getoption
(
"stringinput"
))

```

If we now pass two stringinput values, our test will run twice:

```

$ pytest -q --stringinput="hello" --stringinput="world" test_strings.py
..
[100%]
2 passed
in 0.12s

```

Let’s also run with a stringinput that will lead to a failing test:

```

$ pytest -q --stringinput="!" test_strings.py
F
[100%]
================================= FAILURES =================================
___________________________ test_valid_string[!] ___________________________
stringinput = '!'

    def test_valid_string(stringinput):
>       assert stringinput.isalpha()
E       AssertionError: assert False
E        +  where False = <built-in method isalpha of str object at 0xdeadbeef0001>()
E        +    where <built-in method isalpha of str object at 0xdeadbeef0001> = '!'.isalpha
test_strings.py
:4: AssertionError
========================= short test summary info ==========================
FAILED
test_strings.py::
test_valid_string[!]
- AssertionError: assert False
1 failed
in 0.12s

```

As expected our test function fails. If you don’t specify a stringinput it will be skipped because metafunc.parametrize() will be called with an empty parameter list:

```

$ pytest -q -rs test_strings.py
s
[100%]
========================= short test summary info ==========================
SKIPPED
[1] test_strings.py: got empty parameter set ['stringinput'], function test_valid_string at /home/sweet/project/test_strings.py:2
1 skipped
in 0.12s

```

Note that when calling metafunc.parametrize multiple times with different parameter sets, all parameter names across those sets cannot be duplicated, otherwise an error will be raised.

# More examples¶


---


# pytest for enterprise - pytest documentation

URL: https://docs.pytest.org/en/stable/tidelift.html


# pytest for enterprise¶


---


# How to invoke pytest - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/usage.html


# How to invoke pytest¶

See also Complete pytest command-line flag reference In general, pytest is invoked with the command pytest (see below for other ways to invoke pytest ). This will execute all tests in all files whose names follow the form test_*.py or \*_test.py in the current directory and its subdirectories. More generally, pytest follows standard test discovery rules .

# Specifying which tests to run¶

Pytest supports several ways to run and select tests from the command-line or from a file (see below for reading arguments from file ). Run tests in a module

```

pytest
test_mod.py

```

Run tests in a directory

```

pytest
testing/

```

Run tests by keyword expressions

```

pytest
-k
'MyClass and not method'

```

This will run tests which contain names that match the given string expression (case-insensitive), which can include Python operators that use filenames, class names and function names as variables. The example above will run TestMyClass.test_something but not TestMyClass.test_method_simple . Use "" instead of '' in expression when running this on Windows Run tests by collection arguments Pass the module filename relative to the working directory, followed by specifiers like the class name and function name separated by :: characters, and parameters from parameterization enclosed in [] . To run a specific test within a module:

```

pytest
tests/test_mod.py::test_func

```

To run all tests in a class:

```

pytest
tests/test_mod.py::TestClass

```

Specifying a specific test method:

```

pytest
tests/test_mod.py::TestClass::test_method

```

Specifying a specific parametrization of a test:

```

pytest
tests/test_mod.py::test_func
[
x1,y2
]

```

Run tests by marker expressions To run all tests which are decorated with the @pytest.mark.slow decorator:

```

pytest
-m
slow

```

To run all tests which are decorated with the annotated @pytest.mark.slow(phase=1) decorator, with the phase keyword argument set to 1 :

```

pytest
-m
"slow(phase=1)"

```

For more information see marks . Run tests from packages

```

pytest
--pyargs
pkg.testing

```

This will import pkg.testing and use its filesystem location to find and run tests from. Read arguments from file Added in version 8.2. All of the above can be read from a file using the @ prefix:

```

pytest
@tests_to_run.txt

```

where tests_to_run.txt contains an entry per line, e.g.:

```

tests/test_file.py
tests/test_mod.py::test_func[x1,y2]
tests/test_mod.py::TestClass
-m slow

```

This file can also be generated using pytest --collect-only -q and modified as needed.

# Getting help on version, option names, environment variables¶

```

pytest
--version
# shows where pytest was imported from
pytest
--fixtures
# show available builtin function arguments
pytest
-h
|
--help
# show help on command line and config file options

```

# Profiling test execution duration¶

Changed in version 6.0. To get a list of the slowest 10 test durations over 1.0s long:

```

pytest
--durations
=
10
--durations-min
=
1
.0

```

By default, pytest will not show test durations that are too small (<0.005s) unless -vv is passed on the command-line.

# Managing loading of plugins¶

# Early loading plugins¶

You can early-load plugins (internal and external) explicitly in the command-line with the -p option:

```

pytest
-
p
mypluginmodule

```

The option receives a name parameter, which can be: A full module dotted name, for example myproject.plugins . This dotted name must be importable. The entry-point name of a plugin. This is the name passed to importlib when the plugin is registered. For example to early-load the pytest-cov plugin you can use:

```

pytest
-
p
pytest_cov

```

# Disabling plugins¶

To disable loading specific plugins at invocation time, use the -p option together with the prefix no: . Example: to disable loading the plugin doctest , which is responsible for executing doctest tests from text files, invoke pytest like this:

```

pytest
-p
no:doctest

```

# Other ways of calling pytest¶

# Calling pytest throughpython-mpytest¶

You can invoke testing through the Python interpreter from the command line:

```

python -m pytest [...]

```

This is almost equivalent to invoking the command line script pytest [...] directly, except that calling via python will also add the current directory to sys.path .

# Calling pytest from Python code¶

You can invoke pytest from Python code directly:

```

retcode
=
pytest
.
main
()

```

this acts as if you would call “pytest” from the command line. It will not raise SystemExit but return the exit code instead. If you don’t pass it any arguments, main reads the arguments from the command line arguments of the process ( sys.argv ), which may be undesirable. You can pass in options and arguments explicitly:

```

retcode
=
pytest
.
main
([
"-x"
,
"mytestdir"
])

```

You can specify additional plugins to pytest.main :

```

# content of myinvoke.py
import
sys
import
pytest
class
MyPlugin
:
def
pytest_sessionfinish
(
self
):
print
(
"*** test run reporting finishing"
)
if
__name__
==
"__main__"
:
sys
.
exit
(
pytest
.
main
([
"-qq"
],
plugins
=
[
MyPlugin
()]))

```

Running it will show that MyPlugin was added and its hook was invoked:

```

$ python myinvoke.py
*** test run reporting finishing

```


---


# Managing pytest’s output - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/output.html


# Managing pytest’s output¶

# Modifying Python traceback printing¶

Examples for modifying traceback printing:

```

pytest
--showlocals
# show local variables in tracebacks
pytest
-l
# show local variables (shortcut)
pytest
--no-showlocals
# hide local variables (if addopts enables them)
pytest
--capture
=
fd
# default, capture at the file descriptor level
pytest
--capture
=
sys
# capture at the sys level
pytest
--capture
=
no
# don't capture
pytest
-s
# don't capture (shortcut)
pytest
--capture
=
tee-sys
# capture to logs but also output to sys level streams
pytest
--tb
=
auto
# (default) 'long' tracebacks for the first and last
# entry, but 'short' style for the other entries
pytest
--tb
=
long
# exhaustive, informative traceback formatting
pytest
--tb
=
short
# shorter traceback format
pytest
--tb
=
line
# only one line per failure
pytest
--tb
=
native
# Python standard library formatting
pytest
--tb
=
no
# no traceback at all

```

The --full-trace causes very long traces to be printed on error (longer than --tb=long ). It also ensures that a stack trace is printed on KeyboardInterrupt (Ctrl+C). This is very useful if the tests are taking too long and you interrupt them with Ctrl+C to find out where the tests are hanging . By default no output will be shown (because KeyboardInterrupt is caught by pytest). By using this option you make sure a trace is shown.

# Verbosity¶

Examples for modifying printing verbosity:

```

pytest
--quiet
# quiet - less verbose - mode
pytest
-q
# quiet - less verbose - mode (shortcut)
pytest
-v
# increase verbosity, display individual test names
pytest
-vv
# more verbose, display more details from the test output
pytest
-vvv
# not a standard , but may be used for even more detail in certain setups

```

The -v flag controls the verbosity of pytest output in various aspects: test session progress, assertion details when tests fail, fixtures details with --fixtures , etc. Consider this simple file:

```

# content of test_verbosity_example.py
def
test_ok
():
pass
def
test_words_fail
():
fruits1
=
[
"banana"
,
"apple"
,
"grapes"
,
"melon"
,
"kiwi"
]
fruits2
=
[
"banana"
,
"apple"
,
"orange"
,
"melon"
,
"kiwi"
]
assert
fruits1
==
fruits2
def
test_numbers_fail
():
number_to_text1
=
{
str
(
x
):
x
for
x
in
range
(
5
)}
number_to_text2
=
{
str
(
x
*
10
):
x
*
10
for
x
in
range
(
5
)}
assert
number_to_text1
==
number_to_text2
def
test_long_text_fail
():
long_text
=
"Lorem ipsum dolor sit amet "
*
10
assert
"hello world"
in
long_text

```

Executing pytest normally gives us this output (we are skipping the header to focus on the rest):

```

$ pytest --no-header
=========================== test session starts ============================
collected 4 items

test_verbosity_example.py
.
FFF
[100%]
================================= FAILURES =================================
_____________________________ test_words_fail ______________________________
def test_words_fail():
        fruits1 = ["banana", "apple", "grapes", "melon", "kiwi"]
        fruits2 = ["banana", "apple", "orange", "melon", "kiwi"]
>       assert fruits1 == fruits2
E       AssertionError: assert ['banana', 'a...elon', 'kiwi'] == ['banana', 'a...elon', 'kiwi']
E
E         At index 2 diff: 'grapes' != 'orange'
E         Use -v to get more diff
test_verbosity_example.py
:8: AssertionError
____________________________ test_numbers_fail _____________________________
def test_numbers_fail():
        number_to_text1 = {str(x): x for x in range(5)}
        number_to_text2 = {str(x * 10): x * 10 for x in range(5)}
>       assert number_to_text1 == number_to_text2
E       AssertionError: assert {'0': 0, '1':..., '3': 3, ...} == {'0': 0, '10'...'30': 30, ...}
E
E         Omitting 1 identical items, use -vv to show
E         Left contains 4 more items:
E         {'1': 1, '2': 2, '3': 3, '4': 4}
E         Right contains 4 more items:
E         {'10': 10, '20': 20, '30': 30, '40': 40}
E         Use -v to get more diff
test_verbosity_example.py
:14: AssertionError
___________________________ test_long_text_fail ____________________________
def test_long_text_fail():
        long_text = "Lorem ipsum dolor sit amet " * 10
>       assert "hello world" in long_text
E       AssertionError: assert 'hello world' in 'Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ips... sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet '
test_verbosity_example.py
:19: AssertionError
========================= short test summary info ==========================
FAILED
test_verbosity_example.py::
test_words_fail
- AssertionError: asser...
FAILED
test_verbosity_example.py::
test_numbers_fail
- AssertionError: ass...
FAILED
test_verbosity_example.py::
test_long_text_fail
- AssertionError: a...
=======================
3 failed
,
1 passed
in 0.12s ========================

```

Notice that: Each test inside the file is shown by a single character in the output: . for passing, F for failure. test_words_fail failed, and we are shown a short summary indicating the index 2 of the two lists differ. test_numbers_fail failed, and we are shown a summary of left/right differences on dictionary items. Identical items are omitted. test_long_text_fail failed, and the right hand side of the in statement is truncated using ...` because it is longer than an internal threshold (240 characters currently). Now we can increase pytest’s verbosity:

```

$ pytest --no-header -v
=========================== test session starts ============================
collecting ...
collected 4 items

test_verbosity_example.py::test_ok
PASSED
[ 25%]
test_verbosity_example.py::test_words_fail
FAILED
[ 50%]
test_verbosity_example.py::test_numbers_fail
FAILED
[ 75%]
test_verbosity_example.py::test_long_text_fail
FAILED
[100%]
================================= FAILURES =================================
_____________________________ test_words_fail ______________________________
def test_words_fail():
        fruits1 = ["banana", "apple", "grapes", "melon", "kiwi"]
        fruits2 = ["banana", "apple", "orange", "melon", "kiwi"]
>       assert fruits1 == fruits2
E       AssertionError: assert ['banana', 'a...elon', 'kiwi'] == ['banana', 'a...elon', 'kiwi']
E
E         At index 2 diff: 'grapes' != 'orange'
E
E         Full diff:
E           [
E               'banana',
E               'apple',...
E
E         ...Full output truncated (7 lines hidden), use '-vv' to show
test_verbosity_example.py
:8: AssertionError
____________________________ test_numbers_fail _____________________________
def test_numbers_fail():
        number_to_text1 = {str(x): x for x in range(5)}
        number_to_text2 = {str(x * 10): x * 10 for x in range(5)}
>       assert number_to_text1 == number_to_text2
E       AssertionError: assert {'0': 0, '1':..., '3': 3, ...} == {'0': 0, '10'...'30': 30, ...}
E
E         Omitting 1 identical items, use -vv to show
E         Left contains 4 more items:
E         {'1': 1, '2': 2, '3': 3, '4': 4}
E         Right contains 4 more items:
E         {'10': 10, '20': 20, '30': 30, '40': 40}
E         ...
E
E         ...Full output truncated (16 lines hidden), use '-vv' to show
test_verbosity_example.py
:14: AssertionError
___________________________ test_long_text_fail ____________________________
def test_long_text_fail():
        long_text = "Lorem ipsum dolor sit amet " * 10
>       assert "hello world" in long_text
E       AssertionError: assert 'hello world' in 'Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet '
test_verbosity_example.py
:19: AssertionError
========================= short test summary info ==========================
FAILED
test_verbosity_example.py::
test_words_fail
- AssertionError: asser...
FAILED
test_verbosity_example.py::
test_numbers_fail
- AssertionError: ass...
FAILED
test_verbosity_example.py::
test_long_text_fail
- AssertionError: a...
=======================
3 failed
,
1 passed
in 0.12s ========================

```

Notice now that: Each test inside the file gets its own line in the output. test_words_fail now shows the two failing lists in full, in addition to which index differs. test_numbers_fail now shows a text diff of the two dictionaries, truncated. test_long_text_fail no longer truncates the right hand side of the in statement, because the internal threshold for truncation is larger now (2400 characters currently). Now if we increase verbosity even more:

```

$ pytest --no-header -vv
=========================== test session starts ============================
collecting ...
collected 4 items

test_verbosity_example.py::test_ok
PASSED
[ 25%]
test_verbosity_example.py::test_words_fail
FAILED
[ 50%]
test_verbosity_example.py::test_numbers_fail
FAILED
[ 75%]
test_verbosity_example.py::test_long_text_fail
FAILED
[100%]
================================= FAILURES =================================
_____________________________ test_words_fail ______________________________
def test_words_fail():
        fruits1 = ["banana", "apple", "grapes", "melon", "kiwi"]
        fruits2 = ["banana", "apple", "orange", "melon", "kiwi"]
>       assert fruits1 == fruits2
E       AssertionError: assert ['banana', 'apple', 'grapes', 'melon', 'kiwi'] == ['banana', 'apple', 'orange', 'melon', 'kiwi']
E
E         At index 2 diff: 'grapes' != 'orange'
E
E         Full diff:
E           [
E               'banana',
E               'apple',
E         -     'orange',
E         ?      ^  ^^
E         +     'grapes',
E         ?      ^  ^ +
E               'melon',
E               'kiwi',
E           ]
test_verbosity_example.py
:8: AssertionError
____________________________ test_numbers_fail _____________________________
def test_numbers_fail():
        number_to_text1 = {str(x): x for x in range(5)}
        number_to_text2 = {str(x * 10): x * 10 for x in range(5)}
>       assert number_to_text1 == number_to_text2
E       AssertionError: assert {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4} == {'0': 0, '10': 10, '20': 20, '30': 30, '40': 40}
E
E         Common items:
E         {'0': 0}
E         Left contains 4 more items:
E         {'1': 1, '2': 2, '3': 3, '4': 4}
E         Right contains 4 more items:
E         {'10': 10, '20': 20, '30': 30, '40': 40}
E
E         Full diff:
E           {
E               '0': 0,
E         -     '10': 10,
E         ?       -    -
E         +     '1': 1,
E         -     '20': 20,
E         ?       -    -
E         +     '2': 2,
E         -     '30': 30,
E         ?       -    -
E         +     '3': 3,
E         -     '40': 40,
E         ?       -    -
E         +     '4': 4,
E           }
test_verbosity_example.py
:14: AssertionError
___________________________ test_long_text_fail ____________________________
def test_long_text_fail():
        long_text = "Lorem ipsum dolor sit amet " * 10
>       assert "hello world" in long_text
E       AssertionError: assert 'hello world' in 'Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet '
test_verbosity_example.py
:19: AssertionError
========================= short test summary info ==========================
FAILED
test_verbosity_example.py::
test_words_fail
- AssertionError: assert ['banana', 'apple', 'grapes', 'melon', 'kiwi'] == ['banana', 'apple', 'orange', 'melon', 'kiwi']

  At index 2 diff: 'grapes' != 'orange'

  Full diff:
    [
        'banana',
        'apple',
  -     'orange',
  ?      ^  ^^
  +     'grapes',
  ?      ^  ^ +
        'melon',
        'kiwi',
    ]
FAILED test_verbosity_example.py::test_numbers_fail - AssertionError: assert {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4} == {'0': 0, '10': 10, '20': 20, '30': 30, '40': 40}

  Common items:
  {'0': 0}
  Left contains 4 more items:
  {'1': 1, '2': 2, '3': 3, '4': 4}
  Right contains 4 more items:
  {'10': 10, '20': 20, '30': 30, '40': 40}

  Full diff:
    {
        '0': 0,
  -     '10': 10,
  ?       -    -
  +     '1': 1,
  -     '20': 20,
  ?       -    -
  +     '2': 2,
  -     '30': 30,
  ?       -    -
  +     '3': 3,
  -     '40': 40,
  ?       -    -
  +     '4': 4,
    }
FAILED test_verbosity_example.py::test_long_text_fail - AssertionError: assert 'hello world' in 'Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet '
=======================
3 failed
,
1 passed
in 0.12s ========================

```

Notice now that: Each test inside the file gets its own line in the output. test_words_fail gives the same output as before in this case. test_numbers_fail now shows a full text diff of the two dictionaries. test_long_text_fail also doesn’t truncate on the right hand side as before, but now pytest won’t truncate any text at all, regardless of its size. Those were examples of how verbosity affects normal test session output, but verbosity also is used in other situations, for example you are shown even fixtures that start with _ if you use pytest --fixtures -v . Using higher verbosity levels ( -vvv , -vvvv , …) is supported, but has no effect in pytest itself at the moment, however some plugins might make use of higher verbosity.

# Fine-grained verbosity¶

In addition to specifying the application wide verbosity level, it is possible to control specific aspects independently. This is done by setting a verbosity level in the configuration file for the specific aspect of the output. verbosity_assertions : Controls how verbose the assertion output should be when pytest is executed. Running pytest --no-header with a value of 2 would have the same output as the previous example, but each test inside the file is shown by a single character in the output. verbosity_test_cases : Controls how verbose the test execution output should be when pytest is executed. Running pytest --no-header with a value of 2 would have the same output as the first verbosity example, but each test inside the file gets its own line in the output.

# Producing a detailed summary report¶

The -r flag can be used to display a “short test summary info” at the end of the test session, making it easy in large test suites to get a clear picture of all failures, skips, xfails, etc. It defaults to fE to list failures and errors. Example:

```

# content of test_example.py
import
pytest
@pytest
.
fixture
def
error_fixture
():
assert
0
def
test_ok
():
print
(
"ok"
)
def
test_fail
():
assert
0
def
test_error
(
error_fixture
):
pass
def
test_skip
():
pytest
.
skip
(
"skipping this test"
)
def
test_xfail
():
pytest
.
xfail
(
"xfailing this test"
)
@pytest
.
mark
.
xfail
(
reason
=
"always xfail"
)
def
test_xpass
():
pass

```

```

$ pytest -ra
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 6 items

test_example.py
.
FE
sxX
[100%]
================================== ERRORS ==================================
_______________________ ERROR at setup of test_error _______________________
@pytest.fixture
    def error_fixture():
>       assert 0
E       assert 0
test_example.py
:6: AssertionError
================================= FAILURES =================================
________________________________ test_fail _________________________________
def test_fail():
>       assert 0
E       assert 0
test_example.py
:14: AssertionError
================================= XPASSES ==================================
========================= short test summary info ==========================
SKIPPED
[1] test_example.py:22: skipping this test
XFAIL test_example.py::
test_xfail
- reason: xfailing this test
XPASS
test_example.py::
test_xpass
- always xfail
ERROR
test_example.py::
test_error
- assert 0
FAILED
test_example.py::
test_fail
- assert 0
==
1 failed
,
1 passed
,
1 skipped
,
1 xfailed
,
1 xpassed
,
1 error
in 0.12s ===

```

The -r options accepts a number of characters after it, with a used above meaning “all except passes”. Here is the full list of available characters that can be used: f - failed E - error s - skipped x - xfailed X - xpassed p - passed P - passed with output Special characters for (de)selection of groups: a - all except pP A - all N - none, this can be used to display nothing (since fE is the default) More than one character can be used, so for example to only see failed and skipped tests, you can execute:

```

$ pytest -rfs
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 6 items

test_example.py
.
FE
sxX
[100%]
================================== ERRORS ==================================
_______________________ ERROR at setup of test_error _______________________
@pytest.fixture
    def error_fixture():
>       assert 0
E       assert 0
test_example.py
:6: AssertionError
================================= FAILURES =================================
________________________________ test_fail _________________________________
def test_fail():
>       assert 0
E       assert 0
test_example.py
:14: AssertionError
========================= short test summary info ==========================
FAILED
test_example.py::
test_fail
- assert 0
SKIPPED
[1] test_example.py:22: skipping this test
==
1 failed
,
1 passed
,
1 skipped
,
1 xfailed
,
1 xpassed
,
1 error
in 0.12s ===

```

Using p lists the passing tests, whilst P adds an extra section “PASSES” with those tests that passed but had captured output:

```

$ pytest -rpP
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 6 items

test_example.py
.
FE
sxX
[100%]
================================== ERRORS ==================================
_______________________ ERROR at setup of test_error _______________________
@pytest.fixture
    def error_fixture():
>       assert 0
E       assert 0
test_example.py
:6: AssertionError
================================= FAILURES =================================
________________________________ test_fail _________________________________
def test_fail():
>       assert 0
E       assert 0
test_example.py
:14: AssertionError
================================== PASSES ==================================
_________________________________ test_ok __________________________________
--------------------------- Captured stdout call ---------------------------
ok
========================= short test summary info ==========================
PASSED
test_example.py::test_ok
==
1 failed
,
1 passed
,
1 skipped
,
1 xfailed
,
1 xpassed
,
1 error
in 0.12s ===

```

Note By default, parametrized variants of skipped tests are grouped together if they share the same skip reason. You can use --no-fold-skipped to print each skipped test separately.

# Creating resultlog format files¶

To create plain-text machine-readable result files you can issue:

```

pytest
--resultlog
=
path

```

and look at the content at the path location. Such files are used e.g. by the PyPy-test web page to show test results over several revisions. Warning This option is rarely used and is scheduled for removal in pytest 6.0. If you use this option, consider using the new pytest-reportlog plugin instead. See the deprecation docs for more information.

# Creating JUnitXML format files¶

To create result files which can be read by Jenkins or other Continuous integration servers, use this invocation:

```

pytest
--junit-xml
=
path

```

to create an XML file at path . To set the name of the root test suite xml item, you can configure the junit_suite_name option in your config file:

```

[pytest]
junit_suite_name
=
my_suite

```

Added in version 4.0. JUnit XML specification seems to indicate that "time" attribute should report total test execution times, including setup and teardown ( 1 , 2 ). It is the default pytest behavior. To report just call durations instead, configure the junit_duration_report option like this:

```

[pytest]
junit_duration_report
=
call

```

# record_property¶

If you want to log additional information for a test, you can use the record_property fixture:

```

def
test_function
(
record_property
):
record_property
(
"example_key"
,
1
)
assert
True

```

This will add an extra property example_key="1" to the generated testcase tag:

```

<testcase
classname=
"test_function"
file=
"test_function.py"
line=
"0"
name=
"test_function"
time=
"0.0009"
>
<properties>
<property
name=
"example_key"
value=
"1"
/>
</properties>
</testcase>

```

Alternatively, you can integrate this functionality with custom markers:

```

# content of conftest.py
def
pytest_collection_modifyitems
(
session
,
config
,
items
):
for
item
in
items
:
for
marker
in
item
.
iter_markers
(
name
=
"test_id"
):
test_id
=
marker
.
args
[
0
]
item
.
user_properties
.
append
((
"test_id"
,
test_id
))

```

And in your tests:

```

# content of test_function.py
import
pytest
@pytest
.
mark
.
test_id
(
1501
)
def
test_function
():
assert
True

```

Will result in:

```

<testcase
classname=
"test_function"
file=
"test_function.py"
line=
"0"
name=
"test_function"
time=
"0.0009"
>
<properties>
<property
name=
"test_id"
value=
"1501"
/>
</properties>
</testcase>

```

Warning Please note that using this feature will break schema verifications for the latest JUnitXML schema. This might be a problem when used with some CI servers.

# record_xml_attribute¶

To add an additional xml attribute to a testcase element, you can use record_xml_attribute fixture. This can also be used to override existing values:

```

def
test_function
(
record_xml_attribute
):
record_xml_attribute
(
"assertions"
,
"REQ-1234"
)
record_xml_attribute
(
"classname"
,
"custom_classname"
)
print
(
"hello world"
)
assert
True

```

Unlike record_property , this will not add a new child element. Instead, this will add an attribute assertions="REQ-1234" inside the generated testcase tag and override the default classname with "classname=custom_classname" :

```

<testcase
classname=
"custom_classname"
file=
"test_function.py"
line=
"0"
name=
"test_function"
time=
"0.003"
assertions=
"REQ-1234"
>
<system-out>
hello
world
</system-out>
</testcase>

```

Warning record_xml_attribute is an experimental feature, and its interface might be replaced by something more powerful and general in future versions. The functionality per-se will be kept, however. Using this over record_xml_property can help when using ci tools to parse the xml report. However, some parsers are quite strict about the elements and attributes that are allowed. Many tools use an xsd schema (like the example below) to validate incoming xml. Make sure you are using attribute names that are allowed by your parser. Below is the Scheme used by Jenkins to validate the XML report:

```

<xs:element
name=
"testcase"
>
<xs:complexType>
<xs:sequence>
<xs:element
ref=
"skipped"
minOccurs=
"0"
maxOccurs=
"1"
/>
<xs:element
ref=
"error"
minOccurs=
"0"
maxOccurs=
"unbounded"
/>
<xs:element
ref=
"failure"
minOccurs=
"0"
maxOccurs=
"unbounded"
/>
<xs:element
ref=
"system-out"
minOccurs=
"0"
maxOccurs=
"unbounded"
/>
<xs:element
ref=
"system-err"
minOccurs=
"0"
maxOccurs=
"unbounded"
/>
</xs:sequence>
<xs:attribute
name=
"name"
type=
"xs:string"
use=
"required"
/>
<xs:attribute
name=
"assertions"
type=
"xs:string"
use=
"optional"
/>
<xs:attribute
name=
"time"
type=
"xs:string"
use=
"optional"
/>
<xs:attribute
name=
"classname"
type=
"xs:string"
use=
"optional"
/>
<xs:attribute
name=
"status"
type=
"xs:string"
use=
"optional"
/>
</xs:complexType>
</xs:element>

```

Warning Please note that using this feature will break schema verifications for the latest JUnitXML schema. This might be a problem when used with some CI servers.

# record_testsuite_property¶

Added in version 4.5. If you want to add a properties node at the test-suite level, which may contains properties that are relevant to all tests, you can use the record_testsuite_property session-scoped fixture: The record_testsuite_property session-scoped fixture can be used to add properties relevant to all tests.

```

import
pytest
@pytest
.
fixture
(
scope
=
"session"
,
autouse
=
True
)
def
log_global_env_facts
(
record_testsuite_property
):
record_testsuite_property
(
"ARCH"
,
"PPC"
)
record_testsuite_property
(
"STORAGE_TYPE"
,
"CEPH"
)
class
TestMe
:
def
test_foo
(
self
):
assert
True

```

The fixture is a callable which receives name and value of a <property> tag added at the test-suite level of the generated xml:

```

<testsuite
errors=
"0"
failures=
"0"
name=
"pytest"
skipped=
"0"
tests=
"1"
time=
"0.006"
>
<properties>
<property
name=
"ARCH"
value=
"PPC"
/>
<property
name=
"STORAGE_TYPE"
value=
"CEPH"
/>
</properties>
<testcase
classname=
"test_me.TestMe"
file=
"test_me.py"
line=
"16"
name=
"test_foo"
time=
"0.000243663787842"
/>
</testsuite>

```

name must be a string, value will be converted to a string and properly xml-escaped. The generated XML is compatible with the latest xunit standard, contrary to record_property and record_xml_attribute .

# Sending test report to an online pastebin service¶

Creating a URL for each test failure :

```

pytest
--pastebin
=
failed

```

This will submit test run information to a remote Paste service and provide a URL for each failure. You may select tests as usual or add for example -x if you only want to send one particular failure. Creating a URL for a whole test session log :

```

pytest
--pastebin
=
all

```


---


# API Reference - pytest documentation

URL: https://docs.pytest.org/en/stable/reference/reference.html


# API Reference¶

This page contains the full reference to pytest’s API.

# Constants¶

# pytest.__version__¶

The current pytest version, as a string:

```

>>>
import
pytest
>>>
pytest
.
__version__
'7.0.0'

```

# pytest.version_tuple¶

Added in version 7.0. The current pytest version, as a tuple:

```

>>>
import
pytest
>>>
pytest
.
version_tuple
(7, 0, 0)

```

For pre-releases, the last component will be a string with the prerelease version:

```

>>>
import
pytest
>>>
pytest
.
version_tuple
(7, 0, '0rc1')

```

# Functions¶

# pytest.approx¶

Assert that two numbers (or two ordered sequences of numbers) are equal to each other within some tolerance. Due to the Floating-Point Arithmetic: Issues and Limitations , numbers that we would intuitively expect to be equal are not always so:

```

>>>
0.1
+
0.2
==
0.3
False

```

This problem is commonly encountered when writing tests, e.g. when making sure that floating-point values are what you expect them to be. One way to deal with this problem is to assert that two floating-point numbers are equal to within some appropriate tolerance:

```

>>>
abs
((
0.1
+
0.2
)
-
0.3
)
<
1e-6
True

```

However, comparisons like this are tedious to write and difficult to understand. Furthermore, absolute comparisons like the one above are usually discouraged because there’s no tolerance that works well for all situations. 1e-6 is good for numbers around 1 , but too small for very big numbers and too big for very small ones. It’s better to express the tolerance as a fraction of the expected value, but relative comparisons like that are even more difficult to write correctly and concisely. The approx class performs floating-point comparisons using a syntax that’s as intuitive as possible:

```

>>>
from
pytest
import
approx
>>>
0.1
+
0.2
==
approx
(
0.3
)
True

```

The same syntax also works for ordered sequences of numbers:

```

>>>
(
0.1
+
0.2
,
0.2
+
0.4
)
==
approx
((
0.3
,
0.6
))
True

```

numpy arrays:

```

>>>
import
numpy
as
np
>>>
np
.
array
([
0.1
,
0.2
])
+
np
.
array
([
0.2
,
0.4
])
==
approx
(
np
.
array
([
0.3
,
0.6
]))
True

```

And for a numpy array against a scalar:

```

>>>
import
numpy
as
np
>>>
np
.
array
([
0.1
,
0.2
])
+
np
.
array
([
0.2
,
0.1
])
==
approx
(
0.3
)
True

```

Only ordered sequences are supported, because approx needs to infer the relative position of the sequences without ambiguity. This means sets and other unordered sequences are not supported. Finally, dictionary values can also be compared:

```

>>>
{
'a'
:
0.1
+
0.2
,
'b'
:
0.2
+
0.4
}
==
approx
({
'a'
:
0.3
,
'b'
:
0.6
})
True

```

The comparison will be true if both mappings have the same keys and their respective values match the expected tolerances. Tolerances By default, approx considers numbers within a relative tolerance of 1e-6 (i.e. one part in a million) of its expected value to be equal. This treatment would lead to surprising results if the expected value was 0.0 , because nothing but 0.0 itself is relatively close to 0.0 . To handle this case less surprisingly, approx also considers numbers within an absolute tolerance of 1e-12 of its expected value to be equal. Infinity and NaN are special cases. Infinity is only considered equal to itself, regardless of the relative tolerance. NaN is not considered equal to anything by default, but you can make it be equal to itself by setting the nan_ok argument to True. (This is meant to facilitate comparing arrays that use NaN to mean “no data”.) Both the relative and absolute tolerances can be changed by passing arguments to the approx constructor:

```

>>>
1.0001
==
approx
(
1
)
False
>>>
1.0001
==
approx
(
1
,
rel
=
1e-3
)
True
>>>
1.0001
==
approx
(
1
,
abs
=
1e-3
)
True

```

If you specify abs but not rel , the comparison will not consider the relative tolerance at all. In other words, two numbers that are within the default relative tolerance of 1e-6 will still be considered unequal if they exceed the specified absolute tolerance. If you specify both abs and rel , the numbers will be considered equal if either tolerance is met:

```

>>>
1
+
1e-8
==
approx
(
1
)
True
>>>
1
+
1e-8
==
approx
(
1
,
abs
=
1e-12
)
False
>>>
1
+
1e-8
==
approx
(
1
,
rel
=
1e-6
,
abs
=
1e-12
)
True

```

You can also use approx to compare nonnumeric types, or dicts and sequences containing nonnumeric types, in which case it falls back to strict equality. This can be useful for comparing dicts and sequences that can contain optional values:

```

>>>
{
"required"
:
1.0000005
,
"optional"
:
None
}
==
approx
({
"required"
:
1
,
"optional"
:
None
})
True
>>>
[
None
,
1.0000005
]
==
approx
([
None
,
1
])
True
>>>
[
"foo"
,
1.0000005
]
==
approx
([
None
,
1
])
False

```

If you’re thinking about using approx , then you might want to know how it compares to other good ways of comparing floating-point numbers. All of these algorithms are based on relative and absolute tolerances and should agree for the most part, but they do have meaningful differences: math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0) : True if the relative tolerance is met w.r.t. either a or b or if the absolute tolerance is met. Because the relative tolerance is calculated w.r.t. both a and b , this test is symmetric (i.e. neither a nor b is a “reference value”). You have to specify an absolute tolerance if you want to compare to 0.0 because there is no tolerance by default. More information: math.isclose() . numpy.isclose(a, b, rtol=1e-5, atol=1e-8) : True if the difference between a and b is less that the sum of the relative tolerance w.r.t. b and the absolute tolerance. Because the relative tolerance is only calculated w.r.t. b , this test is asymmetric and you can think of b as the reference value. Support for comparing sequences is provided by numpy.allclose() . More information: numpy.isclose . unittest.TestCase.assertAlmostEqual(a, b) : True if a and b are within an absolute tolerance of 1e-7 . No relative tolerance is considered , so this function is not appropriate for very large or very small numbers. Also, it’s only available in subclasses of unittest.TestCase and it’s ugly because it doesn’t follow PEP8. More information: unittest.TestCase.assertAlmostEqual() . a == pytest.approx(b, rel=1e-6, abs=1e-12) : True if the relative tolerance is met w.r.t. b or if the absolute tolerance is met. Because the relative tolerance is only calculated w.r.t. b , this test is asymmetric and you can think of b as the reference value. In the special case that you explicitly specify an absolute tolerance but not a relative tolerance, only the absolute tolerance is considered. Note approx can handle numpy arrays, but we recommend the specialised test helpers in Test support (numpy.testing) if you need support for comparisons, NaNs, or ULP-based tolerances. To match strings using regex, you can use Matches from the re_assert package . Warning Changed in version 3.2. In order to avoid inconsistent behavior, TypeError is raised for > , >= , < and <= comparisons. The example below illustrates the problem:

```

assert
approx
(
0.1
)
>
0.1
+
1e-10
# calls approx(0.1).__gt__(0.1 + 1e-10)
assert
0.1
+
1e-10
>
approx
(
0.1
)
# calls approx(0.1).__lt__(0.1 + 1e-10)

```

In the second example one expects approx(0.1).__le__(0.1 + 1e-10) to be called. But instead, approx(0.1).__lt__(0.1 + 1e-10) is used to comparison. This is because the call hierarchy of rich comparisons follows a fixed behavior. More information: object.__ge__() Changed in version 3.7.1: approx raises TypeError when it encounters a dict value or sequence element of nonnumeric type. Changed in version 6.1.0: approx falls back to strict equality for nonnumeric types instead of raising TypeError .

# pytest.fail¶

Tutorial : How to use skip and xfail to deal with tests that cannot succeed Explicitly fail an executing test with the given message. reason ( str ) – The message to show the user as reason for the failure. pytrace ( bool ) – If False, msg represents the full failure information and no python traceback will be reported. pytest.fail.Exception – The exception that is raised. The exception raised by pytest.fail() .

# pytest.skip¶

Skip an executing test with the given message. This function should be called only during testing (setup, call or teardown) or during collection by using the allow_module_level flag. This function can be called in doctests as well. reason ( str ) – The message to show the user as reason for the skip. allow_module_level ( bool ) – Allows this function to be called at module level. Raising the skip exception at module level will stop the execution of the module and prevent the collection of all tests in the module, even those defined before the skip call. Defaults to False. Allows this function to be called at module level. Raising the skip exception at module level will stop the execution of the module and prevent the collection of all tests in the module, even those defined before the skip call. Defaults to False. pytest.skip.Exception – The exception that is raised. Note It is better to use the pytest.mark.skipif marker when possible to declare a test to be skipped under certain conditions like mismatching platforms or dependencies. Similarly, use the # doctest: +SKIP directive (see doctest.SKIP ) to skip a doctest statically. The exception raised by pytest.skip() .

# pytest.importorskip¶

Import and return the requested module modname , or skip the current test if the module cannot be imported. modname ( str ) – The name of the module to import. minversion ( str | None ) – If given, the imported module’s __version__ attribute must be at least this minimal version, otherwise the test is still skipped. reason ( str | None ) – If given, this reason is shown as the message when the module cannot be imported. exc_type ( type [ ImportError ] | None ) – The exception that should be captured in order to skip modules. Must be ImportError or a subclass. If the module can be imported but raises ImportError , pytest will issue a warning to the user, as often users expect the module not to be found (which would raise ModuleNotFoundError instead). This warning can be suppressed by passing exc_type=ImportError explicitly. See pytest.importorskip default behavior regarding ImportError for details. The exception that should be captured in order to skip modules. Must be ImportError or a subclass. If the module can be imported but raises ImportError , pytest will issue a warning to the user, as often users expect the module not to be found (which would raise ModuleNotFoundError instead). This warning can be suppressed by passing exc_type=ImportError explicitly. See pytest.importorskip default behavior regarding ImportError for details. The imported module. This should be assigned to its canonical name. pytest.skip.Exception – If the module cannot be imported. Any Example:

```

docutils
=
pytest
.
importorskip
(
"docutils"
)

```

Added in version 8.2: The exc_type parameter.

# pytest.xfail¶

Imperatively xfail an executing test or setup function with the given reason. This function should be called only during testing (setup, call or teardown). No other code is executed after using xfail() (it is implemented internally by raising an exception). reason ( str ) – The message to show the user as reason for the xfail. Note It is better to use the pytest.mark.xfail marker when possible to declare a test to be xfailed under certain conditions like known bugs or missing features. pytest.xfail.Exception – The exception that is raised. The exception raised by pytest.xfail() .

# pytest.exit¶

Exit testing process. reason ( str ) – The message to show as the reason for exiting pytest. reason has a default value only because msg is deprecated. returncode ( int | None ) – Return code to be used when exiting pytest. None means the same as 0 (no error), same as sys.exit() . pytest.exit.Exception – The exception that is raised. The exception raised by pytest.exit() .

# pytest.main¶

Tutorial : Calling pytest from Python code Perform an in-process test run. args ( list [ str ] | PathLike [ str ] | None ) – List of command line arguments. If None or not given, defaults to reading arguments directly from the process command line ( sys.argv ). plugins ( Sequence [ str | object ] | None ) – List of plugin objects to be auto-registered during initialization. An exit code. int | ExitCode

# pytest.param¶

Specify a parameter in pytest.mark.parametrize calls or parametrized fixtures .

```

@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[
(
"3+5"
,
8
),
pytest
.
param
(
"6*9"
,
42
,
marks
=
pytest
.
mark
.
xfail
),
],
)
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

values ( object ) – Variable args of the values of the parameter set, in order. marks ( MarkDecorator | Collection [ MarkDecorator | Mark ] ) – A single mark or a list of marks to be applied to this parameter set. id ( str | None ) – The id to attribute to this parameter set.

# pytest.raises¶

Tutorial : Assertions about expected exceptions Assert that a code block/function call raises an exception type, or one of its subclasses. expected_exception – The expected exception type, or a tuple if one of multiple possible exception types are expected. Note that subclasses of the passed exceptions will also match. match ( str | re.Pattern [ str ] | None ) – If specified, a string containing a regular expression, or a regular expression object, that is tested against the string representation of the exception and its PEP 678 __notes__ using re.search() . To match a literal string that may contain special characters , the pattern can first be escaped with re.escape() . (This is only used when pytest.raises is used as a context manager, and passed through to the function otherwise. When using pytest.raises as a function, you can use: pytest.raises(Exc, func, match="passed on").match("my pattern") .) If specified, a string containing a regular expression, or a regular expression object, that is tested against the string representation of the exception and its PEP 678 __notes__ using re.search() . To match a literal string that may contain special characters , the pattern can first be escaped with re.escape() . (This is only used when pytest.raises is used as a context manager, and passed through to the function otherwise. When using pytest.raises as a function, you can use: pytest.raises(Exc, func, match="passed on").match("my pattern") .) Use pytest.raises as a context manager, which will capture the exception of the given type, or any of its subclasses:

```

>>>
import
pytest
>>>
with
pytest
.
raises
(
ZeroDivisionError
):
...
1
/
0

```

If the code block does not raise the expected exception ( ZeroDivisionError in the example above), or no exception at all, the check will fail instead. You can also use the keyword argument match to assert that the exception matches a text or regex:

```

>>>
with
pytest
.
raises
(
ValueError
,
match
=
'must be 0 or None'
):
...
raise
ValueError
(
"value must be 0 or None"
)
>>>
with
pytest
.
raises
(
ValueError
,
match
=
r
'must be \d+$'
):
...
raise
ValueError
(
"value must be 42"
)

```

The match argument searches the formatted exception string, which includes any PEP-678 __notes__ :

```

>>>
with
pytest
.
raises
(
ValueError
,
match
=
r
"had a note added"
):
...
e
=
ValueError
(
"value must be 42"
)
...
e
.
add_note
(
"had a note added"
)
...
raise
e

```

The context manager produces an ExceptionInfo object which can be used to inspect the details of the captured exception:

```

>>>
with
pytest
.
raises
(
ValueError
)
as
exc_info
:
...
raise
ValueError
(
"value must be 42"
)
>>>
assert
exc_info
.
type
is
ValueError
>>>
assert
exc_info
.
value
.
args
[
0
]
==
"value must be 42"

```

Warning Given that pytest.raises matches subclasses, be wary of using it to match Exception like this:

```

with
pytest
.
raises
(
Exception
):
# Careful, this will catch ANY exception raised.
some_function
()

```

Because Exception is the base class of almost all exceptions, it is easy for this to hide real bugs, where the user wrote this expecting a specific exception, but some other exception is being raised due to a bug introduced during a refactoring. Avoid using pytest.raises to catch Exception unless certain that you really want to catch any exception raised. Note When using pytest.raises as a context manager, it’s worthwhile to note that normal context manager rules apply and that the exception raised must be the final line in the scope of the context manager. Lines of code after that, within the scope of the context manager will not be executed. For example:

```

>>>
value
=
15
>>>
with
pytest
.
raises
(
ValueError
)
as
exc_info
:
...
if
value
>
10
:
...
raise
ValueError
(
"value must be <= 10"
)
...
assert
exc_info
.
type
is
ValueError
# This will not execute.

```

Instead, the following approach must be taken (note the difference in scope):

```

>>>
with
pytest
.
raises
(
ValueError
)
as
exc_info
:
...
if
value
>
10
:
...
raise
ValueError
(
"value must be <= 10"
)
...
>>>
assert
exc_info
.
type
is
ValueError

```

Using with pytest.mark.parametrize When using pytest.mark.parametrize it is possible to parametrize tests such that some runs raise an exception and others do not. See Parametrizing conditional raising for an example. See also Assertions about expected exceptions for more examples and detailed discussion. Legacy form It is possible to specify a callable by passing a to-be-called lambda:

```

>>>
raises
(
ZeroDivisionError
,
lambda
:
1
/
0
)
<ExceptionInfo ...>

```

or you can specify an arbitrary callable with arguments:

```

>>>
def
f
(
x
):
return
1
/
x
...
>>>
raises
(
ZeroDivisionError
,
f
,
0
)
<ExceptionInfo ...>
>>>
raises
(
ZeroDivisionError
,
f
,
x
=
0
)
<ExceptionInfo ...>

```

The form above is fully supported but discouraged for new code because the context manager form is regarded as more readable and less error-prone. Note Similar to caught exception objects in Python, explicitly clearing local references to returned ExceptionInfo objects can help the Python interpreter speed up its garbage collection. Clearing those references breaks a reference cycle ( ExceptionInfo –> caught exception –> frame stack raising the exception –> current frame stack –> local variables –> ExceptionInfo ) which makes Python keep all objects referenced from that cycle (including all local variables in the current frame) alive until the next cyclic garbage collection run. More detailed information can be found in the official Python documentation for the try statement .

# pytest.deprecated_call¶

Tutorial : Ensuring code triggers a deprecation warning Assert that code produces a DeprecationWarning or PendingDeprecationWarning or FutureWarning . This function can be used as a context manager:

```

>>>
import
warnings
>>>
def
api_call_v2
():
...
warnings
.
warn
(
'use v3 of this api'
,
DeprecationWarning
)
...
return
200
>>>
import
pytest
>>>
with
pytest
.
deprecated_call
():
...
assert
api_call_v2
()
==
200

```

It can also be used by passing a function and *args and **kwargs , in which case it will ensure calling func(*args, **kwargs) produces one of the warnings types above. The return value is the return value of the function. In the context manager form you may use the keyword argument match to assert that the warning matches a text or regex. The context manager produces a list of warnings.WarningMessage objects, one for each warning raised.

# pytest.register_assert_rewrite¶

Tutorial : Assertion Rewriting Register one or more module names to be rewritten on import. This function will make sure that this module or all modules inside the package will get their assert statements rewritten. Thus you should make sure to call this before the module is actually imported, usually in your __init__.py if you are a plugin using a package. names ( str ) – The module names to register.

# pytest.warns¶

Tutorial : Asserting warnings with the warns function Assert that code raises a particular class of warning. Specifically, the parameter expected_warning can be a warning class or tuple of warning classes, and the code inside the with block must issue at least one warning of that class or classes. This helper produces a list of warnings.WarningMessage objects, one for each warning emitted (regardless of whether it is an expected_warning or not). Since pytest 8.0, unmatched warnings are also re-emitted when the context closes. This function can be used as a context manager:

```

>>>
import
pytest
>>>
with
pytest
.
warns
(
RuntimeWarning
):
...
warnings
.
warn
(
"my warning"
,
RuntimeWarning
)

```

In the context manager form you may use the keyword argument match to assert that the warning matches a text or regex:

```

>>>
with
pytest
.
warns
(
UserWarning
,
match
=
'must be 0 or None'
):
...
warnings
.
warn
(
"value must be 0 or None"
,
UserWarning
)
>>>
with
pytest
.
warns
(
UserWarning
,
match
=
r
'must be \d+$'
):
...
warnings
.
warn
(
"value must be 42"
,
UserWarning
)
>>>
with
pytest
.
warns
(
UserWarning
):
# catch re-emitted warning
...
with
pytest
.
warns
(
UserWarning
,
match
=
r
'must be \d+$'
):
...
warnings
.
warn
(
"this is not here"
,
UserWarning
)
Traceback (most recent call last):
...
Failed
:
DID NOT WARN. No warnings of type ...UserWarning... were emitted...

```

Using with pytest.mark.parametrize When using pytest.mark.parametrize it is possible to parametrize tests such that some runs raise a warning and others do not. This could be achieved in the same way as with exceptions, see Parametrizing conditional raising for an example.

# pytest.freeze_includes¶

Tutorial : Freezing pytest Return a list of module names used by pytest that should be included by cx_freeze.

# Marks¶

Marks can be used to apply metadata to test functions (but not fixtures), which can then be accessed by fixtures or plugins.

# pytest.mark.filterwarnings¶

Tutorial : @pytest.mark.filterwarnings Add warning filters to marked test items. filter ( str ) – A warning specification string , which is composed of contents of the tuple (action, message, category, module, lineno) as specified in The Warnings Filter section of the Python documentation, separated by ":" . Optional fields can be omitted. Module names passed for filtering are not regex-escaped. For example: @pytest . mark . filterwarnings ( "ignore:.*usage will be deprecated.*:DeprecationWarning" ) def test_foo (): ... A warning specification string , which is composed of contents of the tuple (action, message, category, module, lineno) as specified in The Warnings Filter section of the Python documentation, separated by ":" . Optional fields can be omitted. Module names passed for filtering are not regex-escaped. For example:

```

@pytest
.
mark
.
filterwarnings
(
"ignore:.*usage will be deprecated.*:DeprecationWarning"
)
def
test_foo
():
...

```

# pytest.mark.parametrize¶

Tutorial : How to parametrize fixtures and test functions This mark has the same signature as pytest.Metafunc.parametrize() ; see there.

# pytest.mark.skip¶

Tutorial : Skipping test functions Unconditionally skip a test function. reason ( str ) – Reason why the test function is being skipped.

# pytest.mark.skipif¶

Tutorial : Skipping test functions Skip a test function if a condition is True . condition ( bool or str ) – True/False if the condition should be skipped or a condition string . reason ( str ) – Reason why the test function is being skipped.

# pytest.mark.usefixtures¶

Tutorial : Use fixtures in classes and modules with usefixtures Mark a test function as using the given fixture names. args – The names of the fixture to use, as strings. Note When using usefixtures in hooks, it can only load fixtures when applied to a test function before test setup (for example in the pytest_collection_modifyitems hook). Also note that this mark has no effect when applied to fixtures .

# pytest.mark.xfail¶

Tutorial : XFail: mark test functions as expected to fail Marks a test function as expected to fail . condition ( Union [ bool , str ] ) – Condition for marking the test function as xfail ( True/False or a condition string ). If a bool , you also have to specify reason (see condition string ). reason ( str ) – Reason why the test function is marked as xfail. raises (Type[ Exception ]) – Exception class (or tuple of classes) expected to be raised by the test function; other exceptions will fail the test. Note that subclasses of the classes passed will also result in a match (similar to how the except statement works). run ( bool ) – Whether the test function should actually be executed. If False , the function will always xfail and will not be executed (useful if a function is segfaulting). strict ( bool ) – If False the function will be shown in the terminal output as xfailed if it fails and as xpass if it passes. In both cases this will not cause the test suite to fail as a whole. This is particularly useful to mark flaky tests (tests that fail at random) to be tackled later. If True , the function will be shown in the terminal output as xfailed if it fails, but if it unexpectedly passes then it will fail the test suite. This is particularly useful to mark functions that are always failing and there should be a clear indication if they unexpectedly start to pass (for example a new release of a library fixes a known bug). Defaults to xfail_strict , which is False by default. If False the function will be shown in the terminal output as xfailed if it fails and as xpass if it passes. In both cases this will not cause the test suite to fail as a whole. This is particularly useful to mark flaky tests (tests that fail at random) to be tackled later. If True , the function will be shown in the terminal output as xfailed if it fails, but if it unexpectedly passes then it will fail the test suite. This is particularly useful to mark functions that are always failing and there should be a clear indication if they unexpectedly start to pass (for example a new release of a library fixes a known bug). Defaults to xfail_strict , which is False by default.

# Custom marks¶

Marks are created dynamically using the factory object pytest.mark and applied as a decorator. For example:

```

@pytest
.
mark
.
timeout
(
10
,
"slow"
,
method
=
"thread"
)
def
test_function
():
...

```

Will create and attach a Mark object to the collected Item , which can then be accessed by fixtures or hooks with Node.iter_markers . The mark object will have the following attributes:

```

mark
.
args
==
(
10
,
"slow"
)
mark
.
kwargs
==
{
"method"
:
"thread"
}

```

Example for using multiple custom markers:

```

@pytest
.
mark
.
timeout
(
10
,
"slow"
,
method
=
"thread"
)
@pytest
.
mark
.
slow
def
test_function
():
...

```

When Node.iter_markers or Node.iter_markers_with_node is used with multiple markers, the marker closest to the function will be iterated over first. The above example will result in @pytest.mark.slow followed by @pytest.mark.timeout(...) .

# Fixtures¶

Tutorial : Fixtures reference Fixtures are requested by test functions or other fixtures by declaring them as argument names. Example of a test requiring a fixture:

```

def
test_output
(
capsys
):
print
(
"hello"
)
out
,
err
=
capsys
.
readouterr
()
assert
out
==
"hello
\n
"

```

Example of a fixture requiring another fixture:

```

@pytest
.
fixture
def
db_session
(
tmp_path
):
fn
=
tmp_path
/
"db.file"
return
connect
(
fn
)

```

For more details, consult the full fixtures docs .

# @pytest.fixture¶

Decorator to mark a fixture factory function. This decorator can be used, with or without parameters, to define a fixture function. The name of the fixture function can later be referenced to cause its invocation ahead of running tests: test modules or classes can use the pytest.mark.usefixtures(fixturename) marker. Test functions can directly use fixture names as input arguments in which case the fixture instance returned from the fixture function will be injected. Fixtures can provide their values to test functions using return or yield statements. When using yield the code block after the yield statement is executed as teardown code regardless of the test outcome, and must yield exactly once. scope – The scope for which this fixture is shared; one of "function" (default), "class" , "module" , "package" or "session" . This parameter may also be a callable which receives (fixture_name, config) as parameters, and must return a str with one of the values mentioned above. See Dynamic scope in the docs for more information. The scope for which this fixture is shared; one of "function" (default), "class" , "module" , "package" or "session" . This parameter may also be a callable which receives (fixture_name, config) as parameters, and must return a str with one of the values mentioned above. See Dynamic scope in the docs for more information. params – An optional list of parameters which will cause multiple invocations of the fixture function and all of the tests using it. The current parameter is available in request.param . autouse – If True, the fixture func is activated for all tests that can see it. If False (the default), an explicit reference is needed to activate the fixture. ids – Sequence of ids each corresponding to the params so that they are part of the test id. If no ids are provided they will be generated automatically from the params. name – The name of the fixture. This defaults to the name of the decorated function. If a fixture is used in the same module in which it is defined, the function name of the fixture will be shadowed by the function arg that requests the fixture; one way to resolve this is to name the decorated function fixture_<fixturename> and then use @pytest.fixture(name='<fixturename>') .

# capfd¶

Tutorial : How to capture stdout/stderr output Enable text capturing of writes to file descriptors 1 and 2 . The captured output is made available via capfd.readouterr() method calls, which return a (out, err) namedtuple. out and err will be text objects. Returns an instance of CaptureFixture[str] . Example:

```

def
test_system_echo
(
capfd
):
os
.
system
(
'echo "hello"'
)
captured
=
capfd
.
readouterr
()
assert
captured
.
out
==
"hello
\n
"

```

# capfdbinary¶

Tutorial : How to capture stdout/stderr output Enable bytes capturing of writes to file descriptors 1 and 2 . The captured output is made available via capfd.readouterr() method calls, which return a (out, err) namedtuple. out and err will be byte objects. Returns an instance of CaptureFixture[bytes] . Example:

```

def
test_system_echo
(
capfdbinary
):
os
.
system
(
'echo "hello"'
)
captured
=
capfdbinary
.
readouterr
()
assert
captured
.
out
==
b
"hello
\n
"

```

# caplog¶

Tutorial : How to manage logging Access and control log capturing. Captured logs are available through the following properties/methods:

```

*
caplog
.
messages
->
list
of
format
-
interpolated
log
messages
*
caplog
.
text
->
string
containing
formatted
log
output
*
caplog
.
records
->
list
of
logging
.
LogRecord
instances
*
caplog
.
record_tuples
->
list
of
(
logger_name
,
level
,
message
)
tuples
*
caplog
.
clear
()
->
clear
captured
records
and
formatted
log
output
string

```

Returns a pytest.LogCaptureFixture instance. Provides access and control of log capturing. Get the logging handler used by the fixture. Get the logging records for one of the possible test phases. when ( Literal [ 'setup' , 'call' , 'teardown' ] ) – Which test phase to obtain the records from. Valid values are: “setup”, “call” and “teardown”. The list of captured records at the given stage. list [ LogRecord ] Added in version 3.4. The formatted log text. The list of log records. A list of a stripped down version of log records intended for use in assertion comparison. The format of the tuple is: (logger_name, log_level, message) A list of format-interpolated log messages. Unlike ‘records’, which contains the format string and parameters for interpolation, log messages in this list are all interpolated. Unlike ‘text’, which contains the output from the handler, log messages in this list are unadorned with levels, timestamps, etc, making exact comparisons more reliable. Note that traceback or stack info (from logging.exception() or the exc_info or stack_info arguments to the logging functions) is not included, as this is added by the formatter in the handler. Added in version 3.7. Reset the list of log records and the captured log text. Set the threshold level of a logger for the duration of a test. Logging messages which are less severe than this level will not be captured. Changed in version 3.4: The levels of the loggers changed by this function will be restored to their initial values at the end of the test. Will enable the requested logging level if it was disabled via logging.disable() . level ( int | str ) – The level. logger ( str | None ) – The logger to update. If not given, the root logger. Context manager that sets the level for capturing of logs. After the end of the ‘with’ statement the level is restored to its original value. Will enable the requested logging level if it was disabled via logging.disable() . level ( int | str ) – The level. logger ( str | None ) – The logger to update. If not given, the root logger. Context manager that temporarily adds the given filter to the caplog’s handler() for the ‘with’ statement block, and removes that filter at the end of the block. filter – A custom logging.Filter object. Added in version 7.5.

# capsys¶

Tutorial : How to capture stdout/stderr output Enable text capturing of writes to sys.stdout and sys.stderr . The captured output is made available via capsys.readouterr() method calls, which return a (out, err) namedtuple. out and err will be text objects. Returns an instance of CaptureFixture[str] . Example:

```

def
test_output
(
capsys
):
print
(
"hello"
)
captured
=
capsys
.
readouterr
()
assert
captured
.
out
==
"hello
\n
"

```

Object returned by the capsys , capsysbinary , capfd and capfdbinary fixtures. Read and return the captured output so far, resetting the internal buffer. The captured content as a namedtuple with out and err string attributes. CaptureResult Temporarily disable capturing while inside the with block.

# capsysbinary¶

Tutorial : How to capture stdout/stderr output Enable bytes capturing of writes to sys.stdout and sys.stderr . The captured output is made available via capsysbinary.readouterr() method calls, which return a (out, err) namedtuple. out and err will be bytes objects. Returns an instance of CaptureFixture[bytes] . Example:

```

def
test_output
(
capsysbinary
):
print
(
"hello"
)
captured
=
capsysbinary
.
readouterr
()
assert
captured
.
out
==
b
"hello
\n
"

```

# config.cache¶

Tutorial : How to re-run failed tests and maintain state between test runs The config.cache object allows other plugins and fixtures to store and retrieve values across test runs. To access it from fixtures request pytestconfig into your fixture and get it with pytestconfig.cache . Under the hood, the cache plugin uses the simple dumps / loads API of the json stdlib module. config.cache is an instance of pytest.Cache : Instance of the cache fixture. Return a directory path object with the given name. If the directory does not yet exist, it will be created. You can use it to manage files to e.g. store/retrieve database dumps across test sessions. Added in version 7.0. name ( str ) – Must be a string not containing a / separator. Make sure the name contains your plugin or application identifiers to prevent clashes with other cache users. Return the cached value for the given key. If no value was yet cached or the value cannot be read, the specified default is returned. key ( str ) – Must be a / separated value. Usually the first name is the name of your plugin or your application. default – The value to return in case of a cache-miss or invalid cache value. Save value for the given key. key ( str ) – Must be a / separated value. Usually the first name is the name of your plugin or your application. value ( object ) – Must be of any combination of basic python types, including nested types like lists of dictionaries.

# doctest_namespace¶

Tutorial : How to run doctests Fixture that returns a dict that will be injected into the namespace of doctests. Usually this fixture is used in conjunction with another autouse fixture:

```

@pytest
.
fixture
(
autouse
=
True
)
def
add_np
(
doctest_namespace
):
doctest_namespace
[
"np"
]
=
numpy

```

For more details: ‘doctest_namespace’ fixture .

# monkeypatch¶

Tutorial : How to monkeypatch/mock modules and environments A convenient fixture for monkey-patching. The fixture provides these methods to modify objects, dictionaries, or os.environ : monkeypatch.setattr(obj, name, value, raising=True) monkeypatch.delattr(obj, name, raising=True) monkeypatch.setitem(mapping, name, value) monkeypatch.delitem(obj, name, raising=True) monkeypatch.setenv(name, value, prepend=None) monkeypatch.delenv(name, raising=True) monkeypatch.syspath_prepend(path) monkeypatch.chdir(path) monkeypatch.context() All modifications will be undone after the requesting test function or fixture has finished. The raising parameter determines if a KeyError or AttributeError will be raised if the set/deletion operation does not have the specified target. To undo modifications done by the fixture in a contained scope, use context() . Returns a MonkeyPatch instance. Helper to conveniently monkeypatch attributes/items/environment variables/syspath. Returned by the monkeypatch fixture. Changed in version 6.2: Can now also be used directly as pytest.MonkeyPatch() , for when the fixture is not available. In this case, use with MonkeyPatch.context() as mp: or remember to call undo() explicitly. Context manager that returns a new MonkeyPatch object which undoes any patching done inside the with block upon exit. Example:

```

import
functools
def
test_partial
(
monkeypatch
):
with
monkeypatch
.
context
()
as
m
:
m
.
setattr
(
functools
,
"partial"
,
3
)

```

Useful in situations where it is desired to undo some patches before the test ends, such as mocking stdlib functions that might break pytest itself if mocked (for examples of this see #3290 ). Set attribute value on target, memorizing the old value. For example:

```

import
os
monkeypatch
.
setattr
(
os
,
"getcwd"
,
lambda
:
"/"
)

```

The code above replaces the os.getcwd() function by a lambda which always returns "/" . For convenience, you can specify a string as target which will be interpreted as a dotted import path, with the last part being the attribute name:

```

monkeypatch
.
setattr
(
"os.getcwd"
,
lambda
:
"/"
)

```

Raises AttributeError if the attribute does not exist, unless raising is set to False. Where to patch monkeypatch.setattr works by (temporarily) changing the object that a name points to with another one. There can be many names pointing to any individual object, so for patching to work you must ensure that you patch the name used by the system under test. See the section Where to patch in the unittest.mock docs for a complete explanation, which is meant for unittest.mock.patch() but applies to monkeypatch.setattr as well. Delete attribute name from target . If no name is specified and target is a string it will be interpreted as a dotted import path with the last part being the attribute name. Raises AttributeError it the attribute does not exist, unless raising is set to False. Set dictionary entry name to value. Delete name from dict. Raises KeyError if it doesn’t exist, unless raising is set to False. Set environment variable name to value . If prepend is a character, read the current environment variable value and prepend the value adjoined with the prepend character. Delete name from the environment. Raises KeyError if it does not exist, unless raising is set to False. Prepend path to sys.path list of import locations. Change the current working directory to the specified path. path ( str | PathLike [ str ] ) – The path to change into. Undo previous changes. This call consumes the undo stack. Calling it a second time has no effect unless you do more monkeypatching after the undo call. There is generally no need to call undo() , since it is called automatically during tear-down. Note The same monkeypatch fixture is used across a single test function invocation. If monkeypatch is used both by the test function itself and one of the test fixtures, calling undo() will undo all of the changes made in both functions. Prefer to use context() instead.

# pytestconfig¶

Session-scoped fixture that returns the session’s pytest.Config object. Example:

```

def
test_foo
(
pytestconfig
):
if
pytestconfig
.
get_verbosity
()
>
0
:
...

```

# pytester¶

Added in version 6.2. Provides a Pytester instance that can be used to run and test pytest itself. It provides an empty directory where pytest can be executed in isolation, and contains facilities to write tests, configuration files, and match against expected output. To use it, include in your topmost conftest.py file:

```

pytest_plugins
=
"pytester"

```

Facilities to write tests/configuration files, execute pytest in isolation, and match against expected output, perfect for black-box testing of pytest plugins. It attempts to isolate the test run from external factors as much as possible, modifying the current working directory to path and environment variables during initialization. A list of plugins to use with parseconfig() and runpytest() . Initially this is an empty list but plugins can be added to the list. The type of items to add to the list depends on the method using them so refer to them for details. Temporary directory path used to create files/run tests from, etc. Create a new HookRecorder for a PytestPluginManager . Cd into the temporary directory. This is done automatically upon instantiation. Create new text file(s) in the test directory. ext ( str ) – The extension the file(s) should use, including the dot, e.g. .py . args ( str ) – All args are treated as strings and joined using newlines. The result is written as contents to the file. The name of the file is based on the test function requesting this fixture. kwargs ( str ) – Each keyword is the name of a file, while the value of it will be written as contents of the file. The first created file. Path Examples:

```

pytester
.
makefile
(
".txt"
,
"line1"
,
"line2"
)
pytester
.
makefile
(
".ini"
,
pytest
=
"[pytest]
\n
addopts=-rs
\n
"
)

```

To create binary files, use pathlib.Path.write_bytes() directly:

```

filename
=
pytester
.
path
.
joinpath
(
"foo.bin"
)
filename
.
write_bytes
(
b
"..."
)

```

Write a conftest.py file. source ( str ) – The contents. The conftest.py file. Path Write a tox.ini file. source ( str ) – The contents. The tox.ini file. Path Return the pytest section from the tox.ini config file. Write a pyproject.toml file. source ( str ) – The contents. The pyproject.ini file. Path Added in version 6.0. Shortcut for .makefile() with a .py extension. Defaults to the test name with a ‘.py’ extension, e.g test_foobar.py, overwriting existing files. Examples:

```

def
test_something
(
pytester
):
# Initial file is created test_something.py.
pytester
.
makepyfile
(
"foobar"
)
# To create multiple files, pass kwargs accordingly.
pytester
.
makepyfile
(
custom
=
"foobar"
)
# At this point, both 'test_something.py' & 'custom.py' exist in the test directory.

```

Shortcut for .makefile() with a .txt extension. Defaults to the test name with a ‘.txt’ extension, e.g test_foobar.txt, overwriting existing files. Examples:

```

def
test_something
(
pytester
):
# Initial file is created test_something.txt.
pytester
.
maketxtfile
(
"foobar"
)
# To create multiple files, pass kwargs accordingly.
pytester
.
maketxtfile
(
custom
=
"foobar"
)
# At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.

```

Prepend a directory to sys.path, defaults to path . This is undone automatically when this object dies at the end of each test. path ( str | PathLike [ str ] | None ) – The path. Create a new (sub)directory. name ( str | PathLike [ str ] ) – The name of the directory, relative to the pytester path. The created directory. pathlib.Path Create a new python package. This creates a (sub)directory with an empty __init__.py file so it gets recognised as a Python package. Copy file from project’s directory into the testdir. name ( str | None ) – The name of the file to copy. Path to the copied directory (inside self.path ). pathlib.Path Get the collection node of a file. config ( Config ) – A pytest config. See parseconfig() and parseconfigure() for creating it. arg ( str | PathLike [ str ] ) – Path to the file. The node. Collector | Item Return the collection node of a file. This is like getnode() but uses parseconfigure() to create the (configured) pytest Config instance. path ( str | PathLike [ str ] ) – Path to the file. The node. Collector | Item Generate all test items from a collection node. This recurses into the collection node and returns a list of all the test items contained within. colitems ( Sequence [ Item | Collector ] ) – The collection nodes. The collected items. list [ Item ] Run the “test_func” Item. The calling test instance (class containing the test method) must provide a .getrunner() method which should return a runner which can run the test protocol for a single item, e.g. _pytest.runner.runtestprotocol . Run a test module in process using pytest.main() . This run writes “source” into a temporary file and runs pytest.main() on it, returning a HookRecorder instance for the result. source ( str ) – The source code of the test module. cmdlineargs – Any extra command line arguments to use. Run pytest.main(['--collect-only']) in-process. Runs the pytest.main() function to run all of pytest inside the test process itself like inline_run() , but returns a tuple of the collected items and a HookRecorder instance. Run pytest.main() in-process, returning a HookRecorder. Runs the pytest.main() function to run all of pytest inside the test process itself. This means it can return a HookRecorder instance which gives more detailed results from that run than can be done by matching stdout/stderr from runpytest() . args ( str | PathLike [ str ] ) – Command line arguments to pass to pytest.main() . plugins – Extra plugin instances the pytest.main() instance should use. no_reraise_ctrlc ( bool ) – Typically we reraise keyboard interrupts from the child run. If True, the KeyboardInterrupt exception is captured. Return result of running pytest in-process, providing a similar interface to what self.runpytest() provides. Run pytest inline or in a subprocess, depending on the command line option “–runpytest” and return a RunResult . Return a new pytest pytest.Config instance from given commandline args. This invokes the pytest bootstrapping code in _pytest.config to create a new pytest.PytestPluginManager and call the pytest_cmdline_parse hook to create a new pytest.Config instance. If plugins has been populated they should be plugin modules to be registered with the plugin manager. Return a new pytest configured Config instance. Returns a new pytest.Config instance like parseconfig() , but also calls the pytest_configure hook. Return the test item for a test function. Writes the source to a python file and runs pytest’s collection on the resulting module, returning the test item for the requested function name. source ( str | PathLike [ str ] ) – The module source. funcname ( str ) – The name of the test function for which to return a test item. The test item. Item Return all test items collected from the module. Writes the source to a Python file and runs pytest’s collection on the resulting module, returning all test items contained within. Return the module collection node for source . Writes source to a file using makepyfile() and then runs the pytest collection on it, returning the collection node for the test module. source ( str | PathLike [ str ] ) – The source code of the module to collect. configargs – Any extra arguments to pass to parseconfigure() . withinit ( bool ) – Whether to also write an __init__.py file to the same directory to ensure it is a package. Return the collection node for name from the module collection. Searches a module collection node for a collection node matching the given name. modcol ( Collector ) – A module collection node; see getmodulecol() . name ( str ) – The name of the node to return. Invoke subprocess.Popen . Calls subprocess.Popen making sure the current working directory is in PYTHONPATH . You probably want to use run() instead. Run a command with arguments. Run a process using subprocess.Popen saving the stdout and stderr. cmdargs ( str | PathLike [ str ] ) – The sequence of arguments to pass to subprocess.Popen , with path-like objects being converted to str automatically. timeout ( float | None ) – The period in seconds after which to timeout and raise Pytester.TimeoutExpired . stdin ( _pytest.compat.NotSetType | bytes | IO [ Any ] | int ) – Optional standard input. If it is CLOSE_STDIN (Default), then this method calls subprocess.Popen with stdin=subprocess.PIPE , and the standard input is closed immediately after the new command is started. If it is of type bytes , these bytes are sent to the standard input of the command. Otherwise, it is passed through to subprocess.Popen . For further information in this case, consult the document of the stdin parameter in subprocess.Popen . Optional standard input. If it is CLOSE_STDIN (Default), then this method calls subprocess.Popen with stdin=subprocess.PIPE , and the standard input is closed immediately after the new command is started. If it is of type bytes , these bytes are sent to the standard input of the command. Otherwise, it is passed through to subprocess.Popen . For further information in this case, consult the document of the stdin parameter in subprocess.Popen . The result. RunResult Run a python script using sys.executable as interpreter. Run python -c "command" . Run pytest as a subprocess with given arguments. Any plugins added to the plugins list will be added using the -p command line option. Additionally --basetemp is used to put any temporary files and directories in a numbered directory prefixed with “runpytest-” to not conflict with the normal numbered pytest location for temporary files and directories. args ( str | PathLike [ str ] ) – The sequence of arguments to pass to the pytest subprocess. timeout ( float | None ) – The period in seconds after which to timeout and raise Pytester.TimeoutExpired . The result. RunResult Run pytest using pexpect. This makes sure to use the right pytest and sets up the temporary directory locations. The pexpect child is returned. Run a command using pexpect. The pexpect child is returned. The result of running a command from Pytester . The return value. List of lines captured from stdout. List of lines captured from stderr. LineMatcher of stdout. Use e.g. str(stdout) to reconstruct stdout, or the commonly used stdout.fnmatch_lines() method. LineMatcher of stderr. Duration in seconds. Return a dictionary of outcome noun -> count from parsing the terminal output that the test process produced. The returned nouns will always be in plural form:

```

=======
1
failed
,
1
passed
,
1
warning
,
1
error
in
0.13
s
====

```

Will return {"failed": 1, "passed": 1, "warnings": 1, "errors": 1} . Extract the nouns from a pytest terminal summary line. It always returns the plural noun for consistency:

```

=======
1
failed
,
1
passed
,
1
warning
,
1
error
in
0.13
s
====

```

Will return {"failed": 1, "passed": 1, "warnings": 1, "errors": 1} . Assert that the specified outcomes appear with the respective numbers (0 means it didn’t occur) in the text output from a test run. warnings and deselected are only checked if not None. Flexible matching of text. This is a convenience class to test large texts like the output of commands. The constructor takes a list of lines without their trailing newlines, i.e. text.splitlines() . Return the entire original text. Added in version 6.2: You can use str() in older versions. Check lines exist in the output in any order (using fnmatch.fnmatch() ). Check lines exist in the output in any order (using re.match() ). Return all lines following the given line in the text. The given line can contain glob wildcards. Check lines exist in the output (using fnmatch.fnmatch() ). The argument is a list of lines which have to match and can use glob wildcards. If they do not match a pytest.fail() is called. The matches and non-matches are also shown as part of the error message. lines2 ( Sequence [ str ] ) – String patterns to match. consecutive ( bool ) – Match lines consecutively? Check lines exist in the output (using re.match() ). The argument is a list of lines which have to match using re.match . If they do not match a pytest.fail() is called. The matches and non-matches are also shown as part of the error message. lines2 ( Sequence [ str ] ) – string patterns to match. consecutive ( bool ) – match lines consecutively? Ensure captured lines do not match the given pattern, using fnmatch.fnmatch . pat ( str ) – The pattern to match lines. Ensure captured lines do not match the given pattern, using re.match . pat ( str ) – The regular expression to match lines. Return the entire original text. Record all hooks called in a plugin manager. Hook recorders are created by Pytester . This wraps all the hook calls in the plugin manager, recording each call before propagating the normal calls. Get all recorded calls to hooks with the given names (or name). Return a testreport whose dotted import path matches. A recorded call to a hook. The arguments to the hook call are set as attributes. For example:

```

calls
=
hook_recorder
.
getcalls
(
"pytest_runtest_setup"
)
# Suppose pytest_runtest_setup was called once with `item=an_item`.
assert
calls
[
0
]
.
item
is
an_item

```

# record_property¶

Tutorial : record_property Add extra properties to the calling test. User properties become part of the test report and are available to the configured reporters, like JUnit XML. The fixture is callable with name, value . The value is automatically XML-encoded. Example:

```

def
test_function
(
record_property
):
record_property
(
"example_key"
,
1
)

```

# record_testsuite_property¶

Tutorial : record_testsuite_property Record a new <property> tag as child of the root <testsuite> . This is suitable to writing global information regarding the entire test suite, and is compatible with xunit2 JUnit family. This is a session -scoped fixture which is called with (name, value) . Example:

```

def
test_foo
(
record_testsuite_property
):
record_testsuite_property
(
"ARCH"
,
"PPC"
)
record_testsuite_property
(
"STORAGE_TYPE"
,
"CEPH"
)

```

name – The property name. value – The property value. Will be converted to a string. Warning Currently this fixture does not work with the pytest-xdist plugin. See #7767 for details.

# recwarn¶

Tutorial : Recording warnings Return a WarningsRecorder instance that records all warnings emitted by test functions. See How to capture warnings for information on warning categories. A context manager to record raised warnings. Each recorded warning is an instance of warnings.WarningMessage . Adapted from warnings.catch_warnings . Note DeprecationWarning and PendingDeprecationWarning are treated differently; see Ensuring code triggers a deprecation warning . The list of recorded warnings. Get a recorded warning by index. Iterate through the recorded warnings. The number of recorded warnings. Pop the first recorded warning which is an instance of cls , but not an instance of a child class of any other match. Raises AssertionError if there is no match. Clear the list of recorded warnings.

# request¶

Example : Pass different values to a test function, depending on command line options The request fixture is a special fixture providing information of the requesting test function. The type of the request fixture. A request object gives access to the requesting test context and has a param attribute in case the fixture is parametrized. Fixture for which this request is being performed. Scope string, one of “function”, “class”, “module”, “package”, “session”. Names of all active fixtures in this request. Underlying collection node (depends on current request scope). The pytest config object associated with this request. Test function object if the request has a per-function scope. Class (can be None) where the test function was collected. Instance (can be None) on which test function was collected. Python module object where the test function was collected. Path where the test function was collected. Keywords/markers dictionary for the underlying node. Pytest session object. Add finalizer/teardown function to be called without arguments after the last test within the requesting test context finished execution. Apply a marker to a single test function invocation. This method is useful if you don’t want to have a keyword/marker on all function invocations. marker ( str | MarkDecorator ) – An object created by a call to pytest.mark.NAME(...) . Raise a FixtureLookupError exception. msg ( str | None ) – An optional custom error message. Dynamically run a named fixture function. Declaring fixtures via function argument is recommended where possible. But if you can only decide whether to use another fixture at test setup time, you may use this function to retrieve it inside a fixture or test function body. This method can be used during the test setup phase or the test run phase, but during the test teardown phase a fixture’s value may not be available. argname ( str ) – The fixture name. pytest.FixtureLookupError – If the given fixture could not be found.

# testdir¶

Identical to pytester , but provides an instance whose methods return legacy py.path.local objects instead when applicable. New code should avoid using testdir in favor of pytester . Similar to Pytester , but this class works with legacy legacy_path objects instead. All methods just forward to an internal Pytester instance, converting results to legacy_path objects as necessary. Temporary directory where tests are executed. See Pytester.make_hook_recorder() . See Pytester.chdir() . See Pytester.makefile() . See Pytester.makeconftest() . See Pytester.makeini() . See Pytester.getinicfg() . See Pytester.makepyprojecttoml() . See Pytester.makepyfile() . See Pytester.maketxtfile() . See Pytester.syspathinsert() . See Pytester.mkdir() . See Pytester.mkpydir() . See Pytester.copy_example() . See Pytester.getnode() . See Pytester.getpathnode() . See Pytester.genitems() . See Pytester.runitem() . See Pytester.inline_runsource() . See Pytester.inline_genitems() . See Pytester.inline_run() . See Pytester.runpytest_inprocess() . See Pytester.runpytest() . See Pytester.parseconfig() . See Pytester.parseconfigure() . See Pytester.getitem() . See Pytester.getitems() . See Pytester.getmodulecol() . See Pytester.collect_by_name() . See Pytester.popen() . See Pytester.run() . See Pytester.runpython() . See Pytester.runpython_c() . See Pytester.runpytest_subprocess() . See Pytester.spawn_pytest() . See Pytester.spawn() .

# tmp_path¶

Tutorial : How to use temporary directories and files in tests Return a temporary directory (as pathlib.Path object) which is unique to each test function invocation. The temporary directory is created as a subdirectory of the base temporary directory, with configurable retention, as discussed in Temporary directory location and retention .

# tmp_path_factory¶

Tutorial : The tmp_path_factory fixture tmp_path_factory is an instance of TempPathFactory : Factory for temporary directories under the common base temp directory, as discussed at Temporary directory location and retention . Create a new temporary directory managed by the factory. basename ( str ) – Directory base name, must be a relative path. numbered ( bool ) – If True , ensure the directory is unique by adding a numbered suffix greater than any existing one: basename="foo-" and numbered=True means that this function will create directories named "foo-0" , "foo-1" , "foo-2" and so on. The path to the new directory. Path Return the base temporary directory, creating it if needed. The base temporary directory. Path

# tmpdir¶

Tutorial : The tmpdir and tmpdir_factory fixtures Return a temporary directory (as legacy_path object) which is unique to each test function invocation. The temporary directory is created as a subdirectory of the base temporary directory, with configurable retention, as discussed in Temporary directory location and retention . Note These days, it is preferred to use tmp_path . About the tmpdir and tmpdir_factory fixtures .

# tmpdir_factory¶

Tutorial : The tmpdir and tmpdir_factory fixtures tmpdir_factory is an instance of TempdirFactory : Backward compatibility wrapper that implements py.path.local for TempPathFactory . Note These days, it is preferred to use tmp_path_factory . About the tmpdir and tmpdir_factory fixtures . Same as TempPathFactory.mktemp() , but returns a py.path.local object. Same as TempPathFactory.getbasetemp() , but returns a py.path.local object.

# Hooks¶

Tutorial : Writing plugins Reference to all hooks which can be implemented by conftest.py files and plugins .

# @pytest.hookimpl¶

pytest’s decorator for marking functions as hook implementations. See Writing hook functions and pluggy.HookimplMarker() .

# @pytest.hookspec¶

pytest’s decorator for marking functions as hook specifications. See Declaring new hooks and pluggy.HookspecMarker() .

# Bootstrapping hooks¶

Bootstrapping hooks called for plugins registered early enough (internal and third-party plugins). Called to implement the loading of initial conftest files ahead of command line option parsing. early_config ( Config ) – The pytest config object. args ( list [ str ] ) – Arguments passed on the command line. parser ( Parser ) – To add command line options.

# Use in conftest plugins¶

This hook is not called for conftest files. Return an initialized Config , parsing the specified args. Stops at first non-None result, see firstresult: stop at first non-None result . Note This hook is only called for plugin classes passed to the plugins arg when using pytest.main to perform an in-process test run. pluginmanager ( PytestPluginManager ) – The pytest plugin manager. args ( list [ str ] ) – List of arguments passed on the command line. A pytest config object. Config | None

# Use in conftest plugins¶

This hook is not called for conftest files. Called for performing the main command line action. The default implementation will invoke the configure hooks and pytest_runtestloop . Stops at first non-None result, see firstresult: stop at first non-None result . config ( Config ) – The pytest config object. The exit code. ExitCode | int | None

# Use in conftest plugins¶

This hook is only called for initial conftests .

# Initialization hooks¶

Initialization hooks called for plugins and conftest.py files. Register argparse-style options and ini-style config values, called once at the beginning of a test run. parser ( Parser ) – To add command line options, call parser.addoption(...) . To add ini-file values call parser.addini(...) . pluginmanager ( PytestPluginManager ) – The pytest plugin manager, which can be used to install hookspec() ’s or hookimpl() ’s and allow one plugin to call another plugin’s hooks to change how command line options are added. Options can later be accessed through the config object, respectively: config.getoption(name) to retrieve the value of a command line option. config.getini(name) to retrieve a value read from an ini-style file. The config object is passed around on many internal objects via the .config attribute or can be retrieved as the pytestconfig fixture. Note This hook is incompatible with hook wrappers.

# Use in conftest plugins¶

If a conftest plugin implements this hook, it will be called immediately when the conftest is registered. This hook is only called for initial conftests . Called at plugin registration time to allow adding new hooks via a call to pluginmanager.add_hookspecs(module_or_class, prefix) . pluginmanager ( PytestPluginManager ) – The pytest plugin manager. Note This hook is incompatible with hook wrappers.

# Use in conftest plugins¶

If a conftest plugin implements this hook, it will be called immediately when the conftest is registered. Allow plugins and conftest files to perform initial configuration. Note This hook is incompatible with hook wrappers. config ( Config ) – The pytest config object.

# Use in conftest plugins¶

This hook is called for every initial conftest file after command line options have been parsed. After that, the hook is called for other conftest files as they are registered. Called before test process is exited. config ( Config ) – The pytest config object.

# Use in conftest plugins¶

Any conftest file can implement this hook. Called after the Session object has been created and before performing collection and entering the run test loop. session ( Session ) – The pytest session object.

# Use in conftest plugins¶

This hook is only called for initial conftests . Called after whole test run finished, right before returning the exit status to the system. session ( Session ) – The pytest session object. exitstatus ( int | ExitCode ) – The status which pytest will return to the system.

# Use in conftest plugins¶

Any conftest file can implement this hook. A new pytest plugin got registered. plugin ( _PluggyPlugin ) – The plugin module or instance. plugin_name ( str ) – The name by which the plugin is registered. manager ( PytestPluginManager ) – The pytest plugin manager. Note This hook is incompatible with hook wrappers.

# Use in conftest plugins¶

If a conftest plugin implements this hook, it will be called immediately when the conftest is registered, once for each plugin registered thus far (including itself!), and for all plugins thereafter when they are registered.

# Collection hooks¶

pytest calls the following hooks for collecting files and directories: Perform the collection phase for the given session. Stops at first non-None result, see firstresult: stop at first non-None result . The return value is not used, but only stops further processing. The default collection phase is this (see individual hooks for full details): Starting from session as the initial collector: pytest_collectstart(collector) report = pytest_make_collect_report(collector) pytest_exception_interact(collector, call, report) if an interactive exception occurred For each collected node: If an item, pytest_itemcollected(item) If a collector, recurse into it. pytest_collectreport(report) pytest_collection_modifyitems(session, config, items) pytest_deselected(items) for any deselected items (may be called multiple times) pytest_collection_finish(session) Set session.items to the list of collected items Set session.testscollected to the number of collected items You can implement this hook to only perform some action before collection, for example the terminal plugin uses it to start displaying the collection counter (and returns None ). session ( Session ) – The pytest session object.

# Use in conftest plugins¶

This hook is only called for initial conftests . Return True to ignore this path for collection. Return None to let other plugins ignore the path for collection. Returning False will forcefully not ignore this path for collection, without giving a chance for other plugins to ignore this path. This hook is consulted for all files and directories prior to calling more specific hooks. Stops at first non-None result, see firstresult: stop at first non-None result . collection_path ( pathlib.Path ) – The path to analyze. path ( LEGACY_PATH ) – The path to analyze (deprecated). config ( Config ) – The pytest config object. Changed in version 7.0.0: The collection_path parameter was added as a pathlib.Path equivalent of the path parameter. The path parameter has been deprecated.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given collection path, only conftest files in parent directories of the collection path are consulted (if the path is a directory, its own conftest file is not consulted - a directory cannot ignore itself!). Create a Collector for the given directory, or None if not relevant. Added in version 8.0. For best results, the returned collector should be a subclass of Directory , but this is not required. The new node needs to have the specified parent as a parent. Stops at first non-None result, see firstresult: stop at first non-None result . path ( pathlib.Path ) – The path to analyze. See Using a custom directory collector for a simple example of use of this hook.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given collection path, only conftest files in parent directories of the collection path are consulted (if the path is a directory, its own conftest file is not consulted - a directory cannot collect itself!). Create a Collector for the given path, or None if not relevant. For best results, the returned collector should be a subclass of File , but this is not required. The new node needs to have the specified parent as a parent. file_path ( pathlib.Path ) – The path to analyze. path ( LEGACY_PATH ) – The path to collect (deprecated). Changed in version 7.0.0: The file_path parameter was added as a pathlib.Path equivalent of the path parameter. The path parameter has been deprecated.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given file path, only conftest files in parent directories of the file path are consulted. Return a pytest.Module collector or None for the given path. This hook will be called for each matching test module path. The pytest_collect_file hook needs to be used if you want to create test modules for files that do not match as a test module. Stops at first non-None result, see firstresult: stop at first non-None result . module_path ( pathlib.Path ) – The path of the module to collect. path ( LEGACY_PATH ) – The path of the module to collect (deprecated). Changed in version 7.0.0: The module_path parameter was added as a pathlib.Path equivalent of the path parameter. The path parameter has been deprecated in favor of fspath .

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given parent collector, only conftest files in the collector’s directory and its parent directories are consulted. For influencing the collection of objects in Python modules you can use the following hook: Return a custom item/collector for a Python object in a module, or None. Stops at first non-None result, see firstresult: stop at first non-None result . collector ( Module | Class ) – The module/class collector. name ( str ) – The name of the object in the module/class. obj ( object ) – The object. The created items/collectors. None | Item | Collector | list [ Item | Collector ]

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given collector, only conftest files in the collector’s directory and its parent directories are consulted. Generate (multiple) parametrized calls to a test function. metafunc ( Metafunc ) – The Metafunc helper for the test function.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given function definition, only conftest files in the functions’s directory and its parent directories are consulted. Return a user-friendly string representation of the given val that will be used by @pytest.mark.parametrize calls, or None if the hook doesn’t know about val . The parameter name is available as argname , if required. Stops at first non-None result, see firstresult: stop at first non-None result . config ( Config ) – The pytest config object. val ( object ) – The parametrized value. argname ( str ) – The automatic parameter name produced by pytest.

# Use in conftest plugins¶

Any conftest file can implement this hook. Hooks for influencing test skipping: Called when constructing the globals dictionary used for evaluating string conditions in xfail/skipif markers. This is useful when the condition for a marker requires objects that are expensive or impossible to obtain during collection time, which is required by normal boolean conditions. Added in version 6.2. config ( Config ) – The pytest config object. A dictionary of additional globals to add. dict [ str , Any]

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in parent directories of the item are consulted. After collection is complete, you can modify the order of items, delete or otherwise amend the test items: Called after collection has been performed. May filter or re-order the items in-place. When items are deselected (filtered out from items ), the hook pytest_deselected must be called explicitly with the deselected items to properly notify other plugins, e.g. with config.hook.pytest_deselected(items=deselected_items) . session ( Session ) – The pytest session object. config ( Config ) – The pytest config object. items ( list [ Item ] ) – List of item objects.

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Note If this hook is implemented in conftest.py files, it always receives all collected items, not only those under the conftest.py where it is implemented. Called after collection has been performed and modified. session ( Session ) – The pytest session object.

# Use in conftest plugins¶

Any conftest plugin can implement this hook.

# Test running (runtest) hooks¶

All runtest related hooks receive a pytest.Item object. Perform the main runtest loop (after collection finished). The default hook implementation performs the runtest protocol for all items collected in the session ( session.items ), unless the collection failed or the collectonly pytest option is set. If at any point pytest.exit() is called, the loop is terminated immediately. If at any point session.shouldfail or session.shouldstop are set, the loop is terminated after the runtest protocol for the current item is finished. session ( Session ) – The pytest session object. Stops at first non-None result, see firstresult: stop at first non-None result . The return value is not used, but only stops further processing.

# Use in conftest plugins¶

Any conftest file can implement this hook. Perform the runtest protocol for a single test item. The default runtest protocol is this (see individual hooks for full details): pytest_runtest_logstart(nodeid, location) call = pytest_runtest_setup(item) (wrapped in CallInfo(when="setup") ) report = pytest_runtest_makereport(item, call) pytest_runtest_logreport(report) pytest_exception_interact(call, report) if an interactive exception occurred call = pytest_runtest_call(item) (wrapped in CallInfo(when="call") ) report = pytest_runtest_makereport(item, call) pytest_runtest_logreport(report) pytest_exception_interact(call, report) if an interactive exception occurred call = pytest_runtest_teardown(item, nextitem) (wrapped in CallInfo(when="teardown") ) report = pytest_runtest_makereport(item, call) pytest_runtest_logreport(report) pytest_exception_interact(call, report) if an interactive exception occurred pytest_runtest_logfinish(nodeid, location) item ( Item ) – Test item for which the runtest protocol is performed. nextitem ( Item | None ) – The scheduled-to-be-next test item (or None if this is the end my friend). Stops at first non-None result, see firstresult: stop at first non-None result . The return value is not used, but only stops further processing.

# Use in conftest plugins¶

Any conftest file can implement this hook. Called at the start of running the runtest protocol for a single item. See pytest_runtest_protocol for a description of the runtest protocol. nodeid ( str ) – Full node ID of the item. location ( tuple [ str , int | None , str ] ) – A tuple of (filename, lineno, testname) where filename is a file path relative to config.rootpath and lineno is 0-based.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Called at the end of running the runtest protocol for a single item. See pytest_runtest_protocol for a description of the runtest protocol. nodeid ( str ) – Full node ID of the item. location ( tuple [ str , int | None , str ] ) – A tuple of (filename, lineno, testname) where filename is a file path relative to config.rootpath and lineno is 0-based.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Called to perform the setup phase for a test item. The default implementation runs setup() on item and all of its parents (which haven’t been setup yet). This includes obtaining the values of fixtures required by the item (which haven’t been obtained yet). item ( Item ) – The item.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Called to run the test for test item (the call phase). The default implementation calls item.runtest() . item ( Item ) – The item.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Called to perform the teardown phase for a test item. The default implementation runs the finalizers and calls teardown() on item and all of its parents (which need to be torn down). This includes running the teardown phase of fixtures required by the item (if they go out of scope). item ( Item ) – The item. nextitem ( Item | None ) – The scheduled-to-be-next test item (None if no further test item is scheduled). This argument is used to perform exact teardowns, i.e. calling just enough finalizers so that nextitem only needs to call setup functions.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Called to create a TestReport for each of the setup, call and teardown runtest phases of a test item. See pytest_runtest_protocol for a description of the runtest protocol. item ( Item ) – The item. call ( CallInfo [ None ] ) – The CallInfo for the phase. Stops at first non-None result, see firstresult: stop at first non-None result .

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. For deeper understanding you may look at the default implementation of these hooks in _pytest.runner and maybe also in _pytest.pdb which interacts with _pytest.capture and its input/output capturing in order to immediately drop into interactive debugging when a test failure occurs. Call underlying test function. Stops at first non-None result, see firstresult: stop at first non-None result . pyfuncitem ( Function ) – The function item.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted.

# Reporting hooks¶

Session related reporting hooks: Collector starts collecting. collector ( Collector ) – The collector.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given collector, only conftest files in the collector’s directory and its parent directories are consulted. Perform collector.collect() and return a CollectReport . Stops at first non-None result, see firstresult: stop at first non-None result . collector ( Collector ) – The collector.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given collector, only conftest files in the collector’s directory and its parent directories are consulted. We just collected a test item. item ( Item ) – The item.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Collector finished collecting. report ( CollectReport ) – The collect report.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given collector, only conftest files in the collector’s directory and its parent directories are consulted. Called for deselected test items, e.g. by keyword. Note that this hook has two integration aspects for plugins: it can be implemented to be notified of deselected items it must be called from pytest_collection_modifyitems implementations when items are deselected (to properly notify other plugins). May be called multiple times. items ( Sequence [ Item ] ) – The items.

# Use in conftest plugins¶

Any conftest file can implement this hook. Return a string or list of strings to be displayed as header info for terminal reporting. config ( Config ) – The pytest config object. start_path ( pathlib.Path ) – The starting dir. startdir ( LEGACY_PATH ) – The starting dir (deprecated). Note Lines returned by a plugin are displayed before those of plugins which ran before it. If you want to have your line(s) displayed first, use trylast=True . Changed in version 7.0.0: The start_path parameter was added as a pathlib.Path equivalent of the startdir parameter. The startdir parameter has been deprecated.

# Use in conftest plugins¶

This hook is only called for initial conftests . Return a string or list of strings to be displayed after collection has finished successfully. These strings will be displayed after the standard “collected X items” message. Added in version 3.2. config ( Config ) – The pytest config object. start_path ( pathlib.Path ) – The starting dir. startdir ( LEGACY_PATH ) – The starting dir (deprecated). items ( Sequence [ Item ] ) – List of pytest items that are going to be executed; this list should not be modified. Note Lines returned by a plugin are displayed before those of plugins which ran before it. If you want to have your line(s) displayed first, use trylast=True . Changed in version 7.0.0: The start_path parameter was added as a pathlib.Path equivalent of the startdir parameter. The startdir parameter has been deprecated.

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Return result-category, shortletter and verbose word for status reporting. The result-category is a category in which to count the result, for example “passed”, “skipped”, “error” or the empty string. The shortletter is shown as testing progresses, for example “.”, “s”, “E” or the empty string. The verbose word is shown as testing progresses in verbose mode, for example “PASSED”, “SKIPPED”, “ERROR” or the empty string. pytest may style these implicitly according to the report outcome. To provide explicit styling, return a tuple for the verbose word, for example "rerun", "R", ("RERUN", {"yellow": True}) . report ( CollectReport | TestReport ) – The report object whose status is to be returned. config ( Config ) – The pytest config object. The test status. TestShortLogReport | tuple [ str , str , str | tuple [ str , Mapping[ str , bool ]]] Stops at first non-None result, see firstresult: stop at first non-None result .

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Serialize the given report object into a data structure suitable for sending over the wire, e.g. converted to JSON. config ( Config ) – The pytest config object. report ( CollectReport | TestReport ) – The report.

# Use in conftest plugins¶

Any conftest file can implement this hook. The exact details may depend on the plugin which calls the hook. Restore a report object previously serialized with pytest_report_to_serializable . config ( Config ) – The pytest config object.

# Use in conftest plugins¶

Any conftest file can implement this hook. The exact details may depend on the plugin which calls the hook. Add a section to terminal summary reporting. terminalreporter ( TerminalReporter ) – The internal terminal reporter object. exitstatus ( ExitCode ) – The exit status that will be reported back to the OS. config ( Config ) – The pytest config object. Added in version 4.2: The config parameter.

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Perform fixture setup execution. fixturedef ( FixtureDef [ Any ] ) – The fixture definition object. request ( SubRequest ) – The fixture request object. The return value of the call to the fixture function. object | None Stops at first non-None result, see firstresult: stop at first non-None result . Note If the fixture function returns None, other implementations of this hook function will continue to be called, according to the behavior of the firstresult: stop at first non-None result option.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given fixture, only conftest files in the fixture scope’s directory and its parent directories are consulted. Called after fixture teardown, but before the cache is cleared, so the fixture result fixturedef.cached_result is still available (not None ). fixturedef ( FixtureDef [ Any ] ) – The fixture definition object. request ( SubRequest ) – The fixture request object.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given fixture, only conftest files in the fixture scope’s directory and its parent directories are consulted. Process a warning captured by the internal pytest warnings plugin. warning_message ( warnings.WarningMessage ) – The captured warning. This is the same object produced by warnings.catch_warnings , and contains the same attributes as the parameters of warnings.showwarning() . when ( Literal [ 'config' , 'collect' , 'runtest' ] ) – Indicates when the warning was captured. Possible values: "config" : during pytest configuration/initialization stage. "collect" : during test collection. "runtest" : during test execution. Indicates when the warning was captured. Possible values: "config" : during pytest configuration/initialization stage. "collect" : during test collection. "runtest" : during test execution. nodeid ( str ) – Full id of the item. Empty string for warnings that are not specific to a particular node. location ( tuple [ str , int , str ] | None ) – When available, holds information about the execution context of the captured warning (filename, linenumber, function). function evaluates to <module> when the execution context is at the module level. Added in version 6.0.

# Use in conftest plugins¶

Any conftest file can implement this hook. If the warning is specific to a particular node, only conftest files in parent directories of the node are consulted. Central hook for reporting about test execution: Process the TestReport produced for each of the setup, call and teardown runtest phases of an item. See pytest_runtest_protocol for a description of the runtest protocol.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Assertion related hooks: Return explanation for comparisons in failing assert expressions. Return None for no custom explanation, otherwise return a list of strings. The strings will be joined by newlines but any newlines in a string will be escaped. Note that all but the first line will be indented slightly, the intention is for the first line to be a summary. config ( Config ) – The pytest config object. op ( str ) – The operator, e.g. "==" , "!=" , "not in" . left ( object ) – The left operand. right ( object ) – The right operand.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. Called whenever an assertion passes. Added in version 5.0. Use this hook to do some processing after a passing assertion. The original assertion information is available in the orig string and the pytest introspected assertion information is available in the expl string. This hook must be explicitly enabled by the enable_assertion_pass_hook ini-file option:

```

[pytest]
enable_assertion_pass_hook
=
true

```

You need to clean the .pyc files in your project directory and interpreter libraries when enabling this option, as assertions will require to be re-written. item ( Item ) – pytest item object of current test. lineno ( int ) – Line number of the assert statement. orig ( str ) – String with the original assertion. expl ( str ) – String with the assert explanation.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted.

# Debugging/Interaction hooks¶

There are few hooks which can be used for special reporting or interaction with exceptions: Called for internal errors. Return True to suppress the fallback handling of printing an INTERNALERROR message directly to sys.stderr. excrepr ( ExceptionRepr ) – The exception repr object. excinfo ( ExceptionInfo [ BaseException ] ) – The exception info.

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Called for keyboard interrupt. excinfo ( ExceptionInfo [ KeyboardInterrupt | Exit ] ) – The exception info.

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Called when an exception was raised which can potentially be interactively handled. May be called during collection (see pytest_make_collect_report ), in which case report is a CollectReport . May be called during runtest of an item (see pytest_runtest_protocol ), in which case report is a TestReport . This hook is not called if the exception that was raised is an internal exception like skip.Exception . node ( Item | Collector ) – The item or collector. call ( CallInfo [ Any ] ) – The call information. Contains the exception. report ( CollectReport | TestReport ) – The collection or test report.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given node, only conftest files in parent directories of the node are consulted. Called upon pdb.set_trace(). Can be used by plugins to take special action just before the python debugger enters interactive mode. config ( Config ) – The pytest config object. pdb ( pdb.Pdb ) – The Pdb instance.

# Use in conftest plugins¶

Any conftest plugin can implement this hook. Called when leaving pdb (e.g. with continue after pdb.set_trace()). Can be used by plugins to take special action just after the python debugger leaves interactive mode. config ( Config ) – The pytest config object. pdb ( pdb.Pdb ) – The Pdb instance.

# Use in conftest plugins¶

Any conftest plugin can implement this hook.

# Collection tree objects¶

These are the collector and item classes (collectively called “nodes”) which make up the collection tree.

# Node¶

Bases: ABC Base class of Collector and Item , the components of the test collection tree. Collector 's are the internal nodes of the tree, and Item 's are the leaf nodes. A LEGACY_PATH copy of the path attribute. Intended for usage for methods not migrated to pathlib.Path yet, such as Item.reportinfo . Will be deprecated in a future release, prefer using path instead. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None). Keywords/markers collected from all scopes. The marker objects belonging to this node. Allow adding of extra keywords to use for matching. A place where plugins can store information on the node for their own use. Public constructor for Nodes. This indirection got introduced in order to enable removing the fragile logic from the node constructors. Subclasses can use super().from_parent(...) when overriding the construction. parent ( Node ) – The parent node of this Node. fspath-sensitive hook proxy used to call pytest hooks. Issue a warning for this Node. Warnings will be displayed after the test session, unless explicitly suppressed. warning ( Warning ) – The warning instance to issue. ValueError – If warning instance is not a subclass of Warning. Example usage:

```

node
.
warn
(
PytestWarning
(
"some message"
))
node
.
warn
(
UserWarning
(
"some message"
))

```

Changed in version 6.2: Any subclass of Warning is now accepted, rather than only PytestWarning subclasses. A ::-separated string denoting its collection tree address. Iterate over all parent collectors starting from and including self up to the root of the collection tree. Added in version 8.1. Return a list of all parent collectors starting from the root of the collection tree down to and including self. Dynamically add a marker object to the node. marker ( str | MarkDecorator ) – The marker. append ( bool ) – Whether to append the marker, or prepend it. Iterate over all markers of the node. name ( str | None ) – If given, filter the results by the name attribute. An iterator of the markers of the node. Iterator [ Mark ] Iterate over all markers of the node. name ( str | None ) – If given, filter the results by the name attribute. An iterator of (node, mark) tuples. Iterator [ tuple [ Node , Mark ]] Return the first marker matching the name, from closest (for example function) to farther level (for example module level). default – Fallback return value if no marker was found. name – Name to filter by. Return a set of all extra keywords in self and any parents. Register a function to be called without arguments when this node is finalized. This method can only be called when this node is active in a setup chain, for example during self.setup(). Get the closest parent node (including self) which is an instance of the given class. cls ( type [ _NodeType ] ) – The node class to search for. The node, if found. _NodeType | None Return a representation of a collection or test failure. See also Working with non-python tests excinfo ( ExceptionInfo [ BaseException ] ) – Exception information for the failure.

# Collector¶

Bases: Node , ABC Base class of all collectors. Collector create children through collect() and thus iteratively build the collection tree. Bases: Exception An error during collection, contains a custom message. Collect children (items and collectors) for this collector. Return a representation of a collection failure. excinfo ( ExceptionInfo [ BaseException ] ) – Exception information for the failure. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# Item¶

Bases: Node , ABC Base class of all test invocation items. Note that for a single function there might be multiple test invocation items. A list of tuples (name, value) that holds user defined properties for this test. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None). Run the test case for this item. Must be implemented by subclasses. See also Working with non-python tests Add a new report section, similar to what’s done internally to add stdout and stderr captured output:

```

item
.
add_report_section
(
"call"
,
"stdout"
,
"report section contents"
)

```

when ( str ) – One of the possible capture states, "setup" , "call" , "teardown" . key ( str ) – Name of the section, can be customized at will. Pytest uses "stdout" and "stderr" internally. content ( str ) – The full contents as a string. Get location information for this item for test reports. Returns a tuple with three elements: The path of the test (default self.path ) The 0-based line number of the test (default None ) A name of the test to be shown (default "" ) See also Working with non-python tests Returns a tuple of (relfspath, lineno, testname) for this item where relfspath is file path relative to config.rootpath and lineno is a 0-based line number.

# File¶

Bases: FSCollector , ABC Base class for collecting tests from a file. Working with non-python tests . A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# FSCollector¶

Bases: Collector , ABC Base class for filesystem collectors. Filesystem path where this node was collected from (can be None). The public constructor. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of.

# Session¶

Bases: Collector The root of the collection tree. Session collects the initial paths given as arguments to pytest. Bases: KeyboardInterrupt Signals that the test run was interrupted. Bases: Exception Signals a stop as failed test run. The path from which pytest was invoked. Added in version 7.0.0. Is path an initial path? An initial path is a path explicitly given to pytest on the command line. with_parents ( bool ) – If set, also return True if the path is a parent of an initial path. Changed in version 8.0: Added the with_parents parameter. Perform the collection phase for this session. This is called by the default pytest_collection hook implementation; see the documentation of this hook for more details. For testing purposes, it may also be called directly on a fresh Session . This function normally recursively expands any collectors collected from the session to their items, and only items are returned. For testing purposes, this may be suppressed by passing genitems=False , in which case the return value contains these collectors unexpanded, and session.items is empty. Collect children (items and collectors) for this collector. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# Package¶

Bases: Directory Collector for files and directories in a Python packages – directories with an __init__.py file. Note Directories without an __init__.py file are instead collected by Dir by default. Both are Directory collectors. Changed in version 8.0: Now inherits from Directory . Collect children (items and collectors) for this collector. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# Module¶

Bases: File , PyCollector Collector for test classes and functions in a Python module. Collect children (items and collectors) for this collector. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# Class¶

Bases: PyCollector Collector for test methods (and nested classes) in a Python class. The public constructor. Collect children (items and collectors) for this collector. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# Function¶

Bases: PyobjMixin , Item Item responsible for setting up and executing a Python test function. name – The full function name, including any decorations like those added by parametrization ( my_func[my_param] ). parent – The parent Node. config – The pytest Config object. callspec – If given, this function has been parametrized and the callspec contains meta information about the parametrization. callobj – If given, the object which will be called when the Function is invoked, otherwise the callobj will be obtained from parent using originalname . keywords – Keywords bound to the function object for “-k” matching. session – The pytest Session object. fixtureinfo – Fixture information already resolved at this fixture node.. originalname – The attribute name to use for accessing the underlying function object. Defaults to name . Set this if name is different from the original name, for example when it contains decorations like those added by parametrization ( my_func[my_param] ). Original function name, without any decorations (for example parametrization adds a "[...]" suffix to function names), used to access the underlying function object from parent (in case callobj is not given explicitly). Added in version 3.0. The public constructor. Underlying python ‘function’ object. Python instance object the function is bound to. Returns None if not a test method, e.g. for a standalone test function, a class or a module. Execute the underlying test function. Return a representation of a collection or test failure. See also Working with non-python tests excinfo ( ExceptionInfo [ BaseException ] ) – Exception information for the failure. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# FunctionDefinition¶

Bases: Function This class is a stop gap solution until we evolve to have actual function definition nodes and manage to get rid of metafunc . Execute the underlying test function. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None). Execute the underlying test function.

# Objects¶

Objects accessible from fixtures or hooks or importable from pytest .

# CallInfo¶

Result/Exception info of a function invocation. The captured exception of the call, if it raised. The system time when the call started, in seconds since the epoch. The system time when the call ended, in seconds since the epoch. The call duration, in seconds. The context of invocation: “collect”, “setup”, “call” or “teardown”. The return value of the call, if it didn’t raise. Can only be accessed if excinfo is None. Call func, wrapping the result in a CallInfo. func ( Callable [ [ ] , _pytest.runner.TResult ] ) – The function to call. Called without arguments. when ( Literal [ 'collect' , 'setup' , 'call' , 'teardown' ] ) – The phase in which the function is called. reraise ( type [ BaseException ] | tuple [ type [ BaseException ] , ... ] | None ) – Exception or exceptions that shall propagate if raised by the function, instead of being wrapped in the CallInfo.

# CollectReport¶

Bases: BaseReport Collection report object. Reports can contain arbitrary extra attributes. Normalized collection nodeid. Test outcome, always one of “passed”, “failed”, “skipped”. None or a failure representation. The collected items and collection nodes. Tuples of str (heading, content) with extra information for the test report. Used by pytest to add text captured from stdout , stderr , and intercepted logging events. May be used by other plugins to add arbitrary information to reports. Return captured log lines, if log capturing is enabled. Added in version 3.5. Return captured text from stderr, if capturing is enabled. Added in version 3.0. Return captured text from stdout, if capturing is enabled. Added in version 3.0. Experimental Whether this report should be counted towards the totals shown at the end of the test session: “1 passed, 1 failure, etc”. Note This function is considered experimental , so beware that it is subject to changes even in patch releases. Whether the outcome is failed. The path portion of the reported node, as a string. Experimental The head line shown with longrepr output for this report, more commonly during traceback representation during failures:

```

________
Test
.
foo
________

```

In the example above, the head_line is “Test.foo”. Note This function is considered experimental , so beware that it is subject to changes even in patch releases. Read-only property that returns the full string representation of longrepr . Added in version 3.0. Whether the outcome is passed. Whether the outcome is skipped.

# Config¶

Access to configuration values, pluginmanager and plugin hooks. pluginmanager ( PytestPluginManager ) – A pytest PluginManager. invocation_params ( InvocationParams ) – Object containing parameters regarding the pytest.main() invocation. Holds parameters passed during pytest.main() . The object attributes are read-only. Added in version 5.1. Note Note that the environment variable PYTEST_ADDOPTS and the addopts ini option are handled by pytest, not being included in the args attribute. Plugins accessing InvocationParams must be aware of that. The command-line arguments as passed to pytest.main() . Extra plugins, might be None . The directory from which pytest.main() was invoked. :type: pathlib.Path Indicates the source of the test arguments. Added in version 7.2. Command line arguments. Invocation directory. ‘testpaths’ configuration value. Access to command line option as attributes. argparse.Namespace The parameters with which pytest was invoked. InvocationParams The plugin manager handles plugin registration and hook invocation. PytestPluginManager A place where plugins can store information on the config for their own use. Stash The path to the rootdir . pathlib.Path Added in version 6.1. The path to the configfile . Added in version 6.1. Add a function to be called when the config object gets out of use (usually coinciding with pytest_unconfigure). Constructor usable for subprocesses. Issue and handle a warning during the “configure” stage. During pytest_configure we can’t capture warnings using the catch_warnings_for_item function because it is not possible to have hook wrappers around pytest_configure . This function is mainly intended for plugins that need to issue warnings during pytest_configure (or similar stages). warning ( Warning ) – The warning instance. stacklevel ( int ) – stacklevel forwarded to warnings.warn. Add a line to an ini-file option. The option must have been declared but might not yet be set in which case the line becomes the first line in its value. Return configuration value from an ini file . If a configuration value is not defined in an ini file , then the default value provided while registering the configuration through parser.addini will be returned. Please note that you can even provide None as a valid default value. If default is not provided while registering using parser.addini , then a default value based on the type parameter passed to parser.addini will be returned. The default values based on type are: paths , pathlist , args and linelist : empty list [] bool : False string : empty string "" If neither the default nor the type parameter is passed while registering the configuration through parser.addini , then the configuration is treated as a string and a default empty string ‘’ is returned. If the specified name hasn’t been registered through a prior parser.addini call (usually from a plugin), a ValueError is raised. Return command line option value. name ( str ) – Name of the option. You may also specify the literal --OPT option instead of the “dest” option name. default – Fallback value if no option of that name is declared via pytest_addoption . Note this parameter will be ignored when the option is declared even if the option’s value is None . skip ( bool ) – If True , raise pytest.skip() if option is undeclared or has a None value. Note that even if True , if a default was specified it will be returned instead of a skip. Deprecated, use getoption() instead. Deprecated, use getoption(skip=True) instead. Verbosity type for failed assertions (see verbosity_assertions ). Verbosity type for test case execution (see verbosity_test_cases ). Retrieve the verbosity level for a fine-grained verbosity type. verbosity_type ( str | None ) – Verbosity type to get level for. If a level is configured for the given type, that value will be returned. If the given type is not a known verbosity type, the global verbosity level will be returned. If the given type is None (default), the global verbosity level will be returned. To configure a level for a fine-grained verbosity type, the configuration file should have a setting for the configuration name and a numeric value for the verbosity level. A special value of “auto” can be used to explicitly use the global verbosity level. Example:

```

# content of pytest.ini
[pytest]
verbosity_assertions
=
2

```

```

pytest -v

```

```

print
(
config
.
get_verbosity
())
# 1
print
(
config
.
get_verbosity
(
Config
.
VERBOSITY_ASSERTIONS
))
# 2

```

# Dir¶

Collector of files in a file system directory. Added in version 8.0. Note Python directories with an __init__.py file are instead collected by Package by default. Both are Directory collectors. The public constructor. parent ( nodes.Collector ) – The parent collector of this Dir. path ( pathlib.Path ) – The directory’s path. Collect children (items and collectors) for this collector. A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# Directory¶

Base class for collecting files from a directory. A basic directory collector does the following: goes over the files and sub-directories in the directory and creates collectors for them by calling the hooks pytest_collect_directory and pytest_collect_file , after checking that they are not ignored using pytest_ignore_collect . The default directory collectors are Dir and Package . Added in version 8.0. Using a custom directory collector . A unique name within the scope of the parent node. The parent collector node. The pytest config object. The pytest session this node is part of. Filesystem path where this node was collected from (can be None).

# ExceptionInfo¶

Wraps sys.exc_info() objects and offers help for navigating the traceback. Return an ExceptionInfo for an existing exception. The exception must have a non- None __traceback__ attribute, otherwise this function fails with an assertion error. This means that the exception must have been raised, or added a traceback with the with_traceback() method. exprinfo ( str | None ) – A text string helping to determine if we should strip AssertionError from the output. Defaults to the exception message/ __str__() . Added in version 7.4. Like from_exception() , but using old-style exc_info tuple. Return an ExceptionInfo matching the current traceback. Warning Experimental API exprinfo ( str | None ) – A text string helping to determine if we should strip AssertionError from the output. Defaults to the exception message/ __str__() . Return an unfilled ExceptionInfo. Fill an unfilled ExceptionInfo created with for_later() . The exception class. The exception value. The exception raw traceback. The type name of the exception. The traceback. Return the exception as a string. When ‘tryshort’ resolves to True, and the exception is an AssertionError, only the actual exception part of the exception representation is returned (so ‘AssertionError: ‘ is removed from the beginning). Return True if the exception is an instance of exc. Consider using isinstance(excinfo.value, exc) instead. Return str()able representation of this exception info. showlocals ( bool ) – Show locals per traceback entry. Ignored if style=="native" . style ( str ) – long|short|line|no|native|value traceback style. abspath ( bool ) – If paths should be changed to absolute or left unchanged. tbfilter ( bool | Callable [ [ ExceptionInfo [ BaseException ] ] , Traceback ] ) – A filter for traceback entries. If false, don’t hide any entries. If true, hide internal entries and entries that contain a local variable __tracebackhide__ = True . If a callable, delegates the filtering to the callable. Ignored if style is "native" . A filter for traceback entries. If false, don’t hide any entries. If true, hide internal entries and entries that contain a local variable __tracebackhide__ = True . If a callable, delegates the filtering to the callable. Ignored if style is "native" . funcargs ( bool ) – Show fixtures (“funcargs” for legacy purposes) per traceback entry. truncate_locals ( bool ) – With showlocals==True , make sure locals can be safely represented as strings. truncate_args ( bool ) – With showargs==True , make sure args can be safely represented as strings. chain ( bool ) – If chained exceptions in Python 3 should be shown. Changed in version 3.9: Added the chain parameter. Check whether the regular expression regexp matches the string representation of the exception using re.search() . If it matches True is returned, otherwise an AssertionError is raised. Check whether a captured exception group contains a matching exception. expected_exception ( Type [ BaseException ] | Tuple [ Type [ BaseException ] ] ) – The expected exception type, or a tuple if one of multiple possible exception types are expected. match ( str | Pattern [ str ] | None ) – If specified, a string containing a regular expression, or a regular expression object, that is tested against the string representation of the exception and its PEP-678 <https://peps.python.org/pep-0678/> __notes__ using re.search() . To match a literal string that may contain special characters , the pattern can first be escaped with re.escape() . If specified, a string containing a regular expression, or a regular expression object, that is tested against the string representation of the exception and its PEP-678 <https://peps.python.org/pep-0678/> __notes__ using re.search() . To match a literal string that may contain special characters , the pattern can first be escaped with re.escape() . depth ( Optional [ int ] ) – If None , will search for a matching exception at any nesting depth. If >= 1, will only match an exception if it’s at the specified depth (depth = 1 being the exceptions contained within the topmost exception group). Added in version 8.0.

# ExitCode¶

Encodes the valid exit codes by pytest. Currently users and plugins may supply other exit codes as well. Added in version 5.0. Tests passed. Tests failed. pytest was interrupted. An internal error got in the way. pytest was misused. pytest couldn’t find tests.

# FixtureDef¶

Bases: Generic [ FixtureValue ] A container for a fixture definition. Note: At this time, only explicitly documented fields and methods are considered public stable API. Scope string, one of “function”, “class”, “module”, “package”, “session”. Return the value of this fixture, executing it if not cached.

# MarkDecorator¶

A decorator for applying a mark on test functions and classes. MarkDecorators are created with pytest.mark :

```

mark1
=
pytest
.
mark
.
NAME
# Simple MarkDecorator
mark2
=
pytest
.
mark
.
NAME
(
name1
=
value
)
# Parametrized MarkDecorator

```

and can then be applied as decorators to test functions:

```

@mark2
def
test_function
():
pass

```

When a MarkDecorator is called, it does the following: If called with a single class as its only positional argument and no additional keyword arguments, it attaches the mark to the class so it gets applied automatically to all test cases found in that class. If called with a single function as its only positional argument and no additional keyword arguments, it attaches the mark to the function, containing all the arguments already stored internally in the MarkDecorator . When called in any other case, it returns a new MarkDecorator instance with the original MarkDecorator ’s content updated with the arguments passed to this call. Note: The rules above prevent a MarkDecorator from storing only a single function or class reference as its positional argument with no additional keyword or positional arguments. You can work around this by using with_args() . Alias for mark.name. Alias for mark.args. Alias for mark.kwargs. Return a MarkDecorator with extra arguments added. Unlike calling the MarkDecorator, with_args() can be used even if the sole argument is a callable/class.

# MarkGenerator¶

Factory for MarkDecorator objects - exposed as a pytest.mark singleton instance. Example:

```

import
pytest
@pytest
.
mark
.
slowtest
def
test_function
():
pass

```

applies a ‘slowtest’ Mark on test_function .

# Mark¶

A pytest mark. Name of the mark. Positional arguments of the mark decorator. Keyword arguments of the mark decorator. Return a new Mark which is a combination of this Mark and another Mark. Combines by appending args and merging kwargs. other ( Mark ) – The mark to combine with. Mark

# Metafunc¶

Objects passed to the pytest_generate_tests hook. They help to inspect a test function and to generate tests according to test configuration or values specified in the class or module where a test function is defined. Access to the underlying _pytest.python.FunctionDefinition . Access to the pytest.Config object for the test session. The module object where the test function is defined in. Underlying Python test function. Set of fixture names required by the test function. Class object where the test function is defined in or None . Add new invocations to the underlying test function using the list of argvalues for the given argnames. Parametrization is performed during the collection phase. If you need to setup expensive resources see about setting indirect to do it rather than at test setup time. Can be called multiple times per test function (but only on different argument names), in which case each call parametrizes all previous parametrizations, e.g.

```

unparametrized
:
t
parametrize
[
"x"
,
"y"
]:
t
[
x
],
t
[
y
]
parametrize
[
1
,
2
]:
t
[
x
-
1
],
t
[
x
-
2
],
t
[
y
-
1
],
t
[
y
-
2
]

```

argnames ( str | Sequence [ str ] ) – A comma-separated string denoting one or more argument names, or a list/tuple of argument strings. argvalues ( Iterable [ _pytest.mark.structures.ParameterSet | Sequence [ object ] | object ] ) – The list of argvalues determines how often a test is invoked with different argument values. If only one argname was specified argvalues is a list of values. If N argnames were specified, argvalues must be a list of N-tuples, where each tuple-element specifies a value for its respective argname. The list of argvalues determines how often a test is invoked with different argument values. If only one argname was specified argvalues is a list of values. If N argnames were specified, argvalues must be a list of N-tuples, where each tuple-element specifies a value for its respective argname. indirect ( bool | Sequence [ str ] ) – A list of arguments’ names (subset of argnames) or a boolean. If True the list contains all names from the argnames. Each argvalue corresponding to an argname in this list will be passed as request.param to its respective argname fixture function so that it can perform more expensive setups during the setup phase of a test rather than at collection time. ids ( Iterable [ object | None ] | Callable [ [ Any ] , object | None ] | None ) – Sequence of (or generator for) ids for argvalues , or a callable to return part of the id for each argvalue. With sequences (and generators like itertools.count() ) the returned ids should be of type string , int , float , bool , or None . They are mapped to the corresponding index in argvalues . None means to use the auto-generated id. If it is a callable it will be called for each entry in argvalues , and the return value is used as part of the auto-generated id for the whole set (where parts are joined with dashes (“-“)). This is useful to provide more specific ids for certain items, e.g. dates. Returning None will use an auto-generated id. If no ids are provided they will be generated automatically from the argvalues. Sequence of (or generator for) ids for argvalues , or a callable to return part of the id for each argvalue. With sequences (and generators like itertools.count() ) the returned ids should be of type string , int , float , bool , or None . They are mapped to the corresponding index in argvalues . None means to use the auto-generated id. If it is a callable it will be called for each entry in argvalues , and the return value is used as part of the auto-generated id for the whole set (where parts are joined with dashes (“-“)). This is useful to provide more specific ids for certain items, e.g. dates. Returning None will use an auto-generated id. If no ids are provided they will be generated automatically from the argvalues. scope ( Literal [ 'session' , 'package' , 'module' , 'class' , 'function' ] | None ) – If specified it denotes the scope of the parameters. The scope is used for grouping tests by parameter instances. It will also override any fixture-function defined scope, allowing to set a dynamic scope using test context or configuration.

# Parser¶

Parser for command line arguments and ini-file values. extra_info – Dict of generic param -> value to display in case there’s an error processing the command line arguments. Get (or create) a named option Group. name ( str ) – Name of the option group. description ( str ) – Long description for –help output. after ( str | None ) – Name of another group, used for ordering –help output. The option group. OptionGroup The returned group object has an addoption method with the same signature as parser.addoption but will be shown in the respective group in the output of pytest --help . Register a command line option. opts ( str ) – Option names, can be short or long options. attrs ( Any ) – Same attributes as the argparse library’s add_argument() function accepts. After command line parsing, options are available on the pytest config object via config.option.NAME where NAME is usually set by passing a dest attribute, for example addoption("--long", dest="NAME", ...) . Parse the known arguments at this point. An argparse namespace object. Namespace Parse the known arguments at this point, and also return the remaining unknown arguments. A tuple containing an argparse namespace object for the known arguments, and a list of the unknown arguments. tuple [ Namespace , list [ str ]] Register an ini-file option. name ( str ) – Name of the ini-variable. type ( Literal [ 'string' , 'paths' , 'pathlist' , 'args' , 'linelist' , 'bool' ] | None ) – Type of the variable. Can be: string : a string bool : a boolean args : a list of strings, separated as in a shell linelist : a list of strings, separated by line breaks paths : a list of pathlib.Path , separated as in a shell pathlist : a list of py.path , separated as in a shell For paths and pathlist types, they are considered relative to the ini-file. In case the execution is happening without an ini-file defined, they will be considered relative to the current working directory (for example with --override-ini ). Added in version 7.0: The paths variable type. Added in version 8.1: Use the current working directory to resolve paths and pathlist in the absence of an ini-file. Defaults to string if None or not passed. Type of the variable. Can be: string : a string bool : a boolean args : a list of strings, separated as in a shell linelist : a list of strings, separated by line breaks paths : a list of pathlib.Path , separated as in a shell pathlist : a list of py.path , separated as in a shell For paths and pathlist types, they are considered relative to the ini-file. In case the execution is happening without an ini-file defined, they will be considered relative to the current working directory (for example with --override-ini ). Added in version 7.0: The paths variable type. Added in version 8.1: Use the current working directory to resolve paths and pathlist in the absence of an ini-file. Defaults to string if None or not passed. default ( Any ) – Default value if no ini-file option exists but is queried. The value of ini-variables can be retrieved via a call to config.getini(name) .

# OptionGroup¶

A group of options shown in its own section. Add an option to this group. If a shortened version of a long option is specified, it will be suppressed in the help. addoption('--twowords', '--two-words') results in help showing --two-words only, but --twowords gets accepted and the automatic destination is in args.twowords . opts ( str ) – Option names, can be short or long options. attrs ( Any ) – Same attributes as the argparse library’s add_argument() function accepts.

# PytestPluginManager¶

Bases: PluginManager A pluggy.PluginManager with additional pytest-specific functionality: Loading plugins from the command line, PYTEST_PLUGINS env variable and pytest_plugins global variables found in plugins being loaded. conftest.py loading during start-up. Register a plugin and return its name. name ( str | None ) – The name under which to register the plugin. If not specified, a name is generated using get_canonical_name() . The plugin name. If the name is blocked from registering, returns None . str | None If the plugin is already registered, raises a ValueError . Return whether a plugin with the given name is registered. Import a plugin with modname . If consider_entry_points is True, entry point names are also considered to find a plugin. Add before/after tracing functions for all hooks. Returns an undo function which, when called, removes the added tracers. before(hook_name, hook_impls, kwargs) will be called ahead of all hook calls and receive a hookcaller instance, a list of HookImpl instances and the keyword arguments for the hook call. after(outcome, hook_name, hook_impls, kwargs) receives the same arguments as before but also a Result object which represents the result of the overall hook call. Add new hook specifications defined in the given module_or_class . Functions are recognized as hook specifications if they have been decorated with a matching HookspecMarker . Verify that all hooks which have not been verified against a hook specification are optional, otherwise raise PluginValidationError . Enable tracing of hook calls. Returns an undo function which, when called, removes the added tracing. Return a canonical name for a plugin object. Note that a plugin may be registered under a different name specified by the caller of register(plugin, name) . To obtain the name of a registered plugin use get_name(plugin) instead. Get all hook callers for the specified plugin. The hook callers, or None if plugin is not registered in this plugin manager. list [ HookCaller ] | None Return the name the plugin is registered under, or None if is isn’t. Return the plugin registered under the given name, if any. Return a set of all registered plugin objects. Return whether a plugin with the given name is registered. Return whether the given plugin name is blocked. Return whether the plugin is already registered. Return a list of (name, plugin) pairs for all registered plugins. Return a list of (plugin, distinfo) pairs for all setuptools-registered plugins. Load modules from querying the specified setuptools group . group ( str ) – Entry point group to load plugins. name ( str | None ) – If given, loads only plugins with the given name . The number of plugins loaded by this call. int Block registrations of the given name, unregister if already registered. Return a proxy HookCaller instance for the named method which manages calls to all registered plugins except the ones from remove_plugins. Unblocks a name. Returns whether the name was actually blocked. Unregister a plugin and all of its hook implementations. The plugin can be specified either by the plugin object or the plugin name. If both are specified, they must agree. Returns the unregistered plugin, or None if not found. The project name. The “hook relay”, used to call a hook on all registered plugins. See Calling hooks . The tracing entry point. See Built-in tracing .

# TestReport¶

Bases: BaseReport Basic test report object (also used for setup and teardown calls if they fail). Reports can contain arbitrary extra attributes. Normalized collection nodeid. A (filesystempath, lineno, domaininfo) tuple indicating the actual location of a test item - it might be different from the collected one e.g. if a method is inherited from a different module. The filesystempath may be relative to config.rootdir . The line number is 0-based. A name -> value dictionary containing all keywords and markers associated with a test invocation. Test outcome, always one of “passed”, “failed”, “skipped”. None or a failure representation. One of ‘setup’, ‘call’, ‘teardown’ to indicate runtest phase. User properties is a list of tuples (name, value) that holds user defined properties of the test. Tuples of str (heading, content) with extra information for the test report. Used by pytest to add text captured from stdout , stderr , and intercepted logging events. May be used by other plugins to add arbitrary information to reports. Time it took to run just the test. The system time when the call started, in seconds since the epoch. The system time when the call ended, in seconds since the epoch. Create and fill a TestReport with standard item and call info. item ( Item ) – The item. call ( CallInfo [ None ] ) – The call info. Return captured log lines, if log capturing is enabled. Added in version 3.5. Return captured text from stderr, if capturing is enabled. Added in version 3.0. Return captured text from stdout, if capturing is enabled. Added in version 3.0. Experimental Whether this report should be counted towards the totals shown at the end of the test session: “1 passed, 1 failure, etc”. Note This function is considered experimental , so beware that it is subject to changes even in patch releases. Whether the outcome is failed. The path portion of the reported node, as a string. Experimental The head line shown with longrepr output for this report, more commonly during traceback representation during failures:

```

________
Test
.
foo
________

```

In the example above, the head_line is “Test.foo”. Note This function is considered experimental , so beware that it is subject to changes even in patch releases. Read-only property that returns the full string representation of longrepr . Added in version 3.0. Whether the outcome is passed. Whether the outcome is skipped.

# TestShortLogReport¶

Used to store the test status result category, shortletter and verbose word. For example "rerun", "R", ("RERUN", {"yellow": True}) . category – The class of result, for example “passed” , “skipped” , “error” , or the empty string. letter – The short letter shown as testing progresses, for example "." , "s" , "E" , or the empty string. word – Verbose word is shown as testing progresses in verbose mode, for example "PASSED" , "SKIPPED" , "ERROR" , or the empty string. Alias for field number 0 Alias for field number 1 Alias for field number 2

# Result¶

Result object used within hook wrappers , see Result in the pluggy documentation for more information.

# Stash¶

Stash is a type-safe heterogeneous mutable mapping that allows keys and value types to be defined separately from where it (the Stash ) is created. Usually you will be given an object which has a Stash , for example Config or a Node :

```

stash
:
Stash
=
some_object
.
stash

```

If a module or plugin wants to store data in this Stash , it creates StashKey s for its keys (at the module level):

```

# At the top-level of the module
some_str_key
=
StashKey
[
str
]()
some_bool_key
=
StashKey
[
bool
]()

```

To store information:

```

# Value type must match the key.
stash
[
some_str_key
]
=
"value"
stash
[
some_bool_key
]
=
True

```

To retrieve the information:

```

# The static type of some_str is str.
some_str
=
stash
[
some_str_key
]
# The static type of some_bool is bool.
some_bool
=
stash
[
some_bool_key
]

```

Added in version 7.0. Set a value for key. Get the value for key. Raises KeyError if the key wasn’t set before. Get the value for key, or return default if the key wasn’t set before. Return the value of key if already set, otherwise set the value of key to default and return default. Delete the value for key. Raises KeyError if the key wasn’t set before. Return whether key was set. Return how many items exist in the stash. Bases: Generic [ T ] StashKey is an object used as a key to a Stash . A StashKey is associated with the type T of the value of the key. A StashKey is unique and cannot conflict with another key. Added in version 7.0.

# Global Variables¶

pytest treats some global variables in a special manner when defined in a test module or conftest.py files. Tutorial : Customizing test collection Can be declared in conftest.py files to exclude test directories or modules. Needs to be a list of paths ( str , pathlib.Path or any os.PathLike ).

```

collect_ignore
=
[
"setup.py"
]

```

Tutorial : Customizing test collection Can be declared in conftest.py files to exclude test directories or modules with Unix shell-style wildcards. Needs to be list[str] where str can contain glob patterns.

```

collect_ignore_glob
=
[
"*_ignore.py"
]

```

Tutorial : Requiring/Loading plugins in a test module or conftest file Can be declared at the global level in test modules and conftest.py files to register additional plugins. Can be either a str or Sequence[str] .

```

pytest_plugins
=
"myapp.testsupport.myplugin"

```

```

pytest_plugins
=
(
"myapp.testsupport.tools"
,
"myapp.testsupport.regression"
)

```

Tutorial : Marking whole classes or modules Can be declared at the global level in test modules to apply one or more marks to all test functions and methods. Can be either a single mark or a list of marks (applied in left-to-right order).

```

import
pytest
pytestmark
=
pytest
.
mark
.
webtest

```

```

import
pytest
pytestmark
=
[
pytest
.
mark
.
integration
,
pytest
.
mark
.
slow
]

```

# Environment Variables¶

Environment variables that can be used to change pytest’s behavior. When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to BUILD_NUMBER variable. See also CI Pipelines . When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to CI variable. See also CI Pipelines . This contains a command-line (parsed by the py:mod: shlex module) that will be prepended to the command line given by the user, see Builtin configuration file options for more information. This environment variable is defined at the start of the pytest session and is undefined afterwards. It contains the value of pytest.__version__ , and among other things can be used to easily check if a code is running from within a pytest run. This is not meant to be set by users, but is set by pytest internally with the name of the current test so other processes can inspect it, see PYTEST_CURRENT_TEST environment variable for more information. When set, pytest will print tracing and debug information. Root for temporary directories produced by fixtures like tmp_path as discussed in Temporary directory location and retention . When set, disables plugin auto-loading through entry point packaging metadata . Only explicitly specified plugins will be loaded. Contains comma-separated list of modules that should be loaded as plugins:

```

export
PYTEST_PLUGINS
=
mymodule.plugin,xdist

```

Sets a pygment style to use for the code output. Sets the PYTEST_THEME to be either dark or light . When set to 1 , pytest will use color in terminal output. When set to 0 , pytest will not use color. PY_COLORS takes precedence over NO_COLOR and FORCE_COLOR . When set to a non-empty string (regardless of value), pytest will not use color in terminal output. PY_COLORS takes precedence over NO_COLOR , which takes precedence over FORCE_COLOR . See no-color.org for other libraries supporting this community standard. When set to a non-empty string (regardless of value), pytest will use color in terminal output. PY_COLORS and NO_COLOR take precedence over FORCE_COLOR .

# Exceptions¶

Bases: Exception Error in pytest usage or invocation. Bases: LookupError Could not return a requested fixture (missing or invalid).

# Warnings¶

Custom warnings generated in some situations such as improper usage or deprecated features. Bases: UserWarning Base class for all warnings emitted by pytest. Bases: PytestWarning Warning emitted by the pytest assert rewrite module. Bases: PytestWarning Warning emitted by the cache plugin in various situations. Bases: PytestWarning Warning emitted when pytest is not able to collect a file or symbol in a module. Bases: PytestWarning Warning emitted for configuration issues. Bases: PytestWarning , DeprecationWarning Warning class for features that will be removed in a future version. Bases: PytestWarning , FutureWarning Warning category used to denote experiments in pytest. Use sparingly as the API might change or even be removed completely in a future version. Bases: PytestWarning Warning emitted when a test function is returning value other than None. Bases: PytestDeprecationWarning Warning class for features that will be removed in pytest 9. Bases: PytestReturnNotNoneWarning Warning emitted for an unhandled coroutine. A coroutine was encountered when collecting test functions, but was not handled by any async-aware plugin. Coroutine test functions are not natively supported. Bases: PytestWarning Warning emitted on use of unknown markers. See How to mark test functions with attributes for details. Bases: PytestWarning An unraisable exception was reported. Unraisable exceptions are exceptions raised in __del__ implementations and similar situations when the exception cannot be raised as normal. Bases: PytestWarning An unhandled exception occurred in a Thread . Such exceptions don’t propagate normally. Consult the Internal pytest warnings section in the documentation for more information.

# Configuration Options¶

Here is a list of builtin configuration options that may be written in a pytest.ini (or .pytest.ini ), pyproject.toml , tox.ini , or setup.cfg file, usually located at the root of your repository. To see each file format in details, see Configuration file formats . Warning Usage of setup.cfg is not recommended except for very simple use cases. .cfg files use a different parser than pytest.ini and tox.ini which might cause hard to track down problems. When possible, it is recommended to use the latter files, or pyproject.toml , to hold your pytest configuration. Configuration options may be overwritten in the command-line by using -o/--override-ini , which can also be passed multiple times. The expected format is name=value . For example:

```

pytest
-
o
console_output_style
=
classic
-
o
cache_dir
=/
tmp
/
mycache

```

Add the specified OPTS to the set of command line arguments as if they had been specified by the user. Example: if you have this ini file content:

```

# content of pytest.ini
[pytest]
addopts
=
--maxfail=2 -rf
# exit after 2 failures, report fail info

```

issuing pytest test_hello.py actually means:

```

pytest
--maxfail
=
2
-rf
test_hello.py

```

Default is to add no options. Sets the directory where the cache plugin’s content is stored. Default directory is .pytest_cache which is created in rootdir . Directory may be relative or absolute path. If setting relative path, then directory is created relative to rootdir . Additionally, a path may contain environment variables, that will be expanded. For more information about cache plugin please refer to How to re-run failed tests and maintain state between test runs . Controls if pytest should attempt to identify namespace packages when collecting Python modules. Default is False . Set to True if the package you are testing is part of a namespace package. Only native namespace packages are supported, with no plans to support legacy namespace packages . Added in version 8.1. Sets the console output style while running tests: classic : classic pytest output. progress : like classic pytest output, but with a progress indicator. progress-even-when-capture-no : allows the use of the progress indicator even when capture=no . count : like progress, but shows progress as the number of tests completed instead of a percent. The default is progress , but you can fallback to classic if you prefer or the new mode is causing unexpected problems:

```

# content of pytest.ini
[pytest]
console_output_style
=
classic

```

Default encoding to use to decode text files with docstrings. See how pytest handles doctests . One or more doctest flag names from the standard doctest module. See how pytest handles doctests . Allows to pick the action for empty parametersets in parameterization skip skips tests with an empty parameterset (default) xfail marks tests with an empty parameterset as xfail(run=False) fail_at_collect raises an exception if parametrize collects an empty parameter set

```

# content of pytest.ini
[pytest]
empty_parameter_set_mark
=
xfail

```

Note The default value of this option is planned to change to xfail in future releases as this is considered less error prone, see #3155 for more details. Dumps the tracebacks of all threads if a test takes longer than X seconds to run (including fixture setup and teardown). Implemented using the faulthandler.dump_traceback_later() function, so all caveats there apply.

```

# content of pytest.ini
[pytest]
faulthandler_timeout
=
5

```

For more information please refer to Fault Handler . Sets a list of filters and actions that should be taken for matched warnings. By default all warnings emitted during the test session will be displayed in a summary at the end of the test session.

```

# content of pytest.ini
[pytest]
filterwarnings
=
error
ignore
:
:DeprecationWarning

```

This tells pytest to ignore deprecation warnings and turn all other warnings into errors. For more information please refer to How to capture warnings . Added in version 4.1. Configures how durations are recorded into the JUnit XML report: total (the default): duration times reported include setup, call, and teardown times. call : duration times reported include only call times, excluding setup and teardown.

```

[pytest]
junit_duration_report
=
call

```

Added in version 4.2. Changed in version 6.1: Default changed to xunit2 . Configures the format of the generated JUnit XML file. The possible options are: xunit1 (or legacy ): produces old style output, compatible with the xunit 1.0 format. xunit2 : produces xunit 2.0 style output , which should be more compatible with latest Jenkins versions. This is the default .

```

[pytest]
junit_family
=
xunit2

```

Added in version 3.5. Changed in version 5.4: log , all , out-err options added. Configures if captured output should be written to the JUnit XML file. Valid values are: log : write only logging captured output. system-out : write captured stdout contents. system-err : write captured stderr contents. out-err : write both captured stdout and stderr contents. all : write captured logging , stdout and stderr contents. no (the default): no captured output is written.

```

[pytest]
junit_logging
=
system-out

```

Added in version 4.6. If junit_logging != "no" , configures if the captured output should be written to the JUnit XML file for passing tests. Default is True .

```

[pytest]
junit_log_passing_tests
=
False

```

To set the name of the root test suite xml item, you can configure the junit_suite_name option in your config file:

```

[pytest]
junit_suite_name
=
my_suite

```

Allow selective auto-indentation of multiline log messages. Supports command line option --log-auto-indent [value] and config option log_auto_indent = [value] to set the auto-indentation behavior for all logging. True or “On” - Dynamically auto-indent multiline log messages False or “Off” or 0 - Do not auto-indent multiline log messages (the default behavior) [positive integer] - auto-indent multiline log messages by [value] spaces

```

[pytest]
log_auto_indent
=
False

```

Supports passing kwarg extra={"auto_indent": [value]} to calls to logging.log() to specify auto-indentation behavior for a specific entry in the log. extra kwarg overrides the value specified on the command line or in the config. Enable log display during test run (also known as “live logging” ). The default is False .

```

[pytest]
log_cli
=
True

```

Sets a time.strftime() -compatible string that will be used when formatting dates for live logging.

```

[pytest]
log_cli_date_format
=
%Y-%m-%d %H:%M:%S

```

For more information, see Live Logs . Sets a logging -compatible string used to format live logging messages.

```

[pytest]
log_cli_format
=
%(asctime)s %(levelname)s %(message)s

```

For more information, see Live Logs . Sets the minimum log message level that should be captured for live logging. The integer value or the names of the levels can be used.

```

[pytest]
log_cli_level
=
INFO

```

For more information, see Live Logs . Sets a time.strftime() -compatible string that will be used when formatting dates for logging capture.

```

[pytest]
log_date_format
=
%Y-%m-%d %H:%M:%S

```

For more information, see How to manage logging . Sets a file name relative to the current working directory where log messages should be written to, in addition to the other logging facilities that are active.

```

[pytest]
log_file
=
logs/pytest-logs.txt

```

For more information, see How to manage logging . Sets a time.strftime() -compatible string that will be used when formatting dates for the logging file.

```

[pytest]
log_file_date_format
=
%Y-%m-%d %H:%M:%S

```

For more information, see How to manage logging . Sets a logging -compatible string used to format logging messages redirected to the logging file.

```

[pytest]
log_file_format
=
%(asctime)s %(levelname)s %(message)s

```

For more information, see How to manage logging . Sets the minimum log message level that should be captured for the logging file. The integer value or the names of the levels can be used.

```

[pytest]
log_file_level
=
INFO

```

For more information, see How to manage logging . Sets a logging -compatible string used to format captured logging messages.

```

[pytest]
log_format
=
%(asctime)s %(levelname)s %(message)s

```

For more information, see How to manage logging . Sets the minimum log message level that should be captured for logging capture. The integer value or the names of the levels can be used.

```

[pytest]
log_level
=
INFO

```

For more information, see How to manage logging . When the --strict-markers or --strict command-line arguments are used, only known markers - defined in code by core pytest or some plugin - are allowed. You can list additional markers in this setting to add them to the whitelist, in which case you probably want to add --strict-markers to addopts to avoid future regressions:

```

[pytest]
addopts
=
--strict-markers
markers
=
slow
serial

```

Note The use of --strict-markers is highly preferred. --strict was kept for backward compatibility only and may be confusing for others as it only applies to markers and not to other options. Specifies a minimal pytest version required for running tests.

```

# content of pytest.ini
[pytest]
minversion
=
3.0
# will fail if we run with pytest-2.8

```

Set the directory basename patterns to avoid when recursing for test discovery. The individual (fnmatch-style) patterns are applied to the basename of a directory to decide if to recurse into it. Pattern matching characters:

```

*       matches everything
?       matches any single character
[seq]   matches any character in seq
[!seq]  matches any char not in seq

```

Default patterns are '*.egg' , '.*' , '_darcs' , 'build' , 'CVS' , 'dist' , 'node_modules' , 'venv' , '{arch}' . Setting a norecursedirs replaces the default. Here is an example of how to avoid certain directories:

```

[pytest]
norecursedirs
=
.svn _build tmp*

```

This would tell pytest to not look into typical subversion or sphinx-build directories or into any tmp prefixed directory. Additionally, pytest will attempt to intelligently identify and ignore a virtualenv. Any directory deemed to be the root of a virtual environment will not be considered during test collection unless --collect-in-virtualenv is given. Note also that norecursedirs takes precedence over --collect-in-virtualenv ; e.g. if you intend to run tests in a virtualenv with a base directory that matches '.*' you must override norecursedirs in addition to using the --collect-in-virtualenv flag. One or more name prefixes or glob-style patterns determining which classes are considered for test collection. Search for multiple glob patterns by adding a space between patterns. By default, pytest will consider any class prefixed with Test as a test collection. Here is an example of how to collect tests from classes that end in Suite :

```

[pytest]
python_classes
=
*Suite

```

Note that unittest.TestCase derived classes are always collected regardless of this option, as unittest ’s own collection framework is used to collect those tests. One or more Glob-style file patterns determining which python files are considered as test modules. Search for multiple glob patterns by adding a space between patterns:

```

[pytest]
python_files
=
test_*.py check_*.py example_*.py

```

Or one per line:

```

[pytest]
python_files
=
test_*.py
check_*.py
example_*.py

```

By default, files matching test_*.py and *_test.py will be considered test modules. One or more name prefixes or glob-patterns determining which test functions and methods are considered tests. Search for multiple glob patterns by adding a space between patterns. By default, pytest will consider any function prefixed with test as a test. Here is an example of how to collect test functions and methods that end in _test :

```

[pytest]
python_functions
=
*_test

```

Note that this has no effect on methods that live on a unittest.TestCase derived class, as unittest ’s own collection framework is used to collect those tests. See Changing naming conventions for more detailed examples. Sets list of directories that should be added to the python search path. Directories will be added to the head of sys.path . Similar to the PYTHONPATH environment variable, the directories will be included in where Python will look for imported modules. Paths are relative to the rootdir directory. Directories remain in path for the duration of the test session.

```

[pytest]
pythonpath
=
src1 src2

```

Note pythonpath does not affect some imports that happen very early, most notably plugins loaded using the -p command line option. A space separated list of plugins that must be present for pytest to run. Plugins can be listed with or without version specifiers directly following their name. Whitespace between different version specifiers is not allowed. If any one of the plugins is not found, emit an error.

```

[pytest]
required_plugins
=
pytest-django>=3.0.0,<4.0.0 pytest-html pytest-xdist>=1.0.0

```

Sets list of directories that should be searched for tests when no specific directories, files or test ids are given in the command line when executing pytest from the rootdir directory. File system paths may use shell-style wildcards, including the recursive ** pattern. Useful when all project tests are in a known location to speed up test collection and to avoid picking up undesired tests by accident.

```

[pytest]
testpaths
=
testing doc

```

This configuration means that executing:

```

pytest

```

has the same practical effects as executing:

```

pytest testing doc

```

How many sessions should we keep the tmp_path directories, according to tmp_path_retention_policy .

```

[pytest]
tmp_path_retention_count
=
3

```

Default: 3 Controls which directories created by the tmp_path fixture are kept around, based on test outcome. all : retains directories for all tests, regardless of the outcome. failed : retains directories only for tests with outcome error or failed . none : directories are always removed after each test ends, regardless of the outcome.

```

[pytest]
tmp_path_retention_policy
=
all

```

Default: all List of fixtures that will be applied to all test functions; this is semantically the same to apply the @pytest.mark.usefixtures marker to all test functions.

```

[pytest]
usefixtures
=
clean_db

```

Set a verbosity level specifically for assertion related output, overriding the application wide level.

```

[pytest]
verbosity_assertions
=
2

```

Defaults to application wide verbosity level (via the -v command-line option). A special value of “auto” can be used to explicitly use the global verbosity level. Set a verbosity level specifically for test case execution related output, overriding the application wide level.

```

[pytest]
verbosity_test_cases
=
2

```

Defaults to application wide verbosity level (via the -v command-line option). A special value of “auto” can be used to explicitly use the global verbosity level. If set to True , tests marked with @pytest.mark.xfail that actually succeed will by default fail the test suite. For more information, see strict parameter .

```

[pytest]
xfail_strict
=
True

```

# Command-line Flags¶

All the command-line flags can be obtained by running pytest --help :

```

$ pytest --help
usage: pytest [options] [file_or_dir] [file_or_dir] [...]

positional arguments:
  file_or_dir

general:
  -k EXPRESSION         Only run tests which match the given substring
                        expression. An expression is a Python evaluable
                        expression where all names are substring-matched
                        against test names and their parent classes.
                        Example: -k 'test_method or test_other' matches all
                        test functions and classes whose name contains
                        'test_method' or 'test_other', while -k 'not
                        test_method' matches those that don't contain
                        'test_method' in their names. -k 'not test_method
                        and not test_other' will eliminate the matches.
                        Additionally keywords are matched to classes and
                        functions containing extra names in their
                        'extra_keyword_matches' set, as well as functions
                        which have names assigned directly to them. The
                        matching is case-insensitive.
  -m MARKEXPR           Only run tests matching given mark expression. For
                        example: -m 'mark1 and not mark2'.
  --markers             show markers (builtin, plugin and per-project ones).
  -x, --exitfirst       Exit instantly on first error or failed test
  --fixtures, --funcargs
                        Show available fixtures, sorted by plugin appearance
                        (fixtures with leading '_' are only shown with '-v')
  --fixtures-per-test   Show fixtures per test
  --pdb                 Start the interactive Python debugger on errors or
                        KeyboardInterrupt
  --pdbcls=modulename:classname
                        Specify a custom interactive Python debugger for use
                        with --pdb.For example:
                        --pdbcls=IPython.terminal.debugger:TerminalPdb
  --trace               Immediately break when running each test
  --capture=method      Per-test capturing method: one of fd|sys|no|tee-sys
  -s                    Shortcut for --capture=no
  --runxfail            Report the results of xfail tests as if they were
                        not marked
  --lf, --last-failed   Rerun only the tests that failed at the last run (or
                        all if none failed)
  --ff, --failed-first  Run all tests, but run the last failures first. This
                        may re-order tests and thus lead to repeated fixture
                        setup/teardown.
  --nf, --new-first     Run tests from new files first, then the rest of the
                        tests sorted by file mtime
  --cache-show=[CACHESHOW]
                        Show cache contents, don't perform collection or
                        tests. Optional argument: glob (default: '*').
  --cache-clear         Remove all cache contents at start of test run
  --lfnf, --last-failed-no-failures={all,none}
                        With ``--lf``, determines whether to execute tests
                        when there are no previously (known) failures or
                        when no cached ``lastfailed`` data was found.
                        ``all`` (the default) runs the full test suite
                        again. ``none`` just emits a message about no known
                        failures and exits successfully.
  --sw, --stepwise      Exit on test failure and continue from last failing
                        test next time
  --sw-skip, --stepwise-skip
                        Ignore the first failing test but stop on the next
                        failing test. Implicitly enables --stepwise.

Reporting:
  --durations=N         Show N slowest setup/test durations (N=0 for all)
  --durations-min=N     Minimal duration in seconds for inclusion in slowest
                        list. Default: 0.005.
  -v, --verbose         Increase verbosity
  --no-header           Disable header
  --no-summary          Disable summary
  --no-fold-skipped     Do not fold skipped tests in short summary.
  -q, --quiet           Decrease verbosity
  --verbosity=VERBOSE   Set verbosity. Default: 0.
  -r chars              Show extra test summary info as specified by chars:
                        (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed,
                        (p)assed, (P)assed with output, (a)ll except passed
                        (p/P), or (A)ll. (w)arnings are enabled by default
                        (see --disable-warnings), 'N' can be used to reset
                        the list. (default: 'fE').
  --disable-warnings, --disable-pytest-warnings
                        Disable warnings summary
  -l, --showlocals      Show locals in tracebacks (disabled by default)
  --no-showlocals       Hide locals in tracebacks (negate --showlocals
                        passed through addopts)
  --tb=style            Traceback print mode
                        (auto/long/short/line/native/no)
  --xfail-tb            Show tracebacks for xfail (as long as --tb != no)
  --show-capture={no,stdout,stderr,log,all}
                        Controls how captured stdout/stderr/log is shown on
                        failed tests. Default: all.
  --full-trace          Don't cut any tracebacks (default is to cut)
  --color=color         Color terminal output (yes/no/auto)
  --code-highlight={yes,no}
                        Whether code should be highlighted (only if --color
                        is also enabled). Default: yes.
  --pastebin=mode       Send failed|all info to bpaste.net pastebin service
  --junitxml, --junit-xml=path
                        Create junit-xml style report file at given path
  --junitprefix, --junit-prefix=str
                        Prepend prefix to classnames in junit-xml output

pytest-warnings:
  -W, --pythonwarnings PYTHONWARNINGS
                        Set which warnings to report, see -W option of
                        Python itself
  --maxfail=num         Exit after first num failures or errors
  --strict-config       Any warnings encountered while parsing the `pytest`
                        section of the configuration file raise errors
  --strict-markers      Markers not registered in the `markers` section of
                        the configuration file raise errors
  --strict              (Deprecated) alias to --strict-markers
  -c, --config-file FILE
                        Load configuration from `FILE` instead of trying to
                        locate one of the implicit configuration files.
  --continue-on-collection-errors
                        Force test execution even if collection errors occur
  --rootdir=ROOTDIR     Define root directory for tests. Can be relative
                        path: 'root_dir', './root_dir',
                        'root_dir/another_dir/'; absolute path:
                        '/home/user/root_dir'; path with variables:
                        '$HOME/root_dir'.

collection:
  --collect-only, --co  Only collect tests, don't execute them
  --pyargs              Try to interpret all arguments as Python packages
  --ignore=path         Ignore path during collection (multi-allowed)
  --ignore-glob=path    Ignore path pattern during collection (multi-
                        allowed)
  --deselect=nodeid_prefix
                        Deselect item (via node id prefix) during collection
                        (multi-allowed)
  --confcutdir=dir      Only load conftest.py's relative to specified dir
  --noconftest          Don't load any conftest.py files
  --keep-duplicates     Keep duplicate tests
  --collect-in-virtualenv
                        Don't ignore tests in a local virtualenv directory
  --import-mode={prepend,append,importlib}
                        Prepend/append to sys.path when importing test
                        modules and conftest files. Default: prepend.
  --doctest-modules     Run doctests in all .py modules
  --doctest-report={none,cdiff,ndiff,udiff,only_first_failure}
                        Choose another output format for diffs on doctest
                        failure
  --doctest-glob=pat    Doctests file matching pattern, default: test*.txt
  --doctest-ignore-import-errors
                        Ignore doctest collection errors
  --doctest-continue-on-failure
                        For a given doctest, continue to run after the first
                        failure

test session debugging and configuration:
  --basetemp=dir        Base temporary directory for this test run.
                        (Warning: this directory is removed if it exists.)
  -V, --version         Display pytest version and information about
                        plugins. When given twice, also display information
                        about plugins.
  -h, --help            Show help message and configuration info
  -p name               Early-load given plugin module name or entry point
                        (multi-allowed). To avoid loading of plugins, use
                        the `no:` prefix, e.g. `no:doctest`.
  --trace-config        Trace considerations of conftest.py files
  --debug=[DEBUG_FILE_NAME]
                        Store internal tracing debug information in this log
                        file. This file is opened with 'w' and truncated as
                        a result, care advised. Default: pytestdebug.log.
  -o, --override-ini OVERRIDE_INI
                        Override ini option with "option=value" style, e.g.
                        `-o xfail_strict=True -o cache_dir=cache`.
  --assert=MODE         Control assertion debugging tools.
                        'plain' performs no assertion debugging.
                        'rewrite' (the default) rewrites assert statements
                        in test modules on import to provide assert
                        expression information.
  --setup-only          Only setup fixtures, do not execute tests
  --setup-show          Show setup of fixtures while executing tests
  --setup-plan          Show what fixtures and tests would be executed but
                        don't execute anything

logging:
  --log-level=LEVEL     Level of messages to catch/display. Not set by
                        default, so it depends on the root/parent log
                        handler's effective level, where it is "WARNING" by
                        default.
  --log-format=LOG_FORMAT
                        Log format used by the logging module
  --log-date-format=LOG_DATE_FORMAT
                        Log date format used by the logging module
  --log-cli-level=LOG_CLI_LEVEL
                        CLI logging level
  --log-cli-format=LOG_CLI_FORMAT
                        Log format used by the logging module
  --log-cli-date-format=LOG_CLI_DATE_FORMAT
                        Log date format used by the logging module
  --log-file=LOG_FILE   Path to a file when logging will be written to
  --log-file-mode={w,a}
                        Log file open mode
  --log-file-level=LOG_FILE_LEVEL
                        Log file logging level
  --log-file-format=LOG_FILE_FORMAT
                        Log format used by the logging module
  --log-file-date-format=LOG_FILE_DATE_FORMAT
                        Log date format used by the logging module
  --log-auto-indent=LOG_AUTO_INDENT
                        Auto-indent multiline messages passed to the logging
                        module. Accepts true|on, false|off or an integer.
  --log-disable=LOGGER_DISABLE
                        Disable a logger by name. Can be passed multiple
                        times.

[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg|pyproject.toml file found:

  markers (linelist):   Register new markers for test functions
  empty_parameter_set_mark (string):
                        Default marker for empty parametersets
  norecursedirs (args): Directory patterns to avoid for recursion
  testpaths (args):     Directories to search for tests when no files or
                        directories are given on the command line
  filterwarnings (linelist):
                        Each line specifies a pattern for
                        warnings.filterwarnings. Processed after
                        -W/--pythonwarnings.
  consider_namespace_packages (bool):
                        Consider namespace packages when resolving module
                        names during import
  usefixtures (args):   List of default fixtures to be used with this
                        project
  python_files (args):  Glob-style file patterns for Python test module
                        discovery
  python_classes (args):
                        Prefixes or glob names for Python test class
                        discovery
  python_functions (args):
                        Prefixes or glob names for Python test function and
                        method discovery
  disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool):
                        Disable string escape non-ASCII characters, might
                        cause unwanted side effects(use at your own risk)
  console_output_style (string):
                        Console output: "classic", or with additional
                        progress information ("progress" (percentage) |
                        "count" | "progress-even-when-capture-no" (forces
                        progress even when capture=no)
  verbosity_test_cases (string):
                        Specify a verbosity level for test case execution,
                        overriding the main level. Higher levels will
                        provide more detailed information about each test
                        case executed.
  xfail_strict (bool):  Default for the strict parameter of xfail markers
                        when not given explicitly (default: False)
  tmp_path_retention_count (string):
                        How many sessions should we keep the `tmp_path`
                        directories, according to
                        `tmp_path_retention_policy`.
  tmp_path_retention_policy (string):
                        Controls which directories created by the `tmp_path`
                        fixture are kept around, based on test outcome.
                        (all/failed/none)
  enable_assertion_pass_hook (bool):
                        Enables the pytest_assertion_pass hook. Make sure to
                        delete any previously generated pyc cache files.
  verbosity_assertions (string):
                        Specify a verbosity level for assertions, overriding
                        the main level. Higher levels will provide more
                        detailed explanation when an assertion fails.
  junit_suite_name (string):
                        Test suite name for JUnit report
  junit_logging (string):
                        Write captured log messages to JUnit report: one of
                        no|log|system-out|system-err|out-err|all
  junit_log_passing_tests (bool):
                        Capture log information for passing tests to JUnit
                        report:
  junit_duration_report (string):
                        Duration time to report: one of total|call
  junit_family (string):
                        Emit XML for schema: one of legacy|xunit1|xunit2
  doctest_optionflags (args):
                        Option flags for doctests
  doctest_encoding (string):
                        Encoding used for doctest files
  cache_dir (string):   Cache directory path
  log_level (string):   Default value for --log-level
  log_format (string):  Default value for --log-format
  log_date_format (string):
                        Default value for --log-date-format
  log_cli (bool):       Enable log display during test run (also known as
                        "live logging")
  log_cli_level (string):
                        Default value for --log-cli-level
  log_cli_format (string):
                        Default value for --log-cli-format
  log_cli_date_format (string):
                        Default value for --log-cli-date-format
  log_file (string):    Default value for --log-file
  log_file_mode (string):
                        Default value for --log-file-mode
  log_file_level (string):
                        Default value for --log-file-level
  log_file_format (string):
                        Default value for --log-file-format
  log_file_date_format (string):
                        Default value for --log-file-date-format
  log_auto_indent (string):
                        Default value for --log-auto-indent
  pythonpath (paths):   Add paths to sys.path
  faulthandler_timeout (string):
                        Dump the traceback of all threads if a test takes
                        more than TIMEOUT seconds to finish
  addopts (args):       Extra command line options
  minversion (string):  Minimally required pytest version
  required_plugins (args):
                        Plugins that must be present for pytest to run

Environment variables:
  CI                       When set (regardless of value), pytest knows it is running in a CI process and does not truncate summary info
  BUILD_NUMBER             Equivalent to CI
  PYTEST_ADDOPTS           Extra command line options
  PYTEST_PLUGINS           Comma-separated plugins to load during startup
  PYTEST_DISABLE_PLUGIN_AUTOLOAD Set to disable plugin auto-loading
  PYTEST_DEBUG             Set to enable debug tracing of pytest's internals


to see available markers type: pytest --markers
to see available fixtures type: pytest --fixtures
(shown according to specified file_or_dir or current dir if not specified; fixtures with leading '_' are only shown with the '-v' option

```


---


# How-to guides - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/index.html


# How-to guides¶

# Core pytest functionality¶

# Test output and outcomes¶

# Plugins¶

# pytest and other test systems¶

# pytest development environment¶


---


# How to use unittest-based tests with pytest - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/unittest.html


# How to useunittest-based tests with pytest¶

pytest supports running Python unittest -based tests out of the box. It’s meant for leveraging existing unittest -based test suites to use pytest as a test runner and also allow to incrementally adapt the test suite to take full advantage of pytest’s features. To run an existing unittest -style test suite using pytest , type:

```

pytest
tests

```

pytest will automatically collect unittest.TestCase subclasses and their test methods in test_*.py or *_test.py files. Almost all unittest features are supported: @unittest.skip style decorators; setUp/tearDown ; setUpClass/tearDownClass ; setUpModule/tearDownModule ; Additionally, subtests are supported by the pytest-subtests plugin. Up to this point pytest does not have support for the following features: load_tests protocol ;

# Benefits out of the box¶

By running your test suite with pytest you can make use of several features, in most cases without having to modify existing code: Obtain more informative tracebacks ; stdout and stderr capturing; Test selection options using -k and -m flags; Stopping after the first (or N) failures ; –pdb command-line option for debugging on test failures (see note below); Distribute tests to multiple CPUs using the pytest-xdist plugin; Use plain assert-statements instead of self.assert* functions ( unittest2pytest is immensely helpful in this);

# pytest features inunittest.TestCasesubclasses¶

The following pytest features work in unittest.TestCase subclasses: Marks : skip , skipif , xfail ; Auto-use fixtures ; The following pytest features do not work, and probably never will due to different design philosophies: Fixtures (except for autouse fixtures, see below ); Parametrization ; Custom hooks ; Third party plugins may or may not work well, depending on the plugin and the test suite.

# Mixing pytest fixtures intounittest.TestCasesubclasses using marks¶

Running your unittest with pytest allows you to use its fixture mechanism with unittest.TestCase style tests. Assuming you have at least skimmed the pytest fixture features, let’s jump-start into an example that integrates a pytest db_class fixture, setting up a class-cached database object, and then reference it from a unittest-style test:

```

# content of conftest.py
# we define a fixture function below and it will be "used" by
# referencing its name from tests
import
pytest
@pytest
.
fixture
(
scope
=
"class"
)
def
db_class
(
request
):
class
DummyDB
:
pass
# set a class attribute on the invoking test context
request
.
cls
.
db
=
DummyDB
()

```

This defines a fixture function db_class which - if used - is called once for each test class and which sets the class-level db attribute to a DummyDB instance. The fixture function achieves this by receiving a special request object which gives access to the requesting test context such as the cls attribute, denoting the class from which the fixture is used. This architecture de-couples fixture writing from actual test code and allows reuse of the fixture by a minimal reference, the fixture name. So let’s write an actual unittest.TestCase class using our fixture definition:

```

# content of test_unittest_db.py
import
unittest
import
pytest
@pytest
.
mark
.
usefixtures
(
"db_class"
)
class
MyTest
(
unittest
.
TestCase
):
def
test_method1
(
self
):
assert
hasattr
(
self
,
"db"
)
assert
0
,
self
.
db
# fail for demo purposes
def
test_method2
(
self
):
assert
0
,
self
.
db
# fail for demo purposes

```

The @pytest.mark.usefixtures("db_class") class-decorator makes sure that the pytest fixture function db_class is called once per class. Due to the deliberately failing assert statements, we can take a look at the self.db values in the traceback:

```

$ pytest test_unittest_db.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_unittest_db.py
FF
[100%]
================================= FAILURES =================================
___________________________ MyTest.test_method1 ____________________________
self = <test_unittest_db.MyTest testMethod=test_method1>

    def test_method1(self):
        assert hasattr(self, "db")
>       assert 0, self.db  # fail for demo purposes
E       AssertionError: <conftest.db_class.<locals>.DummyDB object at 0xdeadbeef0001>
E       assert 0
test_unittest_db.py
:11: AssertionError
___________________________ MyTest.test_method2 ____________________________
self = <test_unittest_db.MyTest testMethod=test_method2>

    def test_method2(self):
>       assert 0, self.db  # fail for demo purposes
E       AssertionError: <conftest.db_class.<locals>.DummyDB object at 0xdeadbeef0001>
E       assert 0
test_unittest_db.py
:14: AssertionError
========================= short test summary info ==========================
FAILED
test_unittest_db.py::
MyTest::test_method1
- AssertionError: <conft...
FAILED
test_unittest_db.py::
MyTest::test_method2
- AssertionError: <conft...
============================
2 failed
in 0.12s =============================

```

This default pytest traceback shows that the two test methods share the same self.db instance which was our intention when writing the class-scoped fixture function above.

# Using autouse fixtures and accessing other fixtures¶

Although it’s usually better to explicitly declare use of fixtures you need for a given test, you may sometimes want to have fixtures that are automatically used in a given context. After all, the traditional style of unittest-setup mandates the use of this implicit fixture writing and chances are, you are used to it or like it. You can flag fixture functions with @pytest.fixture(autouse=True) and define the fixture function in the context where you want it used. Let’s look at an initdir fixture which makes all test methods of a TestCase class execute in a temporary directory with a pre-initialized samplefile.ini . Our initdir fixture itself uses the pytest builtin tmp_path fixture to delegate the creation of a per-test temporary directory:

```

# content of test_unittest_cleandir.py
import
unittest
import
pytest
class
MyTest
(
unittest
.
TestCase
):
@pytest
.
fixture
(
autouse
=
True
)
def
initdir
(
self
,
tmp_path
,
monkeypatch
):
monkeypatch
.
chdir
(
tmp_path
)
# change to pytest-provided temporary directory
tmp_path
.
joinpath
(
"samplefile.ini"
)
.
write_text
(
"# testdata"
,
encoding
=
"utf-8"
)
def
test_method
(
self
):
with
open
(
"samplefile.ini"
,
encoding
=
"utf-8"
)
as
f
:
s
=
f
.
read
()
assert
"testdata"
in
s

```

Due to the autouse flag the initdir fixture function will be used for all methods of the class where it is defined. This is a shortcut for using a @pytest.mark.usefixtures("initdir") marker on the class like in the previous example. Running this test module …:

```

$ pytest -q test_unittest_cleandir.py
.
[100%]
1 passed
in 0.12s

```


---


# How to use fixtures - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/fixtures.html


# How to use fixtures¶

See also About fixtures See also Fixtures reference

# “Requesting” fixtures¶

At a basic level, test functions request fixtures they require by declaring them as arguments. When pytest goes to run a test, it looks at the parameters in that test function’s signature, and then searches for fixtures that have the same names as those parameters. Once pytest finds them, it runs those fixtures, captures what they returned (if anything), and passes those objects into the test function as arguments.

# Quick example¶

```

import
pytest
class
Fruit
:
def
__init__
(
self
,
name
):
self
.
name
=
name
self
.
cubed
=
False
def
cube
(
self
):
self
.
cubed
=
True
class
FruitSalad
:
def
__init__
(
self
,
*
fruit_bowl
):
self
.
fruit
=
fruit_bowl
self
.
_cube_fruit
()
def
_cube_fruit
(
self
):
for
fruit
in
self
.
fruit
:
fruit
.
cube
()
# Arrange
@pytest
.
fixture
def
fruit_bowl
():
return
[
Fruit
(
"apple"
),
Fruit
(
"banana"
)]
def
test_fruit_salad
(
fruit_bowl
):
# Act
fruit_salad
=
FruitSalad
(
*
fruit_bowl
)
# Assert
assert
all
(
fruit
.
cubed
for
fruit
in
fruit_salad
.
fruit
)

```

In this example, test_fruit_salad “ requests ” fruit_bowl (i.e. def test_fruit_salad(fruit_bowl): ), and when pytest sees this, it will execute the fruit_bowl fixture function and pass the object it returns into test_fruit_salad as the fruit_bowl argument. Here’s roughly what’s happening if we were to do it by hand:

```

def
fruit_bowl
():
return
[
Fruit
(
"apple"
),
Fruit
(
"banana"
)]
def
test_fruit_salad
(
fruit_bowl
):
# Act
fruit_salad
=
FruitSalad
(
*
fruit_bowl
)
# Assert
assert
all
(
fruit
.
cubed
for
fruit
in
fruit_salad
.
fruit
)
# Arrange
bowl
=
fruit_bowl
()
test_fruit_salad
(
fruit_bowl
=
bowl
)

```

# Fixtures canrequestother fixtures¶

One of pytest’s greatest strengths is its extremely flexible fixture system. It allows us to boil down complex requirements for tests into more simple and organized functions, where we only need to have each one describe the things they are dependent on. We’ll get more into this further down, but for now, here’s a quick example to demonstrate how fixtures can use other fixtures:

```

# contents of test_append.py
import
pytest
# Arrange
@pytest
.
fixture
def
first_entry
():
return
"a"
# Arrange
@pytest
.
fixture
def
order
(
first_entry
):
return
[
first_entry
]
def
test_string
(
order
):
# Act
order
.
append
(
"b"
)
# Assert
assert
order
==
[
"a"
,
"b"
]

```

Notice that this is the same example from above, but very little changed. The fixtures in pytest request fixtures just like tests. All the same requesting rules apply to fixtures that do for tests. Here’s how this example would work if we did it by hand:

```

def
first_entry
():
return
"a"
def
order
(
first_entry
):
return
[
first_entry
]
def
test_string
(
order
):
# Act
order
.
append
(
"b"
)
# Assert
assert
order
==
[
"a"
,
"b"
]
entry
=
first_entry
()
the_list
=
order
(
first_entry
=
entry
)
test_string
(
order
=
the_list
)

```

# Fixtures are reusable¶

One of the things that makes pytest’s fixture system so powerful, is that it gives us the ability to define a generic setup step that can be reused over and over, just like a normal function would be used. Two different tests can request the same fixture and have pytest give each test their own result from that fixture. This is extremely useful for making sure tests aren’t affected by each other. We can use this system to make sure each test gets its own fresh batch of data and is starting from a clean state so it can provide consistent, repeatable results. Here’s an example of how this can come in handy:

```

# contents of test_append.py
import
pytest
# Arrange
@pytest
.
fixture
def
first_entry
():
return
"a"
# Arrange
@pytest
.
fixture
def
order
(
first_entry
):
return
[
first_entry
]
def
test_string
(
order
):
# Act
order
.
append
(
"b"
)
# Assert
assert
order
==
[
"a"
,
"b"
]
def
test_int
(
order
):
# Act
order
.
append
(
2
)
# Assert
assert
order
==
[
"a"
,
2
]

```

Each test here is being given its own copy of that list object, which means the order fixture is getting executed twice (the same is true for the first_entry fixture). If we were to do this by hand as well, it would look something like this:

```

def
first_entry
():
return
"a"
def
order
(
first_entry
):
return
[
first_entry
]
def
test_string
(
order
):
# Act
order
.
append
(
"b"
)
# Assert
assert
order
==
[
"a"
,
"b"
]
def
test_int
(
order
):
# Act
order
.
append
(
2
)
# Assert
assert
order
==
[
"a"
,
2
]
entry
=
first_entry
()
the_list
=
order
(
first_entry
=
entry
)
test_string
(
order
=
the_list
)
entry
=
first_entry
()
the_list
=
order
(
first_entry
=
entry
)
test_int
(
order
=
the_list
)

```

# A test/fixture canrequestmore than one fixture at a time¶

Tests and fixtures aren’t limited to requesting a single fixture at a time. They can request as many as they like. Here’s another quick example to demonstrate:

```

# contents of test_append.py
import
pytest
# Arrange
@pytest
.
fixture
def
first_entry
():
return
"a"
# Arrange
@pytest
.
fixture
def
second_entry
():
return
2
# Arrange
@pytest
.
fixture
def
order
(
first_entry
,
second_entry
):
return
[
first_entry
,
second_entry
]
# Arrange
@pytest
.
fixture
def
expected_list
():
return
[
"a"
,
2
,
3.0
]
def
test_string
(
order
,
expected_list
):
# Act
order
.
append
(
3.0
)
# Assert
assert
order
==
expected_list

```

# Fixtures can berequestedmore than once per test (return values are cached)¶

Fixtures can also be requested more than once during the same test, and pytest won’t execute them again for that test. This means we can request fixtures in multiple fixtures that are dependent on them (and even again in the test itself) without those fixtures being executed more than once.

```

# contents of test_append.py
import
pytest
# Arrange
@pytest
.
fixture
def
first_entry
():
return
"a"
# Arrange
@pytest
.
fixture
def
order
():
return
[]
# Act
@pytest
.
fixture
def
append_first
(
order
,
first_entry
):
return
order
.
append
(
first_entry
)
def
test_string_only
(
append_first
,
order
,
first_entry
):
# Assert
assert
order
==
[
first_entry
]

```

If a requested fixture was executed once for every time it was requested during a test, then this test would fail because both append_first and test_string_only would see order as an empty list (i.e. [] ), but since the return value of order was cached (along with any side effects executing it may have had) after the first time it was called, both the test and append_first were referencing the same object, and the test saw the effect append_first had on that object.

# Autouse fixtures (fixtures you don’t have to request)¶

Sometimes you may want to have a fixture (or even several) that you know all your tests will depend on. “Autouse” fixtures are a convenient way to make all tests automatically request them. This can cut out a lot of redundant requests , and can even provide more advanced fixture usage (more on that further down). We can make a fixture an autouse fixture by passing in autouse=True to the fixture’s decorator. Here’s a simple example for how they can be used:

```

# contents of test_append.py
import
pytest
@pytest
.
fixture
def
first_entry
():
return
"a"
@pytest
.
fixture
def
order
(
first_entry
):
return
[]
@pytest
.
fixture
(
autouse
=
True
)
def
append_first
(
order
,
first_entry
):
return
order
.
append
(
first_entry
)
def
test_string_only
(
order
,
first_entry
):
assert
order
==
[
first_entry
]
def
test_string_and_int
(
order
,
first_entry
):
order
.
append
(
2
)
assert
order
==
[
first_entry
,
2
]

```

In this example, the append_first fixture is an autouse fixture. Because it happens automatically, both tests are affected by it, even though neither test requested it. That doesn’t mean they can’t be requested though; just that it isn’t necessary .

# Scope: sharing fixtures across classes, modules, packages or session¶

Fixtures requiring network access depend on connectivity and are usually time-expensive to create. Extending the previous example, we can add a scope="module" parameter to the @pytest.fixture invocation to cause a smtp_connection fixture function, responsible to create a connection to a preexisting SMTP server, to only be invoked once per test module (the default is to invoke once per test function ). Multiple test functions in a test module will thus each receive the same smtp_connection fixture instance, thus saving time. Possible values for scope are: function , class , module , package or session . The next example puts the fixture function into a separate conftest.py file so that tests from multiple test modules in the directory can access the fixture function:

```

# content of conftest.py
import
smtplib
import
pytest
@pytest
.
fixture
(
scope
=
"module"
)
def
smtp_connection
():
return
smtplib
.
SMTP
(
"smtp.gmail.com"
,
587
,
timeout
=
5
)

```

```

# content of test_module.py
def
test_ehlo
(
smtp_connection
):
response
,
msg
=
smtp_connection
.
ehlo
()
assert
response
==
250
assert
b
"smtp.gmail.com"
in
msg
assert
0
# for demo purposes
def
test_noop
(
smtp_connection
):
response
,
msg
=
smtp_connection
.
noop
()
assert
response
==
250
assert
0
# for demo purposes

```

Here, the test_ehlo needs the smtp_connection fixture value. pytest will discover and call the @pytest.fixture marked smtp_connection fixture function. Running the test looks like this:

```

$ pytest test_module.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_module.py
FF
[100%]
================================= FAILURES =================================
________________________________ test_ehlo _________________________________
smtp_connection = <smtplib.SMTP object at 0xdeadbeef0001>

    def test_ehlo(smtp_connection):
        response, msg = smtp_connection.ehlo()
        assert response == 250
        assert b"smtp.gmail.com" in msg
>       assert 0  # for demo purposes
E       assert 0
test_module.py
:7: AssertionError
________________________________ test_noop _________________________________
smtp_connection = <smtplib.SMTP object at 0xdeadbeef0001>

    def test_noop(smtp_connection):
        response, msg = smtp_connection.noop()
        assert response == 250
>       assert 0  # for demo purposes
E       assert 0
test_module.py
:13: AssertionError
========================= short test summary info ==========================
FAILED
test_module.py::
test_ehlo
- assert 0
FAILED
test_module.py::
test_noop
- assert 0
============================
2 failed
in 0.12s =============================

```

You see the two assert 0 failing and more importantly you can also see that the exactly same smtp_connection object was passed into the two test functions because pytest shows the incoming argument values in the traceback. As a result, the two test functions using smtp_connection run as quick as a single one because they reuse the same instance. If you decide that you rather want to have a session-scoped smtp_connection instance, you can simply declare it:

```

@pytest
.
fixture
(
scope
=
"session"
)
def
smtp_connection
():
# the returned fixture value will be shared for
# all tests requesting it
...

```

# Fixture scopes¶

Fixtures are created when first requested by a test, and are destroyed based on their scope : function : the default scope, the fixture is destroyed at the end of the test. class : the fixture is destroyed during teardown of the last test in the class. module : the fixture is destroyed during teardown of the last test in the module. package : the fixture is destroyed during teardown of the last test in the package where the fixture is defined, including sub-packages and sub-directories within it. session : the fixture is destroyed at the end of the test session. Note Pytest only caches one instance of a fixture at a time, which means that when using a parametrized fixture, pytest may invoke a fixture more than once in the given scope.

# Dynamic scope¶

Added in version 5.2. In some cases, you might want to change the scope of the fixture without changing the code. To do that, pass a callable to scope . The callable must return a string with a valid scope and will be executed only once - during the fixture definition. It will be called with two keyword arguments - fixture_name as a string and config with a configuration object. This can be especially useful when dealing with fixtures that need time for setup, like spawning a docker container. You can use the command-line argument to control the scope of the spawned containers for different environments. See the example below.

```

def
determine_scope
(
fixture_name
,
config
):
if
config
.
getoption
(
"--keep-containers"
,
None
):
return
"session"
return
"function"
@pytest
.
fixture
(
scope
=
determine_scope
)
def
docker_container
():
yield
spawn_container
()

```

# Teardown/Cleanup (AKA Fixture finalization)¶

When we run our tests, we’ll want to make sure they clean up after themselves so they don’t mess with any other tests (and also so that we don’t leave behind a mountain of test data to bloat the system). Fixtures in pytest offer a very useful teardown system, which allows us to define the specific steps necessary for each fixture to clean up after itself. This system can be leveraged in two ways.

# 1.yieldfixtures (recommended)¶

“Yield” fixtures yield instead of return . With these fixtures, we can run some code and pass an object back to the requesting fixture/test, just like with the other fixtures. The only differences are: return is swapped out for yield . Any teardown code for that fixture is placed after the yield . Once pytest figures out a linear order for the fixtures, it will run each one up until it returns or yields, and then move on to the next fixture in the list to do the same thing. Once the test is finished, pytest will go back down the list of fixtures, but in the reverse order , taking each one that yielded, and running the code inside it that was after the yield statement. As a simple example, consider this basic email module:

```

# content of emaillib.py
class
MailAdminClient
:
def
create_user
(
self
):
return
MailUser
()
def
delete_user
(
self
,
user
):
# do some cleanup
pass
class
MailUser
:
def
__init__
(
self
):
self
.
inbox
=
[]
def
send_email
(
self
,
email
,
other
):
other
.
inbox
.
append
(
email
)
def
clear_mailbox
(
self
):
self
.
inbox
.
clear
()
class
Email
:
def
__init__
(
self
,
subject
,
body
):
self
.
subject
=
subject
self
.
body
=
body

```

Let’s say we want to test sending email from one user to another. We’ll have to first make each user, then send the email from one user to the other, and finally assert that the other user received that message in their inbox. If we want to clean up after the test runs, we’ll likely have to make sure the other user’s mailbox is emptied before deleting that user, otherwise the system may complain. Here’s what that might look like:

```

# content of test_emaillib.py
from
emaillib
import
Email
,
MailAdminClient
import
pytest
@pytest
.
fixture
def
mail_admin
():
return
MailAdminClient
()
@pytest
.
fixture
def
sending_user
(
mail_admin
):
user
=
mail_admin
.
create_user
()
yield
user
mail_admin
.
delete_user
(
user
)
@pytest
.
fixture
def
receiving_user
(
mail_admin
):
user
=
mail_admin
.
create_user
()
yield
user
user
.
clear_mailbox
()
mail_admin
.
delete_user
(
user
)
def
test_email_received
(
sending_user
,
receiving_user
):
email
=
Email
(
subject
=
"Hey!"
,
body
=
"How's it going?"
)
sending_user
.
send_email
(
email
,
receiving_user
)
assert
email
in
receiving_user
.
inbox

```

Because receiving_user is the last fixture to run during setup, it’s the first to run during teardown. There is a risk that even having the order right on the teardown side of things doesn’t guarantee a safe cleanup. That’s covered in a bit more detail in Safe teardowns .

```

$ pytest -q test_emaillib.py
.
[100%]
1 passed
in 0.12s

```

# Handling errors for yield fixture¶

If a yield fixture raises an exception before yielding, pytest won’t try to run the teardown code after that yield fixture’s yield statement. But, for every fixture that has already run successfully for that test, pytest will still attempt to tear them down as it normally would.

# 2. Adding finalizers directly¶

While yield fixtures are considered to be the cleaner and more straightforward option, there is another choice, and that is to add “finalizer” functions directly to the test’s request-context object. It brings a similar result as yield fixtures, but requires a bit more verbosity. In order to use this approach, we have to request the request-context object (just like we would request another fixture) in the fixture we need to add teardown code for, and then pass a callable, containing that teardown code, to its addfinalizer method. We have to be careful though, because pytest will run that finalizer once it’s been added, even if that fixture raises an exception after adding the finalizer. So to make sure we don’t run the finalizer code when we wouldn’t need to, we would only add the finalizer once the fixture would have done something that we’d need to teardown. Here’s how the previous example would look using the addfinalizer method:

```

# content of test_emaillib.py
from
emaillib
import
Email
,
MailAdminClient
import
pytest
@pytest
.
fixture
def
mail_admin
():
return
MailAdminClient
()
@pytest
.
fixture
def
sending_user
(
mail_admin
):
user
=
mail_admin
.
create_user
()
yield
user
mail_admin
.
delete_user
(
user
)
@pytest
.
fixture
def
receiving_user
(
mail_admin
,
request
):
user
=
mail_admin
.
create_user
()
def
delete_user
():
mail_admin
.
delete_user
(
user
)
request
.
addfinalizer
(
delete_user
)
return
user
@pytest
.
fixture
def
email
(
sending_user
,
receiving_user
,
request
):
_email
=
Email
(
subject
=
"Hey!"
,
body
=
"How's it going?"
)
sending_user
.
send_email
(
_email
,
receiving_user
)
def
empty_mailbox
():
receiving_user
.
clear_mailbox
()
request
.
addfinalizer
(
empty_mailbox
)
return
_email
def
test_email_received
(
receiving_user
,
email
):
assert
email
in
receiving_user
.
inbox

```

It’s a bit longer than yield fixtures and a bit more complex, but it does offer some nuances for when you’re in a pinch.

```

$ pytest -q test_emaillib.py
.
[100%]
1 passed
in 0.12s

```

# Note on finalizer order¶

Finalizers are executed in a first-in-last-out order. For yield fixtures, the first teardown code to run is from the right-most fixture, i.e. the last test parameter.

```

# content of test_finalizers.py
import
pytest
def
test_bar
(
fix_w_yield1
,
fix_w_yield2
):
print
(
"test_bar"
)
@pytest
.
fixture
def
fix_w_yield1
():
yield
print
(
"after_yield_1"
)
@pytest
.
fixture
def
fix_w_yield2
():
yield
print
(
"after_yield_2"
)

```

```

$ pytest -s test_finalizers.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_finalizers.py test_bar
.after_yield_2
after_yield_1
============================
1 passed
in 0.12s =============================

```

For finalizers, the first fixture to run is last call to request.addfinalizer .

```

# content of test_finalizers.py
from
functools
import
partial
import
pytest
@pytest
.
fixture
def
fix_w_finalizers
(
request
):
request
.
addfinalizer
(
partial
(
print
,
"finalizer_2"
))
request
.
addfinalizer
(
partial
(
print
,
"finalizer_1"
))
def
test_bar
(
fix_w_finalizers
):
print
(
"test_bar"
)

```

```

$ pytest -s test_finalizers.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_finalizers.py test_bar
.finalizer_1
finalizer_2
============================
1 passed
in 0.12s =============================

```

This is so because yield fixtures use addfinalizer behind the scenes: when the fixture executes, addfinalizer registers a function that resumes the generator, which in turn calls the teardown code.

# Safe teardowns¶

The fixture system of pytest is very powerful, but it’s still being run by a computer, so it isn’t able to figure out how to safely teardown everything we throw at it. If we aren’t careful, an error in the wrong spot might leave stuff from our tests behind, and that can cause further issues pretty quickly. For example, consider the following tests (based off of the mail example from above):

```

# content of test_emaillib.py
from
emaillib
import
Email
,
MailAdminClient
import
pytest
@pytest
.
fixture
def
setup
():
mail_admin
=
MailAdminClient
()
sending_user
=
mail_admin
.
create_user
()
receiving_user
=
mail_admin
.
create_user
()
email
=
Email
(
subject
=
"Hey!"
,
body
=
"How's it going?"
)
sending_user
.
send_email
(
email
,
receiving_user
)
yield
receiving_user
,
email
receiving_user
.
clear_mailbox
()
mail_admin
.
delete_user
(
sending_user
)
mail_admin
.
delete_user
(
receiving_user
)
def
test_email_received
(
setup
):
receiving_user
,
email
=
setup
assert
email
in
receiving_user
.
inbox

```

This version is a lot more compact, but it’s also harder to read, doesn’t have a very descriptive fixture name, and none of the fixtures can be reused easily. There’s also a more serious issue, which is that if any of those steps in the setup raise an exception, none of the teardown code will run. One option might be to go with the addfinalizer method instead of yield fixtures, but that might get pretty complex and difficult to maintain (and it wouldn’t be compact anymore).

```

$ pytest -q test_emaillib.py
.
[100%]
1 passed
in 0.12s

```

# Safe fixture structure¶

The safest and simplest fixture structure requires limiting fixtures to only making one state-changing action each, and then bundling them together with their teardown code, as the email examples above showed. The chance that a state-changing operation can fail but still modify state is negligible, as most of these operations tend to be transaction -based (at least at the level of testing where state could be left behind). So if we make sure that any successful state-changing action gets torn down by moving it to a separate fixture function and separating it from other, potentially failing state-changing actions, then our tests will stand the best chance at leaving the test environment the way they found it. For an example, let’s say we have a website with a login page, and we have access to an admin API where we can generate users. For our test, we want to: Create a user through that admin API Launch a browser using Selenium Go to the login page of our site Log in as the user we created Assert that their name is in the header of the landing page We wouldn’t want to leave that user in the system, nor would we want to leave that browser session running, so we’ll want to make sure the fixtures that create those things clean up after themselves. Here’s what that might look like: Note For this example, certain fixtures (i.e. base_url and admin_credentials ) are implied to exist elsewhere. So for now, let’s assume they exist, and we’re just not looking at them.

```

from
uuid
import
uuid4
from
urllib.parse
import
urljoin
from
selenium.webdriver
import
Chrome
import
pytest
from
src.utils.pages
import
LoginPage
,
LandingPage
from
src.utils
import
AdminApiClient
from
src.utils.data_types
import
User
@pytest
.
fixture
def
admin_client
(
base_url
,
admin_credentials
):
return
AdminApiClient
(
base_url
,
**
admin_credentials
)
@pytest
.
fixture
def
user
(
admin_client
):
_user
=
User
(
name
=
"Susan"
,
username
=
f
"testuser-
{
uuid4
()
}
"
,
password
=
"P4$$word"
)
admin_client
.
create_user
(
_user
)
yield
_user
admin_client
.
delete_user
(
_user
)
@pytest
.
fixture
def
driver
():
_driver
=
Chrome
()
yield
_driver
_driver
.
quit
()
@pytest
.
fixture
def
login
(
driver
,
base_url
,
user
):
driver
.
get
(
urljoin
(
base_url
,
"/login"
))
page
=
LoginPage
(
driver
)
page
.
login
(
user
)
@pytest
.
fixture
def
landing_page
(
driver
,
login
):
return
LandingPage
(
driver
)
def
test_name_on_landing_page_after_login
(
landing_page
,
user
):
assert
landing_page
.
header
==
f
"Welcome,
{
user
.
name
}
!"

```

The way the dependencies are laid out means it’s unclear if the user fixture would execute before the driver fixture. But that’s ok, because those are atomic operations, and so it doesn’t matter which one runs first because the sequence of events for the test is still linearizable . But what does matter is that, no matter which one runs first, if the one raises an exception while the other would not have, neither will have left anything behind. If driver executes before user , and user raises an exception, the driver will still quit, and the user was never made. And if driver was the one to raise the exception, then the driver would never have been started and the user would never have been made.

# Running multipleassertstatements safely¶

Sometimes you may want to run multiple asserts after doing all that setup, which makes sense as, in more complex systems, a single action can kick off multiple behaviors. pytest has a convenient way of handling this and it combines a bunch of what we’ve gone over so far. All that’s needed is stepping up to a larger scope, then having the act step defined as an autouse fixture, and finally, making sure all the fixtures are targeting that higher level scope. Let’s pull an example from above , and tweak it a bit. Let’s say that in addition to checking for a welcome message in the header, we also want to check for a sign out button, and a link to the user’s profile. Let’s take a look at how we can structure that so we can run multiple asserts without having to repeat all those steps again. Note For this example, certain fixtures (i.e. base_url and admin_credentials ) are implied to exist elsewhere. So for now, let’s assume they exist, and we’re just not looking at them.

```

# contents of tests/end_to_end/test_login.py
from
uuid
import
uuid4
from
urllib.parse
import
urljoin
from
selenium.webdriver
import
Chrome
import
pytest
from
src.utils.pages
import
LoginPage
,
LandingPage
from
src.utils
import
AdminApiClient
from
src.utils.data_types
import
User
@pytest
.
fixture
(
scope
=
"class"
)
def
admin_client
(
base_url
,
admin_credentials
):
return
AdminApiClient
(
base_url
,
**
admin_credentials
)
@pytest
.
fixture
(
scope
=
"class"
)
def
user
(
admin_client
):
_user
=
User
(
name
=
"Susan"
,
username
=
f
"testuser-
{
uuid4
()
}
"
,
password
=
"P4$$word"
)
admin_client
.
create_user
(
_user
)
yield
_user
admin_client
.
delete_user
(
_user
)
@pytest
.
fixture
(
scope
=
"class"
)
def
driver
():
_driver
=
Chrome
()
yield
_driver
_driver
.
quit
()
@pytest
.
fixture
(
scope
=
"class"
)
def
landing_page
(
driver
,
login
):
return
LandingPage
(
driver
)
class
TestLandingPageSuccess
:
@pytest
.
fixture
(
scope
=
"class"
,
autouse
=
True
)
def
login
(
self
,
driver
,
base_url
,
user
):
driver
.
get
(
urljoin
(
base_url
,
"/login"
))
page
=
LoginPage
(
driver
)
page
.
login
(
user
)
def
test_name_in_header
(
self
,
landing_page
,
user
):
assert
landing_page
.
header
==
f
"Welcome,
{
user
.
name
}
!"
def
test_sign_out_button
(
self
,
landing_page
):
assert
landing_page
.
sign_out_button
.
is_displayed
()
def
test_profile_link
(
self
,
landing_page
,
user
):
profile_href
=
urljoin
(
base_url
,
f
"/profile?id=
{
user
.
profile_id
}
"
)
assert
landing_page
.
profile_link
.
get_attribute
(
"href"
)
==
profile_href

```

Notice that the methods are only referencing self in the signature as a formality. No state is tied to the actual test class as it might be in the unittest.TestCase framework. Everything is managed by the pytest fixture system. Each method only has to request the fixtures that it actually needs without worrying about order. This is because the act fixture is an autouse fixture, and it made sure all the other fixtures executed before it. There’s no more changes of state that need to take place, so the tests are free to make as many non-state-changing queries as they want without risking stepping on the toes of the other tests. The login fixture is defined inside the class as well, because not every one of the other tests in the module will be expecting a successful login, and the act may need to be handled a little differently for another test class. For example, if we wanted to write another test scenario around submitting bad credentials, we could handle it by adding something like this to the test file:

```

class
TestLandingPageBadCredentials
:
@pytest
.
fixture
(
scope
=
"class"
)
def
faux_user
(
self
,
user
):
_user
=
deepcopy
(
user
)
_user
.
password
=
"badpass"
return
_user
def
test_raises_bad_credentials_exception
(
self
,
login_page
,
faux_user
):
with
pytest
.
raises
(
BadCredentialsException
):
login_page
.
login
(
faux_user
)

```

# Fixtures can introspect the requesting test context¶

Fixture functions can accept the request object to introspect the “requesting” test function, class or module context. Further extending the previous smtp_connection fixture example, let’s read an optional server URL from the test module which uses our fixture:

```

# content of conftest.py
import
smtplib
import
pytest
@pytest
.
fixture
(
scope
=
"module"
)
def
smtp_connection
(
request
):
server
=
getattr
(
request
.
module
,
"smtpserver"
,
"smtp.gmail.com"
)
smtp_connection
=
smtplib
.
SMTP
(
server
,
587
,
timeout
=
5
)
yield
smtp_connection
print
(
f
"finalizing
{
smtp_connection
}
(
{
server
}
)"
)
smtp_connection
.
close
()

```

We use the request.module attribute to optionally obtain an smtpserver attribute from the test module. If we just execute again, nothing much has changed:

```

$ pytest -s -q --tb=no test_module.py
FFfinalizing <smtplib.SMTP object at 0xdeadbeef0002> (smtp.gmail.com)
========================= short test summary info ==========================
FAILED
test_module.py::
test_ehlo
- assert 0
FAILED
test_module.py::
test_noop
- assert 0
2 failed
in 0.12s

```

Let’s quickly create another test module that actually sets the server URL in its module namespace:

```

# content of test_anothersmtp.py
smtpserver
=
"mail.python.org"
# will be read by smtp fixture
def
test_showhelo
(
smtp_connection
):
assert
0
,
smtp_connection
.
helo
()

```

Running it:

```

$ pytest -qq --tb=short test_anothersmtp.py
F
[100%]
================================= FAILURES =================================
______________________________ test_showhelo _______________________________
test_anothersmtp.py
:6: in test_showhelo
    assert 0, smtp_connection.helo()
E   AssertionError: (250, b'mail.python.org')
E   assert 0
------------------------- Captured stdout teardown -------------------------
finalizing <smtplib.SMTP object at 0xdeadbeef0003> (mail.python.org)
========================= short test summary info ==========================
FAILED
test_anothersmtp.py::
test_showhelo
- AssertionError: (250, b'mail....

```

voila! The smtp_connection fixture function picked up our mail server name from the module namespace.

# Using markers to pass data to fixtures¶

Using the request object, a fixture can also access markers which are applied to a test function. This can be useful to pass data into a fixture from a test:

```

import
pytest
@pytest
.
fixture
def
fixt
(
request
):
marker
=
request
.
node
.
get_closest_marker
(
"fixt_data"
)
if
marker
is
None
:
# Handle missing marker in some way...
data
=
None
else
:
data
=
marker
.
args
[
0
]
# Do something with the data
return
data
@pytest
.
mark
.
fixt_data
(
42
)
def
test_fixt
(
fixt
):
assert
fixt
==
42

```

# Factories as fixtures¶

The “factory as fixture” pattern can help in situations where the result of a fixture is needed multiple times in a single test. Instead of returning data directly, the fixture instead returns a function which generates the data. This function can then be called multiple times in the test. Factories can have parameters as needed:

```

@pytest
.
fixture
def
make_customer_record
():
def
_make_customer_record
(
name
):
return
{
"name"
:
name
,
"orders"
:
[]}
return
_make_customer_record
def
test_customer_records
(
make_customer_record
):
customer_1
=
make_customer_record
(
"Lisa"
)
customer_2
=
make_customer_record
(
"Mike"
)
customer_3
=
make_customer_record
(
"Meredith"
)

```

If the data created by the factory requires managing, the fixture can take care of that:

```

@pytest
.
fixture
def
make_customer_record
():
created_records
=
[]
def
_make_customer_record
(
name
):
record
=
models
.
Customer
(
name
=
name
,
orders
=
[])
created_records
.
append
(
record
)
return
record
yield
_make_customer_record
for
record
in
created_records
:
record
.
destroy
()
def
test_customer_records
(
make_customer_record
):
customer_1
=
make_customer_record
(
"Lisa"
)
customer_2
=
make_customer_record
(
"Mike"
)
customer_3
=
make_customer_record
(
"Meredith"
)

```

# Parametrizing fixtures¶

Fixture functions can be parametrized in which case they will be called multiple times, each time executing the set of dependent tests, i.e. the tests that depend on this fixture. Test functions usually do not need to be aware of their re-running. Fixture parametrization helps to write exhaustive functional tests for components which themselves can be configured in multiple ways. Extending the previous example, we can flag the fixture to create two smtp_connection fixture instances which will cause all tests using the fixture to run twice. The fixture function gets access to each parameter through the special request object:

```

# content of conftest.py
import
smtplib
import
pytest
@pytest
.
fixture
(
scope
=
"module"
,
params
=
[
"smtp.gmail.com"
,
"mail.python.org"
])
def
smtp_connection
(
request
):
smtp_connection
=
smtplib
.
SMTP
(
request
.
param
,
587
,
timeout
=
5
)
yield
smtp_connection
print
(
f
"finalizing
{
smtp_connection
}
"
)
smtp_connection
.
close
()

```

The main change is the declaration of params with @pytest.fixture , a list of values for each of which the fixture function will execute and can access a value via request.param . No test function code needs to change. So let’s just do another run:

```

$ pytest -q test_module.py
FFFF
[100%]
================================= FAILURES =================================
________________________ test_ehlo[smtp.gmail.com] _________________________
smtp_connection = <smtplib.SMTP object at 0xdeadbeef0004>

    def test_ehlo(smtp_connection):
        response, msg = smtp_connection.ehlo()
        assert response == 250
        assert b"smtp.gmail.com" in msg
>       assert 0  # for demo purposes
E       assert 0
test_module.py
:7: AssertionError
________________________ test_noop[smtp.gmail.com] _________________________
smtp_connection = <smtplib.SMTP object at 0xdeadbeef0004>

    def test_noop(smtp_connection):
        response, msg = smtp_connection.noop()
        assert response == 250
>       assert 0  # for demo purposes
E       assert 0
test_module.py
:13: AssertionError
________________________ test_ehlo[mail.python.org] ________________________
smtp_connection = <smtplib.SMTP object at 0xdeadbeef0005>

    def test_ehlo(smtp_connection):
        response, msg = smtp_connection.ehlo()
        assert response == 250
>       assert b"smtp.gmail.com" in msg
E       AssertionError: assert b'smtp.gmail.com' in b'mail.python.org\nPIPELINING\nSIZE 51200000\nETRN\nSTARTTLS\nAUTH DIGEST-MD5 NTLM CRAM-MD5\nENHANCEDSTATUSCODES\n8BITMIME\nDSN\nSMTPUTF8\nCHUNKING'
test_module.py
:6: AssertionError
-------------------------- Captured stdout setup ---------------------------
finalizing <smtplib.SMTP object at 0xdeadbeef0004>
________________________ test_noop[mail.python.org] ________________________
smtp_connection = <smtplib.SMTP object at 0xdeadbeef0005>

    def test_noop(smtp_connection):
        response, msg = smtp_connection.noop()
        assert response == 250
>       assert 0  # for demo purposes
E       assert 0
test_module.py
:13: AssertionError
------------------------- Captured stdout teardown -------------------------
finalizing <smtplib.SMTP object at 0xdeadbeef0005>
========================= short test summary info ==========================
FAILED
test_module.py::
test_ehlo[smtp.gmail.com]
- assert 0
FAILED
test_module.py::
test_noop[smtp.gmail.com]
- assert 0
FAILED
test_module.py::
test_ehlo[mail.python.org]
- AssertionError: asser...
FAILED
test_module.py::
test_noop[mail.python.org]
- assert 0
4 failed
in 0.12s

```

We see that our two test functions each ran twice, against the different smtp_connection instances. Note also, that with the mail.python.org connection the second test fails in test_ehlo because a different server string is expected than what arrived. pytest will build a string that is the test ID for each fixture value in a parametrized fixture, e.g. test_ehlo[smtp.gmail.com] and test_ehlo[mail.python.org] in the above examples. These IDs can be used with -k to select specific cases to run, and they will also identify the specific case when one is failing. Running pytest with --collect-only will show the generated IDs. Numbers, strings, booleans and None will have their usual string representation used in the test ID. For other objects, pytest will make a string based on the argument name. It is possible to customise the string used in a test ID for a certain fixture value by using the ids keyword argument:

```

# content of test_ids.py
import
pytest
@pytest
.
fixture
(
params
=
[
0
,
1
],
ids
=
[
"spam"
,
"ham"
])
def
a
(
request
):
return
request
.
param
def
test_a
(
a
):
pass
def
idfn
(
fixture_value
):
if
fixture_value
==
0
:
return
"eggs"
else
:
return
None
@pytest
.
fixture
(
params
=
[
0
,
1
],
ids
=
idfn
)
def
b
(
request
):
return
request
.
param
def
test_b
(
b
):
pass

```

The above shows how ids can be either a list of strings to use or a function which will be called with the fixture value and then has to return a string to use. In the latter case if the function returns None then pytest’s auto-generated ID will be used. Running the above tests results in the following test IDs being used:

```

$ pytest --collect-only
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 12 items

<Dir fixtures.rst-227>
  <Module test_anothersmtp.py>
    <Function test_showhelo[smtp.gmail.com]>
    <Function test_showhelo[mail.python.org]>
  <Module test_emaillib.py>
    <Function test_email_received>
  <Module test_finalizers.py>
    <Function test_bar>
  <Module test_ids.py>
    <Function test_a[spam]>
    <Function test_a[ham]>
    <Function test_b[eggs]>
    <Function test_b[1]>
  <Module test_module.py>
    <Function test_ehlo[smtp.gmail.com]>
    <Function test_noop[smtp.gmail.com]>
    <Function test_ehlo[mail.python.org]>
    <Function test_noop[mail.python.org]>

======================= 12 tests collected in 0.12s ========================

```

# Using marks with parametrized fixtures¶

pytest.param() can be used to apply marks in values sets of parametrized fixtures in the same way that they can be used with @pytest.mark.parametrize . Example:

```

# content of test_fixture_marks.py
import
pytest
@pytest
.
fixture
(
params
=
[
0
,
1
,
pytest
.
param
(
2
,
marks
=
pytest
.
mark
.
skip
)])
def
data_set
(
request
):
return
request
.
param
def
test_data
(
data_set
):
pass

```

Running this test will skip the invocation of data_set with value 2 :

```

$ pytest test_fixture_marks.py -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 3 items

test_fixture_marks.py::test_data[0]
PASSED
[ 33%]
test_fixture_marks.py::test_data[1]
PASSED
[ 66%]
test_fixture_marks.py::test_data[2]
SKIPPED
(unconditional skip)
[100%]
=======================
2 passed
,
1 skipped
in 0.12s =======================

```

# Modularity: using fixtures from a fixture function¶

In addition to using fixtures in test functions, fixture functions can use other fixtures themselves. This contributes to a modular design of your fixtures and allows reuse of framework-specific fixtures across many projects. As a simple example, we can extend the previous example and instantiate an object app where we stick the already defined smtp_connection resource into it:

```

# content of test_appsetup.py
import
pytest
class
App
:
def
__init__
(
self
,
smtp_connection
):
self
.
smtp_connection
=
smtp_connection
@pytest
.
fixture
(
scope
=
"module"
)
def
app
(
smtp_connection
):
return
App
(
smtp_connection
)
def
test_smtp_connection_exists
(
app
):
assert
app
.
smtp_connection

```

Here we declare an app fixture which receives the previously defined smtp_connection fixture and instantiates an App object with it. Let’s run it:

```

$ pytest -v test_appsetup.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 2 items

test_appsetup.py::test_smtp_connection_exists[smtp.gmail.com]
PASSED
[ 50%]
test_appsetup.py::test_smtp_connection_exists[mail.python.org]
PASSED
[100%]
============================
2 passed
in 0.12s =============================

```

Due to the parametrization of smtp_connection , the test will run twice with two different App instances and respective smtp servers. There is no need for the app fixture to be aware of the smtp_connection parametrization because pytest will fully analyse the fixture dependency graph. Note that the app fixture has a scope of module and uses a module-scoped smtp_connection fixture. The example would still work if smtp_connection was cached on a session scope: it is fine for fixtures to use “broader” scoped fixtures but not the other way round: A session-scoped fixture could not use a module-scoped one in a meaningful way.

# Automatic grouping of tests by fixture instances¶

pytest minimizes the number of active fixtures during test runs. If you have a parametrized fixture, then all the tests using it will first execute with one instance and then finalizers are called before the next fixture instance is created. Among other things, this eases testing of applications which create and use global state. The following example uses two parametrized fixtures, one of which is scoped on a per-module basis, and all the functions perform print calls to show the setup/teardown flow:

```

# content of test_module.py
import
pytest
@pytest
.
fixture
(
scope
=
"module"
,
params
=
[
"mod1"
,
"mod2"
])
def
modarg
(
request
):
param
=
request
.
param
print
(
"  SETUP modarg"
,
param
)
yield
param
print
(
"  TEARDOWN modarg"
,
param
)
@pytest
.
fixture
(
scope
=
"function"
,
params
=
[
1
,
2
])
def
otherarg
(
request
):
param
=
request
.
param
print
(
"  SETUP otherarg"
,
param
)
yield
param
print
(
"  TEARDOWN otherarg"
,
param
)
def
test_0
(
otherarg
):
print
(
"  RUN test0 with otherarg"
,
otherarg
)
def
test_1
(
modarg
):
print
(
"  RUN test1 with modarg"
,
modarg
)
def
test_2
(
otherarg
,
modarg
):
print
(
f
"  RUN test2 with otherarg
{
otherarg
}
and modarg
{
modarg
}
"
)

```

Let’s run the tests in verbose mode and with looking at the print-output:

```

$ pytest -v -s test_module.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collecting ...
collected 8 items

test_module.py::test_0[1]   SETUP otherarg 1
  RUN test0 with otherarg 1
PASSED  TEARDOWN otherarg 1

test_module.py::test_0[2]   SETUP otherarg 2
  RUN test0 with otherarg 2
PASSED  TEARDOWN otherarg 2

test_module.py::test_1[mod1]   SETUP modarg mod1
  RUN test1 with modarg mod1
PASSED
test_module.py::test_2[mod1-1]   SETUP otherarg 1
  RUN test2 with otherarg 1 and modarg mod1
PASSED  TEARDOWN otherarg 1

test_module.py::test_2[mod1-2]   SETUP otherarg 2
  RUN test2 with otherarg 2 and modarg mod1
PASSED  TEARDOWN otherarg 2

test_module.py::test_1[mod2]   TEARDOWN modarg mod1
  SETUP modarg mod2
  RUN test1 with modarg mod2
PASSED
test_module.py::test_2[mod2-1]   SETUP otherarg 1
  RUN test2 with otherarg 1 and modarg mod2
PASSED  TEARDOWN otherarg 1

test_module.py::test_2[mod2-2]   SETUP otherarg 2
  RUN test2 with otherarg 2 and modarg mod2
PASSED  TEARDOWN otherarg 2
  TEARDOWN modarg mod2
============================
8 passed
in 0.12s =============================

```

You can see that the parametrized module-scoped modarg resource caused an ordering of test execution that lead to the fewest possible “active” resources. The finalizer for the mod1 parametrized resource was executed before the mod2 resource was setup. In particular notice that test_0 is completely independent and finishes first. Then test_1 is executed with mod1 , then test_2 with mod1 , then test_1 with mod2 and finally test_2 with mod2 . The otherarg parametrized resource (having function scope) was set up before and teared down after every test that used it.

# Use fixtures in classes and modules withusefixtures¶

Sometimes test functions do not directly need access to a fixture object. For example, tests may require to operate with an empty directory as the current working directory but otherwise do not care for the concrete directory. Here is how you can use the standard tempfile and pytest fixtures to achieve it. We separate the creation of the fixture into a conftest.py file:

```

# content of conftest.py
import
os
import
tempfile
import
pytest
@pytest
.
fixture
def
cleandir
():
with
tempfile
.
TemporaryDirectory
()
as
newpath
:
old_cwd
=
os
.
getcwd
()
os
.
chdir
(
newpath
)
yield
os
.
chdir
(
old_cwd
)

```

and declare its use in a test module via a usefixtures marker:

```

# content of test_setenv.py
import
os
import
pytest
@pytest
.
mark
.
usefixtures
(
"cleandir"
)
class
TestDirectoryInit
:
def
test_cwd_starts_empty
(
self
):
assert
os
.
listdir
(
os
.
getcwd
())
==
[]
with
open
(
"myfile"
,
"w"
,
encoding
=
"utf-8"
)
as
f
:
f
.
write
(
"hello"
)
def
test_cwd_again_starts_empty
(
self
):
assert
os
.
listdir
(
os
.
getcwd
())
==
[]

```

Due to the usefixtures marker, the cleandir fixture will be required for the execution of each test method, just as if you specified a “cleandir” function argument to each of them. Let’s run it to verify our fixture is activated and the tests pass:

```

$ pytest -q
..
[100%]
2 passed
in 0.12s

```

You can specify multiple fixtures like this:

```

@pytest
.
mark
.
usefixtures
(
"cleandir"
,
"anotherfixture"
)
def
test
():
...

```

and you may specify fixture usage at the test module level using pytestmark :

```

pytestmark
=
pytest
.
mark
.
usefixtures
(
"cleandir"
)

```

It is also possible to put fixtures required by all tests in your project into an ini-file:

```

# content of pytest.ini
[pytest]
usefixtures
=
cleandir

```

Warning Note this mark has no effect in fixture functions . For example, this will not work as expected :

```

@pytest
.
mark
.
usefixtures
(
"my_other_fixture"
)
@pytest
.
fixture
def
my_fixture_that_sadly_wont_use_my_other_fixture
():
...

```

This generates a deprecation warning, and will become an error in Pytest 8.

# Overriding fixtures on various levels¶

In relatively large test suite, you most likely need to override a global or root fixture with a locally defined one, keeping the test code readable and maintainable.

# Override a fixture on a folder (conftest) level¶

Given the tests file structure is:

```

tests
/
conftest
.
py
# content of tests/conftest.py
import
pytest
@pytest
.
fixture
def
username
():
return
'username'
test_something
.
py
# content of tests/test_something.py
def
test_username
(
username
):
assert
username
==
'username'
subfolder
/
conftest
.
py
# content of tests/subfolder/conftest.py
import
pytest
@pytest
.
fixture
def
username
(
username
):
return
'overridden-'
+
username
test_something_else
.
py
# content of tests/subfolder/test_something_else.py
def
test_username
(
username
):
assert
username
==
'overridden-username'

```

As you can see, a fixture with the same name can be overridden for certain test folder level. Note that the base or super fixture can be accessed from the overriding fixture easily - used in the example above.

# Override a fixture on a test module level¶

Given the tests file structure is:

```

tests
/
conftest
.
py
# content of tests/conftest.py
import
pytest
@pytest
.
fixture
def
username
():
return
'username'
test_something
.
py
# content of tests/test_something.py
import
pytest
@pytest
.
fixture
def
username
(
username
):
return
'overridden-'
+
username
def
test_username
(
username
):
assert
username
==
'overridden-username'
test_something_else
.
py
# content of tests/test_something_else.py
import
pytest
@pytest
.
fixture
def
username
(
username
):
return
'overridden-else-'
+
username
def
test_username
(
username
):
assert
username
==
'overridden-else-username'

```

In the example above, a fixture with the same name can be overridden for certain test module.

# Override a fixture with direct test parametrization¶

Given the tests file structure is:

```

tests
/
conftest
.
py
# content of tests/conftest.py
import
pytest
@pytest
.
fixture
def
username
():
return
'username'
@pytest
.
fixture
def
other_username
(
username
):
return
'other-'
+
username
test_something
.
py
# content of tests/test_something.py
import
pytest
@pytest
.
mark
.
parametrize
(
'username'
,
[
'directly-overridden-username'
])
def
test_username
(
username
):
assert
username
==
'directly-overridden-username'
@pytest
.
mark
.
parametrize
(
'username'
,
[
'directly-overridden-username-other'
])
def
test_username_other
(
other_username
):
assert
other_username
==
'other-directly-overridden-username-other'

```

In the example above, a fixture value is overridden by the test parameter value. Note that the value of the fixture can be overridden this way even if the test doesn’t use it directly (doesn’t mention it in the function prototype).

# Override a parametrized fixture with non-parametrized one and vice versa¶

Given the tests file structure is:

```

tests
/
conftest
.
py
# content of tests/conftest.py
import
pytest
@pytest
.
fixture
(
params
=
[
'one'
,
'two'
,
'three'
])
def
parametrized_username
(
request
):
return
request
.
param
@pytest
.
fixture
def
non_parametrized_username
(
request
):
return
'username'
test_something
.
py
# content of tests/test_something.py
import
pytest
@pytest
.
fixture
def
parametrized_username
():
return
'overridden-username'
@pytest
.
fixture
(
params
=
[
'one'
,
'two'
,
'three'
])
def
non_parametrized_username
(
request
):
return
request
.
param
def
test_username
(
parametrized_username
):
assert
parametrized_username
==
'overridden-username'
def
test_parametrized_username
(
non_parametrized_username
):
assert
non_parametrized_username
in
[
'one'
,
'two'
,
'three'
]
test_something_else
.
py
# content of tests/test_something_else.py
def
test_username
(
parametrized_username
):
assert
parametrized_username
in
[
'one'
,
'two'
,
'three'
]
def
test_username
(
non_parametrized_username
):
assert
non_parametrized_username
==
'username'

```

In the example above, a parametrized fixture is overridden with a non-parametrized version, and a non-parametrized fixture is overridden with a parametrized version for certain test module. The same applies for the test folder level obviously.

# Using fixtures from other projects¶

Usually projects that provide pytest support will use entry points , so just installing those projects into an environment will make those fixtures available for use. In case you want to use fixtures from a project that does not use entry points, you can define pytest_plugins in your top conftest.py file to register that module as a plugin. Suppose you have some fixtures in mylibrary.fixtures and you want to reuse them into your app/tests directory. All you need to do is to define pytest_plugins in app/tests/conftest.py pointing to that module.

```

pytest_plugins
=
"mylibrary.fixtures"

```


---


# How to monkeypatch/mock modules and environments - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/monkeypatch.html


# How to monkeypatch/mock modules and environments¶

Sometimes tests need to invoke functionality which depends on global settings or which invokes code which cannot be easily tested such as network access. The monkeypatch fixture helps you to safely set/delete an attribute, dictionary item or environment variable, or to modify sys.path for importing. The monkeypatch fixture provides these helper methods for safely patching and mocking functionality in tests: monkeypatch.setattr(obj, name, value, raising=True) monkeypatch.delattr(obj, name, raising=True) monkeypatch.setitem(mapping, name, value) monkeypatch.delitem(obj, name, raising=True) monkeypatch.setenv(name, value, prepend=None) monkeypatch.delenv(name, raising=True) monkeypatch.syspath_prepend(path) monkeypatch.chdir(path) monkeypatch.context() All modifications will be undone after the requesting test function or fixture has finished. The raising parameter determines if a KeyError or AttributeError will be raised if the target of the set/deletion operation does not exist. Consider the following scenarios: 1. Modifying the behavior of a function or the property of a class for a test e.g. there is an API call or database connection you will not make for a test but you know what the expected output should be. Use monkeypatch.setattr to patch the function or property with your desired testing behavior. This can include your own functions. Use monkeypatch.delattr to remove the function or property for the test. 2. Modifying the values of dictionaries e.g. you have a global configuration that you want to modify for certain test cases. Use monkeypatch.setitem to patch the dictionary for the test. monkeypatch.delitem can be used to remove items. 3. Modifying environment variables for a test e.g. to test program behavior if an environment variable is missing, or to set multiple values to a known variable. monkeypatch.setenv and monkeypatch.delenv can be used for these patches. 4. Use monkeypatch.setenv("PATH", value, prepend=os.pathsep) to modify $PATH , and monkeypatch.chdir to change the context of the current working directory during a test. 5. Use monkeypatch.syspath_prepend to modify sys.path which will also call pkg_resources.fixup_namespace_packages and importlib.invalidate_caches() . 6. Use monkeypatch.context to apply patches only in a specific scope, which can help control teardown of complex fixtures or patches to the stdlib. See the monkeypatch blog post for some introduction material and a discussion of its motivation.

# Monkeypatching functions¶

Consider a scenario where you are working with user directories. In the context of testing, you do not want your test to depend on the running user. monkeypatch can be used to patch functions dependent on the user to always return a specific value. In this example, monkeypatch.setattr is used to patch Path.home so that the known testing path Path("/abc") is always used when the test is run. This removes any dependency on the running user for testing purposes. monkeypatch.setattr must be called before the function which will use the patched function is called. After the test function finishes the Path.home modification will be undone.

```

# contents of test_module.py with source code and the test
from
pathlib
import
Path
def
getssh
():
"""Simple function to return expanded homedir ssh path."""
return
Path
.
home
()
/
".ssh"
def
test_getssh
(
monkeypatch
):
# mocked return function to replace Path.home
# always return '/abc'
def
mockreturn
():
return
Path
(
"/abc"
)
# Application of the monkeypatch to replace Path.home
# with the behavior of mockreturn defined above.
monkeypatch
.
setattr
(
Path
,
"home"
,
mockreturn
)
# Calling getssh() will use mockreturn in place of Path.home
# for this test with the monkeypatch.
x
=
getssh
()
assert
x
==
Path
(
"/abc/.ssh"
)

```

# Monkeypatching returned objects: building mock classes¶

monkeypatch.setattr can be used in conjunction with classes to mock returned objects from functions instead of values. Imagine a simple function to take an API url and return the json response.

```

# contents of app.py, a simple API retrieval example
import
requests
def
get_json
(
url
):
"""Takes a URL, and returns the JSON."""
r
=
requests
.
get
(
url
)
return
r
.
json
()

```

We need to mock r , the returned response object for testing purposes. The mock of r needs a .json() method which returns a dictionary. This can be done in our test file by defining a class to represent r .

```

# contents of test_app.py, a simple test for our API retrieval
# import requests for the purposes of monkeypatching
import
requests
# our app.py that includes the get_json() function
# this is the previous code block example
import
app
# custom class to be the mock return value
# will override the requests.Response returned from requests.get
class
MockResponse
:
# mock json() method always returns a specific testing dictionary
@staticmethod
def
json
():
return
{
"mock_key"
:
"mock_response"
}
def
test_get_json
(
monkeypatch
):
# Any arguments may be passed and mock_get() will always return our
# mocked object, which only has the .json() method.
def
mock_get
(
*
args
,
**
kwargs
):
return
MockResponse
()
# apply the monkeypatch for requests.get to mock_get
monkeypatch
.
setattr
(
requests
,
"get"
,
mock_get
)
# app.get_json, which contains requests.get, uses the monkeypatch
result
=
app
.
get_json
(
"https://fakeurl"
)
assert
result
[
"mock_key"
]
==
"mock_response"

```

monkeypatch applies the mock for requests.get with our mock_get function. The mock_get function returns an instance of the MockResponse class, which has a json() method defined to return a known testing dictionary and does not require any outside API connection. You can build the MockResponse class with the appropriate degree of complexity for the scenario you are testing. For instance, it could include an ok property that always returns True , or return different values from the json() mocked method based on input strings. This mock can be shared across tests using a fixture :

```

# contents of test_app.py, a simple test for our API retrieval
import
pytest
import
requests
# app.py that includes the get_json() function
import
app
# custom class to be the mock return value of requests.get()
class
MockResponse
:
@staticmethod
def
json
():
return
{
"mock_key"
:
"mock_response"
}
# monkeypatched requests.get moved to a fixture
@pytest
.
fixture
def
mock_response
(
monkeypatch
):
"""Requests.get() mocked to return {'mock_key':'mock_response'}."""
def
mock_get
(
*
args
,
**
kwargs
):
return
MockResponse
()
monkeypatch
.
setattr
(
requests
,
"get"
,
mock_get
)
# notice our test uses the custom fixture instead of monkeypatch directly
def
test_get_json
(
mock_response
):
result
=
app
.
get_json
(
"https://fakeurl"
)
assert
result
[
"mock_key"
]
==
"mock_response"

```

Furthermore, if the mock was designed to be applied to all tests, the fixture could be moved to a conftest.py file and use the with autouse=True option.

# Global patch example: preventing “requests” from remote operations¶

If you want to prevent the “requests” library from performing http requests in all your tests, you can do:

```

# contents of conftest.py
import
pytest
@pytest
.
fixture
(
autouse
=
True
)
def
no_requests
(
monkeypatch
):
"""Remove requests.sessions.Session.request for all tests."""
monkeypatch
.
delattr
(
"requests.sessions.Session.request"
)

```

This autouse fixture will be executed for each test function and it will delete the method request.session.Session.request so that any attempts within tests to create http requests will fail. Note Be advised that it is not recommended to patch builtin functions such as open , compile , etc., because it might break pytest’s internals. If that’s unavoidable, passing --tb=native , --assert=plain and --capture=no might help although there’s no guarantee. Note Mind that patching stdlib functions and some third-party libraries used by pytest might break pytest itself, therefore in those cases it is recommended to use MonkeyPatch.context() to limit the patching to the block you want tested:

```

import
functools
def
test_partial
(
monkeypatch
):
with
monkeypatch
.
context
()
as
m
:
m
.
setattr
(
functools
,
"partial"
,
3
)
assert
functools
.
partial
==
3

```

See #3290 for details.

# Monkeypatching environment variables¶

If you are working with environment variables you often need to safely change the values or delete them from the system for testing purposes. monkeypatch provides a mechanism to do this using the setenv and delenv method. Our example code to test:

```

# contents of our original code file e.g. code.py
import
os
def
get_os_user_lower
():
"""Simple retrieval function.
Returns lowercase USER or raises OSError."""
username
=
os
.
getenv
(
"USER"
)
if
username
is
None
:
raise
OSError
(
"USER environment is not set."
)
return
username
.
lower
()

```

There are two potential paths. First, the USER environment variable is set to a value. Second, the USER environment variable does not exist. Using monkeypatch both paths can be safely tested without impacting the running environment:

```

# contents of our test file e.g. test_code.py
import
pytest
def
test_upper_to_lower
(
monkeypatch
):
"""Set the USER env var to assert the behavior."""
monkeypatch
.
setenv
(
"USER"
,
"TestingUser"
)
assert
get_os_user_lower
()
==
"testinguser"
def
test_raise_exception
(
monkeypatch
):
"""Remove the USER env var and assert OSError is raised."""
monkeypatch
.
delenv
(
"USER"
,
raising
=
False
)
with
pytest
.
raises
(
OSError
):
_
=
get_os_user_lower
()

```

This behavior can be moved into fixture structures and shared across tests:

```

# contents of our test file e.g. test_code.py
import
pytest
@pytest
.
fixture
def
mock_env_user
(
monkeypatch
):
monkeypatch
.
setenv
(
"USER"
,
"TestingUser"
)
@pytest
.
fixture
def
mock_env_missing
(
monkeypatch
):
monkeypatch
.
delenv
(
"USER"
,
raising
=
False
)
# notice the tests reference the fixtures for mocks
def
test_upper_to_lower
(
mock_env_user
):
assert
get_os_user_lower
()
==
"testinguser"
def
test_raise_exception
(
mock_env_missing
):
with
pytest
.
raises
(
OSError
):
_
=
get_os_user_lower
()

```

# Monkeypatching dictionaries¶

monkeypatch.setitem can be used to safely set the values of dictionaries to specific values during tests. Take this simplified connection string example:

```

# contents of app.py to generate a simple connection string
DEFAULT_CONFIG
=
{
"user"
:
"user1"
,
"database"
:
"db1"
}
def
create_connection_string
(
config
=
None
):
"""Creates a connection string from input or defaults."""
config
=
config
or
DEFAULT_CONFIG
return
f
"User Id=
{
config
[
'user'
]
}
; Location=
{
config
[
'database'
]
}
;"

```

For testing purposes we can patch the DEFAULT_CONFIG dictionary to specific values.

```

# contents of test_app.py
# app.py with the connection string function (prior code block)
import
app
def
test_connection
(
monkeypatch
):
# Patch the values of DEFAULT_CONFIG to specific
# testing values only for this test.
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
"test_user"
)
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"database"
,
"test_db"
)
# expected result based on the mocks
expected
=
"User Id=test_user; Location=test_db;"
# the test uses the monkeypatched dictionary settings
result
=
app
.
create_connection_string
()
assert
result
==
expected

```

You can use the monkeypatch.delitem to remove values.

```

# contents of test_app.py
import
pytest
# app.py with the connection string function
import
app
def
test_missing_user
(
monkeypatch
):
# patch the DEFAULT_CONFIG t be missing the 'user' key
monkeypatch
.
delitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
raising
=
False
)
# Key error expected because a config is not passed, and the
# default is now missing the 'user' entry.
with
pytest
.
raises
(
KeyError
):
_
=
app
.
create_connection_string
()

```

The modularity of fixtures gives you the flexibility to define separate fixtures for each potential mock and reference them in the needed tests.

```

# contents of test_app.py
import
pytest
# app.py with the connection string function
import
app
# all of the mocks are moved into separated fixtures
@pytest
.
fixture
def
mock_test_user
(
monkeypatch
):
"""Set the DEFAULT_CONFIG user to test_user."""
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
"test_user"
)
@pytest
.
fixture
def
mock_test_database
(
monkeypatch
):
"""Set the DEFAULT_CONFIG database to test_db."""
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"database"
,
"test_db"
)
@pytest
.
fixture
def
mock_missing_default_user
(
monkeypatch
):
"""Remove the user key from DEFAULT_CONFIG"""
monkeypatch
.
delitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
raising
=
False
)
# tests reference only the fixture mocks that are needed
def
test_connection
(
mock_test_user
,
mock_test_database
):
expected
=
"User Id=test_user; Location=test_db;"
result
=
app
.
create_connection_string
()
assert
result
==
expected
def
test_missing_user
(
mock_missing_default_user
):
with
pytest
.
raises
(
KeyError
):
_
=
app
.
create_connection_string
()

```

# API Reference¶


---


# Reference guides - pytest documentation

URL: https://docs.pytest.org/en/stable/reference/index.html


# Reference guides¶


---


# Sponsor - pytest documentation

URL: https://docs.pytest.org/en/stable/sponsor.html


# Sponsor¶

pytest is maintained by a team of volunteers from all around the world in their free time. While we work on pytest because we love the project and use it daily at our daily jobs, monetary compensation when possible is welcome to justify time away from friends, family and personal time. Money is also used to fund local sprints, merchandising (stickers to distribute in conferences for example) and every few years a large sprint involving all members.

# OpenCollective¶


---


# About fixtures - pytest documentation

URL: https://docs.pytest.org/en/stable/explanation/fixtures.html


# About fixtures¶

See also How to use fixtures See also Fixtures reference pytest fixtures are designed to be explicit, modular and scalable.

# What fixtures are¶

In testing, a fixture provides a defined, reliable and consistent context for the tests. This could include environment (for example a database configured with known parameters) or content (such as a dataset). Fixtures define the steps and data that constitute the arrange phase of a test (see Anatomy of a test ). In pytest, they are functions you define that serve this purpose. They can also be used to define a test’s act phase; this is a powerful technique for designing more complex tests. The services, state, or other operating environments set up by fixtures are accessed by test functions through arguments. For each fixture used by a test function there is typically a parameter (named after the fixture) in the test function’s definition. We can tell pytest that a particular function is a fixture by decorating it with @pytest.fixture . Here’s a simple example of what a fixture in pytest might look like:

```

import
pytest
class
Fruit
:
def
__init__
(
self
,
name
):
self
.
name
=
name
def
__eq__
(
self
,
other
):
return
self
.
name
==
other
.
name
@pytest
.
fixture
def
my_fruit
():
return
Fruit
(
"apple"
)
@pytest
.
fixture
def
fruit_basket
(
my_fruit
):
return
[
Fruit
(
"banana"
),
my_fruit
]
def
test_my_fruit_in_basket
(
my_fruit
,
fruit_basket
):
assert
my_fruit
in
fruit_basket

```

Tests don’t have to be limited to a single fixture, either. They can depend on as many fixtures as you want, and fixtures can use other fixtures, as well. This is where pytest’s fixture system really shines.

# Improvements over xUnit-style setup/teardown functions¶

pytest fixtures offer dramatic improvements over the classic xUnit style of setup/teardown functions: fixtures have explicit names and are activated by declaring their use from test functions, modules, classes or whole projects. fixtures are implemented in a modular manner, as each fixture name triggers a fixture function which can itself use other fixtures. fixture management scales from simple unit to complex functional testing, allowing to parametrize fixtures and tests according to configuration and component options, or to reuse fixtures across function, class, module or whole test session scopes. teardown logic can be easily, and safely managed, no matter how many fixtures are used, without the need to carefully handle errors by hand or micromanage the order that cleanup steps are added. In addition, pytest continues to support How to implement xunit-style set-up . You can mix both styles, moving incrementally from classic to new style, as you prefer. You can also start out from existing unittest.TestCase style .

# Fixture errors¶

pytest does its best to put all the fixtures for a given test in a linear order so that it can see which fixture happens first, second, third, and so on. If an earlier fixture has a problem, though, and raises an exception, pytest will stop executing fixtures for that test and mark the test as having an error. When a test is marked as having an error, it doesn’t mean the test failed, though. It just means the test couldn’t even be attempted because one of the things it depends on had a problem. This is one reason why it’s a good idea to cut out as many unnecessary dependencies as possible for a given test. That way a problem in something unrelated isn’t causing us to have an incomplete picture of what may or may not have issues. Here’s a quick example to help explain:

```

import
pytest
@pytest
.
fixture
def
order
():
return
[]
@pytest
.
fixture
def
append_first
(
order
):
order
.
append
(
1
)
@pytest
.
fixture
def
append_second
(
order
,
append_first
):
order
.
extend
([
2
])
@pytest
.
fixture
(
autouse
=
True
)
def
append_third
(
order
,
append_second
):
order
+=
[
3
]
def
test_order
(
order
):
assert
order
==
[
1
,
2
,
3
]

```

If, for whatever reason, order.append(1) had a bug and it raises an exception, we wouldn’t be able to know if order.extend([2]) or order += [3] would also have problems. After append_first throws an exception, pytest won’t run any more fixtures for test_order , and it won’t even try to run test_order itself. The only things that would’ve run would be order and append_first .

# Sharing test data¶

If you want to make test data from files available to your tests, a good way to do this is by loading these data in a fixture for use by your tests. This makes use of the automatic caching mechanisms of pytest. Another good approach is by adding the data files in the tests folder. There are also community plugins available to help to manage this aspect of testing, e.g. pytest-datadir and pytest-datafiles .

# A note about fixture cleanup¶


---


# Fixtures reference - pytest documentation

URL: https://docs.pytest.org/en/stable/reference/fixtures.html


# Fixtures reference¶

See also About fixtures See also How to use fixtures

# Built-in fixtures¶

Fixtures are defined using the @pytest.fixture decorator. Pytest has several useful built-in fixtures: Capture, as text, output to file descriptors 1 and 2 . Capture, as bytes, output to file descriptors 1 and 2 . Control logging and access log entries. Capture, as text, output to sys.stdout and sys.stderr . Capture, as bytes, output to sys.stdout and sys.stderr . Store and retrieve values across pytest runs. Provide a dict injected into the doctests namespace. Temporarily modify classes, functions, dictionaries, os.environ , and other objects. Access to configuration values, pluginmanager and plugin hooks. Add extra properties to the test. Add extra properties to the test suite. Record warnings emitted by test functions. Provide information on the executing test function. Provide a temporary test directory to aid in running, and testing, pytest plugins. Provide a pathlib.Path object to a temporary directory which is unique to each test function. Make session-scoped temporary directories and return pathlib.Path objects. Provide a py.path.local object to a temporary directory which is unique to each test function; replaced by tmp_path . Make session-scoped temporary directories and return py.path.local objects; replaced by tmp_path_factory .

# Fixture availability¶

Fixture availability is determined from the perspective of the test. A fixture is only available for tests to request if they are in the scope that fixture is defined in. If a fixture is defined inside a class, it can only be requested by tests inside that class. But if a fixture is defined inside the global scope of the module, then every test in that module, even if it’s defined inside a class, can request it. Similarly, a test can also only be affected by an autouse fixture if that test is in the same scope that autouse fixture is defined in (see Autouse fixtures are executed first within their scope ). A fixture can also request any other fixture, no matter where it’s defined, so long as the test requesting them can see all fixtures involved. For example, here’s a test file with a fixture ( outer ) that requests a fixture ( inner ) from a scope it wasn’t defined in:

```

from
__future__
import
annotations
import
pytest
@pytest
.
fixture
def
order
():
return
[]
@pytest
.
fixture
def
outer
(
order
,
inner
):
order
.
append
(
"outer"
)
class
TestOne
:
@pytest
.
fixture
def
inner
(
self
,
order
):
order
.
append
(
"one"
)
def
test_order
(
self
,
order
,
outer
):
assert
order
==
[
"one"
,
"outer"
]
class
TestTwo
:
@pytest
.
fixture
def
inner
(
self
,
order
):
order
.
append
(
"two"
)
def
test_order
(
self
,
order
,
outer
):
assert
order
==
[
"two"
,
"outer"
]

```

From the tests’ perspectives, they have no problem seeing each of the fixtures they’re dependent on: So when they run, outer will have no problem finding inner , because pytest searched from the tests’ perspectives. Note The scope a fixture is defined in has no bearing on the order it will be instantiated in: the order is mandated by the logic described here .

# conftest.py: sharing fixtures across multiple files¶

The conftest.py file serves as a means of providing fixtures for an entire directory. Fixtures defined in a conftest.py can be used by any test in that package without needing to import them (pytest will automatically discover them). You can have multiple nested directories/packages containing your tests, and each directory can have its own conftest.py with its own fixtures, adding on to the ones provided by the conftest.py files in parent directories. For example, given a test file structure like this:

```

tests
/
__init__
.
py
conftest
.
py
# content of tests/conftest.py
import
pytest
@pytest
.
fixture
def
order
():
return
[]
@pytest
.
fixture
def
top
(
order
,
innermost
):
order
.
append
(
"top"
)
test_top
.
py
# content of tests/test_top.py
import
pytest
@pytest
.
fixture
def
innermost
(
order
):
order
.
append
(
"innermost top"
)
def
test_order
(
order
,
top
):
assert
order
==
[
"innermost top"
,
"top"
]
subpackage
/
__init__
.
py
conftest
.
py
# content of tests/subpackage/conftest.py
import
pytest
@pytest
.
fixture
def
mid
(
order
):
order
.
append
(
"mid subpackage"
)
test_subpackage
.
py
# content of tests/subpackage/test_subpackage.py
import
pytest
@pytest
.
fixture
def
innermost
(
order
,
mid
):
order
.
append
(
"innermost subpackage"
)
def
test_order
(
order
,
top
):
assert
order
==
[
"mid subpackage"
,
"innermost subpackage"
,
"top"
]

```

The boundaries of the scopes can be visualized like this: The directories become their own sort of scope where fixtures that are defined in a conftest.py file in that directory become available for that whole scope. Tests are allowed to search upward (stepping outside a circle) for fixtures, but can never go down (stepping inside a circle) to continue their search. So tests/subpackage/test_subpackage.py::test_order would be able to find the innermost fixture defined in tests/subpackage/test_subpackage.py , but the one defined in tests/test_top.py would be unavailable to it because it would have to step down a level (step inside a circle) to find it. The first fixture the test finds is the one that will be used, so fixtures can be overridden if you need to change or extend what one does for a particular scope. You can also use the conftest.py file to implement local per-directory plugins .

# Fixtures from third-party plugins¶

Fixtures don’t have to be defined in this structure to be available for tests, though. They can also be provided by third-party plugins that are installed, and this is how many pytest plugins operate. As long as those plugins are installed, the fixtures they provide can be requested from anywhere in your test suite. Because they’re provided from outside the structure of your test suite, third-party plugins don’t really provide a scope like conftest.py files and the directories in your test suite do. As a result, pytest will search for fixtures stepping out through scopes as explained previously, only reaching fixtures defined in plugins last . For example, given the following file structure:

```

tests
/
__init__
.
py
conftest
.
py
# content of tests/conftest.py
import
pytest
@pytest
.
fixture
def
order
():
return
[]
subpackage
/
__init__
.
py
conftest
.
py
# content of tests/subpackage/conftest.py
import
pytest
@pytest
.
fixture
(
autouse
=
True
)
def
mid
(
order
,
b_fix
):
order
.
append
(
"mid subpackage"
)
test_subpackage
.
py
# content of tests/subpackage/test_subpackage.py
import
pytest
@pytest
.
fixture
def
inner
(
order
,
mid
,
a_fix
):
order
.
append
(
"inner subpackage"
)
def
test_order
(
order
,
inner
):
assert
order
==
[
"b_fix"
,
"mid subpackage"
,
"a_fix"
,
"inner subpackage"
]

```

If plugin_a is installed and provides the fixture a_fix , and plugin_b is installed and provides the fixture b_fix , then this is what the test’s search for fixtures would look like: pytest will only search for a_fix and b_fix in the plugins after searching for them first in the scopes inside tests/ .

# Fixture instantiation order¶

When pytest wants to execute a test, once it knows what fixtures will be executed, it has to figure out the order they’ll be executed in. To do this, it considers 3 factors: scope dependencies autouse Names of fixtures or tests, where they’re defined, the order they’re defined in, and the order fixtures are requested in have no bearing on execution order beyond coincidence. While pytest will try to make sure coincidences like these stay consistent from run to run, it’s not something that should be depended on. If you want to control the order, it’s safest to rely on these 3 things and make sure dependencies are clearly established.

# Higher-scoped fixtures are executed first¶

Within a function request for fixtures, those of higher-scopes (such as session ) are executed before lower-scoped fixtures (such as function or class ). Here’s an example:

```

from
__future__
import
annotations
import
pytest
@pytest
.
fixture
(
scope
=
"session"
)
def
order
():
return
[]
@pytest
.
fixture
def
func
(
order
):
order
.
append
(
"function"
)
@pytest
.
fixture
(
scope
=
"class"
)
def
cls
(
order
):
order
.
append
(
"class"
)
@pytest
.
fixture
(
scope
=
"module"
)
def
mod
(
order
):
order
.
append
(
"module"
)
@pytest
.
fixture
(
scope
=
"package"
)
def
pack
(
order
):
order
.
append
(
"package"
)
@pytest
.
fixture
(
scope
=
"session"
)
def
sess
(
order
):
order
.
append
(
"session"
)
class
TestClass
:
def
test_order
(
self
,
func
,
cls
,
mod
,
pack
,
sess
,
order
):
assert
order
==
[
"session"
,
"package"
,
"module"
,
"class"
,
"function"
]

```

The test will pass because the larger scoped fixtures are executing first. The order breaks down to this:

# Fixtures of the same order execute based on dependencies¶

When a fixture requests another fixture, the other fixture is executed first. So if fixture a requests fixture b , fixture b will execute first, because a depends on b and can’t operate without it. Even if a doesn’t need the result of b , it can still request b if it needs to make sure it is executed after b . For example:

```

from
__future__
import
annotations
import
pytest
@pytest
.
fixture
def
order
():
return
[]
@pytest
.
fixture
def
a
(
order
):
order
.
append
(
"a"
)
@pytest
.
fixture
def
b
(
a
,
order
):
order
.
append
(
"b"
)
@pytest
.
fixture
def
c
(
b
,
order
):
order
.
append
(
"c"
)
@pytest
.
fixture
def
d
(
c
,
b
,
order
):
order
.
append
(
"d"
)
@pytest
.
fixture
def
e
(
d
,
b
,
order
):
order
.
append
(
"e"
)
@pytest
.
fixture
def
f
(
e
,
order
):
order
.
append
(
"f"
)
@pytest
.
fixture
def
g
(
f
,
c
,
order
):
order
.
append
(
"g"
)
def
test_order
(
g
,
order
):
assert
order
==
[
"a"
,
"b"
,
"c"
,
"d"
,
"e"
,
"f"
,
"g"
]

```

If we map out what depends on what, we get something that looks like this: The rules provided by each fixture (as to what fixture(s) each one has to come after) are comprehensive enough that it can be flattened to this: Enough information has to be provided through these requests in order for pytest to be able to figure out a clear, linear chain of dependencies, and as a result, an order of operations for a given test. If there’s any ambiguity, and the order of operations can be interpreted more than one way, you should assume pytest could go with any one of those interpretations at any point. For example, if d didn’t request c , i.e.the graph would look like this: Because nothing requested c other than g , and g also requests f , it’s now unclear if c should go before/after f , e , or d . The only rules that were set for c is that it must execute after b and before g . pytest doesn’t know where c should go in the case, so it should be assumed that it could go anywhere between g and b . This isn’t necessarily bad, but it’s something to keep in mind. If the order they execute in could affect the behavior a test is targeting, or could otherwise influence the result of a test, then the order should be defined explicitly in a way that allows pytest to linearize/”flatten” that order.

# Autouse fixtures are executed first within their scope¶

Autouse fixtures are assumed to apply to every test that could reference them, so they are executed before other fixtures in that scope. Fixtures that are requested by autouse fixtures effectively become autouse fixtures themselves for the tests that the real autouse fixture applies to. So if fixture a is autouse and fixture b is not, but fixture a requests fixture b , then fixture b will effectively be an autouse fixture as well, but only for the tests that a applies to. In the last example, the graph became unclear if d didn’t request c . But if c was autouse, then b and a would effectively also be autouse because c depends on them. As a result, they would all be shifted above non-autouse fixtures within that scope. So if the test file looked like this:

```

from
__future__
import
annotations
import
pytest
@pytest
.
fixture
def
order
():
return
[]
@pytest
.
fixture
def
a
(
order
):
order
.
append
(
"a"
)
@pytest
.
fixture
def
b
(
a
,
order
):
order
.
append
(
"b"
)
@pytest
.
fixture
(
autouse
=
True
)
def
c
(
b
,
order
):
order
.
append
(
"c"
)
@pytest
.
fixture
def
d
(
b
,
order
):
order
.
append
(
"d"
)
@pytest
.
fixture
def
e
(
d
,
order
):
order
.
append
(
"e"
)
@pytest
.
fixture
def
f
(
e
,
order
):
order
.
append
(
"f"
)
@pytest
.
fixture
def
g
(
f
,
c
,
order
):
order
.
append
(
"g"
)
def
test_order_and_g
(
g
,
order
):
assert
order
==
[
"a"
,
"b"
,
"c"
,
"d"
,
"e"
,
"f"
,
"g"
]

```

the graph would look like this: Because c can now be put above d in the graph, pytest can once again linearize the graph to this: In this example, c makes b and a effectively autouse fixtures as well. Be careful with autouse, though, as an autouse fixture will automatically execute for every test that can reach it, even if they don’t request it. For example, consider this file:

```

from
__future__
import
annotations
import
pytest
@pytest
.
fixture
(
scope
=
"class"
)
def
order
():
return
[]
@pytest
.
fixture
(
scope
=
"class"
,
autouse
=
True
)
def
c1
(
order
):
order
.
append
(
"c1"
)
@pytest
.
fixture
(
scope
=
"class"
)
def
c2
(
order
):
order
.
append
(
"c2"
)
@pytest
.
fixture
(
scope
=
"class"
)
def
c3
(
order
,
c1
):
order
.
append
(
"c3"
)
class
TestClassWithC1Request
:
def
test_order
(
self
,
order
,
c1
,
c3
):
assert
order
==
[
"c1"
,
"c3"
]
class
TestClassWithoutC1Request
:
def
test_order
(
self
,
order
,
c2
):
assert
order
==
[
"c1"
,
"c2"
]

```

Even though nothing in TestClassWithoutC1Request is requesting c1 , it still is executed for the tests inside it anyway: But just because one autouse fixture requested a non-autouse fixture, that doesn’t mean the non-autouse fixture becomes an autouse fixture for all contexts that it can apply to. It only effectively becomes an autouse fixture for the contexts the real autouse fixture (the one that requested the non-autouse fixture) can apply to. For example, take a look at this test file:

```

from
__future__
import
annotations
import
pytest
@pytest
.
fixture
def
order
():
return
[]
@pytest
.
fixture
def
c1
(
order
):
order
.
append
(
"c1"
)
@pytest
.
fixture
def
c2
(
order
):
order
.
append
(
"c2"
)
class
TestClassWithAutouse
:
@pytest
.
fixture
(
autouse
=
True
)
def
c3
(
self
,
order
,
c2
):
order
.
append
(
"c3"
)
def
test_req
(
self
,
order
,
c1
):
assert
order
==
[
"c2"
,
"c3"
,
"c1"
]
def
test_no_req
(
self
,
order
):
assert
order
==
[
"c2"
,
"c3"
]
class
TestClassWithoutAutouse
:
def
test_req
(
self
,
order
,
c1
):
assert
order
==
[
"c1"
]
def
test_no_req
(
self
,
order
):
assert
order
==
[]

```


---


# How to set up bash completion - pytest documentation

URL: https://docs.pytest.org/en/stable/how-to/bash-completion.html


# How to set up bash completion¶

When using bash as your shell, pytest can use argcomplete ( https://kislyuk.github.io/argcomplete/ ) for auto-completion. For this argcomplete needs to be installed and enabled. Install argcomplete using:

```

sudo
pip
install
'argcomplete>=0.5.7'

```

For global activation of all argcomplete enabled python applications run:

```

sudo
activate-global-python-argcomplete

```

For permanent (but not global) pytest activation, use:

```

register-python-argcomplete
pytest
>>
~/.bashrc

```

For one-time activation of argcomplete for pytest only, use:

```

eval
"
$(
register-python-argcomplete
pytest
)
"

```


---


# _pytest.hookspec - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/hookspec.html


# Source code for _pytest.hookspec

```

# mypy: allow-untyped-defs
# ruff: noqa: T100
"""Hook specifications for pytest plugins which are invoked by pytest itself
and by builtin plugins."""
from
__future__
import
annotations
from
pathlib
import
Path
from
typing
import
Any
from
typing
import
Mapping
from
typing
import
Sequence
from
typing
import
TYPE_CHECKING
from
pluggy
import
HookspecMarker
from
.deprecated
import
HOOK_LEGACY_PATH_ARG
if
TYPE_CHECKING
:
import
pdb
from
typing
import
Literal
import
warnings
from
_pytest._code.code
import
ExceptionInfo
from
_pytest._code.code
import
ExceptionRepr
from
_pytest.compat
import
LEGACY_PATH
from
_pytest.config
import
_PluggyPlugin
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config
import
PytestPluginManager
from
_pytest.config.argparsing
import
Parser
from
_pytest.fixtures
import
FixtureDef
from
_pytest.fixtures
import
SubRequest
from
_pytest.main
import
Session
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
Item
from
_pytest.outcomes
import
Exit
from
_pytest.python
import
Class
from
_pytest.python
import
Function
from
_pytest.python
import
Metafunc
from
_pytest.python
import
Module
from
_pytest.reports
import
CollectReport
from
_pytest.reports
import
TestReport
from
_pytest.runner
import
CallInfo
from
_pytest.terminal
import
TerminalReporter
from
_pytest.terminal
import
TestShortLogReport
hookspec
=
HookspecMarker
(
"pytest"
)
# -------------------------------------------------------------------------
# Initialization hooks called for every plugin
# -------------------------------------------------------------------------
[docs]
@hookspec
(
historic
=
True
)
def
pytest_addhooks
(
pluginmanager
:
PytestPluginManager
)
->
None
:
"""Called at plugin registration time to allow adding new hooks via a call to
:func:`pluginmanager.add_hookspecs(module_or_class, prefix) <pytest.PytestPluginManager.add_hookspecs>`.
:param pluginmanager: The pytest plugin manager.
.. note::
This hook is incompatible with hook wrappers.
Use in conftest plugins
=======================
If a conftest plugin implements this hook, it will be called immediately
when the conftest is registered.
"""
[docs]
@hookspec
(
historic
=
True
)
def
pytest_plugin_registered
(
plugin
:
_PluggyPlugin
,
plugin_name
:
str
,
manager
:
PytestPluginManager
,
)
->
None
:
"""A new pytest plugin got registered.
:param plugin: The plugin module or instance.
:param plugin_name: The name by which the plugin is registered.
:param manager: The pytest plugin manager.
.. note::
This hook is incompatible with hook wrappers.
Use in conftest plugins
=======================
If a conftest plugin implements this hook, it will be called immediately
when the conftest is registered, once for each plugin registered thus far
(including itself!), and for all plugins thereafter when they are
registered.
"""
[docs]
@hookspec
(
historic
=
True
)
def
pytest_addoption
(
parser
:
Parser
,
pluginmanager
:
PytestPluginManager
)
->
None
:
"""Register argparse-style options and ini-style config values,
called once at the beginning of a test run.
:param parser:
To add command line options, call
:py:func:`parser.addoption(...) <pytest.Parser.addoption>`.
To add ini-file values call :py:func:`parser.addini(...)
<pytest.Parser.addini>`.
:param pluginmanager:
The pytest plugin manager, which can be used to install :py:func:`~pytest.hookspec`'s
or :py:func:`~pytest.hookimpl`'s and allow one plugin to call another plugin's hooks
to change how command line options are added.
Options can later be accessed through the
:py:class:`config <pytest.Config>` object, respectively:
- :py:func:`config.getoption(name) <pytest.Config.getoption>` to
retrieve the value of a command line option.
- :py:func:`config.getini(name) <pytest.Config.getini>` to retrieve
a value read from an ini-style file.
The config object is passed around on many internal objects via the ``.config``
attribute or can be retrieved as the ``pytestconfig`` fixture.
.. note::
This hook is incompatible with hook wrappers.
Use in conftest plugins
=======================
If a conftest plugin implements this hook, it will be called immediately
when the conftest is registered.
This hook is only called for :ref:`initial conftests <pluginorder>`.
"""
[docs]
@hookspec
(
historic
=
True
)
def
pytest_configure
(
config
:
Config
)
->
None
:
"""Allow plugins and conftest files to perform initial configuration.
.. note::
This hook is incompatible with hook wrappers.
:param config: The pytest config object.
Use in conftest plugins
=======================
This hook is called for every :ref:`initial conftest <pluginorder>` file
after command line options have been parsed. After that, the hook is called
for other conftest files as they are registered.
"""
# -------------------------------------------------------------------------
# Bootstrapping hooks called for plugins registered early enough:
# internal and 3rd party plugins.
# -------------------------------------------------------------------------
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_cmdline_parse
(
pluginmanager
:
PytestPluginManager
,
args
:
list
[
str
]
)
->
Config
|
None
:
"""Return an initialized :class:`~pytest.Config`, parsing the specified args.
Stops at first non-None result, see :ref:`firstresult`.
.. note::
This hook is only called for plugin classes passed to the
``plugins`` arg when using `pytest.main`_ to perform an in-process
test run.
:param pluginmanager: The pytest plugin manager.
:param args: List of arguments passed on the command line.
:returns: A pytest config object.
Use in conftest plugins
=======================
This hook is not called for conftest files.
"""
[docs]
def
pytest_load_initial_conftests
(
early_config
:
Config
,
parser
:
Parser
,
args
:
list
[
str
]
)
->
None
:
"""Called to implement the loading of :ref:`initial conftest files
<pluginorder>` ahead of command line option parsing.
:param early_config: The pytest config object.
:param args: Arguments passed on the command line.
:param parser: To add command line options.
Use in conftest plugins
=======================
This hook is not called for conftest files.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_cmdline_main
(
config
:
Config
)
->
ExitCode
|
int
|
None
:
"""Called for performing the main command line action.
The default implementation will invoke the configure hooks and
:hook:`pytest_runtestloop`.
Stops at first non-None result, see :ref:`firstresult`.
:param config: The pytest config object.
:returns: The exit code.
Use in conftest plugins
=======================
This hook is only called for :ref:`initial conftests <pluginorder>`.
"""
# -------------------------------------------------------------------------
# collection hooks
# -------------------------------------------------------------------------
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_collection
(
session
:
Session
)
->
object
|
None
:
"""Perform the collection phase for the given session.
Stops at first non-None result, see :ref:`firstresult`.
The return value is not used, but only stops further processing.
The default collection phase is this (see individual hooks for full details):
1. Starting from ``session`` as the initial collector:
1. ``pytest_collectstart(collector)``
2. ``report = pytest_make_collect_report(collector)``
3. ``pytest_exception_interact(collector, call, report)`` if an interactive exception occurred
4. For each collected node:
1. If an item, ``pytest_itemcollected(item)``
2. If a collector, recurse into it.
5. ``pytest_collectreport(report)``
2. ``pytest_collection_modifyitems(session, config, items)``
1. ``pytest_deselected(items)`` for any deselected items (may be called multiple times)
3. ``pytest_collection_finish(session)``
4. Set ``session.items`` to the list of collected items
5. Set ``session.testscollected`` to the number of collected items
You can implement this hook to only perform some action before collection,
for example the terminal plugin uses it to start displaying the collection
counter (and returns `None`).
:param session: The pytest session object.
Use in conftest plugins
=======================
This hook is only called for :ref:`initial conftests <pluginorder>`.
"""
[docs]
def
pytest_collection_modifyitems
(
session
:
Session
,
config
:
Config
,
items
:
list
[
Item
]
)
->
None
:
"""Called after collection has been performed. May filter or re-order
the items in-place.
When items are deselected (filtered out from ``items``),
the hook :hook:`pytest_deselected` must be called explicitly
with the deselected items to properly notify other plugins,
e.g. with ``config.hook.pytest_deselected(items=deselected_items)``.
:param session: The pytest session object.
:param config: The pytest config object.
:param items: List of item objects.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
def
pytest_collection_finish
(
session
:
Session
)
->
None
:
"""Called after collection has been performed and modified.
:param session: The pytest session object.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
@hookspec
(
firstresult
=
True
,
warn_on_impl_args
=
{
"path"
:
HOOK_LEGACY_PATH_ARG
.
format
(
pylib_path_arg
=
"path"
,
pathlib_path_arg
=
"collection_path"
),
},
)
def
pytest_ignore_collect
(
collection_path
:
Path
,
path
:
LEGACY_PATH
,
config
:
Config
)
->
bool
|
None
:
"""Return ``True`` to ignore this path for collection.
Return ``None`` to let other plugins ignore the path for collection.
Returning ``False`` will forcefully *not* ignore this path for collection,
without giving a chance for other plugins to ignore this path.
This hook is consulted for all files and directories prior to calling
more specific hooks.
Stops at first non-None result, see :ref:`firstresult`.
:param collection_path: The path to analyze.
:type collection_path: pathlib.Path
:param path: The path to analyze (deprecated).
:param config: The pytest config object.
.. versionchanged:: 7.0.0
The ``collection_path`` parameter was added as a :class:`pathlib.Path`
equivalent of the ``path`` parameter. The ``path`` parameter
has been deprecated.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given collection path, only
conftest files in parent directories of the collection path are consulted
(if the path is a directory, its own conftest file is *not* consulted - a
directory cannot ignore itself!).
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_collect_directory
(
path
:
Path
,
parent
:
Collector
)
->
Collector
|
None
:
"""Create a :class:`~pytest.Collector` for the given directory, or None if
not relevant.
.. versionadded:: 8.0
For best results, the returned collector should be a subclass of
:class:`~pytest.Directory`, but this is not required.
The new node needs to have the specified ``parent`` as a parent.
Stops at first non-None result, see :ref:`firstresult`.
:param path: The path to analyze.
:type path: pathlib.Path
See :ref:`custom directory collectors` for a simple example of use of this
hook.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given collection path, only
conftest files in parent directories of the collection path are consulted
(if the path is a directory, its own conftest file is *not* consulted - a
directory cannot collect itself!).
"""
[docs]
@hookspec
(
warn_on_impl_args
=
{
"path"
:
HOOK_LEGACY_PATH_ARG
.
format
(
pylib_path_arg
=
"path"
,
pathlib_path_arg
=
"file_path"
),
},
)
def
pytest_collect_file
(
file_path
:
Path
,
path
:
LEGACY_PATH
,
parent
:
Collector
)
->
Collector
|
None
:
"""Create a :class:`~pytest.Collector` for the given path, or None if not relevant.
For best results, the returned collector should be a subclass of
:class:`~pytest.File`, but this is not required.
The new node needs to have the specified ``parent`` as a parent.
:param file_path: The path to analyze.
:type file_path: pathlib.Path
:param path: The path to collect (deprecated).
.. versionchanged:: 7.0.0
The ``file_path`` parameter was added as a :class:`pathlib.Path`
equivalent of the ``path`` parameter. The ``path`` parameter
has been deprecated.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given file path, only
conftest files in parent directories of the file path are consulted.
"""
# logging hooks for collection
[docs]
def
pytest_collectstart
(
collector
:
Collector
)
->
None
:
"""Collector starts collecting.
:param collector:
The collector.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given collector, only
conftest files in the collector's directory and its parent directories are
consulted.
"""
[docs]
def
pytest_itemcollected
(
item
:
Item
)
->
None
:
"""We just collected a test item.
:param item:
The item.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_collectreport
(
report
:
CollectReport
)
->
None
:
"""Collector finished collecting.
:param report:
The collect report.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given collector, only
conftest files in the collector's directory and its parent directories are
consulted.
"""
[docs]
def
pytest_deselected
(
items
:
Sequence
[
Item
])
->
None
:
"""Called for deselected test items, e.g. by keyword.
Note that this hook has two integration aspects for plugins:
- it can be *implemented* to be notified of deselected items
- it must be *called* from :hook:`pytest_collection_modifyitems`
implementations when items are deselected (to properly notify other plugins).
May be called multiple times.
:param items:
The items.
Use in conftest plugins
=======================
Any conftest file can implement this hook.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_make_collect_report
(
collector
:
Collector
)
->
CollectReport
|
None
:
"""Perform :func:`collector.collect() <pytest.Collector.collect>` and return
a :class:`~pytest.CollectReport`.
Stops at first non-None result, see :ref:`firstresult`.
:param collector:
The collector.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given collector, only
conftest files in the collector's directory and its parent directories are
consulted.
"""
# -------------------------------------------------------------------------
# Python test function related hooks
# -------------------------------------------------------------------------
[docs]
@hookspec
(
firstresult
=
True
,
warn_on_impl_args
=
{
"path"
:
HOOK_LEGACY_PATH_ARG
.
format
(
pylib_path_arg
=
"path"
,
pathlib_path_arg
=
"module_path"
),
},
)
def
pytest_pycollect_makemodule
(
module_path
:
Path
,
path
:
LEGACY_PATH
,
parent
)
->
Module
|
None
:
"""Return a :class:`pytest.Module` collector or None for the given path.
This hook will be called for each matching test module path.
The :hook:`pytest_collect_file` hook needs to be used if you want to
create test modules for files that do not match as a test module.
Stops at first non-None result, see :ref:`firstresult`.
:param module_path: The path of the module to collect.
:type module_path: pathlib.Path
:param path: The path of the module to collect (deprecated).
.. versionchanged:: 7.0.0
The ``module_path`` parameter was added as a :class:`pathlib.Path`
equivalent of the ``path`` parameter.
The ``path`` parameter has been deprecated in favor of ``fspath``.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given parent collector,
only conftest files in the collector's directory and its parent directories
are consulted.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_pycollect_makeitem
(
collector
:
Module
|
Class
,
name
:
str
,
obj
:
object
)
->
None
|
Item
|
Collector
|
list
[
Item
|
Collector
]:
"""Return a custom item/collector for a Python object in a module, or None.
Stops at first non-None result, see :ref:`firstresult`.
:param collector:
The module/class collector.
:param name:
The name of the object in the module/class.
:param obj:
The object.
:returns:
The created items/collectors.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given collector, only
conftest files in the collector's directory and its parent directories
are consulted.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_pyfunc_call
(
pyfuncitem
:
Function
)
->
object
|
None
:
"""Call underlying test function.
Stops at first non-None result, see :ref:`firstresult`.
:param pyfuncitem:
The function item.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only
conftest files in the item's directory and its parent directories
are consulted.
"""
[docs]
def
pytest_generate_tests
(
metafunc
:
Metafunc
)
->
None
:
"""Generate (multiple) parametrized calls to a test function.
:param metafunc:
The :class:`~pytest.Metafunc` helper for the test function.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given function definition,
only conftest files in the functions's directory and its parent directories
are consulted.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_make_parametrize_id
(
config
:
Config
,
val
:
object
,
argname
:
str
)
->
str
|
None
:
"""Return a user-friendly string representation of the given ``val``
that will be used by @pytest.mark.parametrize calls, or None if the hook
doesn't know about ``val``.
The parameter name is available as ``argname``, if required.
Stops at first non-None result, see :ref:`firstresult`.
:param config: The pytest config object.
:param val: The parametrized value.
:param argname: The automatic parameter name produced by pytest.
Use in conftest plugins
=======================
Any conftest file can implement this hook.
"""
# -------------------------------------------------------------------------
# runtest related hooks
# -------------------------------------------------------------------------
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_runtestloop
(
session
:
Session
)
->
object
|
None
:
"""Perform the main runtest loop (after collection finished).
The default hook implementation performs the runtest protocol for all items
collected in the session (``session.items``), unless the collection failed
or the ``collectonly`` pytest option is set.
If at any point :py:func:`pytest.exit` is called, the loop is
terminated immediately.
If at any point ``session.shouldfail`` or ``session.shouldstop`` are set, the
loop is terminated after the runtest protocol for the current item is finished.
:param session: The pytest session object.
Stops at first non-None result, see :ref:`firstresult`.
The return value is not used, but only stops further processing.
Use in conftest plugins
=======================
Any conftest file can implement this hook.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_runtest_protocol
(
item
:
Item
,
nextitem
:
Item
|
None
)
->
object
|
None
:
"""Perform the runtest protocol for a single test item.
The default runtest protocol is this (see individual hooks for full details):
- ``pytest_runtest_logstart(nodeid, location)``
- Setup phase:
- ``call = pytest_runtest_setup(item)`` (wrapped in ``CallInfo(when="setup")``)
- ``report = pytest_runtest_makereport(item, call)``
- ``pytest_runtest_logreport(report)``
- ``pytest_exception_interact(call, report)`` if an interactive exception occurred
- Call phase, if the setup passed and the ``setuponly`` pytest option is not set:
- ``call = pytest_runtest_call(item)`` (wrapped in ``CallInfo(when="call")``)
- ``report = pytest_runtest_makereport(item, call)``
- ``pytest_runtest_logreport(report)``
- ``pytest_exception_interact(call, report)`` if an interactive exception occurred
- Teardown phase:
- ``call = pytest_runtest_teardown(item, nextitem)`` (wrapped in ``CallInfo(when="teardown")``)
- ``report = pytest_runtest_makereport(item, call)``
- ``pytest_runtest_logreport(report)``
- ``pytest_exception_interact(call, report)`` if an interactive exception occurred
- ``pytest_runtest_logfinish(nodeid, location)``
:param item: Test item for which the runtest protocol is performed.
:param nextitem: The scheduled-to-be-next test item (or None if this is the end my friend).
Stops at first non-None result, see :ref:`firstresult`.
The return value is not used, but only stops further processing.
Use in conftest plugins
=======================
Any conftest file can implement this hook.
"""
[docs]
def
pytest_runtest_logstart
(
nodeid
:
str
,
location
:
tuple
[
str
,
int
|
None
,
str
])
->
None
:
"""Called at the start of running the runtest protocol for a single item.
See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
:param nodeid: Full node ID of the item.
:param location: A tuple of ``(filename, lineno, testname)``
where ``filename`` is a file path relative to ``config.rootpath``
and ``lineno`` is 0-based.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_runtest_logfinish
(
nodeid
:
str
,
location
:
tuple
[
str
,
int
|
None
,
str
]
)
->
None
:
"""Called at the end of running the runtest protocol for a single item.
See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
:param nodeid: Full node ID of the item.
:param location: A tuple of ``(filename, lineno, testname)``
where ``filename`` is a file path relative to ``config.rootpath``
and ``lineno`` is 0-based.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_runtest_setup
(
item
:
Item
)
->
None
:
"""Called to perform the setup phase for a test item.
The default implementation runs ``setup()`` on ``item`` and all of its
parents (which haven't been setup yet). This includes obtaining the
values of fixtures required by the item (which haven't been obtained
yet).
:param item:
The item.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_runtest_call
(
item
:
Item
)
->
None
:
"""Called to run the test for test item (the call phase).
The default implementation calls ``item.runtest()``.
:param item:
The item.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_runtest_teardown
(
item
:
Item
,
nextitem
:
Item
|
None
)
->
None
:
"""Called to perform the teardown phase for a test item.
The default implementation runs the finalizers and calls ``teardown()``
on ``item`` and all of its parents (which need to be torn down). This
includes running the teardown phase of fixtures required by the item (if
they go out of scope).
:param item:
The item.
:param nextitem:
The scheduled-to-be-next test item (None if no further test item is
scheduled). This argument is used to perform exact teardowns, i.e.
calling just enough finalizers so that nextitem only needs to call
setup functions.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_runtest_makereport
(
item
:
Item
,
call
:
CallInfo
[
None
])
->
TestReport
|
None
:
"""Called to create a :class:`~pytest.TestReport` for each of
the setup, call and teardown runtest phases of a test item.
See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
:param item: The item.
:param call: The :class:`~pytest.CallInfo` for the phase.
Stops at first non-None result, see :ref:`firstresult`.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_runtest_logreport
(
report
:
TestReport
)
->
None
:
"""Process the :class:`~pytest.TestReport` produced for each
of the setup, call and teardown runtest phases of an item.
See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_report_to_serializable
(
config
:
Config
,
report
:
CollectReport
|
TestReport
,
)
->
dict
[
str
,
Any
]
|
None
:
"""Serialize the given report object into a data structure suitable for
sending over the wire, e.g. converted to JSON.
:param config: The pytest config object.
:param report: The report.
Use in conftest plugins
=======================
Any conftest file can implement this hook. The exact details may depend
on the plugin which calls the hook.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_report_from_serializable
(
config
:
Config
,
data
:
dict
[
str
,
Any
],
)
->
CollectReport
|
TestReport
|
None
:
"""Restore a report object previously serialized with
:hook:`pytest_report_to_serializable`.
:param config: The pytest config object.
Use in conftest plugins
=======================
Any conftest file can implement this hook. The exact details may depend
on the plugin which calls the hook.
"""
# -------------------------------------------------------------------------
# Fixture related hooks
# -------------------------------------------------------------------------
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_fixture_setup
(
fixturedef
:
FixtureDef
[
Any
],
request
:
SubRequest
)
->
object
|
None
:
"""Perform fixture setup execution.
:param fixturedef:
The fixture definition object.
:param request:
The fixture request object.
:returns:
The return value of the call to the fixture function.
Stops at first non-None result, see :ref:`firstresult`.
.. note::
If the fixture function returns None, other implementations of
this hook function will continue to be called, according to the
behavior of the :ref:`firstresult` option.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given fixture, only
conftest files in the fixture scope's directory and its parent directories
are consulted.
"""
[docs]
def
pytest_fixture_post_finalizer
(
fixturedef
:
FixtureDef
[
Any
],
request
:
SubRequest
)
->
None
:
"""Called after fixture teardown, but before the cache is cleared, so
the fixture result ``fixturedef.cached_result`` is still available (not
``None``).
:param fixturedef:
The fixture definition object.
:param request:
The fixture request object.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given fixture, only
conftest files in the fixture scope's directory and its parent directories
are consulted.
"""
# -------------------------------------------------------------------------
# test session related hooks
# -------------------------------------------------------------------------
[docs]
def
pytest_sessionstart
(
session
:
Session
)
->
None
:
"""Called after the ``Session`` object has been created and before performing collection
and entering the run test loop.
:param session: The pytest session object.
Use in conftest plugins
=======================
This hook is only called for :ref:`initial conftests <pluginorder>`.
"""
[docs]
def
pytest_sessionfinish
(
session
:
Session
,
exitstatus
:
int
|
ExitCode
,
)
->
None
:
"""Called after whole test run finished, right before returning the exit status to the system.
:param session: The pytest session object.
:param exitstatus: The status which pytest will return to the system.
Use in conftest plugins
=======================
Any conftest file can implement this hook.
"""
[docs]
def
pytest_unconfigure
(
config
:
Config
)
->
None
:
"""Called before test process is exited.
:param config: The pytest config object.
Use in conftest plugins
=======================
Any conftest file can implement this hook.
"""
# -------------------------------------------------------------------------
# hooks for customizing the assert methods
# -------------------------------------------------------------------------
[docs]
def
pytest_assertrepr_compare
(
config
:
Config
,
op
:
str
,
left
:
object
,
right
:
object
)
->
list
[
str
]
|
None
:
"""Return explanation for comparisons in failing assert expressions.
Return None for no custom explanation, otherwise return a list
of strings. The strings will be joined by newlines but any newlines
*in* a string will be escaped. Note that all but the first line will
be indented slightly, the intention is for the first line to be a summary.
:param config: The pytest config object.
:param op: The operator, e.g. `"=="`, `"!="`, `"not in"`.
:param left: The left operand.
:param right: The right operand.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
[docs]
def
pytest_assertion_pass
(
item
:
Item
,
lineno
:
int
,
orig
:
str
,
expl
:
str
)
->
None
:
"""Called whenever an assertion passes.
.. versionadded:: 5.0
Use this hook to do some processing after a passing assertion.
The original assertion information is available in the `orig` string
and the pytest introspected assertion information is available in the
`expl` string.
This hook must be explicitly enabled by the ``enable_assertion_pass_hook``
ini-file option:
.. code-block:: ini
[pytest]
enable_assertion_pass_hook=true
You need to **clean the .pyc** files in your project directory and interpreter libraries
when enabling this option, as assertions will require to be re-written.
:param item: pytest item object of current test.
:param lineno: Line number of the assert statement.
:param orig: String with the original assertion.
:param expl: String with the assert explanation.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in the item's directory and its parent directories are consulted.
"""
# -------------------------------------------------------------------------
# Hooks for influencing reporting (invoked from _pytest_terminal).
# -------------------------------------------------------------------------
[docs]
@hookspec
(
warn_on_impl_args
=
{
"startdir"
:
HOOK_LEGACY_PATH_ARG
.
format
(
pylib_path_arg
=
"startdir"
,
pathlib_path_arg
=
"start_path"
),
},
)
def
pytest_report_header
(
# type:ignore[empty-body]
config
:
Config
,
start_path
:
Path
,
startdir
:
LEGACY_PATH
)
->
str
|
list
[
str
]:
"""Return a string or list of strings to be displayed as header info for terminal reporting.
:param config: The pytest config object.
:param start_path: The starting dir.
:type start_path: pathlib.Path
:param startdir: The starting dir (deprecated).
.. note::
Lines returned by a plugin are displayed before those of plugins which
ran before it.
If you want to have your line(s) displayed first, use
:ref:`trylast=True <plugin-hookorder>`.
.. versionchanged:: 7.0.0
The ``start_path`` parameter was added as a :class:`pathlib.Path`
equivalent of the ``startdir`` parameter. The ``startdir`` parameter
has been deprecated.
Use in conftest plugins
=======================
This hook is only called for :ref:`initial conftests <pluginorder>`.
"""
[docs]
@hookspec
(
warn_on_impl_args
=
{
"startdir"
:
HOOK_LEGACY_PATH_ARG
.
format
(
pylib_path_arg
=
"startdir"
,
pathlib_path_arg
=
"start_path"
),
},
)
def
pytest_report_collectionfinish
(
# type:ignore[empty-body]
config
:
Config
,
start_path
:
Path
,
startdir
:
LEGACY_PATH
,
items
:
Sequence
[
Item
],
)
->
str
|
list
[
str
]:
"""Return a string or list of strings to be displayed after collection
has finished successfully.
These strings will be displayed after the standard "collected X items" message.
.. versionadded:: 3.2
:param config: The pytest config object.
:param start_path: The starting dir.
:type start_path: pathlib.Path
:param startdir: The starting dir (deprecated).
:param items: List of pytest items that are going to be executed; this list should not be modified.
.. note::
Lines returned by a plugin are displayed before those of plugins which
ran before it.
If you want to have your line(s) displayed first, use
:ref:`trylast=True <plugin-hookorder>`.
.. versionchanged:: 7.0.0
The ``start_path`` parameter was added as a :class:`pathlib.Path`
equivalent of the ``startdir`` parameter. The ``startdir`` parameter
has been deprecated.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
@hookspec
(
firstresult
=
True
)
def
pytest_report_teststatus
(
# type:ignore[empty-body]
report
:
CollectReport
|
TestReport
,
config
:
Config
)
->
TestShortLogReport
|
tuple
[
str
,
str
,
str
|
tuple
[
str
,
Mapping
[
str
,
bool
]]]:
"""Return result-category, shortletter and verbose word for status
reporting.
The result-category is a category in which to count the result, for
example "passed", "skipped", "error" or the empty string.
The shortletter is shown as testing progresses, for example ".", "s",
"E" or the empty string.
The verbose word is shown as testing progresses in verbose mode, for
example "PASSED", "SKIPPED", "ERROR" or the empty string.
pytest may style these implicitly according to the report outcome.
To provide explicit styling, return a tuple for the verbose word,
for example ``"rerun", "R", ("RERUN", {"yellow": True})``.
:param report: The report object whose status is to be returned.
:param config: The pytest config object.
:returns: The test status.
Stops at first non-None result, see :ref:`firstresult`.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
def
pytest_terminal_summary
(
terminalreporter
:
TerminalReporter
,
exitstatus
:
ExitCode
,
config
:
Config
,
)
->
None
:
"""Add a section to terminal summary reporting.
:param terminalreporter: The internal terminal reporter object.
:param exitstatus: The exit status that will be reported back to the OS.
:param config: The pytest config object.
.. versionadded:: 4.2
The ``config`` parameter.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
@hookspec
(
historic
=
True
)
def
pytest_warning_recorded
(
warning_message
:
warnings
.
WarningMessage
,
when
:
Literal
[
"config"
,
"collect"
,
"runtest"
],
nodeid
:
str
,
location
:
tuple
[
str
,
int
,
str
]
|
None
,
)
->
None
:
"""Process a warning captured by the internal pytest warnings plugin.
:param warning_message:
The captured warning. This is the same object produced by :class:`warnings.catch_warnings`,
and contains the same attributes as the parameters of :py:func:`warnings.showwarning`.
:param when:
Indicates when the warning was captured. Possible values:
* ``"config"``: during pytest configuration/initialization stage.
* ``"collect"``: during test collection.
* ``"runtest"``: during test execution.
:param nodeid:
Full id of the item. Empty string for warnings that are not specific to
a particular node.
:param location:
When available, holds information about the execution context of the captured
warning (filename, linenumber, function). ``function`` evaluates to <module>
when the execution context is at the module level.
.. versionadded:: 6.0
Use in conftest plugins
=======================
Any conftest file can implement this hook. If the warning is specific to a
particular node, only conftest files in parent directories of the node are
consulted.
"""
# -------------------------------------------------------------------------
# Hooks for influencing skipping
# -------------------------------------------------------------------------
[docs]
def
pytest_markeval_namespace
(
# type:ignore[empty-body]
config
:
Config
,
)
->
dict
[
str
,
Any
]:
"""Called when constructing the globals dictionary used for
evaluating string conditions in xfail/skipif markers.
This is useful when the condition for a marker requires
objects that are expensive or impossible to obtain during
collection time, which is required by normal boolean
conditions.
.. versionadded:: 6.2
:param config: The pytest config object.
:returns: A dictionary of additional globals to add.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given item, only conftest
files in parent directories of the item are consulted.
"""
# -------------------------------------------------------------------------
# error handling and internal debugging hooks
# -------------------------------------------------------------------------
[docs]
def
pytest_internalerror
(
excrepr
:
ExceptionRepr
,
excinfo
:
ExceptionInfo
[
BaseException
],
)
->
bool
|
None
:
"""Called for internal errors.
Return True to suppress the fallback handling of printing an
INTERNALERROR message directly to sys.stderr.
:param excrepr: The exception repr object.
:param excinfo: The exception info.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
def
pytest_keyboard_interrupt
(
excinfo
:
ExceptionInfo
[
KeyboardInterrupt
|
Exit
],
)
->
None
:
"""Called for keyboard interrupt.
:param excinfo: The exception info.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
def
pytest_exception_interact
(
node
:
Item
|
Collector
,
call
:
CallInfo
[
Any
],
report
:
CollectReport
|
TestReport
,
)
->
None
:
"""Called when an exception was raised which can potentially be
interactively handled.
May be called during collection (see :hook:`pytest_make_collect_report`),
in which case ``report`` is a :class:`~pytest.CollectReport`.
May be called during runtest of an item (see :hook:`pytest_runtest_protocol`),
in which case ``report`` is a :class:`~pytest.TestReport`.
This hook is not called if the exception that was raised is an internal
exception like ``skip.Exception``.
:param node:
The item or collector.
:param call:
The call information. Contains the exception.
:param report:
The collection or test report.
Use in conftest plugins
=======================
Any conftest file can implement this hook. For a given node, only conftest
files in parent directories of the node are consulted.
"""
[docs]
def
pytest_enter_pdb
(
config
:
Config
,
pdb
:
pdb
.
Pdb
)
->
None
:
"""Called upon pdb.set_trace().
Can be used by plugins to take special action just before the python
debugger enters interactive mode.
:param config: The pytest config object.
:param pdb: The Pdb instance.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""
[docs]
def
pytest_leave_pdb
(
config
:
Config
,
pdb
:
pdb
.
Pdb
)
->
None
:
"""Called when leaving pdb (e.g. with continue after pdb.set_trace()).
Can be used by plugins to take special action just after the python
debugger leaves interactive mode.
:param config: The pytest config object.
:param pdb: The Pdb instance.
Use in conftest plugins
=======================
Any conftest plugin can implement this hook.
"""

```


---


# pytest documentation

URL: https://docs.pytest.org/en/stable/index.html


Next Open Trainings and Events Professional Testing with Python , via Python Academy (3 day in-depth training), March 4th – 6th 2025 , Remote Also see previous talks and blogposts

# pytest: helps you write better programs¶

The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries. pytest requires: Python 3.8+ or PyPy3. PyPI package name : pytest

# A quick example¶

```

# content of test_sample.py
def
inc
(
x
):
return
x
+
1
def
test_answer
():
assert
inc
(
3
)
==
5

```

To execute it:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_sample.py
F
[100%]
================================= FAILURES =================================
_______________________________ test_answer ________________________________
def test_answer():
>       assert inc(3) == 5
E       assert 4 == 5
E        +  where 4 = inc(3)
test_sample.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_sample.py::
test_answer
- assert 4 == 5
============================
1 failed
in 0.12s =============================

```

Due to pytest ’s detailed assertion introspection, only plain assert statements are used. See Get started for a basic introduction to using pytest.

# Features¶

Detailed info on failing assert statements (no need to remember self.assert* names) Auto-discovery of test modules and functions Modular fixtures for managing small or parametrized long-lived test resources Can run unittest (including trial) test suites out of the box Python 3.8+ or PyPy 3 Rich plugin architecture, with over 1300+ external plugins and thriving community

# Documentation¶

Get started - install pytest and grasp its basics in just twenty minutes How-to guides - step-by-step guides, covering a vast range of use-cases and needs Reference guides - includes the complete pytest API reference, lists of plugins and more Explanation - background, discussion of key topics, answers to higher-level questions

# Bugs/Requests¶

Please use the GitHub issue tracker to submit bugs or request features.

# Support pytest¶

Open Collective is an online funding platform for open and transparent communities. It provides tools to raise money and share your finances in full transparency. It is the platform of choice for individuals and companies that want to make one-time or monthly donations directly to the project. See more details in the pytest collective .

# pytest for enterprise¶

Available as part of the Tidelift Subscription. The maintainers of pytest and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.

# Security¶


---


# _pytest.assertion - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/assertion.html


# Source code for _pytest.assertion

```

# mypy: allow-untyped-defs
"""Support for presenting detailed information in failing assertions."""
from
__future__
import
annotations
import
sys
from
typing
import
Any
from
typing
import
Generator
from
typing
import
TYPE_CHECKING
from
_pytest.assertion
import
rewrite
from
_pytest.assertion
import
truncate
from
_pytest.assertion
import
util
from
_pytest.assertion.rewrite
import
assertstate_key
from
_pytest.config
import
Config
from
_pytest.config
import
hookimpl
from
_pytest.config.argparsing
import
Parser
from
_pytest.nodes
import
Item
if
TYPE_CHECKING
:
from
_pytest.main
import
Session
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"debugconfig"
)
group
.
addoption
(
"--assert"
,
action
=
"store"
,
dest
=
"assertmode"
,
choices
=
(
"rewrite"
,
"plain"
),
default
=
"rewrite"
,
metavar
=
"MODE"
,
help
=
(
"Control assertion debugging tools.
\n
"
"'plain' performs no assertion debugging.
\n
"
"'rewrite' (the default) rewrites assert statements in test modules"
" on import to provide assert expression information."
),
)
parser
.
addini
(
"enable_assertion_pass_hook"
,
type
=
"bool"
,
default
=
False
,
help
=
"Enables the pytest_assertion_pass hook. "
"Make sure to delete any previously generated pyc cache files."
,
)
Config
.
_add_verbosity_ini
(
parser
,
Config
.
VERBOSITY_ASSERTIONS
,
help
=
(
"Specify a verbosity level for assertions, overriding the main level. "
"Higher levels will provide more detailed explanation when an assertion fails."
),
)
[docs]
def
register_assert_rewrite
(
*
names
:
str
)
->
None
:
"""Register one or more module names to be rewritten on import.
This function will make sure that this module or all modules inside
the package will get their assert statements rewritten.
Thus you should make sure to call this before the module is
actually imported, usually in your __init__.py if you are a plugin
using a package.
:param names: The module names to register.
"""
for
name
in
names
:
if
not
isinstance
(
name
,
str
):
msg
=
"expected module names as *args, got
{0}
instead"
# type: ignore[unreachable]
raise
TypeError
(
msg
.
format
(
repr
(
names
)))
for
hook
in
sys
.
meta_path
:
if
isinstance
(
hook
,
rewrite
.
AssertionRewritingHook
):
importhook
=
hook
break
else
:
# TODO(typing): Add a protocol for mark_rewrite() and use it
# for importhook and for PytestPluginManager.rewrite_hook.
importhook
=
DummyRewriteHook
()
# type: ignore
importhook
.
mark_rewrite
(
*
names
)
class
DummyRewriteHook
:
"""A no-op import hook for when rewriting is disabled."""
def
mark_rewrite
(
self
,
*
names
:
str
)
->
None
:
pass
class
AssertionState
:
"""State for the assertion plugin."""
def
__init__
(
self
,
config
:
Config
,
mode
)
->
None
:
self
.
mode
=
mode
self
.
trace
=
config
.
trace
.
root
.
get
(
"assertion"
)
self
.
hook
:
rewrite
.
AssertionRewritingHook
|
None
=
None
def
install_importhook
(
config
:
Config
)
->
rewrite
.
AssertionRewritingHook
:
"""Try to install the rewrite hook, raise SystemError if it fails."""
config
.
stash
[
assertstate_key
]
=
AssertionState
(
config
,
"rewrite"
)
config
.
stash
[
assertstate_key
]
.
hook
=
hook
=
rewrite
.
AssertionRewritingHook
(
config
)
sys
.
meta_path
.
insert
(
0
,
hook
)
config
.
stash
[
assertstate_key
]
.
trace
(
"installed rewrite import hook"
)
def
undo
()
->
None
:
hook
=
config
.
stash
[
assertstate_key
]
.
hook
if
hook
is
not
None
and
hook
in
sys
.
meta_path
:
sys
.
meta_path
.
remove
(
hook
)
config
.
add_cleanup
(
undo
)
return
hook
def
pytest_collection
(
session
:
Session
)
->
None
:
# This hook is only called when test modules are collected
# so for example not in the managing process of pytest-xdist
# (which does not collect test modules).
assertstate
=
session
.
config
.
stash
.
get
(
assertstate_key
,
None
)
if
assertstate
:
if
assertstate
.
hook
is
not
None
:
assertstate
.
hook
.
set_session
(
session
)
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_runtest_protocol
(
item
:
Item
)
->
Generator
[
None
,
object
,
object
]:
"""Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks.
The rewrite module will use util._reprcompare if it exists to use custom
reporting via the pytest_assertrepr_compare hook.  This sets up this custom
comparison for the test.
"""
ihook
=
item
.
ihook
def
callbinrepr
(
op
,
left
:
object
,
right
:
object
)
->
str
|
None
:
"""Call the pytest_assertrepr_compare hook and prepare the result.
This uses the first result from the hook and then ensures the
following:
* Overly verbose explanations are truncated unless configured otherwise
(eg. if running in verbose mode).
* Embedded newlines are escaped to help util.format_explanation()
later.
* If the rewrite mode is used embedded %-characters are replaced
to protect later % formatting.
The result can be formatted by util.format_explanation() for
pretty printing.
"""
hook_result
=
ihook
.
pytest_assertrepr_compare
(
config
=
item
.
config
,
op
=
op
,
left
=
left
,
right
=
right
)
for
new_expl
in
hook_result
:
if
new_expl
:
new_expl
=
truncate
.
truncate_if_required
(
new_expl
,
item
)
new_expl
=
[
line
.
replace
(
"
\n
"
,
"
\\
n"
)
for
line
in
new_expl
]
res
=
"
\n
~"
.
join
(
new_expl
)
if
item
.
config
.
getvalue
(
"assertmode"
)
==
"rewrite"
:
res
=
res
.
replace
(
"%"
,
"
%%
"
)
return
res
return
None
saved_assert_hooks
=
util
.
_reprcompare
,
util
.
_assertion_pass
util
.
_reprcompare
=
callbinrepr
util
.
_config
=
item
.
config
if
ihook
.
pytest_assertion_pass
.
get_hookimpls
():
def
call_assertion_pass_hook
(
lineno
:
int
,
orig
:
str
,
expl
:
str
)
->
None
:
ihook
.
pytest_assertion_pass
(
item
=
item
,
lineno
=
lineno
,
orig
=
orig
,
expl
=
expl
)
util
.
_assertion_pass
=
call_assertion_pass_hook
try
:
return
(
yield
)
finally
:
util
.
_reprcompare
,
util
.
_assertion_pass
=
saved_assert_hooks
util
.
_config
=
None
def
pytest_sessionfinish
(
session
:
Session
)
->
None
:
assertstate
=
session
.
config
.
stash
.
get
(
assertstate_key
,
None
)
if
assertstate
:
if
assertstate
.
hook
is
not
None
:
assertstate
.
hook
.
set_session
(
None
)
def
pytest_assertrepr_compare
(
config
:
Config
,
op
:
str
,
left
:
Any
,
right
:
Any
)
->
list
[
str
]
|
None
:
return
util
.
assertrepr_compare
(
config
=
config
,
op
=
op
,
left
=
left
,
right
=
right
)

```


---


# Full pytest documentation - pytest documentation

URL: https://docs.pytest.org/en/stable/contents.html


# Full pytest documentation¶

Download latest version as PDF

# Start here¶

# How-to guides¶

# Reference guides¶

# Explanation¶

# Further topics¶


---


# pytest-2.3: reasoning for fixture/funcarg evolution - pytest documentation

URL: https://docs.pytest.org/en/stable/funcarg_compare.html


# pytest-2.3: reasoning for fixture/funcarg evolution¶

Target audience : Reading this document requires basic knowledge of python testing, xUnit setup methods and the (previous) basic pytest funcarg mechanism, see funcargs and pytest_funcarg__ . If you are new to pytest, then you can simply ignore this section and read the other sections.

# Shortcomings of the previouspytest_funcarg__mechanism¶

The pre pytest-2.3 funcarg mechanism calls a factory each time a funcarg for a test function is required. If a factory wants to reuse a resource across different scopes, it often used the request.cached_setup() helper to manage caching of resources. Here is a basic example how we could implement a per-session Database object:

```

# content of conftest.py
class
Database
:
def
__init__
(
self
):
print
(
"database instance created"
)
def
destroy
(
self
):
print
(
"database instance destroyed"
)
def
pytest_funcarg__db
(
request
):
return
request
.
cached_setup
(
setup
=
DataBase
,
teardown
=
lambda
db
:
db
.
destroy
,
scope
=
"session"
)

```

There are several limitations and difficulties with this approach: Scoping funcarg resource creation is not straight forward, instead one must understand the intricate cached_setup() method mechanics. parametrizing the “db” resource is not straight forward: you need to apply a “parametrize” decorator or implement a pytest_generate_tests hook calling parametrize() which performs parametrization at the places where the resource is used. Moreover, you need to modify the factory to use an extrakey parameter containing request.param to the Request.cached_setup call. Multiple parametrized session-scoped resources will be active at the same time, making it hard for them to affect global state of the application under test. there is no way how you can make use of funcarg factories in xUnit setup methods. A non-parametrized fixture function cannot use a parametrized funcarg resource if it isn’t stated in the test function signature. All of these limitations are addressed with pytest-2.3 and its improved fixture mechanism .

# Direct scoping of fixture/funcarg factories¶

Instead of calling cached_setup() with a cache scope, you can use the @pytest.fixture decorator and directly state the scope:

```

@pytest
.
fixture
(
scope
=
"session"
)
def
db
(
request
):
# factory will only be invoked once per session -
db
=
DataBase
()
request
.
addfinalizer
(
db
.
destroy
)
# destroy when session is finished
return
db

```

This factory implementation does not need to call cached_setup() anymore because it will only be invoked once per session. Moreover, the request.addfinalizer() registers a finalizer according to the specified resource scope on which the factory function is operating.

# Direct parametrization of funcarg resource factories¶

Previously, funcarg factories could not directly cause parametrization. You needed to specify a @parametrize decorator on your test function or implement a pytest_generate_tests hook to perform parametrization, i.e. calling a test multiple times with different value sets. pytest-2.3 introduces a decorator for use on the factory itself:

```

@pytest
.
fixture
(
params
=
[
"mysql"
,
"pg"
])
def
db
(
request
):
...
# use request.param

```

Here the factory will be invoked twice (with the respective “mysql” and “pg” values set as request.param attributes) and all of the tests requiring “db” will run twice as well. The “mysql” and “pg” values will also be used for reporting the test-invocation variants. This new way of parametrizing funcarg factories should in many cases allow to reuse already written factories because effectively request.param was already used when test functions/classes were parametrized via metafunc.parametrize(indirect=True) calls. Of course it’s perfectly fine to combine parametrization and scoping:

```

@pytest
.
fixture
(
scope
=
"session"
,
params
=
[
"mysql"
,
"pg"
])
def
db
(
request
):
if
request
.
param
==
"mysql"
:
db
=
MySQL
()
elif
request
.
param
==
"pg"
:
db
=
PG
()
request
.
addfinalizer
(
db
.
destroy
)
# destroy when session is finished
return
db

```

This would execute all tests requiring the per-session “db” resource twice, receiving the values created by the two respective invocations to the factory function.

# Nopytest_funcarg__prefix when using @fixture decorator¶

When using the @fixture decorator the name of the function denotes the name under which the resource can be accessed as a function argument:

```

@pytest
.
fixture
()
def
db
(
request
):
...

```

The name under which the funcarg resource can be requested is db . You can still use the “old” non-decorator way of specifying funcarg factories aka:

```

def
pytest_funcarg__db
(
request
):
...

```

But it is then not possible to define scoping and parametrization. It is thus recommended to use the factory decorator.

# solving per-session setup / autouse fixtures¶

pytest for a long time offered a pytest_configure and a pytest_sessionstart hook which are often used to setup global resources. This suffers from several problems: in distributed testing the managing process would setup test resources that are never needed because it only coordinates the test run activities of the worker processes. if you only perform a collection (with “–collect-only”) resource-setup will still be executed. If a pytest_sessionstart is contained in some subdirectories conftest.py file, it will not be called. This stems from the fact that this hook is actually used for reporting, in particular the test-header with platform/custom information. Moreover, it was not easy to define a scoped setup from plugins or conftest files other than to implement a pytest_runtest_setup() hook and caring for scoping/caching yourself. And it’s virtually impossible to do this with parametrization as pytest_runtest_setup() is called during test execution and parametrization happens at collection time. It follows that pytest_configure/session/runtest_setup are often not appropriate for implementing common fixture needs. Therefore, pytest-2.3 introduces Autouse fixtures (fixtures you don’t have to request) which fully integrate with the generic fixture mechanism and obsolete many prior uses of pytest hooks.

# funcargs/fixture discovery now happens at collection time¶

Since pytest-2.3, discovery of fixture/funcarg factories are taken care of at collection time. This is more efficient especially for large test suites. Moreover, a call to “pytest –collect-only” should be able to in the future show a lot of setup-information and thus presents a nice method to get an overview of fixture management in your project.

# Conclusion and compatibility notes¶


---


# Historical Notes - pytest documentation

URL: https://docs.pytest.org/en/stable/historical-notes.html


# Historical Notes¶

This page lists features or behavior from previous versions of pytest which have changed over the years. They are kept here as a historical note so users looking at old code can find documentation related to them.

# Marker revamp and iteration¶

Changed in version 3.6. pytest’s marker implementation traditionally worked by simply updating the __dict__ attribute of functions to cumulatively add markers. As a result, markers would unintentionally be passed along class hierarchies in surprising ways. Further, the API for retrieving them was inconsistent, as markers from parameterization would be stored differently than markers applied using the @pytest.mark decorator and markers added via node.add_marker . This state of things made it technically next to impossible to use data from markers correctly without having a deep understanding of the internals, leading to subtle and hard to understand bugs in more advanced usages. Depending on how a marker got declared/changed one would get either a MarkerInfo which might contain markers from sibling classes, MarkDecorators when marks came from parameterization or from a node.add_marker call, discarding prior marks. Also MarkerInfo acts like a single mark, when it in fact represents a merged view on multiple marks with the same name. On top of that markers were not accessible in the same way for modules, classes, and functions/methods. In fact, markers were only accessible in functions, even if they were declared on classes/modules. A new API to access markers has been introduced in pytest 3.6 in order to solve the problems with the initial design, providing the _pytest.nodes.Node.iter_markers() method to iterate over markers in a consistent manner and reworking the internals, which solved a great deal of problems with the initial design.

# Updating code¶

The old Node.get_marker(name) function is considered deprecated because it returns an internal MarkerInfo object which contains the merged name, *args and **kwargs of all the markers which apply to that node. In general there are two scenarios on how markers should be handled: 1. Marks overwrite each other. Order matters but you only want to think of your mark as a single item. E.g. log_level('info') at a module level can be overwritten by log_level('debug') for a specific test. In this case, use Node.get_closest_marker(name) :

```

# replace this:
marker
=
item
.
get_marker
(
"log_level"
)
if
marker
:
level
=
marker
.
args
[
0
]
# by this:
marker
=
item
.
get_closest_marker
(
"log_level"
)
if
marker
:
level
=
marker
.
args
[
0
]

```

2. Marks compose in an additive manner. E.g. skipif(condition) marks mean you just want to evaluate all of them, order doesn’t even matter. You probably want to think of your marks as a set here. In this case iterate over each mark and handle their *args and **kwargs individually.

```

# replace this
skipif
=
item
.
get_marker
(
"skipif"
)
if
skipif
:
for
condition
in
skipif
.
args
:
# eval condition
...
# by this:
for
skipif
in
item
.
iter_markers
(
"skipif"
):
condition
=
skipif
.
args
[
0
]
# eval condition

```

If you are unsure or have any questions, please consider opening an issue .

# Related issues¶

Here is a non-exhaustive list of issues fixed by the new implementation: Marks don’t pick up nested classes ( #199 ). Markers stain on all related classes ( #568 ). Combining marks - args and kwargs calculation ( #2897 ). request.node.get_marker('name') returns None for markers applied in classes ( #902 ). Marks applied in parametrize are stored as markdecorator ( #2400 ). Fix marker interaction in a backward incompatible way ( #1670 ). Refactor marks to get rid of the current “marks transfer” mechanism ( #2363 ). Introduce FunctionDefinition node, use it in generate_tests ( #2522 ). Remove named marker attributes and collect markers in items ( #891 ). skipif mark from parametrize hides module level skipif mark ( #1540 ). skipif + parametrize not skipping tests ( #1296 ). Marker transfer incompatible with inheritance ( #535 ). More details can be found in the original PR . Note in a future major release of pytest we will introduce class based markers, at which point markers will no longer be limited to instances of Mark .

# cache plugin integrated into the core¶

The functionality of the core cache plugin was previously distributed as a third party plugin named pytest-cache . The core plugin is compatible regarding command line options and API usage except that you can only store/receive data between test runs that is json-serializable.

# funcargs andpytest_funcarg__¶

In versions prior to 2.3 there was no @pytest.fixture marker and you had to use a magic pytest_funcarg__NAME prefix for the fixture factory. This remains and will remain supported but is not anymore advertised as the primary means of declaring fixture functions.

# @pytest.yield_fixturedecorator¶

Prior to version 2.10, in order to use a yield statement to execute teardown code one had to mark a fixture using the yield_fixture marker. From 2.10 onward, normal fixtures can use yield directly so the yield_fixture decorator is no longer needed and considered deprecated.

# [pytest]header insetup.cfg¶

Prior to 3.0, the supported section name was [pytest] . Due to how this may collide with some distutils commands, the recommended section name for setup.cfg files is now [tool:pytest] . Note that for pytest.ini and tox.ini files the section name is [pytest] .

# Applying marks to@pytest.mark.parametrizeparameters¶

Prior to version 3.1 the supported mechanism for marking values used the syntax:

```

import
pytest
@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[(
"3+5"
,
8
),
(
"2+4"
,
6
),
pytest
.
mark
.
xfail
((
"6*9"
,
42
))]
)
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

This was an initial hack to support the feature but soon was demonstrated to be incomplete, broken for passing functions or applying multiple marks with the same name but different parameters. The old syntax is planned to be removed in pytest-4.0.

# @pytest.mark.parametrizeargument names as a tuple¶

In versions prior to 2.4 one needed to specify the argument names as a tuple. This remains valid but the simpler "name1,name2,..." comma-separated-string syntax is now advertised first because it’s easier to write and produces less line noise.

# setup: is now an “autouse fixture”¶

During development prior to the pytest-2.3 release the name pytest.setup was used but before the release it was renamed and moved to become part of the general fixture mechanism, namely Autouse fixtures (fixtures you don’t have to request)

# Conditions as strings instead of booleans¶

Prior to pytest-2.4 the only way to specify skipif/xfail conditions was to use strings:

```

import
sys
@pytest
.
mark
.
skipif
(
"sys.version_info >= (3,3)"
)
def
test_function
():
...

```

During test function setup the skipif condition is evaluated by calling eval('sys.version_info >= (3,0)', namespace) . The namespace contains all the module globals, and os and sys as a minimum. Since pytest-2.4 boolean conditions are considered preferable because markers can then be freely imported between test modules. With strings you need to import not only the marker but all variables used by the marker, which violates encapsulation. The reason for specifying the condition as a string was that pytest can report a summary of skip conditions based purely on the condition string. With conditions as booleans you are required to specify a reason string. Note that string conditions will remain fully supported and you are free to use them if you have no need for cross-importing markers. The evaluation of a condition string in pytest.mark.skipif(conditionstring) or pytest.mark.xfail(conditionstring) takes place in a namespace dictionary which is constructed as follows: the namespace is initialized by putting the sys and os modules and the pytest config object into it. updated with the module globals of the test function for which the expression is applied. The pytest config object allows you to skip based on a test configuration value which you might have added:

```

@pytest
.
mark
.
skipif
(
"not config.getvalue('db')"
)
def
test_function
():
...

```

The equivalent with “boolean conditions” is:

```

@pytest
.
mark
.
skipif
(
not
pytest
.
config
.
getvalue
(
"db"
),
reason
=
"--db was not specified"
)
def
test_function
():
pass

```

Note You cannot use pytest.config.getvalue() in code imported before pytest’s argument parsing takes place. For example, conftest.py files are imported before command line parsing and thus config.getvalue() will not execute correctly.

# pytest.set_trace()¶

Previous to version 2.4 to set a break point in code one needed to use pytest.set_trace() :

```

import
pytest
def
test_function
():
...
pytest
.
set_trace
()
# invoke PDB debugger and tracing

```

This is no longer needed and one can use the native import pdb;pdb.set_trace() call directly. For more details see Setting breakpoints .

# “compat” properties¶


---


# Deprecations and Removals - pytest documentation

URL: https://docs.pytest.org/en/stable/deprecations.html


# Deprecations and Removals¶

This page lists all pytest features that are currently deprecated or have been removed in past major releases. The objective is to give users a clear rationale why a certain feature has been removed, and what alternatives should be used instead.

# Deprecated Features¶

Below is a complete list of all pytest features which are considered deprecated. Using those features will issue PytestWarning or subclasses, which can be filtered using standard warning filters .

# pytest.importorskipdefault behavior regardingImportError¶

Deprecated since version 8.2. Traditionally pytest.importorskip() will capture ImportError , with the original intent being to skip tests where a dependent module is not installed, for example testing with different dependencies. However some packages might be installed in the system, but are not importable due to some other issue, for example, a compilation error or a broken installation. In those cases pytest.importorskip() would still silently skip the test, but more often than not users would like to see the unexpected error so the underlying issue can be fixed. In 8.2 the exc_type parameter has been added, giving users the ability of passing ModuleNotFoundError to skip tests only if the module cannot really be found, and not because of some other error. Catching only ModuleNotFoundError by default (and letting other errors propagate) would be the best solution, however for backward compatibility, pytest will keep the existing behavior but raise an warning if: The captured exception is of type ImportError , and: The user does not pass exc_type explicitly. If the import attempt raises ModuleNotFoundError (the usual case), then the module is skipped and no warning is emitted. This way, the usual cases will keep working the same way, while unexpected errors will now issue a warning, with users being able to suppress the warning by passing exc_type=ImportError explicitly. In 9.0 , the warning will turn into an error, and in 9.1 pytest.importorskip() will only capture ModuleNotFoundError by default and no warnings will be issued anymore – but users can still capture ImportError by passing it to exc_type .

# fspathargument for Node constructors replaced withpathlib.Path¶

Deprecated since version 7.0. In order to support the transition from py.path.local to pathlib , the fspath argument to Node constructors like pytest.Function.from_parent() and pytest.Class.from_parent() is now deprecated. Plugins which construct nodes should pass the path argument, of type pathlib.Path , instead of the fspath argument. Plugins which implement custom items and collectors are encouraged to replace fspath parameters ( py.path.local ) with path parameters ( pathlib.Path ), and drop any other usage of the py library if possible. If possible, plugins with custom items should use cooperative constructors to avoid hardcoding arguments they only pass on to the superclass. Note The name of the Node arguments and attributes (the new attribute being path ) is the opposite of the situation for hooks, outlined below (the old argument being path ). This is an unfortunate artifact due to historical reasons, which should be resolved in future versions as we slowly get rid of the py dependency (see #9283 for a longer discussion). Due to the ongoing migration of methods like reportinfo() which still is expected to return a py.path.local object, nodes still have both fspath ( py.path.local ) and path ( pathlib.Path ) attributes, no matter what argument was used in the constructor. We expect to deprecate the fspath attribute in a future release.

# Configuring hook specs/impls using markers¶

Before pluggy, pytest’s plugin library, was its own package and had a clear API, pytest just used pytest.mark to configure hooks. The pytest.hookimpl() and pytest.hookspec() decorators have been available since years and should be used instead.

```

@pytest
.
mark
.
tryfirst
def
pytest_runtest_call
():
...
# or
def
pytest_runtest_call
():
...
pytest_runtest_call
.
tryfirst
=
True

```

should be changed to:

```

@pytest
.
hookimpl
(
tryfirst
=
True
)
def
pytest_runtest_call
():
...

```

Changed hookimpl attributes: tryfirst trylast optionalhook hookwrapper Changed hookwrapper attributes: firstresult historic

# py.path.localarguments for hooks replaced withpathlib.Path¶

Deprecated since version 7.0. In order to support the transition from py.path.local to pathlib , the following hooks now receive additional arguments: pytest_ignore_collect(collection_path: pathlib.Path) as equivalent to path pytest_collect_file(file_path: pathlib.Path) as equivalent to path pytest_pycollect_makemodule(module_path: pathlib.Path) as equivalent to path pytest_report_header(start_path: pathlib.Path) as equivalent to startdir pytest_report_collectionfinish(start_path: pathlib.Path) as equivalent to startdir The accompanying py.path.local based paths have been deprecated: plugins which manually invoke those hooks should only pass the new pathlib.Path arguments, and users should change their hook implementations to use the new pathlib.Path arguments. Note The name of the Node arguments and attributes, outlined above (the new attribute being path ) is the opposite of the situation for hooks (the old argument being path ). This is an unfortunate artifact due to historical reasons, which should be resolved in future versions as we slowly get rid of the py dependency (see #9283 for a longer discussion).

# Directly constructing internal classes¶

Deprecated since version 7.0. Directly constructing the following classes is now deprecated: _pytest.mark.structures.Mark _pytest.mark.structures.MarkDecorator _pytest.mark.structures.MarkGenerator _pytest.python.Metafunc _pytest.runner.CallInfo _pytest._code.ExceptionInfo _pytest.config.argparsing.Parser _pytest.config.argparsing.OptionGroup _pytest.pytester.HookRecorder These constructors have always been considered private, but now issue a deprecation warning, which may become a hard error in pytest 8.

# Diamond inheritance betweenpytest.Collectorandpytest.Item¶

Deprecated since version 7.0. Defining a custom pytest node type which is both an Item and a Collector (e.g. File ) now issues a warning. It was never sanely supported and triggers hard to debug errors. Some plugins providing linting/code analysis have been using this as a hack. Instead, a separate collector node should be used, which collects the item. See Working with non-python tests for an example, as well as an example pr fixing inheritance .

# Constructors of customNodesubclasses should take**kwargs¶

Deprecated since version 7.0. If custom subclasses of nodes like pytest.Item override the __init__ method, they should take **kwargs . Thus,

```

class
CustomItem
(
pytest
.
Item
):
def
__init__
(
self
,
name
,
parent
,
additional_arg
):
super
()
.
__init__
(
name
,
parent
)
self
.
additional_arg
=
additional_arg

```

should be turned into:

```

class
CustomItem
(
pytest
.
Item
):
def
__init__
(
self
,
*
,
additional_arg
,
**
kwargs
):
super
()
.
__init__
(
**
kwargs
)
self
.
additional_arg
=
additional_arg

```

to avoid hard-coding the arguments pytest can pass to the superclass. See Working with non-python tests for a full example. For cases without conflicts, no deprecation warning is emitted. For cases with conflicts (such as pytest.File now taking path instead of fspath , as outlined above ), a deprecation warning is now raised.

# Applying a mark to a fixture function¶

Deprecated since version 7.4. Applying a mark to a fixture function never had any effect, but it is a common user error.

```

@pytest
.
mark
.
usefixtures
(
"clean_database"
)
@pytest
.
fixture
def
user
()
->
User
:
...

```

Users expected in this case that the usefixtures mark would have its intended effect of using the clean_database fixture when user was invoked, when in fact it has no effect at all. Now pytest will issue a warning when it encounters this problem, and will raise an error in the future versions.

# Returning non-None value in test functions¶

Deprecated since version 7.2. A pytest.PytestReturnNotNoneWarning is now emitted if a test function returns something other than None . This prevents a common mistake among beginners that expect that returning a bool would cause a test to pass or fail, for example:

```

@pytest
.
mark
.
parametrize
(
[
"a"
,
"b"
,
"result"
],
[
[
1
,
2
,
5
],
[
2
,
3
,
8
],
[
5
,
3
,
18
],
],
)
def
test_foo
(
a
,
b
,
result
):
return
foo
(
a
,
b
)
==
result

```

Given that pytest ignores the return value, this might be surprising that it will never fail. The proper fix is to change the return to an assert :

```

@pytest
.
mark
.
parametrize
(
[
"a"
,
"b"
,
"result"
],
[
[
1
,
2
,
5
],
[
2
,
3
,
8
],
[
5
,
3
,
18
],
],
)
def
test_foo
(
a
,
b
,
result
):
assert
foo
(
a
,
b
)
==
result

```

# Theyield_fixturefunction/decorator¶

Deprecated since version 6.2. pytest.yield_fixture is a deprecated alias for pytest.fixture() . It has been so for a very long time, so can be search/replaced safely.

# Removed Features and Breaking Changes¶

As stated in our Backwards Compatibility Policy policy, deprecated features are removed only in major releases after an appropriate period of deprecation has passed. Some breaking changes which could not be deprecated are also listed.

# Support for tests written for nose¶

Deprecated since version 7.2. Removed in version 8.0. Support for running tests written for nose is now deprecated. nose has been in maintenance mode-only for years, and maintaining the plugin is not trivial as it spills over the code base (see #9886 for more details).

# setup/teardown¶

One thing that might catch users by surprise is that plain setup and teardown methods are not pytest native, they are in fact part of the nose support.

```

class
Test
:
def
setup
(
self
):
self
.
resource
=
make_resource
()
def
teardown
(
self
):
self
.
resource
.
close
()
def
test_foo
(
self
):
...
def
test_bar
(
self
):
...

```

Native pytest support uses setup_method and teardown_method (see Method and function level setup/teardown ), so the above should be changed to:

```

class
Test
:
def
setup_method
(
self
):
self
.
resource
=
make_resource
()
def
teardown_method
(
self
):
self
.
resource
.
close
()
def
test_foo
(
self
):
...
def
test_bar
(
self
):
...

```

This is easy to do in an entire code base by doing a simple find/replace.

# @with_setup¶

Code using @with_setup such as this:

```

from
nose.tools
import
with_setup
def
setup_some_resource
():
...
def
teardown_some_resource
():
...
@with_setup
(
setup_some_resource
,
teardown_some_resource
)
def
test_foo
():
...

```

Will also need to be ported to a supported pytest style. One way to do it is using a fixture:

```

import
pytest
def
setup_some_resource
():
...
def
teardown_some_resource
():
...
@pytest
.
fixture
def
some_resource
():
setup_some_resource
()
yield
teardown_some_resource
()
def
test_foo
(
some_resource
):
...

```

# Thecompat_co_firstlinenoattribute¶

Nose inspects this attribute on function objects to allow overriding the function’s inferred line number. Pytest no longer respects this attribute.

# Passingmsg=topytest.skip,pytest.failorpytest.exit¶

Deprecated since version 7.0. Removed in version 8.0. Passing the keyword argument msg to pytest.skip() , pytest.fail() or pytest.exit() is now deprecated and reason should be used instead. This change is to bring consistency between these functions and the @pytest.mark.skip and @pytest.mark.xfail markers which already accept a reason argument.

```

def
test_fail_example
():
# old
pytest
.
fail
(
msg
=
"foo"
)
# new
pytest
.
fail
(
reason
=
"bar"
)
def
test_skip_example
():
# old
pytest
.
skip
(
msg
=
"foo"
)
# new
pytest
.
skip
(
reason
=
"bar"
)
def
test_exit_example
():
# old
pytest
.
exit
(
msg
=
"foo"
)
# new
pytest
.
exit
(
reason
=
"bar"
)

```

# Thepytest.Instancecollector¶

Removed in version 7.0. The pytest.Instance collector type has been removed. Previously, Python test methods were collected as Class -> Instance -> Function . Now Class collects the test methods directly. Most plugins which reference Instance do so in order to ignore or skip it, using a check such as if isinstance(node, Instance): return . Such plugins should simply remove consideration of Instance on pytest>=7. However, to keep such uses working, a dummy type has been instanced in pytest.Instance and _pytest.python.Instance , and importing it emits a deprecation warning. This was removed in pytest 8.

# Usingpytest.warns(None)¶

Deprecated since version 7.0. Removed in version 8.0. pytest.warns(None) is now deprecated because it was frequently misused. Its correct usage was checking that the code emits at least one warning of any type - like pytest.warns() or pytest.warns(Warning) . See Additional use cases of warnings in tests for examples.

# Backward compatibilities inParser.addoption¶

Deprecated since version 2.4. Removed in version 8.0. Several behaviors of Parser.addoption are now removed in pytest 8 (deprecated since pytest 2.4.0): parser.addoption(..., help=".. %default ..") - use %(default)s instead. parser.addoption(..., type="int/string/float/complex") - use type=int etc. instead.

# The--strictcommand-line option¶

Deprecated since version 6.2. Removed in version 8.0. The --strict command-line option has been deprecated in favor of --strict-markers , which better conveys what the option does. We have plans to maybe in the future to reintroduce --strict and make it an encompassing flag for all strictness related options ( --strict-markers and --strict-config at the moment, more might be introduced in the future).

# Implementing thepytest_cmdline_preparsehook¶

Deprecated since version 7.0. Removed in version 8.0. Implementing the pytest_cmdline_preparse hook has been officially deprecated. Implement the pytest_load_initial_conftests hook instead.

```

def
pytest_cmdline_preparse
(
config
:
Config
,
args
:
List
[
str
])
->
None
:
...
# becomes:
def
pytest_load_initial_conftests
(
early_config
:
Config
,
parser
:
Parser
,
args
:
List
[
str
]
)
->
None
:
...

```

# Collection changes in pytest 8¶

Added a new pytest.Directory base collection node, which all collector nodes for filesystem directories are expected to subclass. This is analogous to the existing pytest.File for file nodes. Changed pytest.Package to be a subclass of pytest.Directory . A Package represents a filesystem directory which is a Python package, i.e. contains an __init__.py file. pytest.Package now only collects files in its own directory; previously it collected recursively. Sub-directories are collected as sub-collector nodes, thus creating a collection tree which mirrors the filesystem hierarchy. session.name is now "" ; previously it was the rootdir directory name. This matches session.nodeid which has always been "" . Added a new pytest.Dir concrete collection node, a subclass of pytest.Directory . This node represents a filesystem directory, which is not a pytest.Package , i.e. does not contain an __init__.py file. Similarly to Package , it only collects the files in its own directory, while collecting sub-directories as sub-collector nodes. Files and directories are now collected in alphabetical order jointly, unless changed by a plugin. Previously, files were collected before directories. The collection tree now contains directories/packages up to the rootdir , for initial arguments that are found within the rootdir. For files outside the rootdir, only the immediate directory/package is collected – note however that collecting from outside the rootdir is discouraged. As an example, given the following filesystem tree:

```

myroot/
    pytest.ini
    top/
    ├── aaa
    │   └── test_aaa.py
    ├── test_a.py
    ├── test_b
    │   ├── __init__.py
    │   └── test_b.py
    ├── test_c.py
    └── zzz
        ├── __init__.py
        └── test_zzz.py

```

the collection tree, as shown by pytest --collect-only top/ but with the otherwise-hidden Session node added for clarity, is now the following:

```

<
Session
>
<
Dir
myroot
>
<
Dir
top
>
<
Dir
aaa
>
<
Module
test_aaa
.
py
>
<
Function
test_it
>
<
Module
test_a
.
py
>
<
Function
test_it
>
<
Package
test_b
>
<
Module
test_b
.
py
>
<
Function
test_it
>
<
Module
test_c
.
py
>
<
Function
test_it
>
<
Package
zzz
>
<
Module
test_zzz
.
py
>
<
Function
test_it
>

```

Previously, it was:

```

<
Session
>
<
Module
top
/
test_a
.
py
>
<
Function
test_it
>
<
Module
top
/
test_c
.
py
>
<
Function
test_it
>
<
Module
top
/
aaa
/
test_aaa
.
py
>
<
Function
test_it
>
<
Package
test_b
>
<
Module
test_b
.
py
>
<
Function
test_it
>
<
Package
zzz
>
<
Module
test_zzz
.
py
>
<
Function
test_it
>

```

Code/plugins which rely on a specific shape of the collection tree might need to update.

# pytest.Packageis no longer apytest.Moduleorpytest.File¶

Changed in version 8.0. The Package collector node designates a Python package, that is, a directory with an __init__.py file. Previously Package was a subtype of pytest.Module (which represents a single Python module), the module being the __init__.py file. This has been deemed a design mistake (see #11137 and #7777 for details). The path property of Package nodes now points to the package directory instead of the __init__.py file. Note that a Module node for __init__.py (which is not a Package ) may still exist, if it is picked up during collection (e.g. if you configured python_files to include __init__.py files).

# Collecting__init__.pyfiles no longer collects package¶

Removed in version 8.0. Running pytest pkg/__init__.py now collects the pkg/__init__.py file (module) only. Previously, it collected the entire pkg package, including other test files in the directory, but excluding tests in the __init__.py file itself (unless python_files was changed to allow __init__.py file). To collect the entire package, specify just the directory: pytest pkg .

# Thepytest.collectmodule¶

Deprecated since version 6.0. Removed in version 7.0. The pytest.collect module is no longer part of the public API, all its names should now be imported from pytest directly instead.

# Thepytest_warning_capturedhook¶

Deprecated since version 6.0. Removed in version 7.0. This hook has an item parameter which cannot be serialized by pytest-xdist . Use the pytest_warning_recorded hook instead, which replaces the item parameter by a nodeid parameter.

# Thepytest._fillfuncargsfunction¶

Deprecated since version 6.0. Removed in version 7.0. This function was kept for backward compatibility with an older plugin. It’s functionality is not meant to be used directly, but if you must replace it, use function._request._fillfixtures() instead, though note this is not a public API and may break in the future.

# --no-print-logscommand-line option¶

Deprecated since version 5.4. Removed in version 6.0. The --no-print-logs option and log_print ini setting are removed. If you used them, please use --show-capture instead. A --show-capture command-line option was added in pytest 3.5.0 which allows to specify how to display captured output when tests fail: no , stdout , stderr , log or all (the default).

# Result log (--result-log)¶

Deprecated since version 4.0. Removed in version 6.0. The --result-log option produces a stream of test reports which can be analysed at runtime, but it uses a custom format which requires users to implement their own parser. The pytest-reportlog plugin provides a --report-log option, a more standard and extensible alternative, producing one JSON object per-line, and should cover the same use cases. Please try it out and provide feedback. The pytest-reportlog plugin might even be merged into the core at some point, depending on the plans for the plugins and number of users using it.

# pytest_collect_directoryhook¶

Removed in version 6.0. The pytest_collect_directory hook has not worked properly for years (it was called but the results were ignored). Users may consider using pytest_collection_modifyitems instead.

# TerminalReporter.writer¶

Removed in version 6.0. The TerminalReporter.writer attribute has been deprecated and should no longer be used. This was inadvertently exposed as part of the public API of that plugin and ties it too much with py.io.TerminalWriter . Plugins that used TerminalReporter.writer directly should instead use TerminalReporter methods that provide the same functionality.

# junit_familydefault value change to “xunit2”¶

Changed in version 6.0. The default value of junit_family option will change to xunit2 in pytest 6.0, which is an update of the old xunit1 format and is supported by default in modern tools that manipulate this type of file (for example, Jenkins, Azure Pipelines, etc.). Users are recommended to try the new xunit2 format and see if their tooling that consumes the JUnit XML file supports it. To use the new format, update your pytest.ini :

```

[pytest]
junit_family
=
xunit2

```

If you discover that your tooling does not support the new format, and want to keep using the legacy version, set the option to legacy instead:

```

[pytest]
junit_family
=
legacy

```

By using legacy you will keep using the legacy/xunit1 format when upgrading to pytest 6.0, where the default format will be xunit2 . In order to let users know about the transition, pytest will issue a warning in case the --junit-xml option is given in the command line but junit_family is not explicitly configured in pytest.ini . Services known to support the xunit2 format: Jenkins with the JUnit plugin. Azure Pipelines .

# Node Construction changed toNode.from_parent¶

Changed in version 6.0. The construction of nodes now should use the named constructor from_parent . This limitation in api surface intends to enable better/simpler refactoring of the collection tree. This means that instead of MyItem(name="foo", parent=collector, obj=42) one now has to invoke MyItem.from_parent(collector, name="foo") . Plugins that wish to support older versions of pytest and suppress the warning can use hasattr to check if from_parent exists in that version:

```

def
pytest_pycollect_makeitem
(
collector
,
name
,
obj
):
if
hasattr
(
MyItem
,
"from_parent"
):
item
=
MyItem
.
from_parent
(
collector
,
name
=
"foo"
)
item
.
obj
=
42
return
item
else
:
return
MyItem
(
name
=
"foo"
,
parent
=
collector
,
obj
=
42
)

```

Note that from_parent should only be called with keyword arguments for the parameters.

# pytest.fixturearguments are keyword only¶

Removed in version 6.0. Passing arguments to pytest.fixture() as positional arguments has been removed - pass them by keyword instead.

# funcargnamesalias forfixturenames¶

Removed in version 6.0. The FixtureRequest , Metafunc , and Function classes track the names of their associated fixtures, with the aptly-named fixturenames attribute. Prior to pytest 2.3, this attribute was named funcargnames , and we have kept that as an alias since. It is finally due for removal, as it is often confusing in places where we or plugin authors must distinguish between fixture names and names supplied by non-fixture things such as pytest.mark.parametrize .

# pytest.configglobal¶

Removed in version 5.0. The pytest.config global object is deprecated. Instead use request.config (via the request fixture) or if you are a plugin author use the pytest_configure(config) hook. Note that many hooks can also access the config object indirectly, through session.config or item.config for example.

# "message"parameter ofpytest.raises¶

Removed in version 5.0. It is a common mistake to think this parameter will match the exception message, while in fact it only serves to provide a custom message in case the pytest.raises check fails. To prevent users from making this mistake, and because it is believed to be little used, pytest is deprecating it without providing an alternative for the moment. If you have a valid use case for this parameter, consider that to obtain the same results you can just call pytest.fail manually at the end of the with statement. For example:

```

with
pytest
.
raises
(
TimeoutError
,
message
=
"Client got unexpected message"
):
wait_for
(
websocket
.
recv
(),
0.5
)

```

Becomes:

```

with
pytest
.
raises
(
TimeoutError
):
wait_for
(
websocket
.
recv
(),
0.5
)
pytest
.
fail
(
"Client got unexpected message"
)

```

If you still have concerns about this deprecation and future removal, please comment on #3974 .

# raises/warnswith a string as the second argument¶

Removed in version 5.0. Use the context manager form of these instead. When necessary, invoke exec directly. Example:

```

pytest
.
raises
(
ZeroDivisionError
,
"1 / 0"
)
pytest
.
raises
(
SyntaxError
,
"a $ b"
)
pytest
.
warns
(
DeprecationWarning
,
"my_function()"
)
pytest
.
warns
(
SyntaxWarning
,
"assert(1, 2)"
)

```

Becomes:

```

with
pytest
.
raises
(
ZeroDivisionError
):
1
/
0
with
pytest
.
raises
(
SyntaxError
):
exec
(
"a $ b"
)
# exec is required for invalid syntax
with
pytest
.
warns
(
DeprecationWarning
):
my_function
()
with
pytest
.
warns
(
SyntaxWarning
):
exec
(
"assert(1, 2)"
)
# exec is used to avoid a top-level warning

```

# UsingClassin custom Collectors¶

Removed in version 4.0. Using objects named "Class" as a way to customize the type of nodes that are collected in Collector subclasses has been deprecated. Users instead should use pytest_pycollect_makeitem to customize node types during collection. This issue should affect only advanced plugins who create new collection types, so if you see this warning message please contact the authors so they can change the code.

# marks inpytest.mark.parametrize¶

Removed in version 4.0. Applying marks to values of a pytest.mark.parametrize call is now deprecated. For example:

```

@pytest
.
mark
.
parametrize
(
"a, b"
,
[
(
3
,
9
),
pytest
.
mark
.
xfail
(
reason
=
"flaky"
)(
6
,
36
),
(
10
,
100
),
(
20
,
200
),
(
40
,
400
),
(
50
,
500
),
],
)
def
test_foo
(
a
,
b
):
...

```

This code applies the pytest.mark.xfail(reason="flaky") mark to the (6, 36) value of the above parametrization call. This was considered hard to read and understand, and also its implementation presented problems to the code preventing further internal improvements in the marks architecture. To update the code, use pytest.param :

```

@pytest
.
mark
.
parametrize
(
"a, b"
,
[
(
3
,
9
),
pytest
.
param
(
6
,
36
,
marks
=
pytest
.
mark
.
xfail
(
reason
=
"flaky"
)),
(
10
,
100
),
(
20
,
200
),
(
40
,
400
),
(
50
,
500
),
],
)
def
test_foo
(
a
,
b
):
...

```

# pytest_funcarg__prefix¶

Removed in version 4.0. In very early pytest versions fixtures could be defined using the pytest_funcarg__ prefix:

```

def
pytest_funcarg__data
():
return
SomeData
()

```

Switch over to the @pytest.fixture decorator:

```

@pytest
.
fixture
def
data
():
return
SomeData
()

```

# [pytest] section in setup.cfg files¶

Removed in version 4.0. [pytest] sections in setup.cfg files should now be named [tool:pytest] to avoid conflicts with other distutils commands.

# Metafunc.addcall¶

Removed in version 4.0. Metafunc.addcall was a precursor to the current parametrized mechanism. Users should use pytest.Metafunc.parametrize() instead. Example:

```

def
pytest_generate_tests
(
metafunc
):
metafunc
.
addcall
({
"i"
:
1
},
id
=
"1"
)
metafunc
.
addcall
({
"i"
:
2
},
id
=
"2"
)

```

Becomes:

```

def
pytest_generate_tests
(
metafunc
):
metafunc
.
parametrize
(
"i"
,
[
1
,
2
],
ids
=
[
"1"
,
"2"
])

```

# cached_setup¶

Removed in version 4.0. request.cached_setup was the precursor of the setup/teardown mechanism available to fixtures. Example:

```

@pytest
.
fixture
def
db_session
():
return
request
.
cached_setup
(
setup
=
Session
.
create
,
teardown
=
lambda
session
:
session
.
close
(),
scope
=
"module"
)

```

This should be updated to make use of standard fixture mechanisms:

```

@pytest
.
fixture
(
scope
=
"module"
)
def
db_session
():
session
=
Session
.
create
()
yield
session
session
.
close
()

```

You can consult funcarg comparison section in the docs for more information.

# pytest_plugins in non-top-level conftest files¶

Removed in version 4.0. Defining pytest_plugins is now deprecated in non-top-level conftest.py files because they will activate referenced plugins globally , which is surprising because for all other pytest features conftest.py files are only active for tests at or below it.

# Config.warnandNode.warn¶

Removed in version 4.0. Those methods were part of the internal pytest warnings system, but since 3.8 pytest is using the builtin warning system for its own warnings, so those two functions are now deprecated. Config.warn should be replaced by calls to the standard warnings.warn , example:

```

config
.
warn
(
"C1"
,
"some warning"
)

```

Becomes:

```

warnings
.
warn
(
pytest
.
PytestWarning
(
"some warning"
))

```

Node.warn now supports two signatures: node.warn(PytestWarning("some message")) : is now the recommended way to call this function. The warning instance must be a PytestWarning or subclass. node.warn("CI", "some message") : this code/message form has been removed and should be converted to the warning instance form above.

# record_xml_property¶

Removed in version 4.0. The record_xml_property fixture is now deprecated in favor of the more generic record_property , which can be used by other consumers (for example pytest-html ) to obtain custom information about the test run. This is just a matter of renaming the fixture as the API is the same:

```

def
test_foo
(
record_xml_property
):
...

```

Change to:

```

def
test_foo
(
record_property
):
...

```

# Passing command-line string topytest.main()¶

Removed in version 4.0. Passing a command-line string to pytest.main() is deprecated:

```

pytest
.
main
(
"-v -s"
)

```

Pass a list instead:

```

pytest
.
main
([
"-v"
,
"-s"
])

```

By passing a string, users expect that pytest will interpret that command-line using the shell rules they are working on (for example bash or Powershell ), but this is very hard/impossible to do in a portable way.

# Calling fixtures directly¶

Removed in version 4.0. Calling a fixture function directly, as opposed to request them in a test function, is deprecated. For example:

```

@pytest
.
fixture
def
cell
():
return
...
@pytest
.
fixture
def
full_cell
():
cell
=
cell
()
cell
.
make_full
()
return
cell

```

This is a great source of confusion to new users, which will often call the fixture functions and request them from test functions interchangeably, which breaks the fixture resolution model. In those cases just request the function directly in the dependent fixture:

```

@pytest
.
fixture
def
cell
():
return
...
@pytest
.
fixture
def
full_cell
(
cell
):
cell
.
make_full
()
return
cell

```

Alternatively if the fixture function is called multiple times inside a test (making it hard to apply the above pattern) or if you would like to make minimal changes to the code, you can create a fixture which calls the original function together with the name parameter:

```

def
cell
():
return
...
@pytest
.
fixture
(
name
=
"cell"
)
def
cell_fixture
():
return
cell
()

```

# yieldtests¶

Removed in version 4.0. pytest supported yield -style tests, where a test function actually yield functions and values that are then turned into proper test methods. Example:

```

def
check
(
x
,
y
):
assert
x
**
x
==
y
def
test_squared
():
yield
check
,
2
,
4
yield
check
,
3
,
9

```

This would result into two actual test functions being generated. This form of test function doesn’t support fixtures properly, and users should switch to pytest.mark.parametrize :

```

@pytest
.
mark
.
parametrize
(
"x, y"
,
[(
2
,
4
),
(
3
,
9
)])
def
test_squared
(
x
,
y
):
assert
x
**
x
==
y

```

# Internal classes accessed throughNode¶

Removed in version 4.0. Access of Module , Function , Class , Instance , File and Item through Node instances now issue this warning:

```

usage of Function.Module is deprecated, please use pytest.Module instead

```

Users should just import pytest and access those objects using the pytest module. This has been documented as deprecated for years, but only now we are actually emitting deprecation warnings.

# Node.get_marker¶

Removed in version 4.0. As part of a large Marker revamp and iteration , _pytest.nodes.Node.get_marker is removed. See the documentation on tips on how to update your code.

# somefunction.markname¶

Removed in version 4.0. As part of a large Marker revamp and iteration we already deprecated using MarkInfo the only correct way to get markers of an element is via node.iter_markers(name) .

# pytest_namespace¶

Removed in version 4.0. This hook is deprecated because it greatly complicates the pytest internals regarding configuration and initialization, making some bug fixes and refactorings impossible. Example of usage:

```

class
MySymbol
:
...
def
pytest_namespace
():
return
{
"my_symbol"
:
MySymbol
()}

```

Plugin authors relying on this hook should instead require that users now import the plugin modules directly (with an appropriate public API). As a stopgap measure, plugin authors may still inject their names into pytest’s namespace, usually during pytest_configure :

```

import
pytest
def
pytest_configure
():
pytest
.
my_symbol
=
MySymbol
()

```


---


# How to install and use plugins - pytest documentation

URL: https://docs.pytest.org/en/stable/plugins.html


# How to install and use plugins¶

This section talks about installing and using third party plugins. For writing your own plugins, please refer to Writing plugins . Installing a third party plugin can be easily done with pip :

```

pip
install
pytest-NAME
pip
uninstall
pytest-NAME

```

If a plugin is installed, pytest automatically finds and integrates it, there is no need to activate it. Here is a little annotated list for some popular plugins: pytest-django : write tests for django apps, using pytest integration. pytest-twisted : write tests for twisted apps, starting a reactor and processing deferreds from test functions. pytest-cov : coverage reporting, compatible with distributed testing pytest-xdist : to distribute tests to CPUs and remote hosts, to run in boxed mode which allows to survive segmentation faults, to run in looponfailing mode, automatically re-running failing tests on file changes. pytest-instafail : to report failures while the test run is happening. pytest-bdd : to write tests using behaviour-driven testing. pytest-timeout : to timeout tests based on function marks or global definitions. pytest-pep8 : a --pep8 option to enable PEP8 compliance checking. pytest-flakes : check source code with pyflakes. allure-pytest : report test results via allure-framework . To see a complete list of all plugins with their latest testing status against different pytest and Python versions, please visit Pytest Plugin List . You may also discover more plugins through a pytest- pypi.org search .

# Requiring/Loading plugins in a test module or conftest file¶

You can require plugins in a test module or a conftest file using pytest_plugins :

```

pytest_plugins
=
(
"myapp.testsupport.myplugin"
,)

```

When the test module or conftest plugin is loaded the specified plugins will be loaded as well. Note Requiring plugins using a pytest_plugins variable in non-root conftest.py files is deprecated. See full explanation in the Writing plugins section. Note The name pytest_plugins is reserved and should not be used as a name for a custom plugin module.

# Finding out which plugins are active¶

If you want to find out which plugins are active in your environment you can type:

```

pytest
--trace-config

```

and will get an extended test header which shows activated plugins and their names. It will also print local plugins aka conftest.py files when they are loaded.

# Deactivating / unregistering a plugin by name¶

You can prevent plugins from loading or unregister them:

```

pytest
-p
no:NAME

```

This means that any subsequent try to activate/load the named plugin will not work. If you want to unconditionally disable a plugin for a project, you can add this option to your pytest.ini file:

```

[pytest]
addopts
=
-p no:NAME

```


---


# How to parametrize fixtures and test functions - pytest documentation

URL: https://docs.pytest.org/en/stable/parametrize.html


# How to parametrize fixtures and test functions¶

pytest enables test parametrization at several levels: pytest.fixture() allows one to parametrize fixture functions . @pytest.mark.parametrize allows one to define multiple sets of arguments and fixtures at the test function or class. pytest_generate_tests allows one to define custom parametrization schemes or extensions.

# @pytest.mark.parametrize: parametrizing test functions¶

The builtin pytest.mark.parametrize decorator enables parametrization of arguments for a test function. Here is a typical example of a test function that implements checking that a certain input leads to an expected output:

```

# content of test_expectation.py
import
pytest
@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[(
"3+5"
,
8
),
(
"2+4"
,
6
),
(
"6*9"
,
42
)])
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

Here, the @parametrize decorator defines three different (test_input,expected) tuples so that the test_eval function will run three times using them in turn:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 3 items

test_expectation.py
..
F
[100%]
================================= FAILURES =================================
____________________________ test_eval[6*9-42] _____________________________
test_input = '6*9', expected = 42

    @pytest.mark.parametrize("test_input,expected", [("3+5", 8), ("2+4", 6), ("6*9", 42)])
    def test_eval(test_input, expected):
>       assert eval(test_input) == expected
E       AssertionError: assert 54 == 42
E        +  where 54 = eval('6*9')
test_expectation.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_expectation.py::
test_eval[6*9-42]
- AssertionError: assert 54...
=======================
1 failed
,
2 passed
in 0.12s ========================

```

Note Parameter values are passed as-is to tests (no copy whatsoever). For example, if you pass a list or a dict as a parameter value, and the test case code mutates it, the mutations will be reflected in subsequent test case calls. Note pytest by default escapes any non-ascii characters used in unicode strings for the parametrization because it has several downsides. If however you would like to use unicode strings in parametrization and see them in the terminal as is (non-escaped), use this option in your pytest.ini :

```

[pytest]
disable_test_id_escaping_and_forfeit_all_rights_to_community_support
=
True

```

Keep in mind however that this might cause unwanted side effects and even bugs depending on the OS used and plugins currently installed, so use it at your own risk. As designed in this example, only one pair of input/output values fails the simple test function. And as usual with test function arguments, you can see the input and output values in the traceback. Note that you could also use the parametrize marker on a class or a module (see How to mark test functions with attributes ) which would invoke several functions with the argument sets, for instance:

```

import
pytest
@pytest
.
mark
.
parametrize
(
"n,expected"
,
[(
1
,
2
),
(
3
,
4
)])
class
TestClass
:
def
test_simple_case
(
self
,
n
,
expected
):
assert
n
+
1
==
expected
def
test_weird_simple_case
(
self
,
n
,
expected
):
assert
(
n
*
1
)
+
1
==
expected

```

To parametrize all tests in a module, you can assign to the pytestmark global variable:

```

import
pytest
pytestmark
=
pytest
.
mark
.
parametrize
(
"n,expected"
,
[(
1
,
2
),
(
3
,
4
)])
class
TestClass
:
def
test_simple_case
(
self
,
n
,
expected
):
assert
n
+
1
==
expected
def
test_weird_simple_case
(
self
,
n
,
expected
):
assert
(
n
*
1
)
+
1
==
expected

```

It is also possible to mark individual test instances within parametrize, for example with the builtin mark.xfail :

```

# content of test_expectation.py
import
pytest
@pytest
.
mark
.
parametrize
(
"test_input,expected"
,
[(
"3+5"
,
8
),
(
"2+4"
,
6
),
pytest
.
param
(
"6*9"
,
42
,
marks
=
pytest
.
mark
.
xfail
)],
)
def
test_eval
(
test_input
,
expected
):
assert
eval
(
test_input
)
==
expected

```

Let’s run this:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 3 items

test_expectation.py
..
x
[100%]
=======================
2 passed
,
1 xfailed
in 0.12s =======================

```

The one parameter set which caused a failure previously now shows up as an “xfailed” (expected to fail) test. In case the values provided to parametrize result in an empty list - for example, if they’re dynamically generated by some function - the behaviour of pytest is defined by the empty_parameter_set_mark option. To get all combinations of multiple parametrized arguments you can stack parametrize decorators:

```

import
pytest
@pytest
.
mark
.
parametrize
(
"x"
,
[
0
,
1
])
@pytest
.
mark
.
parametrize
(
"y"
,
[
2
,
3
])
def
test_foo
(
x
,
y
):
pass

```

This will run the test with the arguments set to x=0/y=2 , x=1/y=2 , x=0/y=3 , and x=1/y=3 exhausting parameters in the order of the decorators.

# Basicpytest_generate_testsexample¶

Sometimes you may want to implement your own parametrization scheme or implement some dynamism for determining the parameters or scope of a fixture. For this, you can use the pytest_generate_tests hook which is called when collecting a test function. Through the passed in metafunc object you can inspect the requesting test context and, most importantly, you can call metafunc.parametrize() to cause parametrization. For example, let’s say we want to run a test taking string inputs which we want to set via a new pytest command line option. Let’s first write a simple test accepting a stringinput fixture function argument:

```

# content of test_strings.py
def
test_valid_string
(
stringinput
):
assert
stringinput
.
isalpha
()

```

Now we add a conftest.py file containing the addition of a command line option and the parametrization of our test function:

```

# content of conftest.py
def
pytest_addoption
(
parser
):
parser
.
addoption
(
"--stringinput"
,
action
=
"append"
,
default
=
[],
help
=
"list of stringinputs to pass to test functions"
,
)
def
pytest_generate_tests
(
metafunc
):
if
"stringinput"
in
metafunc
.
fixturenames
:
metafunc
.
parametrize
(
"stringinput"
,
metafunc
.
config
.
getoption
(
"stringinput"
))

```

If we now pass two stringinput values, our test will run twice:

```

$ pytest -q --stringinput="hello" --stringinput="world" test_strings.py
..
[100%]
2 passed
in 0.12s

```

Let’s also run with a stringinput that will lead to a failing test:

```

$ pytest -q --stringinput="!" test_strings.py
F
[100%]
================================= FAILURES =================================
___________________________ test_valid_string[!] ___________________________
stringinput = '!'

    def test_valid_string(stringinput):
>       assert stringinput.isalpha()
E       AssertionError: assert False
E        +  where False = <built-in method isalpha of str object at 0xdeadbeef0001>()
E        +    where <built-in method isalpha of str object at 0xdeadbeef0001> = '!'.isalpha
test_strings.py
:4: AssertionError
========================= short test summary info ==========================
FAILED
test_strings.py::
test_valid_string[!]
- AssertionError: assert False
1 failed
in 0.12s

```

As expected our test function fails. If you don’t specify a stringinput it will be skipped because metafunc.parametrize() will be called with an empty parameter list:

```

$ pytest -q -rs test_strings.py
s
[100%]
========================= short test summary info ==========================
SKIPPED
[1] test_strings.py: got empty parameter set ['stringinput'], function test_valid_string at /home/sweet/project/test_strings.py:2
1 skipped
in 0.12s

```

Note that when calling metafunc.parametrize multiple times with different parameter sets, all parameter names across those sets cannot be duplicated, otherwise an error will be raised.

# More examples¶


---


# How to monkeypatch/mock modules and environments - pytest documentation

URL: https://docs.pytest.org/en/stable/monkeypatch.html


# How to monkeypatch/mock modules and environments¶

Sometimes tests need to invoke functionality which depends on global settings or which invokes code which cannot be easily tested such as network access. The monkeypatch fixture helps you to safely set/delete an attribute, dictionary item or environment variable, or to modify sys.path for importing. The monkeypatch fixture provides these helper methods for safely patching and mocking functionality in tests: monkeypatch.setattr(obj, name, value, raising=True) monkeypatch.delattr(obj, name, raising=True) monkeypatch.setitem(mapping, name, value) monkeypatch.delitem(obj, name, raising=True) monkeypatch.setenv(name, value, prepend=None) monkeypatch.delenv(name, raising=True) monkeypatch.syspath_prepend(path) monkeypatch.chdir(path) monkeypatch.context() All modifications will be undone after the requesting test function or fixture has finished. The raising parameter determines if a KeyError or AttributeError will be raised if the target of the set/deletion operation does not exist. Consider the following scenarios: 1. Modifying the behavior of a function or the property of a class for a test e.g. there is an API call or database connection you will not make for a test but you know what the expected output should be. Use monkeypatch.setattr to patch the function or property with your desired testing behavior. This can include your own functions. Use monkeypatch.delattr to remove the function or property for the test. 2. Modifying the values of dictionaries e.g. you have a global configuration that you want to modify for certain test cases. Use monkeypatch.setitem to patch the dictionary for the test. monkeypatch.delitem can be used to remove items. 3. Modifying environment variables for a test e.g. to test program behavior if an environment variable is missing, or to set multiple values to a known variable. monkeypatch.setenv and monkeypatch.delenv can be used for these patches. 4. Use monkeypatch.setenv("PATH", value, prepend=os.pathsep) to modify $PATH , and monkeypatch.chdir to change the context of the current working directory during a test. 5. Use monkeypatch.syspath_prepend to modify sys.path which will also call pkg_resources.fixup_namespace_packages and importlib.invalidate_caches() . 6. Use monkeypatch.context to apply patches only in a specific scope, which can help control teardown of complex fixtures or patches to the stdlib. See the monkeypatch blog post for some introduction material and a discussion of its motivation.

# Monkeypatching functions¶

Consider a scenario where you are working with user directories. In the context of testing, you do not want your test to depend on the running user. monkeypatch can be used to patch functions dependent on the user to always return a specific value. In this example, monkeypatch.setattr is used to patch Path.home so that the known testing path Path("/abc") is always used when the test is run. This removes any dependency on the running user for testing purposes. monkeypatch.setattr must be called before the function which will use the patched function is called. After the test function finishes the Path.home modification will be undone.

```

# contents of test_module.py with source code and the test
from
pathlib
import
Path
def
getssh
():
"""Simple function to return expanded homedir ssh path."""
return
Path
.
home
()
/
".ssh"
def
test_getssh
(
monkeypatch
):
# mocked return function to replace Path.home
# always return '/abc'
def
mockreturn
():
return
Path
(
"/abc"
)
# Application of the monkeypatch to replace Path.home
# with the behavior of mockreturn defined above.
monkeypatch
.
setattr
(
Path
,
"home"
,
mockreturn
)
# Calling getssh() will use mockreturn in place of Path.home
# for this test with the monkeypatch.
x
=
getssh
()
assert
x
==
Path
(
"/abc/.ssh"
)

```

# Monkeypatching returned objects: building mock classes¶

monkeypatch.setattr can be used in conjunction with classes to mock returned objects from functions instead of values. Imagine a simple function to take an API url and return the json response.

```

# contents of app.py, a simple API retrieval example
import
requests
def
get_json
(
url
):
"""Takes a URL, and returns the JSON."""
r
=
requests
.
get
(
url
)
return
r
.
json
()

```

We need to mock r , the returned response object for testing purposes. The mock of r needs a .json() method which returns a dictionary. This can be done in our test file by defining a class to represent r .

```

# contents of test_app.py, a simple test for our API retrieval
# import requests for the purposes of monkeypatching
import
requests
# our app.py that includes the get_json() function
# this is the previous code block example
import
app
# custom class to be the mock return value
# will override the requests.Response returned from requests.get
class
MockResponse
:
# mock json() method always returns a specific testing dictionary
@staticmethod
def
json
():
return
{
"mock_key"
:
"mock_response"
}
def
test_get_json
(
monkeypatch
):
# Any arguments may be passed and mock_get() will always return our
# mocked object, which only has the .json() method.
def
mock_get
(
*
args
,
**
kwargs
):
return
MockResponse
()
# apply the monkeypatch for requests.get to mock_get
monkeypatch
.
setattr
(
requests
,
"get"
,
mock_get
)
# app.get_json, which contains requests.get, uses the monkeypatch
result
=
app
.
get_json
(
"https://fakeurl"
)
assert
result
[
"mock_key"
]
==
"mock_response"

```

monkeypatch applies the mock for requests.get with our mock_get function. The mock_get function returns an instance of the MockResponse class, which has a json() method defined to return a known testing dictionary and does not require any outside API connection. You can build the MockResponse class with the appropriate degree of complexity for the scenario you are testing. For instance, it could include an ok property that always returns True , or return different values from the json() mocked method based on input strings. This mock can be shared across tests using a fixture :

```

# contents of test_app.py, a simple test for our API retrieval
import
pytest
import
requests
# app.py that includes the get_json() function
import
app
# custom class to be the mock return value of requests.get()
class
MockResponse
:
@staticmethod
def
json
():
return
{
"mock_key"
:
"mock_response"
}
# monkeypatched requests.get moved to a fixture
@pytest
.
fixture
def
mock_response
(
monkeypatch
):
"""Requests.get() mocked to return {'mock_key':'mock_response'}."""
def
mock_get
(
*
args
,
**
kwargs
):
return
MockResponse
()
monkeypatch
.
setattr
(
requests
,
"get"
,
mock_get
)
# notice our test uses the custom fixture instead of monkeypatch directly
def
test_get_json
(
mock_response
):
result
=
app
.
get_json
(
"https://fakeurl"
)
assert
result
[
"mock_key"
]
==
"mock_response"

```

Furthermore, if the mock was designed to be applied to all tests, the fixture could be moved to a conftest.py file and use the with autouse=True option.

# Global patch example: preventing “requests” from remote operations¶

If you want to prevent the “requests” library from performing http requests in all your tests, you can do:

```

# contents of conftest.py
import
pytest
@pytest
.
fixture
(
autouse
=
True
)
def
no_requests
(
monkeypatch
):
"""Remove requests.sessions.Session.request for all tests."""
monkeypatch
.
delattr
(
"requests.sessions.Session.request"
)

```

This autouse fixture will be executed for each test function and it will delete the method request.session.Session.request so that any attempts within tests to create http requests will fail. Note Be advised that it is not recommended to patch builtin functions such as open , compile , etc., because it might break pytest’s internals. If that’s unavoidable, passing --tb=native , --assert=plain and --capture=no might help although there’s no guarantee. Note Mind that patching stdlib functions and some third-party libraries used by pytest might break pytest itself, therefore in those cases it is recommended to use MonkeyPatch.context() to limit the patching to the block you want tested:

```

import
functools
def
test_partial
(
monkeypatch
):
with
monkeypatch
.
context
()
as
m
:
m
.
setattr
(
functools
,
"partial"
,
3
)
assert
functools
.
partial
==
3

```

See #3290 for details.

# Monkeypatching environment variables¶

If you are working with environment variables you often need to safely change the values or delete them from the system for testing purposes. monkeypatch provides a mechanism to do this using the setenv and delenv method. Our example code to test:

```

# contents of our original code file e.g. code.py
import
os
def
get_os_user_lower
():
"""Simple retrieval function.
Returns lowercase USER or raises OSError."""
username
=
os
.
getenv
(
"USER"
)
if
username
is
None
:
raise
OSError
(
"USER environment is not set."
)
return
username
.
lower
()

```

There are two potential paths. First, the USER environment variable is set to a value. Second, the USER environment variable does not exist. Using monkeypatch both paths can be safely tested without impacting the running environment:

```

# contents of our test file e.g. test_code.py
import
pytest
def
test_upper_to_lower
(
monkeypatch
):
"""Set the USER env var to assert the behavior."""
monkeypatch
.
setenv
(
"USER"
,
"TestingUser"
)
assert
get_os_user_lower
()
==
"testinguser"
def
test_raise_exception
(
monkeypatch
):
"""Remove the USER env var and assert OSError is raised."""
monkeypatch
.
delenv
(
"USER"
,
raising
=
False
)
with
pytest
.
raises
(
OSError
):
_
=
get_os_user_lower
()

```

This behavior can be moved into fixture structures and shared across tests:

```

# contents of our test file e.g. test_code.py
import
pytest
@pytest
.
fixture
def
mock_env_user
(
monkeypatch
):
monkeypatch
.
setenv
(
"USER"
,
"TestingUser"
)
@pytest
.
fixture
def
mock_env_missing
(
monkeypatch
):
monkeypatch
.
delenv
(
"USER"
,
raising
=
False
)
# notice the tests reference the fixtures for mocks
def
test_upper_to_lower
(
mock_env_user
):
assert
get_os_user_lower
()
==
"testinguser"
def
test_raise_exception
(
mock_env_missing
):
with
pytest
.
raises
(
OSError
):
_
=
get_os_user_lower
()

```

# Monkeypatching dictionaries¶

monkeypatch.setitem can be used to safely set the values of dictionaries to specific values during tests. Take this simplified connection string example:

```

# contents of app.py to generate a simple connection string
DEFAULT_CONFIG
=
{
"user"
:
"user1"
,
"database"
:
"db1"
}
def
create_connection_string
(
config
=
None
):
"""Creates a connection string from input or defaults."""
config
=
config
or
DEFAULT_CONFIG
return
f
"User Id=
{
config
[
'user'
]
}
; Location=
{
config
[
'database'
]
}
;"

```

For testing purposes we can patch the DEFAULT_CONFIG dictionary to specific values.

```

# contents of test_app.py
# app.py with the connection string function (prior code block)
import
app
def
test_connection
(
monkeypatch
):
# Patch the values of DEFAULT_CONFIG to specific
# testing values only for this test.
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
"test_user"
)
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"database"
,
"test_db"
)
# expected result based on the mocks
expected
=
"User Id=test_user; Location=test_db;"
# the test uses the monkeypatched dictionary settings
result
=
app
.
create_connection_string
()
assert
result
==
expected

```

You can use the monkeypatch.delitem to remove values.

```

# contents of test_app.py
import
pytest
# app.py with the connection string function
import
app
def
test_missing_user
(
monkeypatch
):
# patch the DEFAULT_CONFIG t be missing the 'user' key
monkeypatch
.
delitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
raising
=
False
)
# Key error expected because a config is not passed, and the
# default is now missing the 'user' entry.
with
pytest
.
raises
(
KeyError
):
_
=
app
.
create_connection_string
()

```

The modularity of fixtures gives you the flexibility to define separate fixtures for each potential mock and reference them in the needed tests.

```

# contents of test_app.py
import
pytest
# app.py with the connection string function
import
app
# all of the mocks are moved into separated fixtures
@pytest
.
fixture
def
mock_test_user
(
monkeypatch
):
"""Set the DEFAULT_CONFIG user to test_user."""
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
"test_user"
)
@pytest
.
fixture
def
mock_test_database
(
monkeypatch
):
"""Set the DEFAULT_CONFIG database to test_db."""
monkeypatch
.
setitem
(
app
.
DEFAULT_CONFIG
,
"database"
,
"test_db"
)
@pytest
.
fixture
def
mock_missing_default_user
(
monkeypatch
):
"""Remove the user key from DEFAULT_CONFIG"""
monkeypatch
.
delitem
(
app
.
DEFAULT_CONFIG
,
"user"
,
raising
=
False
)
# tests reference only the fixture mocks that are needed
def
test_connection
(
mock_test_user
,
mock_test_database
):
expected
=
"User Id=test_user; Location=test_db;"
result
=
app
.
create_connection_string
()
assert
result
==
expected
def
test_missing_user
(
mock_missing_default_user
):
with
pytest
.
raises
(
KeyError
):
_
=
app
.
create_connection_string
()

```

# API Reference¶


---


# Pytest API and builtin fixtures - pytest documentation

URL: https://docs.pytest.org/en/stable/builtin.html


# Pytest API and builtin fixtures¶

Most of the information of this page has been moved over to API Reference . For information on plugin hooks and objects, see Writing plugins . For information on the pytest.mark mechanism, see How to mark test functions with attributes . For information about fixtures, see Fixtures reference . To see a complete list of available fixtures (add -v to also see fixtures with leading _ ), type :

```

$ pytest  --fixtures -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: .pytest_cache
rootdir: /home/sweet/project
collected 0 items
cache -- .../_pytest/cacheprovider.py:556
    Return a cache object that can persist state between testing sessions.

    cache.get(key, default)
    cache.set(key, value)

    Keys must be ``/`` separated strings, where the first part is usually the
    name of your plugin or application to avoid clashes with other cache users.

    Values can be any object handled by the json stdlib module.

capsysbinary -- .../_pytest/capture.py:1024
    Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``.

    The captured output is made available via ``capsysbinary.readouterr()``
    method calls, which return a ``(out, err)`` namedtuple.
    ``out`` and ``err`` will be ``bytes`` objects.

    Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.

    Example:

    .. code-block:: python

        def test_output(capsysbinary):
            print("hello")
            captured = capsysbinary.readouterr()
            assert captured.out == b"hello\n"

capfd -- .../_pytest/capture.py:1052
    Enable text capturing of writes to file descriptors ``1`` and ``2``.

    The captured output is made available via ``capfd.readouterr()`` method
    calls, which return a ``(out, err)`` namedtuple.
    ``out`` and ``err`` will be ``text`` objects.

    Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.

    Example:

    .. code-block:: python

        def test_system_echo(capfd):
            os.system('echo "hello"')
            captured = capfd.readouterr()
            assert captured.out == "hello\n"

capfdbinary -- .../_pytest/capture.py:1080
    Enable bytes capturing of writes to file descriptors ``1`` and ``2``.

    The captured output is made available via ``capfd.readouterr()`` method
    calls, which return a ``(out, err)`` namedtuple.
    ``out`` and ``err`` will be ``byte`` objects.

    Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.

    Example:

    .. code-block:: python

        def test_system_echo(capfdbinary):
            os.system('echo "hello"')
            captured = capfdbinary.readouterr()
            assert captured.out == b"hello\n"

capsys -- .../_pytest/capture.py:996
    Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``.

    The captured output is made available via ``capsys.readouterr()`` method
    calls, which return a ``(out, err)`` namedtuple.
    ``out`` and ``err`` will be ``text`` objects.

    Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.

    Example:

    .. code-block:: python

        def test_output(capsys):
            print("hello")
            captured = capsys.readouterr()
            assert captured.out == "hello\n"

doctest_namespace [session scope] -- .../_pytest/doctest.py:741
    Fixture that returns a :py:class:`dict` that will be injected into the
    namespace of doctests.

    Usually this fixture is used in conjunction with another ``autouse`` fixture:

    .. code-block:: python

        @pytest.fixture(autouse=True)
        def add_np(doctest_namespace):
            doctest_namespace["np"] = numpy

    For more details: :ref:`doctest_namespace`.

pytestconfig [session scope] -- .../_pytest/fixtures.py:1345
    Session-scoped fixture that returns the session's :class:`pytest.Config`
    object.

    Example::

        def test_foo(pytestconfig):
            if pytestconfig.get_verbosity() > 0:
                ...

record_property -- .../_pytest/junitxml.py:280
    Add extra properties to the calling test.

    User properties become part of the test report and are available to the
    configured reporters, like JUnit XML.

    The fixture is callable with ``name, value``. The value is automatically
    XML-encoded.

    Example::

        def test_function(record_property):
            record_property("example_key", 1)

record_xml_attribute -- .../_pytest/junitxml.py:303
    Add extra xml attributes to the tag for the calling test.

    The fixture is callable with ``name, value``. The value is
    automatically XML-encoded.

record_testsuite_property [session scope] -- .../_pytest/junitxml.py:341
    Record a new ``<property>`` tag as child of the root ``<testsuite>``.

    This is suitable to writing global information regarding the entire test
    suite, and is compatible with ``xunit2`` JUnit family.

    This is a ``session``-scoped fixture which is called with ``(name, value)``. Example:

    .. code-block:: python

        def test_foo(record_testsuite_property):
            record_testsuite_property("ARCH", "PPC")
            record_testsuite_property("STORAGE_TYPE", "CEPH")

    :param name:
        The property name.
    :param value:
        The property value. Will be converted to a string.

    .. warning::

        Currently this fixture **does not work** with the
        `pytest-xdist <https://github.com/pytest-dev/pytest-xdist>`__ plugin. See
        :issue:`7767` for details.

tmpdir_factory [session scope] -- .../_pytest/legacypath.py:298
    Return a :class:`pytest.TempdirFactory` instance for the test session.

tmpdir -- .../_pytest/legacypath.py:305
    Return a temporary directory (as `legacy_path`_ object)
    which is unique to each test function invocation.
    The temporary directory is created as a subdirectory
    of the base temporary directory, with configurable retention,
    as discussed in :ref:`temporary directory location and retention`.

    .. note::
        These days, it is preferred to use ``tmp_path``.

        :ref:`About the tmpdir and tmpdir_factory fixtures<tmpdir and tmpdir_factory>`.

    .. _legacy_path: https://py.readthedocs.io/en/latest/path.html

caplog -- .../_pytest/logging.py:598
    Access and control log capturing.

    Captured logs are available through the following properties/methods::

    * caplog.messages        -> list of format-interpolated log messages
    * caplog.text            -> string containing formatted log output
    * caplog.records         -> list of logging.LogRecord instances
    * caplog.record_tuples   -> list of (logger_name, level, message) tuples
    * caplog.clear()         -> clear captured records and formatted log output string

monkeypatch -- .../_pytest/monkeypatch.py:31
    A convenient fixture for monkey-patching.

    The fixture provides these methods to modify objects, dictionaries, or
    :data:`os.environ`:

    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`
    * :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`
    * :meth:`monkeypatch.setitem(mapping, name, value) <pytest.MonkeyPatch.setitem>`
    * :meth:`monkeypatch.delitem(obj, name, raising=True) <pytest.MonkeyPatch.delitem>`
    * :meth:`monkeypatch.setenv(name, value, prepend=None) <pytest.MonkeyPatch.setenv>`
    * :meth:`monkeypatch.delenv(name, raising=True) <pytest.MonkeyPatch.delenv>`
    * :meth:`monkeypatch.syspath_prepend(path) <pytest.MonkeyPatch.syspath_prepend>`
    * :meth:`monkeypatch.chdir(path) <pytest.MonkeyPatch.chdir>`
    * :meth:`monkeypatch.context() <pytest.MonkeyPatch.context>`

    All modifications will be undone after the requesting test function or
    fixture has finished. The ``raising`` parameter determines if a :class:`KeyError`
    or :class:`AttributeError` will be raised if the set/deletion operation does not have the
    specified target.

    To undo modifications done by the fixture in a contained scope,
    use :meth:`context() <pytest.MonkeyPatch.context>`.

recwarn -- .../_pytest/recwarn.py:35
    Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.

    See :ref:`warnings` for information on warning categories.

tmp_path_factory [session scope] -- .../_pytest/tmpdir.py:241
    Return a :class:`pytest.TempPathFactory` instance for the test session.

tmp_path -- .../_pytest/tmpdir.py:256
    Return a temporary directory (as :class:`pathlib.Path` object)
    which is unique to each test function invocation.
    The temporary directory is created as a subdirectory
    of the base temporary directory, with configurable retention,
    as discussed in :ref:`temporary directory location and retention`.
========================== no tests ran in 0.12s ===========================

```

You can also interactively ask for help, e.g. by typing on the Python interactive prompt something like:

```

import
pytest
help
(
pytest
)

```


---


# _pytest.config.argparsing - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/config/argparsing.html


# Source code for _pytest.config.argparsing

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
import
argparse
from
gettext
import
gettext
import
os
import
sys
from
typing
import
Any
from
typing
import
Callable
from
typing
import
cast
from
typing
import
final
from
typing
import
List
from
typing
import
Literal
from
typing
import
Mapping
from
typing
import
NoReturn
from
typing
import
Sequence
import
_pytest._io
from
_pytest.config.exceptions
import
UsageError
from
_pytest.deprecated
import
check_ispytest
FILE_OR_DIR
=
"file_or_dir"
class
NotSet
:
def
__repr__
(
self
)
->
str
:
return
"<notset>"
NOT_SET
=
NotSet
()
[docs]
@final
class
Parser
:
"""Parser for command line arguments and ini-file values.
:ivar extra_info: Dict of generic param -> value to display in case
there's an error processing the command line arguments.
"""
prog
:
str
|
None
=
None
def
__init__
(
self
,
usage
:
str
|
None
=
None
,
processopt
:
Callable
[[
Argument
],
None
]
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_anonymous
=
OptionGroup
(
"Custom options"
,
parser
=
self
,
_ispytest
=
True
)
self
.
_groups
:
list
[
OptionGroup
]
=
[]
self
.
_processopt
=
processopt
self
.
_usage
=
usage
self
.
_inidict
:
dict
[
str
,
tuple
[
str
,
str
|
None
,
Any
]]
=
{}
self
.
_ininames
:
list
[
str
]
=
[]
self
.
extra_info
:
dict
[
str
,
Any
]
=
{}
def
processoption
(
self
,
option
:
Argument
)
->
None
:
if
self
.
_processopt
:
if
option
.
dest
:
self
.
_processopt
(
option
)
[docs]
def
getgroup
(
self
,
name
:
str
,
description
:
str
=
""
,
after
:
str
|
None
=
None
)
->
OptionGroup
:
"""Get (or create) a named option Group.
:param name: Name of the option group.
:param description: Long description for --help output.
:param after: Name of another group, used for ordering --help output.
:returns: The option group.
The returned group object has an ``addoption`` method with the same
signature as :func:`parser.addoption <pytest.Parser.addoption>` but
will be shown in the respective group in the output of
``pytest --help``.
"""
for
group
in
self
.
_groups
:
if
group
.
name
==
name
:
return
group
group
=
OptionGroup
(
name
,
description
,
parser
=
self
,
_ispytest
=
True
)
i
=
0
for
i
,
grp
in
enumerate
(
self
.
_groups
):
if
grp
.
name
==
after
:
break
self
.
_groups
.
insert
(
i
+
1
,
group
)
return
group
[docs]
def
addoption
(
self
,
*
opts
:
str
,
**
attrs
:
Any
)
->
None
:
"""Register a command line option.
:param opts:
Option names, can be short or long options.
:param attrs:
Same attributes as the argparse library's :meth:`add_argument()
<argparse.ArgumentParser.add_argument>` function accepts.
After command line parsing, options are available on the pytest config
object via ``config.option.NAME`` where ``NAME`` is usually set
by passing a ``dest`` attribute, for example
``addoption("--long", dest="NAME", ...)``.
"""
self
.
_anonymous
.
addoption
(
*
opts
,
**
attrs
)
def
parse
(
self
,
args
:
Sequence
[
str
|
os
.
PathLike
[
str
]],
namespace
:
argparse
.
Namespace
|
None
=
None
,
)
->
argparse
.
Namespace
:
from
_pytest._argcomplete
import
try_argcomplete
self
.
optparser
=
self
.
_getparser
()
try_argcomplete
(
self
.
optparser
)
strargs
=
[
os
.
fspath
(
x
)
for
x
in
args
]
return
self
.
optparser
.
parse_args
(
strargs
,
namespace
=
namespace
)
def
_getparser
(
self
)
->
MyOptionParser
:
from
_pytest._argcomplete
import
filescompleter
optparser
=
MyOptionParser
(
self
,
self
.
extra_info
,
prog
=
self
.
prog
)
groups
=
[
*
self
.
_groups
,
self
.
_anonymous
]
for
group
in
groups
:
if
group
.
options
:
desc
=
group
.
description
or
group
.
name
arggroup
=
optparser
.
add_argument_group
(
desc
)
for
option
in
group
.
options
:
n
=
option
.
names
()
a
=
option
.
attrs
()
arggroup
.
add_argument
(
*
n
,
**
a
)
file_or_dir_arg
=
optparser
.
add_argument
(
FILE_OR_DIR
,
nargs
=
"*"
)
# bash like autocompletion for dirs (appending '/')
# Type ignored because typeshed doesn't know about argcomplete.
file_or_dir_arg
.
completer
=
filescompleter
# type: ignore
return
optparser
def
parse_setoption
(
self
,
args
:
Sequence
[
str
|
os
.
PathLike
[
str
]],
option
:
argparse
.
Namespace
,
namespace
:
argparse
.
Namespace
|
None
=
None
,
)
->
list
[
str
]:
parsedoption
=
self
.
parse
(
args
,
namespace
=
namespace
)
for
name
,
value
in
parsedoption
.
__dict__
.
items
():
setattr
(
option
,
name
,
value
)
return
cast
(
List
[
str
],
getattr
(
parsedoption
,
FILE_OR_DIR
))
[docs]
def
parse_known_args
(
self
,
args
:
Sequence
[
str
|
os
.
PathLike
[
str
]],
namespace
:
argparse
.
Namespace
|
None
=
None
,
)
->
argparse
.
Namespace
:
"""Parse the known arguments at this point.
:returns: An argparse namespace object.
"""
return
self
.
parse_known_and_unknown_args
(
args
,
namespace
=
namespace
)[
0
]
[docs]
def
parse_known_and_unknown_args
(
self
,
args
:
Sequence
[
str
|
os
.
PathLike
[
str
]],
namespace
:
argparse
.
Namespace
|
None
=
None
,
)
->
tuple
[
argparse
.
Namespace
,
list
[
str
]]:
"""Parse the known arguments at this point, and also return the
remaining unknown arguments.
:returns:
A tuple containing an argparse namespace object for the known
arguments, and a list of the unknown arguments.
"""
optparser
=
self
.
_getparser
()
strargs
=
[
os
.
fspath
(
x
)
for
x
in
args
]
return
optparser
.
parse_known_args
(
strargs
,
namespace
=
namespace
)
[docs]
def
addini
(
self
,
name
:
str
,
help
:
str
,
type
:
Literal
[
"string"
,
"paths"
,
"pathlist"
,
"args"
,
"linelist"
,
"bool"
]
|
None
=
None
,
default
:
Any
=
NOT_SET
,
)
->
None
:
"""Register an ini-file option.
:param name:
Name of the ini-variable.
:param type:
Type of the variable. Can be:
* ``string``: a string
* ``bool``: a boolean
* ``args``: a list of strings, separated as in a shell
* ``linelist``: a list of strings, separated by line breaks
* ``paths``: a list of :class:`pathlib.Path`, separated as in a shell
* ``pathlist``: a list of ``py.path``, separated as in a shell
For ``paths`` and ``pathlist`` types, they are considered relative to the ini-file.
In case the execution is happening without an ini-file defined,
they will be considered relative to the current working directory (for example with ``--override-ini``).
.. versionadded:: 7.0
The ``paths`` variable type.
.. versionadded:: 8.1
Use the current working directory to resolve ``paths`` and ``pathlist`` in the absence of an ini-file.
Defaults to ``string`` if ``None`` or not passed.
:param default:
Default value if no ini-file option exists but is queried.
The value of ini-variables can be retrieved via a call to
:py:func:`config.getini(name) <pytest.Config.getini>`.
"""
assert
type
in
(
None
,
"string"
,
"paths"
,
"pathlist"
,
"args"
,
"linelist"
,
"bool"
)
if
default
is
NOT_SET
:
default
=
get_ini_default_for_type
(
type
)
self
.
_inidict
[
name
]
=
(
help
,
type
,
default
)
self
.
_ininames
.
append
(
name
)
def
get_ini_default_for_type
(
type
:
Literal
[
"string"
,
"paths"
,
"pathlist"
,
"args"
,
"linelist"
,
"bool"
]
|
None
,
)
->
Any
:
"""
Used by addini to get the default value for a given ini-option type, when
default is not supplied.
"""
if
type
is
None
:
return
""
elif
type
in
(
"paths"
,
"pathlist"
,
"args"
,
"linelist"
):
return
[]
elif
type
==
"bool"
:
return
False
else
:
return
""
class
ArgumentError
(
Exception
):
"""Raised if an Argument instance is created with invalid or
inconsistent arguments."""
def
__init__
(
self
,
msg
:
str
,
option
:
Argument
|
str
)
->
None
:
self
.
msg
=
msg
self
.
option_id
=
str
(
option
)
def
__str__
(
self
)
->
str
:
if
self
.
option_id
:
return
f
"option
{
self
.
option_id
}
:
{
self
.
msg
}
"
else
:
return
self
.
msg
class
Argument
:
"""Class that mimics the necessary behaviour of optparse.Option.
It's currently a least effort implementation and ignoring choices
and integer prefixes.
https://docs.python.org/3/library/optparse.html#optparse-standard-option-types
"""
def
__init__
(
self
,
*
names
:
str
,
**
attrs
:
Any
)
->
None
:
"""Store params in private vars for use in add_argument."""
self
.
_attrs
=
attrs
self
.
_short_opts
:
list
[
str
]
=
[]
self
.
_long_opts
:
list
[
str
]
=
[]
try
:
self
.
type
=
attrs
[
"type"
]
except
KeyError
:
pass
try
:
# Attribute existence is tested in Config._processopt.
self
.
default
=
attrs
[
"default"
]
except
KeyError
:
pass
self
.
_set_opt_strings
(
names
)
dest
:
str
|
None
=
attrs
.
get
(
"dest"
)
if
dest
:
self
.
dest
=
dest
elif
self
.
_long_opts
:
self
.
dest
=
self
.
_long_opts
[
0
][
2
:]
.
replace
(
"-"
,
"_"
)
else
:
try
:
self
.
dest
=
self
.
_short_opts
[
0
][
1
:]
except
IndexError
as
e
:
self
.
dest
=
"???"
# Needed for the error repr.
raise
ArgumentError
(
"need a long or short option"
,
self
)
from
e
def
names
(
self
)
->
list
[
str
]:
return
self
.
_short_opts
+
self
.
_long_opts
def
attrs
(
self
)
->
Mapping
[
str
,
Any
]:
# Update any attributes set by processopt.
attrs
=
"default dest help"
.
split
()
attrs
.
append
(
self
.
dest
)
for
attr
in
attrs
:
try
:
self
.
_attrs
[
attr
]
=
getattr
(
self
,
attr
)
except
AttributeError
:
pass
return
self
.
_attrs
def
_set_opt_strings
(
self
,
opts
:
Sequence
[
str
])
->
None
:
"""Directly from optparse.
Might not be necessary as this is passed to argparse later on.
"""
for
opt
in
opts
:
if
len
(
opt
)
<
2
:
raise
ArgumentError
(
f
"invalid option string
{
opt
!r}
: "
"must be at least two characters long"
,
self
,
)
elif
len
(
opt
)
==
2
:
if
not
(
opt
[
0
]
==
"-"
and
opt
[
1
]
!=
"-"
):
raise
ArgumentError
(
f
"invalid short option string
{
opt
!r}
: "
"must be of the form -x, (x any non-dash char)"
,
self
,
)
self
.
_short_opts
.
append
(
opt
)
else
:
if
not
(
opt
[
0
:
2
]
==
"--"
and
opt
[
2
]
!=
"-"
):
raise
ArgumentError
(
f
"invalid long option string
{
opt
!r}
: "
"must start with --, followed by non-dash"
,
self
,
)
self
.
_long_opts
.
append
(
opt
)
def
__repr__
(
self
)
->
str
:
args
:
list
[
str
]
=
[]
if
self
.
_short_opts
:
args
+=
[
"_short_opts: "
+
repr
(
self
.
_short_opts
)]
if
self
.
_long_opts
:
args
+=
[
"_long_opts: "
+
repr
(
self
.
_long_opts
)]
args
+=
[
"dest: "
+
repr
(
self
.
dest
)]
if
hasattr
(
self
,
"type"
):
args
+=
[
"type: "
+
repr
(
self
.
type
)]
if
hasattr
(
self
,
"default"
):
args
+=
[
"default: "
+
repr
(
self
.
default
)]
return
"Argument(
{}
)"
.
format
(
", "
.
join
(
args
))
[docs]
class
OptionGroup
:
"""A group of options shown in its own section."""
def
__init__
(
self
,
name
:
str
,
description
:
str
=
""
,
parser
:
Parser
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
name
=
name
self
.
description
=
description
self
.
options
:
list
[
Argument
]
=
[]
self
.
parser
=
parser
[docs]
def
addoption
(
self
,
*
opts
:
str
,
**
attrs
:
Any
)
->
None
:
"""Add an option to this group.
If a shortened version of a long option is specified, it will
be suppressed in the help. ``addoption('--twowords', '--two-words')``
results in help showing ``--two-words`` only, but ``--twowords`` gets
accepted **and** the automatic destination is in ``args.twowords``.
:param opts:
Option names, can be short or long options.
:param attrs:
Same attributes as the argparse library's :meth:`add_argument()
<argparse.ArgumentParser.add_argument>` function accepts.
"""
conflict
=
set
(
opts
)
.
intersection
(
name
for
opt
in
self
.
options
for
name
in
opt
.
names
()
)
if
conflict
:
raise
ValueError
(
f
"option names
{
conflict
}
already added"
)
option
=
Argument
(
*
opts
,
**
attrs
)
self
.
_addoption_instance
(
option
,
shortupper
=
False
)
def
_addoption
(
self
,
*
opts
:
str
,
**
attrs
:
Any
)
->
None
:
option
=
Argument
(
*
opts
,
**
attrs
)
self
.
_addoption_instance
(
option
,
shortupper
=
True
)
def
_addoption_instance
(
self
,
option
:
Argument
,
shortupper
:
bool
=
False
)
->
None
:
if
not
shortupper
:
for
opt
in
option
.
_short_opts
:
if
opt
[
0
]
==
"-"
and
opt
[
1
]
.
islower
():
raise
ValueError
(
"lowercase shortoptions reserved"
)
if
self
.
parser
:
self
.
parser
.
processoption
(
option
)
self
.
options
.
append
(
option
)
class
MyOptionParser
(
argparse
.
ArgumentParser
):
def
__init__
(
self
,
parser
:
Parser
,
extra_info
:
dict
[
str
,
Any
]
|
None
=
None
,
prog
:
str
|
None
=
None
,
)
->
None
:
self
.
_parser
=
parser
super
()
.
__init__
(
prog
=
prog
,
usage
=
parser
.
_usage
,
add_help
=
False
,
formatter_class
=
DropShorterLongHelpFormatter
,
allow_abbrev
=
False
,
fromfile_prefix_chars
=
"@"
,
)
# extra_info is a dict of (param -> value) to display if there's
# an usage error to provide more contextual information to the user.
self
.
extra_info
=
extra_info
if
extra_info
else
{}
def
error
(
self
,
message
:
str
)
->
NoReturn
:
"""Transform argparse error message into UsageError."""
msg
=
f
"
{
self
.
prog
}
: error:
{
message
}
"
if
hasattr
(
self
.
_parser
,
"_config_source_hint"
):
msg
=
f
"
{
msg
}
(
{
self
.
_parser
.
_config_source_hint
}
)"
raise
UsageError
(
self
.
format_usage
()
+
msg
)
# Type ignored because typeshed has a very complex type in the superclass.
def
parse_args
(
# type: ignore
self
,
args
:
Sequence
[
str
]
|
None
=
None
,
namespace
:
argparse
.
Namespace
|
None
=
None
,
)
->
argparse
.
Namespace
:
"""Allow splitting of positional arguments."""
parsed
,
unrecognized
=
self
.
parse_known_args
(
args
,
namespace
)
if
unrecognized
:
for
arg
in
unrecognized
:
if
arg
and
arg
[
0
]
==
"-"
:
lines
=
[
"unrecognized arguments:
{}
"
.
format
(
" "
.
join
(
unrecognized
))
]
for
k
,
v
in
sorted
(
self
.
extra_info
.
items
()):
lines
.
append
(
f
"
{
k
}
:
{
v
}
"
)
self
.
error
(
"
\n
"
.
join
(
lines
))
getattr
(
parsed
,
FILE_OR_DIR
)
.
extend
(
unrecognized
)
return
parsed
if
sys
.
version_info
<
(
3
,
9
):
# pragma: no cover
# Backport of https://github.com/python/cpython/pull/14316 so we can
# disable long --argument abbreviations without breaking short flags.
def
_parse_optional
(
self
,
arg_string
:
str
)
->
tuple
[
argparse
.
Action
|
None
,
str
,
str
|
None
]
|
None
:
if
not
arg_string
:
return
None
if
arg_string
[
0
]
not
in
self
.
prefix_chars
:
return
None
if
arg_string
in
self
.
_option_string_actions
:
action
=
self
.
_option_string_actions
[
arg_string
]
return
action
,
arg_string
,
None
if
len
(
arg_string
)
==
1
:
return
None
if
"="
in
arg_string
:
option_string
,
explicit_arg
=
arg_string
.
split
(
"="
,
1
)
if
option_string
in
self
.
_option_string_actions
:
action
=
self
.
_option_string_actions
[
option_string
]
return
action
,
option_string
,
explicit_arg
if
self
.
allow_abbrev
or
not
arg_string
.
startswith
(
"--"
):
option_tuples
=
self
.
_get_option_tuples
(
arg_string
)
if
len
(
option_tuples
)
>
1
:
msg
=
gettext
(
"ambiguous option:
%(option)s
could match
%(matches)s
"
)
options
=
", "
.
join
(
option
for
_
,
option
,
_
in
option_tuples
)
self
.
error
(
msg
%
{
"option"
:
arg_string
,
"matches"
:
options
})
elif
len
(
option_tuples
)
==
1
:
(
option_tuple
,)
=
option_tuples
return
option_tuple
if
self
.
_negative_number_matcher
.
match
(
arg_string
):
if
not
self
.
_has_negative_number_optionals
:
return
None
if
" "
in
arg_string
:
return
None
return
None
,
arg_string
,
None
class
DropShorterLongHelpFormatter
(
argparse
.
HelpFormatter
):
"""Shorten help for long options that differ only in extra hyphens.
- Collapse **long** options that are the same except for extra hyphens.
- Shortcut if there are only two options and one of them is a short one.
- Cache result on the action object as this is called at least 2 times.
"""
def
__init__
(
self
,
*
args
:
Any
,
**
kwargs
:
Any
)
->
None
:
# Use more accurate terminal width.
if
"width"
not
in
kwargs
:
kwargs
[
"width"
]
=
_pytest
.
_io
.
get_terminal_width
()
super
()
.
__init__
(
*
args
,
**
kwargs
)
def
_format_action_invocation
(
self
,
action
:
argparse
.
Action
)
->
str
:
orgstr
=
super
()
.
_format_action_invocation
(
action
)
if
orgstr
and
orgstr
[
0
]
!=
"-"
:
# only optional arguments
return
orgstr
res
:
str
|
None
=
getattr
(
action
,
"_formatted_action_invocation"
,
None
)
if
res
:
return
res
options
=
orgstr
.
split
(
", "
)
if
len
(
options
)
==
2
and
(
len
(
options
[
0
])
==
2
or
len
(
options
[
1
])
==
2
):
# a shortcut for '-h, --help' or '--abc', '-a'
action
.
_formatted_action_invocation
=
orgstr
# type: ignore
return
orgstr
return_list
=
[]
short_long
:
dict
[
str
,
str
]
=
{}
for
option
in
options
:
if
len
(
option
)
==
2
or
option
[
2
]
==
" "
:
continue
if
not
option
.
startswith
(
"--"
):
raise
ArgumentError
(
f
'long optional argument without "--": [
{
option
}
]'
,
option
)
xxoption
=
option
[
2
:]
shortened
=
xxoption
.
replace
(
"-"
,
""
)
if
shortened
not
in
short_long
or
len
(
short_long
[
shortened
])
<
len
(
xxoption
):
short_long
[
shortened
]
=
xxoption
# now short_long has been filled out to the longest with dashes
# **and** we keep the right option ordering from add_argument
for
option
in
options
:
if
len
(
option
)
==
2
or
option
[
2
]
==
" "
:
return_list
.
append
(
option
)
if
option
[
2
:]
==
short_long
.
get
(
option
.
replace
(
"-"
,
""
)):
return_list
.
append
(
option
.
replace
(
" "
,
"="
,
1
))
formatted_action_invocation
=
", "
.
join
(
return_list
)
action
.
_formatted_action_invocation
=
formatted_action_invocation
# type: ignore
return
formatted_action_invocation
def
_split_lines
(
self
,
text
,
width
):
"""Wrap lines after splitting on original newlines.
This allows to have explicit line breaks in the help text.
"""
import
textwrap
lines
=
[]
for
line
in
text
.
splitlines
():
lines
.
extend
(
textwrap
.
wrap
(
line
.
strip
(),
width
))
return
lines

```


---


# _pytest.python_api - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/python_api.html


# Source code for _pytest.python_api

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
from
collections.abc
import
Collection
from
collections.abc
import
Sized
from
decimal
import
Decimal
import
math
from
numbers
import
Complex
import
pprint
import
re
from
types
import
TracebackType
from
typing
import
Any
from
typing
import
Callable
from
typing
import
cast
from
typing
import
ContextManager
from
typing
import
final
from
typing
import
Mapping
from
typing
import
overload
from
typing
import
Pattern
from
typing
import
Sequence
from
typing
import
Tuple
from
typing
import
Type
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
import
_pytest._code
from
_pytest.outcomes
import
fail
if
TYPE_CHECKING
:
from
numpy
import
ndarray
def
_compare_approx
(
full_object
:
object
,
message_data
:
Sequence
[
tuple
[
str
,
str
,
str
]],
number_of_elements
:
int
,
different_ids
:
Sequence
[
object
],
max_abs_diff
:
float
,
max_rel_diff
:
float
,
)
->
list
[
str
]:
message_list
=
list
(
message_data
)
message_list
.
insert
(
0
,
(
"Index"
,
"Obtained"
,
"Expected"
))
max_sizes
=
[
0
,
0
,
0
]
for
index
,
obtained
,
expected
in
message_list
:
max_sizes
[
0
]
=
max
(
max_sizes
[
0
],
len
(
index
))
max_sizes
[
1
]
=
max
(
max_sizes
[
1
],
len
(
obtained
))
max_sizes
[
2
]
=
max
(
max_sizes
[
2
],
len
(
expected
))
explanation
=
[
f
"comparison failed. Mismatched elements:
{
len
(
different_ids
)
}
/
{
number_of_elements
}
:"
,
f
"Max absolute difference:
{
max_abs_diff
}
"
,
f
"Max relative difference:
{
max_rel_diff
}
"
,
]
+
[
f
"
{
indexes
:
<
{
max_sizes
[
0
]
}}
|
{
obtained
:
<
{
max_sizes
[
1
]
}}
|
{
expected
:
<
{
max_sizes
[
2
]
}}
"
for
indexes
,
obtained
,
expected
in
message_list
]
return
explanation
# builtin pytest.approx helper
class
ApproxBase
:
"""Provide shared utilities for making approximate comparisons between
numbers or sequences of numbers."""
# Tell numpy to use our `__eq__` operator instead of its.
__array_ufunc__
=
None
__array_priority__
=
100
def
__init__
(
self
,
expected
,
rel
=
None
,
abs
=
None
,
nan_ok
:
bool
=
False
)
->
None
:
__tracebackhide__
=
True
self
.
expected
=
expected
self
.
abs
=
abs
self
.
rel
=
rel
self
.
nan_ok
=
nan_ok
self
.
_check_type
()
def
__repr__
(
self
)
->
str
:
raise
NotImplementedError
def
_repr_compare
(
self
,
other_side
:
Any
)
->
list
[
str
]:
return
[
"comparison failed"
,
f
"Obtained:
{
other_side
}
"
,
f
"Expected:
{
self
}
"
,
]
def
__eq__
(
self
,
actual
)
->
bool
:
return
all
(
a
==
self
.
_approx_scalar
(
x
)
for
a
,
x
in
self
.
_yield_comparisons
(
actual
)
)
def
__bool__
(
self
):
__tracebackhide__
=
True
raise
AssertionError
(
"approx() is not supported in a boolean context.
\n
Did you mean: `assert a == approx(b)`?"
)
# Ignore type because of https://github.com/python/mypy/issues/4266.
__hash__
=
None
# type: ignore
def
__ne__
(
self
,
actual
)
->
bool
:
return
not
(
actual
==
self
)
def
_approx_scalar
(
self
,
x
)
->
ApproxScalar
:
if
isinstance
(
x
,
Decimal
):
return
ApproxDecimal
(
x
,
rel
=
self
.
rel
,
abs
=
self
.
abs
,
nan_ok
=
self
.
nan_ok
)
return
ApproxScalar
(
x
,
rel
=
self
.
rel
,
abs
=
self
.
abs
,
nan_ok
=
self
.
nan_ok
)
def
_yield_comparisons
(
self
,
actual
):
"""Yield all the pairs of numbers to be compared.
This is used to implement the `__eq__` method.
"""
raise
NotImplementedError
def
_check_type
(
self
)
->
None
:
"""Raise a TypeError if the expected value is not a valid type."""
# This is only a concern if the expected value is a sequence.  In every
# other case, the approx() function ensures that the expected value has
# a numeric type.  For this reason, the default is to do nothing.  The
# classes that deal with sequences should reimplement this method to
# raise if there are any non-numeric elements in the sequence.
def
_recursive_sequence_map
(
f
,
x
):
"""Recursively map a function over a sequence of arbitrary depth"""
if
isinstance
(
x
,
(
list
,
tuple
)):
seq_type
=
type
(
x
)
return
seq_type
(
_recursive_sequence_map
(
f
,
xi
)
for
xi
in
x
)
elif
_is_sequence_like
(
x
):
return
[
_recursive_sequence_map
(
f
,
xi
)
for
xi
in
x
]
else
:
return
f
(
x
)
class
ApproxNumpy
(
ApproxBase
):
"""Perform approximate comparisons where the expected value is numpy array."""
def
__repr__
(
self
)
->
str
:
list_scalars
=
_recursive_sequence_map
(
self
.
_approx_scalar
,
self
.
expected
.
tolist
()
)
return
f
"approx(
{
list_scalars
!r}
)"
def
_repr_compare
(
self
,
other_side
:
ndarray
|
list
[
Any
])
->
list
[
str
]:
import
itertools
import
math
def
get_value_from_nested_list
(
nested_list
:
list
[
Any
],
nd_index
:
tuple
[
Any
,
...
]
)
->
Any
:
"""
Helper function to get the value out of a nested list, given an n-dimensional index.
This mimics numpy's indexing, but for raw nested python lists.
"""
value
:
Any
=
nested_list
for
i
in
nd_index
:
value
=
value
[
i
]
return
value
np_array_shape
=
self
.
expected
.
shape
approx_side_as_seq
=
_recursive_sequence_map
(
self
.
_approx_scalar
,
self
.
expected
.
tolist
()
)
# convert other_side to numpy array to ensure shape attribute is available
other_side_as_array
=
_as_numpy_array
(
other_side
)
assert
other_side_as_array
is
not
None
if
np_array_shape
!=
other_side_as_array
.
shape
:
return
[
"Impossible to compare arrays with different shapes."
,
f
"Shapes:
{
np_array_shape
}
and
{
other_side_as_array
.
shape
}
"
,
]
number_of_elements
=
self
.
expected
.
size
max_abs_diff
=
-
math
.
inf
max_rel_diff
=
-
math
.
inf
different_ids
=
[]
for
index
in
itertools
.
product
(
*
(
range
(
i
)
for
i
in
np_array_shape
)):
approx_value
=
get_value_from_nested_list
(
approx_side_as_seq
,
index
)
other_value
=
get_value_from_nested_list
(
other_side_as_array
,
index
)
if
approx_value
!=
other_value
:
abs_diff
=
abs
(
approx_value
.
expected
-
other_value
)
max_abs_diff
=
max
(
max_abs_diff
,
abs_diff
)
if
other_value
==
0.0
:
max_rel_diff
=
math
.
inf
else
:
max_rel_diff
=
max
(
max_rel_diff
,
abs_diff
/
abs
(
other_value
))
different_ids
.
append
(
index
)
message_data
=
[
(
str
(
index
),
str
(
get_value_from_nested_list
(
other_side_as_array
,
index
)),
str
(
get_value_from_nested_list
(
approx_side_as_seq
,
index
)),
)
for
index
in
different_ids
]
return
_compare_approx
(
self
.
expected
,
message_data
,
number_of_elements
,
different_ids
,
max_abs_diff
,
max_rel_diff
,
)
def
__eq__
(
self
,
actual
)
->
bool
:
import
numpy
as
np
# self.expected is supposed to always be an array here.
if
not
np
.
isscalar
(
actual
):
try
:
actual
=
np
.
asarray
(
actual
)
except
Exception
as
e
:
raise
TypeError
(
f
"cannot compare '
{
actual
}
' to numpy.ndarray"
)
from
e
if
not
np
.
isscalar
(
actual
)
and
actual
.
shape
!=
self
.
expected
.
shape
:
return
False
return
super
()
.
__eq__
(
actual
)
def
_yield_comparisons
(
self
,
actual
):
import
numpy
as
np
# `actual` can either be a numpy array or a scalar, it is treated in
# `__eq__` before being passed to `ApproxBase.__eq__`, which is the
# only method that calls this one.
if
np
.
isscalar
(
actual
):
for
i
in
np
.
ndindex
(
self
.
expected
.
shape
):
yield
actual
,
self
.
expected
[
i
]
.
item
()
else
:
for
i
in
np
.
ndindex
(
self
.
expected
.
shape
):
yield
actual
[
i
]
.
item
(),
self
.
expected
[
i
]
.
item
()
class
ApproxMapping
(
ApproxBase
):
"""Perform approximate comparisons where the expected value is a mapping
with numeric values (the keys can be anything)."""
def
__repr__
(
self
)
->
str
:
return
f
"approx(
{
({
k
:
self
.
_approx_scalar
(
v
)
for
k
,
v
in
self
.
expected
.
items
()})
!r}
)"
def
_repr_compare
(
self
,
other_side
:
Mapping
[
object
,
float
])
->
list
[
str
]:
import
math
approx_side_as_map
=
{
k
:
self
.
_approx_scalar
(
v
)
for
k
,
v
in
self
.
expected
.
items
()
}
number_of_elements
=
len
(
approx_side_as_map
)
max_abs_diff
=
-
math
.
inf
max_rel_diff
=
-
math
.
inf
different_ids
=
[]
for
(
approx_key
,
approx_value
),
other_value
in
zip
(
approx_side_as_map
.
items
(),
other_side
.
values
()
):
if
approx_value
!=
other_value
:
if
approx_value
.
expected
is
not
None
and
other_value
is
not
None
:
try
:
max_abs_diff
=
max
(
max_abs_diff
,
abs
(
approx_value
.
expected
-
other_value
)
)
if
approx_value
.
expected
==
0.0
:
max_rel_diff
=
math
.
inf
else
:
max_rel_diff
=
max
(
max_rel_diff
,
abs
(
(
approx_value
.
expected
-
other_value
)
/
approx_value
.
expected
),
)
except
ZeroDivisionError
:
pass
different_ids
.
append
(
approx_key
)
message_data
=
[
(
str
(
key
),
str
(
other_side
[
key
]),
str
(
approx_side_as_map
[
key
]))
for
key
in
different_ids
]
return
_compare_approx
(
self
.
expected
,
message_data
,
number_of_elements
,
different_ids
,
max_abs_diff
,
max_rel_diff
,
)
def
__eq__
(
self
,
actual
)
->
bool
:
try
:
if
set
(
actual
.
keys
())
!=
set
(
self
.
expected
.
keys
()):
return
False
except
AttributeError
:
return
False
return
super
()
.
__eq__
(
actual
)
def
_yield_comparisons
(
self
,
actual
):
for
k
in
self
.
expected
.
keys
():
yield
actual
[
k
],
self
.
expected
[
k
]
def
_check_type
(
self
)
->
None
:
__tracebackhide__
=
True
for
key
,
value
in
self
.
expected
.
items
():
if
isinstance
(
value
,
type
(
self
.
expected
)):
msg
=
"pytest.approx() does not support nested dictionaries: key=
{!r}
value=
{!r}
\n
full mapping=
{}
"
raise
TypeError
(
msg
.
format
(
key
,
value
,
pprint
.
pformat
(
self
.
expected
)))
class
ApproxSequenceLike
(
ApproxBase
):
"""Perform approximate comparisons where the expected value is a sequence of numbers."""
def
__repr__
(
self
)
->
str
:
seq_type
=
type
(
self
.
expected
)
if
seq_type
not
in
(
tuple
,
list
):
seq_type
=
list
return
f
"approx(
{
seq_type
(
self
.
_approx_scalar
(
x
)
for
x
in
self
.
expected
)
!r}
)"
def
_repr_compare
(
self
,
other_side
:
Sequence
[
float
])
->
list
[
str
]:
import
math
if
len
(
self
.
expected
)
!=
len
(
other_side
):
return
[
"Impossible to compare lists with different sizes."
,
f
"Lengths:
{
len
(
self
.
expected
)
}
and
{
len
(
other_side
)
}
"
,
]
approx_side_as_map
=
_recursive_sequence_map
(
self
.
_approx_scalar
,
self
.
expected
)
number_of_elements
=
len
(
approx_side_as_map
)
max_abs_diff
=
-
math
.
inf
max_rel_diff
=
-
math
.
inf
different_ids
=
[]
for
i
,
(
approx_value
,
other_value
)
in
enumerate
(
zip
(
approx_side_as_map
,
other_side
)
):
if
approx_value
!=
other_value
:
abs_diff
=
abs
(
approx_value
.
expected
-
other_value
)
max_abs_diff
=
max
(
max_abs_diff
,
abs_diff
)
if
other_value
==
0.0
:
max_rel_diff
=
math
.
inf
else
:
max_rel_diff
=
max
(
max_rel_diff
,
abs_diff
/
abs
(
other_value
))
different_ids
.
append
(
i
)
message_data
=
[
(
str
(
i
),
str
(
other_side
[
i
]),
str
(
approx_side_as_map
[
i
]))
for
i
in
different_ids
]
return
_compare_approx
(
self
.
expected
,
message_data
,
number_of_elements
,
different_ids
,
max_abs_diff
,
max_rel_diff
,
)
def
__eq__
(
self
,
actual
)
->
bool
:
try
:
if
len
(
actual
)
!=
len
(
self
.
expected
):
return
False
except
TypeError
:
return
False
return
super
()
.
__eq__
(
actual
)
def
_yield_comparisons
(
self
,
actual
):
return
zip
(
actual
,
self
.
expected
)
def
_check_type
(
self
)
->
None
:
__tracebackhide__
=
True
for
index
,
x
in
enumerate
(
self
.
expected
):
if
isinstance
(
x
,
type
(
self
.
expected
)):
msg
=
"pytest.approx() does not support nested data structures:
{!r}
at index
{}
\n
full sequence:
{}
"
raise
TypeError
(
msg
.
format
(
x
,
index
,
pprint
.
pformat
(
self
.
expected
)))
class
ApproxScalar
(
ApproxBase
):
"""Perform approximate comparisons where the expected value is a single number."""
# Using Real should be better than this Union, but not possible yet:
# https://github.com/python/typeshed/pull/3108
DEFAULT_ABSOLUTE_TOLERANCE
:
float
|
Decimal
=
1e-12
DEFAULT_RELATIVE_TOLERANCE
:
float
|
Decimal
=
1e-6
def
__repr__
(
self
)
->
str
:
"""Return a string communicating both the expected value and the
tolerance for the comparison being made.
For example, ``1.0 ± 1e-6``, ``(3+4j) ± 5e-6 ∠ ±180°``.
"""
# Don't show a tolerance for values that aren't compared using
# tolerances, i.e. non-numerics and infinities. Need to call abs to
# handle complex numbers, e.g. (inf + 1j).
if
(
isinstance
(
self
.
expected
,
bool
)
or
(
not
isinstance
(
self
.
expected
,
(
Complex
,
Decimal
)))
or
math
.
isinf
(
abs
(
self
.
expected
)
or
isinstance
(
self
.
expected
,
bool
))
):
return
str
(
self
.
expected
)
# If a sensible tolerance can't be calculated, self.tolerance will
# raise a ValueError.  In this case, display '???'.
try
:
vetted_tolerance
=
f
"
{
self
.
tolerance
:
.1e
}
"
if
(
isinstance
(
self
.
expected
,
Complex
)
and
self
.
expected
.
imag
and
not
math
.
isinf
(
self
.
tolerance
)
):
vetted_tolerance
+=
" ∠ ±180°"
except
ValueError
:
vetted_tolerance
=
"???"
return
f
"
{
self
.
expected
}
±
{
vetted_tolerance
}
"
def
__eq__
(
self
,
actual
)
->
bool
:
"""Return whether the given value is equal to the expected value
within the pre-specified tolerance."""
asarray
=
_as_numpy_array
(
actual
)
if
asarray
is
not
None
:
# Call ``__eq__()`` manually to prevent infinite-recursion with
# numpy<1.13.  See #3748.
return
all
(
self
.
__eq__
(
a
)
for
a
in
asarray
.
flat
)
# Short-circuit exact equality, except for bool
if
isinstance
(
self
.
expected
,
bool
)
and
not
isinstance
(
actual
,
bool
):
return
False
elif
actual
==
self
.
expected
:
return
True
# If either type is non-numeric, fall back to strict equality.
# NB: we need Complex, rather than just Number, to ensure that __abs__,
# __sub__, and __float__ are defined. Also, consider bool to be
# nonnumeric, even though it has the required arithmetic.
if
isinstance
(
self
.
expected
,
bool
)
or
not
(
isinstance
(
self
.
expected
,
(
Complex
,
Decimal
))
and
isinstance
(
actual
,
(
Complex
,
Decimal
))
):
return
False
# Allow the user to control whether NaNs are considered equal to each
# other or not.  The abs() calls are for compatibility with complex
# numbers.
if
math
.
isnan
(
abs
(
self
.
expected
)):
return
self
.
nan_ok
and
math
.
isnan
(
abs
(
actual
))
# Infinity shouldn't be approximately equal to anything but itself, but
# if there's a relative tolerance, it will be infinite and infinity
# will seem approximately equal to everything.  The equal-to-itself
# case would have been short circuited above, so here we can just
# return false if the expected value is infinite.  The abs() call is
# for compatibility with complex numbers.
if
math
.
isinf
(
abs
(
self
.
expected
)):
return
False
# Return true if the two numbers are within the tolerance.
result
:
bool
=
abs
(
self
.
expected
-
actual
)
<=
self
.
tolerance
return
result
# Ignore type because of https://github.com/python/mypy/issues/4266.
__hash__
=
None
# type: ignore
@property
def
tolerance
(
self
):
"""Return the tolerance for the comparison.
This could be either an absolute tolerance or a relative tolerance,
depending on what the user specified or which would be larger.
"""
def
set_default
(
x
,
default
):
return
x
if
x
is
not
None
else
default
# Figure out what the absolute tolerance should be.  ``self.abs`` is
# either None or a value specified by the user.
absolute_tolerance
=
set_default
(
self
.
abs
,
self
.
DEFAULT_ABSOLUTE_TOLERANCE
)
if
absolute_tolerance
<
0
:
raise
ValueError
(
f
"absolute tolerance can't be negative:
{
absolute_tolerance
}
"
)
if
math
.
isnan
(
absolute_tolerance
):
raise
ValueError
(
"absolute tolerance can't be NaN."
)
# If the user specified an absolute tolerance but not a relative one,
# just return the absolute tolerance.
if
self
.
rel
is
None
:
if
self
.
abs
is
not
None
:
return
absolute_tolerance
# Figure out what the relative tolerance should be.  ``self.rel`` is
# either None or a value specified by the user.  This is done after
# we've made sure the user didn't ask for an absolute tolerance only,
# because we don't want to raise errors about the relative tolerance if
# we aren't even going to use it.
relative_tolerance
=
set_default
(
self
.
rel
,
self
.
DEFAULT_RELATIVE_TOLERANCE
)
*
abs
(
self
.
expected
)
if
relative_tolerance
<
0
:
raise
ValueError
(
f
"relative tolerance can't be negative:
{
relative_tolerance
}
"
)
if
math
.
isnan
(
relative_tolerance
):
raise
ValueError
(
"relative tolerance can't be NaN."
)
# Return the larger of the relative and absolute tolerances.
return
max
(
relative_tolerance
,
absolute_tolerance
)
class
ApproxDecimal
(
ApproxScalar
):
"""Perform approximate comparisons where the expected value is a Decimal."""
DEFAULT_ABSOLUTE_TOLERANCE
=
Decimal
(
"1e-12"
)
DEFAULT_RELATIVE_TOLERANCE
=
Decimal
(
"1e-6"
)
[docs]
def
approx
(
expected
,
rel
=
None
,
abs
=
None
,
nan_ok
:
bool
=
False
)
->
ApproxBase
:
"""Assert that two numbers (or two ordered sequences of numbers) are equal to each other
within some tolerance.
Due to the :doc:`python:tutorial/floatingpoint`, numbers that we
would intuitively expect to be equal are not always so::
>>> 0.1 + 0.2 == 0.3
False
This problem is commonly encountered when writing tests, e.g. when making
sure that floating-point values are what you expect them to be.  One way to
deal with this problem is to assert that two floating-point numbers are
equal to within some appropriate tolerance::
>>> abs((0.1 + 0.2) - 0.3) < 1e-6
True
However, comparisons like this are tedious to write and difficult to
understand.  Furthermore, absolute comparisons like the one above are
usually discouraged because there's no tolerance that works well for all
situations.  ``1e-6`` is good for numbers around ``1``, but too small for
very big numbers and too big for very small ones.  It's better to express
the tolerance as a fraction of the expected value, but relative comparisons
like that are even more difficult to write correctly and concisely.
The ``approx`` class performs floating-point comparisons using a syntax
that's as intuitive as possible::
>>> from pytest import approx
>>> 0.1 + 0.2 == approx(0.3)
True
The same syntax also works for ordered sequences of numbers::
>>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
True
``numpy`` arrays::
>>> import numpy as np                                                          # doctest: +SKIP
>>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
True
And for a ``numpy`` array against a scalar::
>>> import numpy as np                                         # doctest: +SKIP
>>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
True
Only ordered sequences are supported, because ``approx`` needs
to infer the relative position of the sequences without ambiguity. This means
``sets`` and other unordered sequences are not supported.
Finally, dictionary *values* can also be compared::
>>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
True
The comparison will be true if both mappings have the same keys and their
respective values match the expected tolerances.
**Tolerances**
By default, ``approx`` considers numbers within a relative tolerance of
``1e-6`` (i.e. one part in a million) of its expected value to be equal.
This treatment would lead to surprising results if the expected value was
``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
To handle this case less surprisingly, ``approx`` also considers numbers
within an absolute tolerance of ``1e-12`` of its expected value to be
equal.  Infinity and NaN are special cases.  Infinity is only considered
equal to itself, regardless of the relative tolerance.  NaN is not
considered equal to anything by default, but you can make it be equal to
itself by setting the ``nan_ok`` argument to True.  (This is meant to
facilitate comparing arrays that use NaN to mean "no data".)
Both the relative and absolute tolerances can be changed by passing
arguments to the ``approx`` constructor::
>>> 1.0001 == approx(1)
False
>>> 1.0001 == approx(1, rel=1e-3)
True
>>> 1.0001 == approx(1, abs=1e-3)
True
If you specify ``abs`` but not ``rel``, the comparison will not consider
the relative tolerance at all.  In other words, two numbers that are within
the default relative tolerance of ``1e-6`` will still be considered unequal
if they exceed the specified absolute tolerance.  If you specify both
``abs`` and ``rel``, the numbers will be considered equal if either
tolerance is met::
>>> 1 + 1e-8 == approx(1)
True
>>> 1 + 1e-8 == approx(1, abs=1e-12)
False
>>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
True
You can also use ``approx`` to compare nonnumeric types, or dicts and
sequences containing nonnumeric types, in which case it falls back to
strict equality. This can be useful for comparing dicts and sequences that
can contain optional values::
>>> {"required": 1.0000005, "optional": None} == approx({"required": 1, "optional": None})
True
>>> [None, 1.0000005] == approx([None,1])
True
>>> ["foo", 1.0000005] == approx([None,1])
False
If you're thinking about using ``approx``, then you might want to know how
it compares to other good ways of comparing floating-point numbers.  All of
these algorithms are based on relative and absolute tolerances and should
agree for the most part, but they do have meaningful differences:
- ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute
tolerance is met.  Because the relative tolerance is calculated w.r.t.
both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
``b`` is a "reference value").  You have to specify an absolute tolerance
if you want to compare to ``0.0`` because there is no tolerance by
default.  More information: :py:func:`math.isclose`.
- ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
between ``a`` and ``b`` is less that the sum of the relative tolerance
w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
is only calculated w.r.t. ``b``, this test is asymmetric and you can
think of ``b`` as the reference value.  Support for comparing sequences
is provided by :py:func:`numpy.allclose`.  More information:
:std:doc:`numpy:reference/generated/numpy.isclose`.
- ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
are within an absolute tolerance of ``1e-7``.  No relative tolerance is
considered , so this function is not appropriate for very large or very
small numbers.  Also, it's only available in subclasses of ``unittest.TestCase``
and it's ugly because it doesn't follow PEP8.  More information:
:py:meth:`unittest.TestCase.assertAlmostEqual`.
- ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.
Because the relative tolerance is only calculated w.r.t. ``b``, this test
is asymmetric and you can think of ``b`` as the reference value.  In the
special case that you explicitly specify an absolute tolerance but not a
relative tolerance, only the absolute tolerance is considered.
.. note::
``approx`` can handle numpy arrays, but we recommend the
specialised test helpers in :std:doc:`numpy:reference/routines.testing`
if you need support for comparisons, NaNs, or ULP-based tolerances.
To match strings using regex, you can use
`Matches <https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs>`_
from the
`re_assert package <https://github.com/asottile/re-assert>`_.
.. warning::
.. versionchanged:: 3.2
In order to avoid inconsistent behavior, :py:exc:`TypeError` is
raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.
The example below illustrates the problem::
assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)
In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
comparison. This is because the call hierarchy of rich comparisons
follows a fixed behavior. More information: :py:meth:`object.__ge__`
.. versionchanged:: 3.7.1
``approx`` raises ``TypeError`` when it encounters a dict value or
sequence element of nonnumeric type.
.. versionchanged:: 6.1.0
``approx`` falls back to strict equality for nonnumeric types instead
of raising ``TypeError``.
"""
# Delegate the comparison to a class that knows how to deal with the type
# of the expected value (e.g. int, float, list, dict, numpy.array, etc).
#
# The primary responsibility of these classes is to implement ``__eq__()``
# and ``__repr__()``.  The former is used to actually check if some
# "actual" value is equivalent to the given expected value within the
# allowed tolerance.  The latter is used to show the user the expected
# value and tolerance, in the case that a test failed.
#
# The actual logic for making approximate comparisons can be found in
# ApproxScalar, which is used to compare individual numbers.  All of the
# other Approx classes eventually delegate to this class.  The ApproxBase
# class provides some convenient methods and overloads, but isn't really
# essential.
__tracebackhide__
=
True
if
isinstance
(
expected
,
Decimal
):
cls
:
type
[
ApproxBase
]
=
ApproxDecimal
elif
isinstance
(
expected
,
Mapping
):
cls
=
ApproxMapping
elif
_is_numpy_array
(
expected
):
expected
=
_as_numpy_array
(
expected
)
cls
=
ApproxNumpy
elif
_is_sequence_like
(
expected
):
cls
=
ApproxSequenceLike
elif
isinstance
(
expected
,
Collection
)
and
not
isinstance
(
expected
,
(
str
,
bytes
)):
msg
=
f
"pytest.approx() only supports ordered sequences, but got:
{
expected
!r}
"
raise
TypeError
(
msg
)
else
:
cls
=
ApproxScalar
return
cls
(
expected
,
rel
,
abs
,
nan_ok
)
def
_is_sequence_like
(
expected
:
object
)
->
bool
:
return
(
hasattr
(
expected
,
"__getitem__"
)
and
isinstance
(
expected
,
Sized
)
and
not
isinstance
(
expected
,
(
str
,
bytes
))
)
def
_is_numpy_array
(
obj
:
object
)
->
bool
:
"""
Return true if the given object is implicitly convertible to ndarray,
and numpy is already imported.
"""
return
_as_numpy_array
(
obj
)
is
not
None
def
_as_numpy_array
(
obj
:
object
)
->
ndarray
|
None
:
"""
Return an ndarray if the given object is implicitly convertible to ndarray,
and numpy is already imported, otherwise None.
"""
import
sys
np
:
Any
=
sys
.
modules
.
get
(
"numpy"
)
if
np
is
not
None
:
# avoid infinite recursion on numpy scalars, which have __array__
if
np
.
isscalar
(
obj
):
return
None
elif
isinstance
(
obj
,
np
.
ndarray
):
return
obj
elif
hasattr
(
obj
,
"__array__"
)
or
hasattr
(
"obj"
,
"__array_interface__"
):
return
np
.
asarray
(
obj
)
return
None
# builtin pytest.raises helper
E
=
TypeVar
(
"E"
,
bound
=
BaseException
)
@overload
def
raises
(
expected_exception
:
type
[
E
]
|
tuple
[
type
[
E
],
...
],
*
,
match
:
str
|
Pattern
[
str
]
|
None
=
...
,
)
->
RaisesContext
[
E
]:
...
@overload
def
raises
(
expected_exception
:
type
[
E
]
|
tuple
[
type
[
E
],
...
],
func
:
Callable
[
...
,
Any
],
*
args
:
Any
,
**
kwargs
:
Any
,
)
->
_pytest
.
_code
.
ExceptionInfo
[
E
]:
...
[docs]
def
raises
(
expected_exception
:
type
[
E
]
|
tuple
[
type
[
E
],
...
],
*
args
:
Any
,
**
kwargs
:
Any
)
->
RaisesContext
[
E
]
|
_pytest
.
_code
.
ExceptionInfo
[
E
]:
r
"""Assert that a code block/function call raises an exception type, or one of its subclasses.
:param expected_exception:
The expected exception type, or a tuple if one of multiple possible
exception types are expected. Note that subclasses of the passed exceptions
will also match.
:kwparam str | re.Pattern[str] | None match:
If specified, a string containing a regular expression,
or a regular expression object, that is tested against the string
representation of the exception and its :pep:`678` `__notes__`
using :func:`re.search`.
To match a literal string that may contain :ref:`special characters
<re-syntax>`, the pattern can first be escaped with :func:`re.escape`.
(This is only used when ``pytest.raises`` is used as a context manager,
and passed through to the function otherwise.
When using ``pytest.raises`` as a function, you can use:
``pytest.raises(Exc, func, match="passed on").match("my pattern")``.)
Use ``pytest.raises`` as a context manager, which will capture the exception of the given
type, or any of its subclasses::
>>> import pytest
>>> with pytest.raises(ZeroDivisionError):
...    1/0
If the code block does not raise the expected exception (:class:`ZeroDivisionError` in the example
above), or no exception at all, the check will fail instead.
You can also use the keyword argument ``match`` to assert that the
exception matches a text or regex::
>>> with pytest.raises(ValueError, match='must be 0 or None'):
...     raise ValueError("value must be 0 or None")
>>> with pytest.raises(ValueError, match=r'must be \d+$'):
...     raise ValueError("value must be 42")
The ``match`` argument searches the formatted exception string, which includes any
`PEP-678 <https://peps.python.org/pep-0678/>`__ ``__notes__``:
>>> with pytest.raises(ValueError, match=r"had a note added"):  # doctest: +SKIP
...     e = ValueError("value must be 42")
...     e.add_note("had a note added")
...     raise e
The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
details of the captured exception::
>>> with pytest.raises(ValueError) as exc_info:
...     raise ValueError("value must be 42")
>>> assert exc_info.type is ValueError
>>> assert exc_info.value.args[0] == "value must be 42"
.. warning::
Given that ``pytest.raises`` matches subclasses, be wary of using it to match :class:`Exception` like this::
with pytest.raises(Exception):  # Careful, this will catch ANY exception raised.
some_function()
Because :class:`Exception` is the base class of almost all exceptions, it is easy for this to hide
real bugs, where the user wrote this expecting a specific exception, but some other exception is being
raised due to a bug introduced during a refactoring.
Avoid using ``pytest.raises`` to catch :class:`Exception` unless certain that you really want to catch
**any** exception raised.
.. note::
When using ``pytest.raises`` as a context manager, it's worthwhile to
note that normal context manager rules apply and that the exception
raised *must* be the final line in the scope of the context manager.
Lines of code after that, within the scope of the context manager will
not be executed. For example::
>>> value = 15
>>> with pytest.raises(ValueError) as exc_info:
...     if value > 10:
...         raise ValueError("value must be <= 10")
...     assert exc_info.type is ValueError  # This will not execute.
Instead, the following approach must be taken (note the difference in
scope)::
>>> with pytest.raises(ValueError) as exc_info:
...     if value > 10:
...         raise ValueError("value must be <= 10")
...
>>> assert exc_info.type is ValueError
**Using with** ``pytest.mark.parametrize``
When using :ref:`pytest.mark.parametrize ref`
it is possible to parametrize tests such that
some runs raise an exception and others do not.
See :ref:`parametrizing_conditional_raising` for an example.
.. seealso::
:ref:`assertraises` for more examples and detailed discussion.
**Legacy form**
It is possible to specify a callable by passing a to-be-called lambda::
>>> raises(ZeroDivisionError, lambda: 1/0)
<ExceptionInfo ...>
or you can specify an arbitrary callable with arguments::
>>> def f(x): return 1/x
...
>>> raises(ZeroDivisionError, f, 0)
<ExceptionInfo ...>
>>> raises(ZeroDivisionError, f, x=0)
<ExceptionInfo ...>
The form above is fully supported but discouraged for new code because the
context manager form is regarded as more readable and less error-prone.
.. note::
Similar to caught exception objects in Python, explicitly clearing
local references to returned ``ExceptionInfo`` objects can
help the Python interpreter speed up its garbage collection.
Clearing those references breaks a reference cycle
(``ExceptionInfo`` --> caught exception --> frame stack raising
the exception --> current frame stack --> local variables -->
``ExceptionInfo``) which makes Python keep all objects referenced
from that cycle (including all local variables in the current
frame) alive until the next cyclic garbage collection run.
More detailed information can be found in the official Python
documentation for :ref:`the try statement <python:try>`.
"""
__tracebackhide__
=
True
if
not
expected_exception
:
raise
ValueError
(
f
"Expected an exception type or a tuple of exception types, but got `
{
expected_exception
!r}
`. "
f
"Raising exceptions is already understood as failing the test, so you don't need "
f
"any special code to say 'this should never raise an exception'."
)
if
isinstance
(
expected_exception
,
type
):
expected_exceptions
:
tuple
[
type
[
E
],
...
]
=
(
expected_exception
,)
else
:
expected_exceptions
=
expected_exception
for
exc
in
expected_exceptions
:
if
not
isinstance
(
exc
,
type
)
or
not
issubclass
(
exc
,
BaseException
):
msg
=
"expected exception must be a BaseException type, not
{}
"
# type: ignore[unreachable]
not_a
=
exc
.
__name__
if
isinstance
(
exc
,
type
)
else
type
(
exc
)
.
__name__
raise
TypeError
(
msg
.
format
(
not_a
))
message
=
f
"DID NOT RAISE
{
expected_exception
}
"
if
not
args
:
match
:
str
|
Pattern
[
str
]
|
None
=
kwargs
.
pop
(
"match"
,
None
)
if
kwargs
:
msg
=
"Unexpected keyword arguments passed to pytest.raises: "
msg
+=
", "
.
join
(
sorted
(
kwargs
))
msg
+=
"
\n
Use context-manager form instead?"
raise
TypeError
(
msg
)
return
RaisesContext
(
expected_exception
,
message
,
match
)
else
:
func
=
args
[
0
]
if
not
callable
(
func
):
raise
TypeError
(
f
"
{
func
!r}
object (type:
{
type
(
func
)
}
) must be callable"
)
try
:
func
(
*
args
[
1
:],
**
kwargs
)
except
expected_exception
as
e
:
return
_pytest
.
_code
.
ExceptionInfo
.
from_exception
(
e
)
fail
(
message
)
# This doesn't work with mypy for now. Use fail.Exception instead.
raises
.
Exception
=
fail
.
Exception
# type: ignore
@final
class
RaisesContext
(
ContextManager
[
_pytest
.
_code
.
ExceptionInfo
[
E
]]):
def
__init__
(
self
,
expected_exception
:
type
[
E
]
|
tuple
[
type
[
E
],
...
],
message
:
str
,
match_expr
:
str
|
Pattern
[
str
]
|
None
=
None
,
)
->
None
:
self
.
expected_exception
=
expected_exception
self
.
message
=
message
self
.
match_expr
=
match_expr
self
.
excinfo
:
_pytest
.
_code
.
ExceptionInfo
[
E
]
|
None
=
None
if
self
.
match_expr
is
not
None
:
re_error
=
None
try
:
re
.
compile
(
self
.
match_expr
)
except
re
.
error
as
e
:
re_error
=
e
if
re_error
is
not
None
:
fail
(
f
"Invalid regex pattern provided to 'match':
{
re_error
}
"
)
def
__enter__
(
self
)
->
_pytest
.
_code
.
ExceptionInfo
[
E
]:
self
.
excinfo
=
_pytest
.
_code
.
ExceptionInfo
.
for_later
()
return
self
.
excinfo
def
__exit__
(
self
,
exc_type
:
type
[
BaseException
]
|
None
,
exc_val
:
BaseException
|
None
,
exc_tb
:
TracebackType
|
None
,
)
->
bool
:
__tracebackhide__
=
True
if
exc_type
is
None
:
fail
(
self
.
message
)
assert
self
.
excinfo
is
not
None
if
not
issubclass
(
exc_type
,
self
.
expected_exception
):
return
False
# Cast to narrow the exception type now that it's verified.
exc_info
=
cast
(
Tuple
[
Type
[
E
],
E
,
TracebackType
],
(
exc_type
,
exc_val
,
exc_tb
))
self
.
excinfo
.
fill_unfilled
(
exc_info
)
if
self
.
match_expr
is
not
None
:
self
.
excinfo
.
match
(
self
.
match_expr
)
return
True

```


---


# _pytest.stash - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/stash.html


# Source code for _pytest.stash

```

from
__future__
import
annotations
from
typing
import
Any
from
typing
import
cast
from
typing
import
Generic
from
typing
import
TypeVar
__all__
=
[
"Stash"
,
"StashKey"
]
T
=
TypeVar
(
"T"
)
D
=
TypeVar
(
"D"
)
[docs]
class
StashKey
(
Generic
[
T
]):
"""``StashKey`` is an object used as a key to a :class:`Stash`.
A ``StashKey`` is associated with the type ``T`` of the value of the key.
A ``StashKey`` is unique and cannot conflict with another key.
.. versionadded:: 7.0
"""
__slots__
=
()
[docs]
class
Stash
:
r
"""``Stash`` is a type-safe heterogeneous mutable mapping that
allows keys and value types to be defined separately from
where it (the ``Stash``) is created.
Usually you will be given an object which has a ``Stash``, for example
:class:`~pytest.Config` or a :class:`~_pytest.nodes.Node`:
.. code-block:: python
stash: Stash = some_object.stash
If a module or plugin wants to store data in this ``Stash``, it creates
:class:`StashKey`\s for its keys (at the module level):
.. code-block:: python
# At the top-level of the module
some_str_key = StashKey[str]()
some_bool_key = StashKey[bool]()
To store information:
.. code-block:: python
# Value type must match the key.
stash[some_str_key] = "value"
stash[some_bool_key] = True
To retrieve the information:
.. code-block:: python
# The static type of some_str is str.
some_str = stash[some_str_key]
# The static type of some_bool is bool.
some_bool = stash[some_bool_key]
.. versionadded:: 7.0
"""
__slots__
=
(
"_storage"
,)
def
__init__
(
self
)
->
None
:
self
.
_storage
:
dict
[
StashKey
[
Any
],
object
]
=
{}
[docs]
def
__setitem__
(
self
,
key
:
StashKey
[
T
],
value
:
T
)
->
None
:
"""Set a value for key."""
self
.
_storage
[
key
]
=
value
[docs]
def
__getitem__
(
self
,
key
:
StashKey
[
T
])
->
T
:
"""Get the value for key.
Raises ``KeyError`` if the key wasn't set before.
"""
return
cast
(
T
,
self
.
_storage
[
key
])
[docs]
def
get
(
self
,
key
:
StashKey
[
T
],
default
:
D
)
->
T
|
D
:
"""Get the value for key, or return default if the key wasn't set
before."""
try
:
return
self
[
key
]
except
KeyError
:
return
default
[docs]
def
setdefault
(
self
,
key
:
StashKey
[
T
],
default
:
T
)
->
T
:
"""Return the value of key if already set, otherwise set the value
of key to default and return default."""
try
:
return
self
[
key
]
except
KeyError
:
self
[
key
]
=
default
return
default
[docs]
def
__delitem__
(
self
,
key
:
StashKey
[
T
])
->
None
:
"""Delete the value for key.
Raises ``KeyError`` if the key wasn't set before.
"""
del
self
.
_storage
[
key
]
[docs]
def
__contains__
(
self
,
key
:
StashKey
[
T
])
->
bool
:
"""Return whether key was set."""
return
key
in
self
.
_storage
[docs]
def
__len__
(
self
)
->
int
:
"""Return how many items exist in the stash."""
return
len
(
self
.
_storage
)

```


---


# _pytest.mark.structures - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/mark/structures.html


# Source code for _pytest.mark.structures

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
import
collections.abc
import
dataclasses
import
inspect
from
typing
import
Any
from
typing
import
Callable
from
typing
import
Collection
from
typing
import
final
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Mapping
from
typing
import
MutableMapping
from
typing
import
NamedTuple
from
typing
import
overload
from
typing
import
Sequence
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
from
typing
import
Union
import
warnings
from
.._code
import
getfslineno
from
..compat
import
ascii_escaped
from
..compat
import
NOTSET
from
..compat
import
NotSetType
from
_pytest.config
import
Config
from
_pytest.deprecated
import
check_ispytest
from
_pytest.deprecated
import
MARKED_FIXTURE
from
_pytest.outcomes
import
fail
from
_pytest.scope
import
_ScopeName
from
_pytest.warning_types
import
PytestUnknownMarkWarning
if
TYPE_CHECKING
:
from
..nodes
import
Node
EMPTY_PARAMETERSET_OPTION
=
"empty_parameter_set_mark"
def
istestfunc
(
func
)
->
bool
:
return
callable
(
func
)
and
getattr
(
func
,
"__name__"
,
"<lambda>"
)
!=
"<lambda>"
def
get_empty_parameterset_mark
(
config
:
Config
,
argnames
:
Sequence
[
str
],
func
)
->
MarkDecorator
:
from
..nodes
import
Collector
fs
,
lineno
=
getfslineno
(
func
)
reason
=
"got empty parameter set
%r
, function
%s
at
%s
:
%d
"
%
(
argnames
,
func
.
__name__
,
fs
,
lineno
,
)
requested_mark
=
config
.
getini
(
EMPTY_PARAMETERSET_OPTION
)
if
requested_mark
in
(
""
,
None
,
"skip"
):
mark
=
MARK_GEN
.
skip
(
reason
=
reason
)
elif
requested_mark
==
"xfail"
:
mark
=
MARK_GEN
.
xfail
(
reason
=
reason
,
run
=
False
)
elif
requested_mark
==
"fail_at_collect"
:
f_name
=
func
.
__name__
_
,
lineno
=
getfslineno
(
func
)
raise
Collector
.
CollectError
(
"Empty parameter set in '
%s
' at line
%d
"
%
(
f_name
,
lineno
+
1
)
)
else
:
raise
LookupError
(
requested_mark
)
return
mark
class
ParameterSet
(
NamedTuple
):
values
:
Sequence
[
object
|
NotSetType
]
marks
:
Collection
[
MarkDecorator
|
Mark
]
id
:
str
|
None
@classmethod
def
param
(
cls
,
*
values
:
object
,
marks
:
MarkDecorator
|
Collection
[
MarkDecorator
|
Mark
]
=
(),
id
:
str
|
None
=
None
,
)
->
ParameterSet
:
if
isinstance
(
marks
,
MarkDecorator
):
marks
=
(
marks
,)
else
:
assert
isinstance
(
marks
,
collections
.
abc
.
Collection
)
if
id
is
not
None
:
if
not
isinstance
(
id
,
str
):
raise
TypeError
(
f
"Expected id to be a string, got
{
type
(
id
)
}
:
{
id
!r}
"
)
id
=
ascii_escaped
(
id
)
return
cls
(
values
,
marks
,
id
)
@classmethod
def
extract_from
(
cls
,
parameterset
:
ParameterSet
|
Sequence
[
object
]
|
object
,
force_tuple
:
bool
=
False
,
)
->
ParameterSet
:
"""Extract from an object or objects.
:param parameterset:
A legacy style parameterset that may or may not be a tuple,
and may or may not be wrapped into a mess of mark objects.
:param force_tuple:
Enforce tuple wrapping so single argument tuple values
don't get decomposed and break tests.
"""
if
isinstance
(
parameterset
,
cls
):
return
parameterset
if
force_tuple
:
return
cls
.
param
(
parameterset
)
else
:
# TODO: Refactor to fix this type-ignore. Currently the following
# passes type-checking but crashes:
#
#   @pytest.mark.parametrize(('x', 'y'), [1, 2])
#   def test_foo(x, y): pass
return
cls
(
parameterset
,
marks
=
[],
id
=
None
)
# type: ignore[arg-type]
@staticmethod
def
_parse_parametrize_args
(
argnames
:
str
|
Sequence
[
str
],
argvalues
:
Iterable
[
ParameterSet
|
Sequence
[
object
]
|
object
],
*
args
,
**
kwargs
,
)
->
tuple
[
Sequence
[
str
],
bool
]:
if
isinstance
(
argnames
,
str
):
argnames
=
[
x
.
strip
()
for
x
in
argnames
.
split
(
","
)
if
x
.
strip
()]
force_tuple
=
len
(
argnames
)
==
1
else
:
force_tuple
=
False
return
argnames
,
force_tuple
@staticmethod
def
_parse_parametrize_parameters
(
argvalues
:
Iterable
[
ParameterSet
|
Sequence
[
object
]
|
object
],
force_tuple
:
bool
,
)
->
list
[
ParameterSet
]:
return
[
ParameterSet
.
extract_from
(
x
,
force_tuple
=
force_tuple
)
for
x
in
argvalues
]
@classmethod
def
_for_parametrize
(
cls
,
argnames
:
str
|
Sequence
[
str
],
argvalues
:
Iterable
[
ParameterSet
|
Sequence
[
object
]
|
object
],
func
,
config
:
Config
,
nodeid
:
str
,
)
->
tuple
[
Sequence
[
str
],
list
[
ParameterSet
]]:
argnames
,
force_tuple
=
cls
.
_parse_parametrize_args
(
argnames
,
argvalues
)
parameters
=
cls
.
_parse_parametrize_parameters
(
argvalues
,
force_tuple
)
del
argvalues
if
parameters
:
# Check all parameter sets have the correct number of values.
for
param
in
parameters
:
if
len
(
param
.
values
)
!=
len
(
argnames
):
msg
=
(
'
{nodeid}
: in "parametrize" the number of names (
{names_len}
):
\n
'
"
{names}
\n
"
"must be equal to the number of values (
{values_len}
):
\n
"
"
{values}
"
)
fail
(
msg
.
format
(
nodeid
=
nodeid
,
values
=
param
.
values
,
names
=
argnames
,
names_len
=
len
(
argnames
),
values_len
=
len
(
param
.
values
),
),
pytrace
=
False
,
)
else
:
# Empty parameter set (likely computed at runtime): create a single
# parameter set with NOTSET values, with the "empty parameter set" mark applied to it.
mark
=
get_empty_parameterset_mark
(
config
,
argnames
,
func
)
parameters
.
append
(
ParameterSet
(
values
=
(
NOTSET
,)
*
len
(
argnames
),
marks
=
[
mark
],
id
=
None
)
)
return
argnames
,
parameters
[docs]
@final
@dataclasses
.
dataclass
(
frozen
=
True
)
class
Mark
:
"""A pytest mark."""
#: Name of the mark.
name
:
str
#: Positional arguments of the mark decorator.
args
:
tuple
[
Any
,
...
]
#: Keyword arguments of the mark decorator.
kwargs
:
Mapping
[
str
,
Any
]
#: Source Mark for ids with parametrize Marks.
_param_ids_from
:
Mark
|
None
=
dataclasses
.
field
(
default
=
None
,
repr
=
False
)
#: Resolved/generated ids with parametrize Marks.
_param_ids_generated
:
Sequence
[
str
]
|
None
=
dataclasses
.
field
(
default
=
None
,
repr
=
False
)
def
__init__
(
self
,
name
:
str
,
args
:
tuple
[
Any
,
...
],
kwargs
:
Mapping
[
str
,
Any
],
param_ids_from
:
Mark
|
None
=
None
,
param_ids_generated
:
Sequence
[
str
]
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
""":meta private:"""
check_ispytest
(
_ispytest
)
# Weirdness to bypass frozen=True.
object
.
__setattr__
(
self
,
"name"
,
name
)
object
.
__setattr__
(
self
,
"args"
,
args
)
object
.
__setattr__
(
self
,
"kwargs"
,
kwargs
)
object
.
__setattr__
(
self
,
"_param_ids_from"
,
param_ids_from
)
object
.
__setattr__
(
self
,
"_param_ids_generated"
,
param_ids_generated
)
def
_has_param_ids
(
self
)
->
bool
:
return
"ids"
in
self
.
kwargs
or
len
(
self
.
args
)
>=
4
[docs]
def
combined_with
(
self
,
other
:
Mark
)
->
Mark
:
"""Return a new Mark which is a combination of this
Mark and another Mark.
Combines by appending args and merging kwargs.
:param Mark other: The mark to combine with.
:rtype: Mark
"""
assert
self
.
name
==
other
.
name
# Remember source of ids with parametrize Marks.
param_ids_from
:
Mark
|
None
=
None
if
self
.
name
==
"parametrize"
:
if
other
.
_has_param_ids
():
param_ids_from
=
other
elif
self
.
_has_param_ids
():
param_ids_from
=
self
return
Mark
(
self
.
name
,
self
.
args
+
other
.
args
,
dict
(
self
.
kwargs
,
**
other
.
kwargs
),
param_ids_from
=
param_ids_from
,
_ispytest
=
True
,
)
# A generic parameter designating an object to which a Mark may
# be applied -- a test function (callable) or class.
# Note: a lambda is not allowed, but this can't be represented.
Markable
=
TypeVar
(
"Markable"
,
bound
=
Union
[
Callable
[
...
,
object
],
type
])
[docs]
@dataclasses
.
dataclass
class
MarkDecorator
:
"""A decorator for applying a mark on test functions and classes.
``MarkDecorators`` are created with ``pytest.mark``::
mark1 = pytest.mark.NAME  # Simple MarkDecorator
mark2 = pytest.mark.NAME(name1=value)  # Parametrized MarkDecorator
and can then be applied as decorators to test functions::
@mark2
def test_function():
pass
When a ``MarkDecorator`` is called, it does the following:
1. If called with a single class as its only positional argument and no
additional keyword arguments, it attaches the mark to the class so it
gets applied automatically to all test cases found in that class.
2. If called with a single function as its only positional argument and
no additional keyword arguments, it attaches the mark to the function,
containing all the arguments already stored internally in the
``MarkDecorator``.
3. When called in any other case, it returns a new ``MarkDecorator``
instance with the original ``MarkDecorator``'s content updated with
the arguments passed to this call.
Note: The rules above prevent a ``MarkDecorator`` from storing only a
single function or class reference as its positional argument with no
additional keyword or positional arguments. You can work around this by
using `with_args()`.
"""
mark
:
Mark
def
__init__
(
self
,
mark
:
Mark
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
""":meta private:"""
check_ispytest
(
_ispytest
)
self
.
mark
=
mark
@property
def
name
(
self
)
->
str
:
"""Alias for mark.name."""
return
self
.
mark
.
name
@property
def
args
(
self
)
->
tuple
[
Any
,
...
]:
"""Alias for mark.args."""
return
self
.
mark
.
args
@property
def
kwargs
(
self
)
->
Mapping
[
str
,
Any
]:
"""Alias for mark.kwargs."""
return
self
.
mark
.
kwargs
@property
def
markname
(
self
)
->
str
:
""":meta private:"""
return
self
.
name
# for backward-compat (2.4.1 had this attr)
[docs]
def
with_args
(
self
,
*
args
:
object
,
**
kwargs
:
object
)
->
MarkDecorator
:
"""Return a MarkDecorator with extra arguments added.
Unlike calling the MarkDecorator, with_args() can be used even
if the sole argument is a callable/class.
"""
mark
=
Mark
(
self
.
name
,
args
,
kwargs
,
_ispytest
=
True
)
return
MarkDecorator
(
self
.
mark
.
combined_with
(
mark
),
_ispytest
=
True
)
# Type ignored because the overloads overlap with an incompatible
# return type. Not much we can do about that. Thankfully mypy picks
# the first match so it works out even if we break the rules.
@overload
def
__call__
(
self
,
arg
:
Markable
)
->
Markable
:
# type: ignore[overload-overlap]
pass
@overload
def
__call__
(
self
,
*
args
:
object
,
**
kwargs
:
object
)
->
MarkDecorator
:
pass
def
__call__
(
self
,
*
args
:
object
,
**
kwargs
:
object
):
"""Call the MarkDecorator."""
if
args
and
not
kwargs
:
func
=
args
[
0
]
is_class
=
inspect
.
isclass
(
func
)
if
len
(
args
)
==
1
and
(
istestfunc
(
func
)
or
is_class
):
store_mark
(
func
,
self
.
mark
,
stacklevel
=
3
)
return
func
return
self
.
with_args
(
*
args
,
**
kwargs
)
def
get_unpacked_marks
(
obj
:
object
|
type
,
*
,
consider_mro
:
bool
=
True
,
)
->
list
[
Mark
]:
"""Obtain the unpacked marks that are stored on an object.
If obj is a class and consider_mro is true, return marks applied to
this class and all of its super-classes in MRO order. If consider_mro
is false, only return marks applied directly to this class.
"""
if
isinstance
(
obj
,
type
):
if
not
consider_mro
:
mark_lists
=
[
obj
.
__dict__
.
get
(
"pytestmark"
,
[])]
else
:
mark_lists
=
[
x
.
__dict__
.
get
(
"pytestmark"
,
[])
for
x
in
reversed
(
obj
.
__mro__
)
]
mark_list
=
[]
for
item
in
mark_lists
:
if
isinstance
(
item
,
list
):
mark_list
.
extend
(
item
)
else
:
mark_list
.
append
(
item
)
else
:
mark_attribute
=
getattr
(
obj
,
"pytestmark"
,
[])
if
isinstance
(
mark_attribute
,
list
):
mark_list
=
mark_attribute
else
:
mark_list
=
[
mark_attribute
]
return
list
(
normalize_mark_list
(
mark_list
))
def
normalize_mark_list
(
mark_list
:
Iterable
[
Mark
|
MarkDecorator
],
)
->
Iterable
[
Mark
]:
"""
Normalize an iterable of Mark or MarkDecorator objects into a list of marks
by retrieving the `mark` attribute on MarkDecorator instances.
:param mark_list: marks to normalize
:returns: A new list of the extracted Mark objects
"""
for
mark
in
mark_list
:
mark_obj
=
getattr
(
mark
,
"mark"
,
mark
)
if
not
isinstance
(
mark_obj
,
Mark
):
raise
TypeError
(
f
"got
{
mark_obj
!r}
instead of Mark"
)
yield
mark_obj
def
store_mark
(
obj
,
mark
:
Mark
,
*
,
stacklevel
:
int
=
2
)
->
None
:
"""Store a Mark on an object.
This is used to implement the Mark declarations/decorators correctly.
"""
assert
isinstance
(
mark
,
Mark
),
mark
from
..fixtures
import
getfixturemarker
if
getfixturemarker
(
obj
)
is
not
None
:
warnings
.
warn
(
MARKED_FIXTURE
,
stacklevel
=
stacklevel
)
# Always reassign name to avoid updating pytestmark in a reference that
# was only borrowed.
obj
.
pytestmark
=
[
*
get_unpacked_marks
(
obj
,
consider_mro
=
False
),
mark
]
# Typing for builtin pytest marks. This is cheating; it gives builtin marks
# special privilege, and breaks modularity. But practicality beats purity...
if
TYPE_CHECKING
:
class
_SkipMarkDecorator
(
MarkDecorator
):
@overload
# type: ignore[override,no-overload-impl]
def
__call__
(
self
,
arg
:
Markable
)
->
Markable
:
...
@overload
def
__call__
(
self
,
reason
:
str
=
...
)
->
MarkDecorator
:
...
class
_SkipifMarkDecorator
(
MarkDecorator
):
def
__call__
(
# type: ignore[override]
self
,
condition
:
str
|
bool
=
...
,
*
conditions
:
str
|
bool
,
reason
:
str
=
...
,
)
->
MarkDecorator
:
...
class
_XfailMarkDecorator
(
MarkDecorator
):
@overload
# type: ignore[override,no-overload-impl]
def
__call__
(
self
,
arg
:
Markable
)
->
Markable
:
...
@overload
def
__call__
(
self
,
condition
:
str
|
bool
=
False
,
*
conditions
:
str
|
bool
,
reason
:
str
=
...
,
run
:
bool
=
...
,
raises
:
None
|
type
[
BaseException
]
|
tuple
[
type
[
BaseException
],
...
]
=
...
,
strict
:
bool
=
...
,
)
->
MarkDecorator
:
...
class
_ParametrizeMarkDecorator
(
MarkDecorator
):
def
__call__
(
# type: ignore[override]
self
,
argnames
:
str
|
Sequence
[
str
],
argvalues
:
Iterable
[
ParameterSet
|
Sequence
[
object
]
|
object
],
*
,
indirect
:
bool
|
Sequence
[
str
]
=
...
,
ids
:
Iterable
[
None
|
str
|
float
|
int
|
bool
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
...
,
scope
:
_ScopeName
|
None
=
...
,
)
->
MarkDecorator
:
...
class
_UsefixturesMarkDecorator
(
MarkDecorator
):
def
__call__
(
self
,
*
fixtures
:
str
)
->
MarkDecorator
:
# type: ignore[override]
...
class
_FilterwarningsMarkDecorator
(
MarkDecorator
):
def
__call__
(
self
,
*
filters
:
str
)
->
MarkDecorator
:
# type: ignore[override]
...
[docs]
@final
class
MarkGenerator
:
"""Factory for :class:`MarkDecorator` objects - exposed as
a ``pytest.mark`` singleton instance.
Example::
import pytest
@pytest.mark.slowtest
def test_function():
pass
applies a 'slowtest' :class:`Mark` on ``test_function``.
"""
# See TYPE_CHECKING above.
if
TYPE_CHECKING
:
skip
:
_SkipMarkDecorator
skipif
:
_SkipifMarkDecorator
xfail
:
_XfailMarkDecorator
parametrize
:
_ParametrizeMarkDecorator
usefixtures
:
_UsefixturesMarkDecorator
filterwarnings
:
_FilterwarningsMarkDecorator
def
__init__
(
self
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_config
:
Config
|
None
=
None
self
.
_markers
:
set
[
str
]
=
set
()
def
__getattr__
(
self
,
name
:
str
)
->
MarkDecorator
:
"""Generate a new :class:`MarkDecorator` with the given name."""
if
name
[
0
]
==
"_"
:
raise
AttributeError
(
"Marker name must NOT start with underscore"
)
if
self
.
_config
is
not
None
:
# We store a set of markers as a performance optimisation - if a mark
# name is in the set we definitely know it, but a mark may be known and
# not in the set.  We therefore start by updating the set!
if
name
not
in
self
.
_markers
:
for
line
in
self
.
_config
.
getini
(
"markers"
):
# example lines: "skipif(condition): skip the given test if..."
# or "hypothesis: tests which use Hypothesis", so to get the
# marker name we split on both `:` and `(`.
marker
=
line
.
split
(
":"
)[
0
]
.
split
(
"("
)[
0
]
.
strip
()
self
.
_markers
.
add
(
marker
)
# If the name is not in the set of known marks after updating,
# then it really is time to issue a warning or an error.
if
name
not
in
self
.
_markers
:
if
self
.
_config
.
option
.
strict_markers
or
self
.
_config
.
option
.
strict
:
fail
(
f
"
{
name
!r}
not found in `markers` configuration option"
,
pytrace
=
False
,
)
# Raise a specific error for common misspellings of "parametrize".
if
name
in
[
"parameterize"
,
"parametrise"
,
"parameterise"
]:
__tracebackhide__
=
True
fail
(
f
"Unknown '
{
name
}
' mark, did you mean 'parametrize'?"
)
warnings
.
warn
(
f
"Unknown pytest.mark.
{
name
}
- is this a typo?  You can register "
"custom marks to avoid this warning - for details, see "
"https://docs.pytest.org/en/stable/how-to/mark.html"
,
PytestUnknownMarkWarning
,
2
,
)
return
MarkDecorator
(
Mark
(
name
,
(),
{},
_ispytest
=
True
),
_ispytest
=
True
)
MARK_GEN
=
MarkGenerator
(
_ispytest
=
True
)
@final
class
NodeKeywords
(
MutableMapping
[
str
,
Any
]):
__slots__
=
(
"node"
,
"parent"
,
"_markers"
)
def
__init__
(
self
,
node
:
Node
)
->
None
:
self
.
node
=
node
self
.
parent
=
node
.
parent
self
.
_markers
=
{
node
.
name
:
True
}
def
__getitem__
(
self
,
key
:
str
)
->
Any
:
try
:
return
self
.
_markers
[
key
]
except
KeyError
:
if
self
.
parent
is
None
:
raise
return
self
.
parent
.
keywords
[
key
]
def
__setitem__
(
self
,
key
:
str
,
value
:
Any
)
->
None
:
self
.
_markers
[
key
]
=
value
# Note: we could've avoided explicitly implementing some of the methods
# below and use the collections.abc fallback, but that would be slow.
def
__contains__
(
self
,
key
:
object
)
->
bool
:
return
(
key
in
self
.
_markers
or
self
.
parent
is
not
None
and
key
in
self
.
parent
.
keywords
)
def
update
(
# type: ignore[override]
self
,
other
:
Mapping
[
str
,
Any
]
|
Iterable
[
tuple
[
str
,
Any
]]
=
(),
**
kwds
:
Any
,
)
->
None
:
self
.
_markers
.
update
(
other
)
self
.
_markers
.
update
(
kwds
)
def
__delitem__
(
self
,
key
:
str
)
->
None
:
raise
ValueError
(
"cannot delete key in keywords dict"
)
def
__iter__
(
self
)
->
Iterator
[
str
]:
# Doesn't need to be fast.
yield from
self
.
_markers
if
self
.
parent
is
not
None
:
for
keyword
in
self
.
parent
.
keywords
:
# self._marks and self.parent.keywords can have duplicates.
if
keyword
not
in
self
.
_markers
:
yield
keyword
def
__len__
(
self
)
->
int
:
# Doesn't need to be fast.
return
sum
(
1
for
keyword
in
self
)
def
__repr__
(
self
)
->
str
:
return
f
"<NodeKeywords for node
{
self
.
node
}
>"

```


---


# _pytest.capture - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/capture.html


# Source code for _pytest.capture

```

# mypy: allow-untyped-defs
"""Per-test stdout/stderr capturing mechanism."""
from
__future__
import
annotations
import
abc
import
collections
import
contextlib
import
io
from
io
import
UnsupportedOperation
import
os
import
sys
from
tempfile
import
TemporaryFile
from
types
import
TracebackType
from
typing
import
Any
from
typing
import
AnyStr
from
typing
import
BinaryIO
from
typing
import
Final
from
typing
import
final
from
typing
import
Generator
from
typing
import
Generic
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Literal
from
typing
import
NamedTuple
from
typing
import
TextIO
from
typing
import
TYPE_CHECKING
if
TYPE_CHECKING
:
from
typing_extensions
import
Self
from
_pytest.config
import
Config
from
_pytest.config
import
hookimpl
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
SubRequest
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
File
from
_pytest.nodes
import
Item
from
_pytest.reports
import
CollectReport
_CaptureMethod
=
Literal
[
"fd"
,
"sys"
,
"no"
,
"tee-sys"
]
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"general"
)
group
.
_addoption
(
"--capture"
,
action
=
"store"
,
default
=
"fd"
,
metavar
=
"method"
,
choices
=
[
"fd"
,
"sys"
,
"no"
,
"tee-sys"
],
help
=
"Per-test capturing method: one of fd|sys|no|tee-sys"
,
)
group
.
_addoption
(
"-s"
,
action
=
"store_const"
,
const
=
"no"
,
dest
=
"capture"
,
help
=
"Shortcut for --capture=no"
,
)
def
_colorama_workaround
()
->
None
:
"""Ensure colorama is imported so that it attaches to the correct stdio
handles on Windows.
colorama uses the terminal on import time. So if something does the
first import of colorama while I/O capture is active, colorama will
fail in various ways.
"""
if
sys
.
platform
.
startswith
(
"win32"
):
try
:
import
colorama
# noqa: F401
except
ImportError
:
pass
def
_readline_workaround
()
->
None
:
"""Ensure readline is imported early so it attaches to the correct stdio handles.
This isn't a problem with the default GNU readline implementation, but in
some configurations, Python uses libedit instead (on macOS, and for prebuilt
binaries such as used by uv).
In theory this is only needed if readline.backend == "libedit", but the
workaround consists of importing readline here, so we already worked around
the issue by the time we could check if we need to.
"""
try
:
import
readline
# noqa: F401
except
ImportError
:
pass
def
_windowsconsoleio_workaround
(
stream
:
TextIO
)
->
None
:
"""Workaround for Windows Unicode console handling.
Python 3.6 implemented Unicode console handling for Windows. This works
by reading/writing to the raw console handle using
``{Read,Write}ConsoleW``.
The problem is that we are going to ``dup2`` over the stdio file
descriptors when doing ``FDCapture`` and this will ``CloseHandle`` the
handles used by Python to write to the console. Though there is still some
weirdness and the console handle seems to only be closed randomly and not
on the first call to ``CloseHandle``, or maybe it gets reopened with the
same handle value when we suspend capturing.
The workaround in this case will reopen stdio with a different fd which
also means a different handle by replicating the logic in
"Py_lifecycle.c:initstdio/create_stdio".
:param stream:
In practice ``sys.stdout`` or ``sys.stderr``, but given
here as parameter for unittesting purposes.
See https://github.com/pytest-dev/py/issues/103.
"""
if
not
sys
.
platform
.
startswith
(
"win32"
)
or
hasattr
(
sys
,
"pypy_version_info"
):
return
# Bail out if ``stream`` doesn't seem like a proper ``io`` stream (#2666).
if
not
hasattr
(
stream
,
"buffer"
):
# type: ignore[unreachable,unused-ignore]
return
raw_stdout
=
stream
.
buffer
.
raw
if
hasattr
(
stream
.
buffer
,
"raw"
)
else
stream
.
buffer
if
not
isinstance
(
raw_stdout
,
io
.
_WindowsConsoleIO
):
# type: ignore[attr-defined,unused-ignore]
return
def
_reopen_stdio
(
f
,
mode
):
if
not
hasattr
(
stream
.
buffer
,
"raw"
)
and
mode
[
0
]
==
"w"
:
buffering
=
0
else
:
buffering
=
-
1
return
io
.
TextIOWrapper
(
open
(
os
.
dup
(
f
.
fileno
()),
mode
,
buffering
),
f
.
encoding
,
f
.
errors
,
f
.
newlines
,
f
.
line_buffering
,
)
sys
.
stdin
=
_reopen_stdio
(
sys
.
stdin
,
"rb"
)
sys
.
stdout
=
_reopen_stdio
(
sys
.
stdout
,
"wb"
)
sys
.
stderr
=
_reopen_stdio
(
sys
.
stderr
,
"wb"
)
@hookimpl
(
wrapper
=
True
)
def
pytest_load_initial_conftests
(
early_config
:
Config
)
->
Generator
[
None
]:
ns
=
early_config
.
known_args_namespace
if
ns
.
capture
==
"fd"
:
_windowsconsoleio_workaround
(
sys
.
stdout
)
_colorama_workaround
()
_readline_workaround
()
pluginmanager
=
early_config
.
pluginmanager
capman
=
CaptureManager
(
ns
.
capture
)
pluginmanager
.
register
(
capman
,
"capturemanager"
)
# Make sure that capturemanager is properly reset at final shutdown.
early_config
.
add_cleanup
(
capman
.
stop_global_capturing
)
# Finally trigger conftest loading but while capturing (issue #93).
capman
.
start_global_capturing
()
try
:
try
:
yield
finally
:
capman
.
suspend_global_capture
()
except
BaseException
:
out
,
err
=
capman
.
read_global_capture
()
sys
.
stdout
.
write
(
out
)
sys
.
stderr
.
write
(
err
)
raise
# IO Helpers.
class
EncodedFile
(
io
.
TextIOWrapper
):
__slots__
=
()
@property
def
name
(
self
)
->
str
:
# Ensure that file.name is a string. Workaround for a Python bug
# fixed in >=3.7.4: https://bugs.python.org/issue36015
return
repr
(
self
.
buffer
)
@property
def
mode
(
self
)
->
str
:
# TextIOWrapper doesn't expose a mode, but at least some of our
# tests check it.
return
self
.
buffer
.
mode
.
replace
(
"b"
,
""
)
class
CaptureIO
(
io
.
TextIOWrapper
):
def
__init__
(
self
)
->
None
:
super
()
.
__init__
(
io
.
BytesIO
(),
encoding
=
"UTF-8"
,
newline
=
""
,
write_through
=
True
)
def
getvalue
(
self
)
->
str
:
assert
isinstance
(
self
.
buffer
,
io
.
BytesIO
)
return
self
.
buffer
.
getvalue
()
.
decode
(
"UTF-8"
)
class
TeeCaptureIO
(
CaptureIO
):
def
__init__
(
self
,
other
:
TextIO
)
->
None
:
self
.
_other
=
other
super
()
.
__init__
()
def
write
(
self
,
s
:
str
)
->
int
:
super
()
.
write
(
s
)
return
self
.
_other
.
write
(
s
)
class
DontReadFromInput
(
TextIO
):
@property
def
encoding
(
self
)
->
str
:
assert
sys
.
__stdin__
is
not
None
return
sys
.
__stdin__
.
encoding
def
read
(
self
,
size
:
int
=
-
1
)
->
str
:
raise
OSError
(
"pytest: reading from stdin while output is captured!  Consider using `-s`."
)
readline
=
read
def
__next__
(
self
)
->
str
:
return
self
.
readline
()
def
readlines
(
self
,
hint
:
int
|
None
=
-
1
)
->
list
[
str
]:
raise
OSError
(
"pytest: reading from stdin while output is captured!  Consider using `-s`."
)
def
__iter__
(
self
)
->
Iterator
[
str
]:
return
self
def
fileno
(
self
)
->
int
:
raise
UnsupportedOperation
(
"redirected stdin is pseudofile, has no fileno()"
)
def
flush
(
self
)
->
None
:
raise
UnsupportedOperation
(
"redirected stdin is pseudofile, has no flush()"
)
def
isatty
(
self
)
->
bool
:
return
False
def
close
(
self
)
->
None
:
pass
def
readable
(
self
)
->
bool
:
return
False
def
seek
(
self
,
offset
:
int
,
whence
:
int
=
0
)
->
int
:
raise
UnsupportedOperation
(
"redirected stdin is pseudofile, has no seek(int)"
)
def
seekable
(
self
)
->
bool
:
return
False
def
tell
(
self
)
->
int
:
raise
UnsupportedOperation
(
"redirected stdin is pseudofile, has no tell()"
)
def
truncate
(
self
,
size
:
int
|
None
=
None
)
->
int
:
raise
UnsupportedOperation
(
"cannot truncate stdin"
)
def
write
(
self
,
data
:
str
)
->
int
:
raise
UnsupportedOperation
(
"cannot write to stdin"
)
def
writelines
(
self
,
lines
:
Iterable
[
str
])
->
None
:
raise
UnsupportedOperation
(
"Cannot write to stdin"
)
def
writable
(
self
)
->
bool
:
return
False
def
__enter__
(
self
)
->
Self
:
return
self
def
__exit__
(
self
,
type
:
type
[
BaseException
]
|
None
,
value
:
BaseException
|
None
,
traceback
:
TracebackType
|
None
,
)
->
None
:
pass
@property
def
buffer
(
self
)
->
BinaryIO
:
# The str/bytes doesn't actually matter in this type, so OK to fake.
return
self
# type: ignore[return-value]
# Capture classes.
class
CaptureBase
(
abc
.
ABC
,
Generic
[
AnyStr
]):
EMPTY_BUFFER
:
AnyStr
@abc
.
abstractmethod
def
__init__
(
self
,
fd
:
int
)
->
None
:
raise
NotImplementedError
()
@abc
.
abstractmethod
def
start
(
self
)
->
None
:
raise
NotImplementedError
()
@abc
.
abstractmethod
def
done
(
self
)
->
None
:
raise
NotImplementedError
()
@abc
.
abstractmethod
def
suspend
(
self
)
->
None
:
raise
NotImplementedError
()
@abc
.
abstractmethod
def
resume
(
self
)
->
None
:
raise
NotImplementedError
()
@abc
.
abstractmethod
def
writeorg
(
self
,
data
:
AnyStr
)
->
None
:
raise
NotImplementedError
()
@abc
.
abstractmethod
def
snap
(
self
)
->
AnyStr
:
raise
NotImplementedError
()
patchsysdict
=
{
0
:
"stdin"
,
1
:
"stdout"
,
2
:
"stderr"
}
class
NoCapture
(
CaptureBase
[
str
]):
EMPTY_BUFFER
=
""
def
__init__
(
self
,
fd
:
int
)
->
None
:
pass
def
start
(
self
)
->
None
:
pass
def
done
(
self
)
->
None
:
pass
def
suspend
(
self
)
->
None
:
pass
def
resume
(
self
)
->
None
:
pass
def
snap
(
self
)
->
str
:
return
""
def
writeorg
(
self
,
data
:
str
)
->
None
:
pass
class
SysCaptureBase
(
CaptureBase
[
AnyStr
]):
def
__init__
(
self
,
fd
:
int
,
tmpfile
:
TextIO
|
None
=
None
,
*
,
tee
:
bool
=
False
)
->
None
:
name
=
patchsysdict
[
fd
]
self
.
_old
:
TextIO
=
getattr
(
sys
,
name
)
self
.
name
=
name
if
tmpfile
is
None
:
if
name
==
"stdin"
:
tmpfile
=
DontReadFromInput
()
else
:
tmpfile
=
CaptureIO
()
if
not
tee
else
TeeCaptureIO
(
self
.
_old
)
self
.
tmpfile
=
tmpfile
self
.
_state
=
"initialized"
def
repr
(
self
,
class_name
:
str
)
->
str
:
return
"<
{}
{}
_old=
{}
_state=
{!r}
tmpfile=
{!r}
>"
.
format
(
class_name
,
self
.
name
,
hasattr
(
self
,
"_old"
)
and
repr
(
self
.
_old
)
or
"<UNSET>"
,
self
.
_state
,
self
.
tmpfile
,
)
def
__repr__
(
self
)
->
str
:
return
"<
{}
{}
_old=
{}
_state=
{!r}
tmpfile=
{!r}
>"
.
format
(
self
.
__class__
.
__name__
,
self
.
name
,
hasattr
(
self
,
"_old"
)
and
repr
(
self
.
_old
)
or
"<UNSET>"
,
self
.
_state
,
self
.
tmpfile
,
)
def
_assert_state
(
self
,
op
:
str
,
states
:
tuple
[
str
,
...
])
->
None
:
assert
(
self
.
_state
in
states
),
"cannot
{}
in state
{!r}
: expected one of
{}
"
.
format
(
op
,
self
.
_state
,
", "
.
join
(
states
)
)
def
start
(
self
)
->
None
:
self
.
_assert_state
(
"start"
,
(
"initialized"
,))
setattr
(
sys
,
self
.
name
,
self
.
tmpfile
)
self
.
_state
=
"started"
def
done
(
self
)
->
None
:
self
.
_assert_state
(
"done"
,
(
"initialized"
,
"started"
,
"suspended"
,
"done"
))
if
self
.
_state
==
"done"
:
return
setattr
(
sys
,
self
.
name
,
self
.
_old
)
del
self
.
_old
self
.
tmpfile
.
close
()
self
.
_state
=
"done"
def
suspend
(
self
)
->
None
:
self
.
_assert_state
(
"suspend"
,
(
"started"
,
"suspended"
))
setattr
(
sys
,
self
.
name
,
self
.
_old
)
self
.
_state
=
"suspended"
def
resume
(
self
)
->
None
:
self
.
_assert_state
(
"resume"
,
(
"started"
,
"suspended"
))
if
self
.
_state
==
"started"
:
return
setattr
(
sys
,
self
.
name
,
self
.
tmpfile
)
self
.
_state
=
"started"
class
SysCaptureBinary
(
SysCaptureBase
[
bytes
]):
EMPTY_BUFFER
=
b
""
def
snap
(
self
)
->
bytes
:
self
.
_assert_state
(
"snap"
,
(
"started"
,
"suspended"
))
self
.
tmpfile
.
seek
(
0
)
res
=
self
.
tmpfile
.
buffer
.
read
()
self
.
tmpfile
.
seek
(
0
)
self
.
tmpfile
.
truncate
()
return
res
def
writeorg
(
self
,
data
:
bytes
)
->
None
:
self
.
_assert_state
(
"writeorg"
,
(
"started"
,
"suspended"
))
self
.
_old
.
flush
()
self
.
_old
.
buffer
.
write
(
data
)
self
.
_old
.
buffer
.
flush
()
class
SysCapture
(
SysCaptureBase
[
str
]):
EMPTY_BUFFER
=
""
def
snap
(
self
)
->
str
:
self
.
_assert_state
(
"snap"
,
(
"started"
,
"suspended"
))
assert
isinstance
(
self
.
tmpfile
,
CaptureIO
)
res
=
self
.
tmpfile
.
getvalue
()
self
.
tmpfile
.
seek
(
0
)
self
.
tmpfile
.
truncate
()
return
res
def
writeorg
(
self
,
data
:
str
)
->
None
:
self
.
_assert_state
(
"writeorg"
,
(
"started"
,
"suspended"
))
self
.
_old
.
write
(
data
)
self
.
_old
.
flush
()
class
FDCaptureBase
(
CaptureBase
[
AnyStr
]):
def
__init__
(
self
,
targetfd
:
int
)
->
None
:
self
.
targetfd
=
targetfd
try
:
os
.
fstat
(
targetfd
)
except
OSError
:
# FD capturing is conceptually simple -- create a temporary file,
# redirect the FD to it, redirect back when done. But when the
# target FD is invalid it throws a wrench into this lovely scheme.
#
# Tests themselves shouldn't care if the FD is valid, FD capturing
# should work regardless of external circumstances. So falling back
# to just sys capturing is not a good option.
#
# Further complications are the need to support suspend() and the
# possibility of FD reuse (e.g. the tmpfile getting the very same
# target FD). The following approach is robust, I believe.
self
.
targetfd_invalid
:
int
|
None
=
os
.
open
(
os
.
devnull
,
os
.
O_RDWR
)
os
.
dup2
(
self
.
targetfd_invalid
,
targetfd
)
else
:
self
.
targetfd_invalid
=
None
self
.
targetfd_save
=
os
.
dup
(
targetfd
)
if
targetfd
==
0
:
self
.
tmpfile
=
open
(
os
.
devnull
,
encoding
=
"utf-8"
)
self
.
syscapture
:
CaptureBase
[
str
]
=
SysCapture
(
targetfd
)
else
:
self
.
tmpfile
=
EncodedFile
(
TemporaryFile
(
buffering
=
0
),
encoding
=
"utf-8"
,
errors
=
"replace"
,
newline
=
""
,
write_through
=
True
,
)
if
targetfd
in
patchsysdict
:
self
.
syscapture
=
SysCapture
(
targetfd
,
self
.
tmpfile
)
else
:
self
.
syscapture
=
NoCapture
(
targetfd
)
self
.
_state
=
"initialized"
def
__repr__
(
self
)
->
str
:
return
(
f
"<
{
self
.
__class__
.
__name__
}
{
self
.
targetfd
}
oldfd=
{
self
.
targetfd_save
}
"
f
"_state=
{
self
.
_state
!r}
tmpfile=
{
self
.
tmpfile
!r}
>"
)
def
_assert_state
(
self
,
op
:
str
,
states
:
tuple
[
str
,
...
])
->
None
:
assert
(
self
.
_state
in
states
),
"cannot
{}
in state
{!r}
: expected one of
{}
"
.
format
(
op
,
self
.
_state
,
", "
.
join
(
states
)
)
def
start
(
self
)
->
None
:
"""Start capturing on targetfd using memorized tmpfile."""
self
.
_assert_state
(
"start"
,
(
"initialized"
,))
os
.
dup2
(
self
.
tmpfile
.
fileno
(),
self
.
targetfd
)
self
.
syscapture
.
start
()
self
.
_state
=
"started"
def
done
(
self
)
->
None
:
"""Stop capturing, restore streams, return original capture file,
seeked to position zero."""
self
.
_assert_state
(
"done"
,
(
"initialized"
,
"started"
,
"suspended"
,
"done"
))
if
self
.
_state
==
"done"
:
return
os
.
dup2
(
self
.
targetfd_save
,
self
.
targetfd
)
os
.
close
(
self
.
targetfd_save
)
if
self
.
targetfd_invalid
is
not
None
:
if
self
.
targetfd_invalid
!=
self
.
targetfd
:
os
.
close
(
self
.
targetfd
)
os
.
close
(
self
.
targetfd_invalid
)
self
.
syscapture
.
done
()
self
.
tmpfile
.
close
()
self
.
_state
=
"done"
def
suspend
(
self
)
->
None
:
self
.
_assert_state
(
"suspend"
,
(
"started"
,
"suspended"
))
if
self
.
_state
==
"suspended"
:
return
self
.
syscapture
.
suspend
()
os
.
dup2
(
self
.
targetfd_save
,
self
.
targetfd
)
self
.
_state
=
"suspended"
def
resume
(
self
)
->
None
:
self
.
_assert_state
(
"resume"
,
(
"started"
,
"suspended"
))
if
self
.
_state
==
"started"
:
return
self
.
syscapture
.
resume
()
os
.
dup2
(
self
.
tmpfile
.
fileno
(),
self
.
targetfd
)
self
.
_state
=
"started"
class
FDCaptureBinary
(
FDCaptureBase
[
bytes
]):
"""Capture IO to/from a given OS-level file descriptor.
snap() produces `bytes`.
"""
EMPTY_BUFFER
=
b
""
def
snap
(
self
)
->
bytes
:
self
.
_assert_state
(
"snap"
,
(
"started"
,
"suspended"
))
self
.
tmpfile
.
seek
(
0
)
res
=
self
.
tmpfile
.
buffer
.
read
()
self
.
tmpfile
.
seek
(
0
)
self
.
tmpfile
.
truncate
()
return
res
def
writeorg
(
self
,
data
:
bytes
)
->
None
:
"""Write to original file descriptor."""
self
.
_assert_state
(
"writeorg"
,
(
"started"
,
"suspended"
))
os
.
write
(
self
.
targetfd_save
,
data
)
class
FDCapture
(
FDCaptureBase
[
str
]):
"""Capture IO to/from a given OS-level file descriptor.
snap() produces text.
"""
EMPTY_BUFFER
=
""
def
snap
(
self
)
->
str
:
self
.
_assert_state
(
"snap"
,
(
"started"
,
"suspended"
))
self
.
tmpfile
.
seek
(
0
)
res
=
self
.
tmpfile
.
read
()
self
.
tmpfile
.
seek
(
0
)
self
.
tmpfile
.
truncate
()
return
res
def
writeorg
(
self
,
data
:
str
)
->
None
:
"""Write to original file descriptor."""
self
.
_assert_state
(
"writeorg"
,
(
"started"
,
"suspended"
))
# XXX use encoding of original stream
os
.
write
(
self
.
targetfd_save
,
data
.
encode
(
"utf-8"
))
# MultiCapture
# Generic NamedTuple only supported since Python 3.11.
if
sys
.
version_info
>=
(
3
,
11
)
or
TYPE_CHECKING
:
@final
class
CaptureResult
(
NamedTuple
,
Generic
[
AnyStr
]):
"""The result of :method:`caplog.readouterr() <pytest.CaptureFixture.readouterr>`."""
out
:
AnyStr
err
:
AnyStr
else
:
class
CaptureResult
(
collections
.
namedtuple
(
"CaptureResult"
,
[
"out"
,
"err"
]),
# noqa: PYI024
Generic
[
AnyStr
],
):
"""The result of :method:`caplog.readouterr() <pytest.CaptureFixture.readouterr>`."""
__slots__
=
()
class
MultiCapture
(
Generic
[
AnyStr
]):
_state
=
None
_in_suspended
=
False
def
__init__
(
self
,
in_
:
CaptureBase
[
AnyStr
]
|
None
,
out
:
CaptureBase
[
AnyStr
]
|
None
,
err
:
CaptureBase
[
AnyStr
]
|
None
,
)
->
None
:
self
.
in_
:
CaptureBase
[
AnyStr
]
|
None
=
in_
self
.
out
:
CaptureBase
[
AnyStr
]
|
None
=
out
self
.
err
:
CaptureBase
[
AnyStr
]
|
None
=
err
def
__repr__
(
self
)
->
str
:
return
(
f
"<MultiCapture out=
{
self
.
out
!r}
err=
{
self
.
err
!r}
in_=
{
self
.
in_
!r}
"
f
"_state=
{
self
.
_state
!r}
_in_suspended=
{
self
.
_in_suspended
!r}
>"
)
def
start_capturing
(
self
)
->
None
:
self
.
_state
=
"started"
if
self
.
in_
:
self
.
in_
.
start
()
if
self
.
out
:
self
.
out
.
start
()
if
self
.
err
:
self
.
err
.
start
()
def
pop_outerr_to_orig
(
self
)
->
tuple
[
AnyStr
,
AnyStr
]:
"""Pop current snapshot out/err capture and flush to orig streams."""
out
,
err
=
self
.
readouterr
()
if
out
:
assert
self
.
out
is
not
None
self
.
out
.
writeorg
(
out
)
if
err
:
assert
self
.
err
is
not
None
self
.
err
.
writeorg
(
err
)
return
out
,
err
def
suspend_capturing
(
self
,
in_
:
bool
=
False
)
->
None
:
self
.
_state
=
"suspended"
if
self
.
out
:
self
.
out
.
suspend
()
if
self
.
err
:
self
.
err
.
suspend
()
if
in_
and
self
.
in_
:
self
.
in_
.
suspend
()
self
.
_in_suspended
=
True
def
resume_capturing
(
self
)
->
None
:
self
.
_state
=
"started"
if
self
.
out
:
self
.
out
.
resume
()
if
self
.
err
:
self
.
err
.
resume
()
if
self
.
_in_suspended
:
assert
self
.
in_
is
not
None
self
.
in_
.
resume
()
self
.
_in_suspended
=
False
def
stop_capturing
(
self
)
->
None
:
"""Stop capturing and reset capturing streams."""
if
self
.
_state
==
"stopped"
:
raise
ValueError
(
"was already stopped"
)
self
.
_state
=
"stopped"
if
self
.
out
:
self
.
out
.
done
()
if
self
.
err
:
self
.
err
.
done
()
if
self
.
in_
:
self
.
in_
.
done
()
def
is_started
(
self
)
->
bool
:
"""Whether actively capturing -- not suspended or stopped."""
return
self
.
_state
==
"started"
def
readouterr
(
self
)
->
CaptureResult
[
AnyStr
]:
out
=
self
.
out
.
snap
()
if
self
.
out
else
""
err
=
self
.
err
.
snap
()
if
self
.
err
else
""
# TODO: This type error is real, need to fix.
return
CaptureResult
(
out
,
err
)
# type: ignore[arg-type]
def
_get_multicapture
(
method
:
_CaptureMethod
)
->
MultiCapture
[
str
]:
if
method
==
"fd"
:
return
MultiCapture
(
in_
=
FDCapture
(
0
),
out
=
FDCapture
(
1
),
err
=
FDCapture
(
2
))
elif
method
==
"sys"
:
return
MultiCapture
(
in_
=
SysCapture
(
0
),
out
=
SysCapture
(
1
),
err
=
SysCapture
(
2
))
elif
method
==
"no"
:
return
MultiCapture
(
in_
=
None
,
out
=
None
,
err
=
None
)
elif
method
==
"tee-sys"
:
return
MultiCapture
(
in_
=
None
,
out
=
SysCapture
(
1
,
tee
=
True
),
err
=
SysCapture
(
2
,
tee
=
True
)
)
raise
ValueError
(
f
"unknown capturing method:
{
method
!r}
"
)
# CaptureManager and CaptureFixture
class
CaptureManager
:
"""The capture plugin.
Manages that the appropriate capture method is enabled/disabled during
collection and each test phase (setup, call, teardown). After each of
those points, the captured output is obtained and attached to the
collection/runtest report.
There are two levels of capture:
* global: enabled by default and can be suppressed by the ``-s``
option. This is always enabled/disabled during collection and each test
phase.
* fixture: when a test function or one of its fixture depend on the
``capsys`` or ``capfd`` fixtures. In this case special handling is
needed to ensure the fixtures take precedence over the global capture.
"""
def
__init__
(
self
,
method
:
_CaptureMethod
)
->
None
:
self
.
_method
:
Final
=
method
self
.
_global_capturing
:
MultiCapture
[
str
]
|
None
=
None
self
.
_capture_fixture
:
CaptureFixture
[
Any
]
|
None
=
None
def
__repr__
(
self
)
->
str
:
return
(
f
"<CaptureManager _method=
{
self
.
_method
!r}
_global_capturing=
{
self
.
_global_capturing
!r}
"
f
"_capture_fixture=
{
self
.
_capture_fixture
!r}
>"
)
def
is_capturing
(
self
)
->
str
|
bool
:
if
self
.
is_globally_capturing
():
return
"global"
if
self
.
_capture_fixture
:
return
f
"fixture
{
self
.
_capture_fixture
.
request
.
fixturename
}
"
return
False
# Global capturing control
def
is_globally_capturing
(
self
)
->
bool
:
return
self
.
_method
!=
"no"
def
start_global_capturing
(
self
)
->
None
:
assert
self
.
_global_capturing
is
None
self
.
_global_capturing
=
_get_multicapture
(
self
.
_method
)
self
.
_global_capturing
.
start_capturing
()
def
stop_global_capturing
(
self
)
->
None
:
if
self
.
_global_capturing
is
not
None
:
self
.
_global_capturing
.
pop_outerr_to_orig
()
self
.
_global_capturing
.
stop_capturing
()
self
.
_global_capturing
=
None
def
resume_global_capture
(
self
)
->
None
:
# During teardown of the python process, and on rare occasions, capture
# attributes can be `None` while trying to resume global capture.
if
self
.
_global_capturing
is
not
None
:
self
.
_global_capturing
.
resume_capturing
()
def
suspend_global_capture
(
self
,
in_
:
bool
=
False
)
->
None
:
if
self
.
_global_capturing
is
not
None
:
self
.
_global_capturing
.
suspend_capturing
(
in_
=
in_
)
def
suspend
(
self
,
in_
:
bool
=
False
)
->
None
:
# Need to undo local capsys-et-al if it exists before disabling global capture.
self
.
suspend_fixture
()
self
.
suspend_global_capture
(
in_
)
def
resume
(
self
)
->
None
:
self
.
resume_global_capture
()
self
.
resume_fixture
()
def
read_global_capture
(
self
)
->
CaptureResult
[
str
]:
assert
self
.
_global_capturing
is
not
None
return
self
.
_global_capturing
.
readouterr
()
# Fixture Control
def
set_fixture
(
self
,
capture_fixture
:
CaptureFixture
[
Any
])
->
None
:
if
self
.
_capture_fixture
:
current_fixture
=
self
.
_capture_fixture
.
request
.
fixturename
requested_fixture
=
capture_fixture
.
request
.
fixturename
capture_fixture
.
request
.
raiseerror
(
f
"cannot use
{
requested_fixture
}
and
{
current_fixture
}
at the same time"
)
self
.
_capture_fixture
=
capture_fixture
def
unset_fixture
(
self
)
->
None
:
self
.
_capture_fixture
=
None
def
activate_fixture
(
self
)
->
None
:
"""If the current item is using ``capsys`` or ``capfd``, activate
them so they take precedence over the global capture."""
if
self
.
_capture_fixture
:
self
.
_capture_fixture
.
_start
()
def
deactivate_fixture
(
self
)
->
None
:
"""Deactivate the ``capsys`` or ``capfd`` fixture of this item, if any."""
if
self
.
_capture_fixture
:
self
.
_capture_fixture
.
close
()
def
suspend_fixture
(
self
)
->
None
:
if
self
.
_capture_fixture
:
self
.
_capture_fixture
.
_suspend
()
def
resume_fixture
(
self
)
->
None
:
if
self
.
_capture_fixture
:
self
.
_capture_fixture
.
_resume
()
# Helper context managers
@contextlib
.
contextmanager
def
global_and_fixture_disabled
(
self
)
->
Generator
[
None
]:
"""Context manager to temporarily disable global and current fixture capturing."""
do_fixture
=
self
.
_capture_fixture
and
self
.
_capture_fixture
.
_is_started
()
if
do_fixture
:
self
.
suspend_fixture
()
do_global
=
self
.
_global_capturing
and
self
.
_global_capturing
.
is_started
()
if
do_global
:
self
.
suspend_global_capture
()
try
:
yield
finally
:
if
do_global
:
self
.
resume_global_capture
()
if
do_fixture
:
self
.
resume_fixture
()
@contextlib
.
contextmanager
def
item_capture
(
self
,
when
:
str
,
item
:
Item
)
->
Generator
[
None
]:
self
.
resume_global_capture
()
self
.
activate_fixture
()
try
:
yield
finally
:
self
.
deactivate_fixture
()
self
.
suspend_global_capture
(
in_
=
False
)
out
,
err
=
self
.
read_global_capture
()
item
.
add_report_section
(
when
,
"stdout"
,
out
)
item
.
add_report_section
(
when
,
"stderr"
,
err
)
# Hooks
@hookimpl
(
wrapper
=
True
)
def
pytest_make_collect_report
(
self
,
collector
:
Collector
)
->
Generator
[
None
,
CollectReport
,
CollectReport
]:
if
isinstance
(
collector
,
File
):
self
.
resume_global_capture
()
try
:
rep
=
yield
finally
:
self
.
suspend_global_capture
()
out
,
err
=
self
.
read_global_capture
()
if
out
:
rep
.
sections
.
append
((
"Captured stdout"
,
out
))
if
err
:
rep
.
sections
.
append
((
"Captured stderr"
,
err
))
else
:
rep
=
yield
return
rep
@hookimpl
(
wrapper
=
True
)
def
pytest_runtest_setup
(
self
,
item
:
Item
)
->
Generator
[
None
]:
with
self
.
item_capture
(
"setup"
,
item
):
return
(
yield
)
@hookimpl
(
wrapper
=
True
)
def
pytest_runtest_call
(
self
,
item
:
Item
)
->
Generator
[
None
]:
with
self
.
item_capture
(
"call"
,
item
):
return
(
yield
)
@hookimpl
(
wrapper
=
True
)
def
pytest_runtest_teardown
(
self
,
item
:
Item
)
->
Generator
[
None
]:
with
self
.
item_capture
(
"teardown"
,
item
):
return
(
yield
)
@hookimpl
(
tryfirst
=
True
)
def
pytest_keyboard_interrupt
(
self
)
->
None
:
self
.
stop_global_capturing
()
@hookimpl
(
tryfirst
=
True
)
def
pytest_internalerror
(
self
)
->
None
:
self
.
stop_global_capturing
()
[docs]
class
CaptureFixture
(
Generic
[
AnyStr
]):
"""Object returned by the :fixture:`capsys`, :fixture:`capsysbinary`,
:fixture:`capfd` and :fixture:`capfdbinary` fixtures."""
def
__init__
(
self
,
captureclass
:
type
[
CaptureBase
[
AnyStr
]],
request
:
SubRequest
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
captureclass
:
type
[
CaptureBase
[
AnyStr
]]
=
captureclass
self
.
request
=
request
self
.
_capture
:
MultiCapture
[
AnyStr
]
|
None
=
None
self
.
_captured_out
:
AnyStr
=
self
.
captureclass
.
EMPTY_BUFFER
self
.
_captured_err
:
AnyStr
=
self
.
captureclass
.
EMPTY_BUFFER
def
_start
(
self
)
->
None
:
if
self
.
_capture
is
None
:
self
.
_capture
=
MultiCapture
(
in_
=
None
,
out
=
self
.
captureclass
(
1
),
err
=
self
.
captureclass
(
2
),
)
self
.
_capture
.
start_capturing
()
def
close
(
self
)
->
None
:
if
self
.
_capture
is
not
None
:
out
,
err
=
self
.
_capture
.
pop_outerr_to_orig
()
self
.
_captured_out
+=
out
self
.
_captured_err
+=
err
self
.
_capture
.
stop_capturing
()
self
.
_capture
=
None
[docs]
def
readouterr
(
self
)
->
CaptureResult
[
AnyStr
]:
"""Read and return the captured output so far, resetting the internal
buffer.
:returns:
The captured content as a namedtuple with ``out`` and ``err``
string attributes.
"""
captured_out
,
captured_err
=
self
.
_captured_out
,
self
.
_captured_err
if
self
.
_capture
is
not
None
:
out
,
err
=
self
.
_capture
.
readouterr
()
captured_out
+=
out
captured_err
+=
err
self
.
_captured_out
=
self
.
captureclass
.
EMPTY_BUFFER
self
.
_captured_err
=
self
.
captureclass
.
EMPTY_BUFFER
return
CaptureResult
(
captured_out
,
captured_err
)
def
_suspend
(
self
)
->
None
:
"""Suspend this fixture's own capturing temporarily."""
if
self
.
_capture
is
not
None
:
self
.
_capture
.
suspend_capturing
()
def
_resume
(
self
)
->
None
:
"""Resume this fixture's own capturing temporarily."""
if
self
.
_capture
is
not
None
:
self
.
_capture
.
resume_capturing
()
def
_is_started
(
self
)
->
bool
:
"""Whether actively capturing -- not disabled or closed."""
if
self
.
_capture
is
not
None
:
return
self
.
_capture
.
is_started
()
return
False
[docs]
@contextlib
.
contextmanager
def
disabled
(
self
)
->
Generator
[
None
]:
"""Temporarily disable capturing while inside the ``with`` block."""
capmanager
:
CaptureManager
=
self
.
request
.
config
.
pluginmanager
.
getplugin
(
"capturemanager"
)
with
capmanager
.
global_and_fixture_disabled
():
yield
# The fixtures.
[docs]
@fixture
def
capsys
(
request
:
SubRequest
)
->
Generator
[
CaptureFixture
[
str
]]:
r
"""Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``.
The captured output is made available via ``capsys.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``text`` objects.
Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.
Example:
.. code-block:: python
def test_output(capsys):
print("hello")
captured = capsys.readouterr()
assert captured.out == "hello\n"
"""
capman
:
CaptureManager
=
request
.
config
.
pluginmanager
.
getplugin
(
"capturemanager"
)
capture_fixture
=
CaptureFixture
(
SysCapture
,
request
,
_ispytest
=
True
)
capman
.
set_fixture
(
capture_fixture
)
capture_fixture
.
_start
()
yield
capture_fixture
capture_fixture
.
close
()
capman
.
unset_fixture
()
[docs]
@fixture
def
capsysbinary
(
request
:
SubRequest
)
->
Generator
[
CaptureFixture
[
bytes
]]:
r
"""Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``.
The captured output is made available via ``capsysbinary.readouterr()``
method calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``bytes`` objects.
Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.
Example:
.. code-block:: python
def test_output(capsysbinary):
print("hello")
captured = capsysbinary.readouterr()
assert captured.out == b"hello\n"
"""
capman
:
CaptureManager
=
request
.
config
.
pluginmanager
.
getplugin
(
"capturemanager"
)
capture_fixture
=
CaptureFixture
(
SysCaptureBinary
,
request
,
_ispytest
=
True
)
capman
.
set_fixture
(
capture_fixture
)
capture_fixture
.
_start
()
yield
capture_fixture
capture_fixture
.
close
()
capman
.
unset_fixture
()
[docs]
@fixture
def
capfd
(
request
:
SubRequest
)
->
Generator
[
CaptureFixture
[
str
]]:
r
"""Enable text capturing of writes to file descriptors ``1`` and ``2``.
The captured output is made available via ``capfd.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``text`` objects.
Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.
Example:
.. code-block:: python
def test_system_echo(capfd):
os.system('echo "hello"')
captured = capfd.readouterr()
assert captured.out == "hello\n"
"""
capman
:
CaptureManager
=
request
.
config
.
pluginmanager
.
getplugin
(
"capturemanager"
)
capture_fixture
=
CaptureFixture
(
FDCapture
,
request
,
_ispytest
=
True
)
capman
.
set_fixture
(
capture_fixture
)
capture_fixture
.
_start
()
yield
capture_fixture
capture_fixture
.
close
()
capman
.
unset_fixture
()
[docs]
@fixture
def
capfdbinary
(
request
:
SubRequest
)
->
Generator
[
CaptureFixture
[
bytes
]]:
r
"""Enable bytes capturing of writes to file descriptors ``1`` and ``2``.
The captured output is made available via ``capfd.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``byte`` objects.
Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.
Example:
.. code-block:: python
def test_system_echo(capfdbinary):
os.system('echo "hello"')
captured = capfdbinary.readouterr()
assert captured.out == b"hello\n"
"""
capman
:
CaptureManager
=
request
.
config
.
pluginmanager
.
getplugin
(
"capturemanager"
)
capture_fixture
=
CaptureFixture
(
FDCaptureBinary
,
request
,
_ispytest
=
True
)
capman
.
set_fixture
(
capture_fixture
)
capture_fixture
.
_start
()
yield
capture_fixture
capture_fixture
.
close
()
capman
.
unset_fixture
()

```


---


# _pytest.terminal - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/terminal.html


# Source code for _pytest.terminal

```

# mypy: allow-untyped-defs
"""Terminal reporting of the full testing process.
This is a good source for looking at the various reporting hooks.
"""
from
__future__
import
annotations
import
argparse
from
collections
import
Counter
import
dataclasses
import
datetime
from
functools
import
partial
import
inspect
from
pathlib
import
Path
import
platform
import
sys
import
textwrap
from
typing
import
Any
from
typing
import
Callable
from
typing
import
ClassVar
from
typing
import
final
from
typing
import
Generator
from
typing
import
Literal
from
typing
import
Mapping
from
typing
import
NamedTuple
from
typing
import
Sequence
from
typing
import
TextIO
from
typing
import
TYPE_CHECKING
import
warnings
import
pluggy
from
_pytest
import
nodes
from
_pytest
import
timing
from
_pytest._code
import
ExceptionInfo
from
_pytest._code.code
import
ExceptionRepr
from
_pytest._io
import
TerminalWriter
from
_pytest._io.wcwidth
import
wcswidth
import
_pytest._version
from
_pytest.assertion.util
import
running_on_ci
from
_pytest.config
import
_PluggyPlugin
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config
import
hookimpl
from
_pytest.config.argparsing
import
Parser
from
_pytest.nodes
import
Item
from
_pytest.nodes
import
Node
from
_pytest.pathlib
import
absolutepath
from
_pytest.pathlib
import
bestrelpath
from
_pytest.reports
import
BaseReport
from
_pytest.reports
import
CollectReport
from
_pytest.reports
import
TestReport
if
TYPE_CHECKING
:
from
_pytest.main
import
Session
REPORT_COLLECTING_RESOLUTION
=
0.5
KNOWN_TYPES
=
(
"failed"
,
"passed"
,
"skipped"
,
"deselected"
,
"xfailed"
,
"xpassed"
,
"warnings"
,
"error"
,
)
_REPORTCHARS_DEFAULT
=
"fE"
class
MoreQuietAction
(
argparse
.
Action
):
"""A modified copy of the argparse count action which counts down and updates
the legacy quiet attribute at the same time.
Used to unify verbosity handling.
"""
def
__init__
(
self
,
option_strings
:
Sequence
[
str
],
dest
:
str
,
default
:
object
=
None
,
required
:
bool
=
False
,
help
:
str
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
option_strings
=
option_strings
,
dest
=
dest
,
nargs
=
0
,
default
=
default
,
required
=
required
,
help
=
help
,
)
def
__call__
(
self
,
parser
:
argparse
.
ArgumentParser
,
namespace
:
argparse
.
Namespace
,
values
:
str
|
Sequence
[
object
]
|
None
,
option_string
:
str
|
None
=
None
,
)
->
None
:
new_count
=
getattr
(
namespace
,
self
.
dest
,
0
)
-
1
setattr
(
namespace
,
self
.
dest
,
new_count
)
# todo Deprecate config.quiet
namespace
.
quiet
=
getattr
(
namespace
,
"quiet"
,
0
)
+
1
[docs]
class
TestShortLogReport
(
NamedTuple
):
"""Used to store the test status result category, shortletter and verbose word.
For example ``"rerun", "R", ("RERUN", {"yellow": True})``.
:ivar category:
The class of result, for example ``“passed”``, ``“skipped”``, ``“error”``, or the empty string.
:ivar letter:
The short letter shown as testing progresses, for example ``"."``, ``"s"``, ``"E"``, or the empty string.
:ivar word:
Verbose word is shown as testing progresses in verbose mode, for example ``"PASSED"``, ``"SKIPPED"``,
``"ERROR"``, or the empty string.
"""
category
:
str
letter
:
str
word
:
str
|
tuple
[
str
,
Mapping
[
str
,
bool
]]
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"terminal reporting"
,
"Reporting"
,
after
=
"general"
)
group
.
_addoption
(
"-v"
,
"--verbose"
,
action
=
"count"
,
default
=
0
,
dest
=
"verbose"
,
help
=
"Increase verbosity"
,
)
group
.
_addoption
(
"--no-header"
,
action
=
"store_true"
,
default
=
False
,
dest
=
"no_header"
,
help
=
"Disable header"
,
)
group
.
_addoption
(
"--no-summary"
,
action
=
"store_true"
,
default
=
False
,
dest
=
"no_summary"
,
help
=
"Disable summary"
,
)
group
.
_addoption
(
"--no-fold-skipped"
,
action
=
"store_false"
,
dest
=
"fold_skipped"
,
default
=
True
,
help
=
"Do not fold skipped tests in short summary."
,
)
group
.
_addoption
(
"-q"
,
"--quiet"
,
action
=
MoreQuietAction
,
default
=
0
,
dest
=
"verbose"
,
help
=
"Decrease verbosity"
,
)
group
.
_addoption
(
"--verbosity"
,
dest
=
"verbose"
,
type
=
int
,
default
=
0
,
help
=
"Set verbosity. Default: 0."
,
)
group
.
_addoption
(
"-r"
,
action
=
"store"
,
dest
=
"reportchars"
,
default
=
_REPORTCHARS_DEFAULT
,
metavar
=
"chars"
,
help
=
"Show extra test summary info as specified by chars: (f)ailed, "
"(E)rror, (s)kipped, (x)failed, (X)passed, "
"(p)assed, (P)assed with output, (a)ll except passed (p/P), or (A)ll. "
"(w)arnings are enabled by default (see --disable-warnings), "
"'N' can be used to reset the list. (default: 'fE')."
,
)
group
.
_addoption
(
"--disable-warnings"
,
"--disable-pytest-warnings"
,
default
=
False
,
dest
=
"disable_warnings"
,
action
=
"store_true"
,
help
=
"Disable warnings summary"
,
)
group
.
_addoption
(
"-l"
,
"--showlocals"
,
action
=
"store_true"
,
dest
=
"showlocals"
,
default
=
False
,
help
=
"Show locals in tracebacks (disabled by default)"
,
)
group
.
_addoption
(
"--no-showlocals"
,
action
=
"store_false"
,
dest
=
"showlocals"
,
help
=
"Hide locals in tracebacks (negate --showlocals passed through addopts)"
,
)
group
.
_addoption
(
"--tb"
,
metavar
=
"style"
,
action
=
"store"
,
dest
=
"tbstyle"
,
default
=
"auto"
,
choices
=
[
"auto"
,
"long"
,
"short"
,
"no"
,
"line"
,
"native"
],
help
=
"Traceback print mode (auto/long/short/line/native/no)"
,
)
group
.
_addoption
(
"--xfail-tb"
,
action
=
"store_true"
,
dest
=
"xfail_tb"
,
default
=
False
,
help
=
"Show tracebacks for xfail (as long as --tb != no)"
,
)
group
.
_addoption
(
"--show-capture"
,
action
=
"store"
,
dest
=
"showcapture"
,
choices
=
[
"no"
,
"stdout"
,
"stderr"
,
"log"
,
"all"
],
default
=
"all"
,
help
=
"Controls how captured stdout/stderr/log is shown on failed tests. "
"Default: all."
,
)
group
.
_addoption
(
"--fulltrace"
,
"--full-trace"
,
action
=
"store_true"
,
default
=
False
,
help
=
"Don't cut any tracebacks (default is to cut)"
,
)
group
.
_addoption
(
"--color"
,
metavar
=
"color"
,
action
=
"store"
,
dest
=
"color"
,
default
=
"auto"
,
choices
=
[
"yes"
,
"no"
,
"auto"
],
help
=
"Color terminal output (yes/no/auto)"
,
)
group
.
_addoption
(
"--code-highlight"
,
default
=
"yes"
,
choices
=
[
"yes"
,
"no"
],
help
=
"Whether code should be highlighted (only if --color is also enabled). "
"Default: yes."
,
)
parser
.
addini
(
"console_output_style"
,
help
=
'Console output: "classic", or with additional progress information '
'("progress" (percentage) | "count" | "progress-even-when-capture-no" (forces '
"progress even when capture=no)"
,
default
=
"progress"
,
)
Config
.
_add_verbosity_ini
(
parser
,
Config
.
VERBOSITY_TEST_CASES
,
help
=
(
"Specify a verbosity level for test case execution, overriding the main level. "
"Higher levels will provide more detailed information about each test case executed."
),
)
def
pytest_configure
(
config
:
Config
)
->
None
:
reporter
=
TerminalReporter
(
config
,
sys
.
stdout
)
config
.
pluginmanager
.
register
(
reporter
,
"terminalreporter"
)
if
config
.
option
.
debug
or
config
.
option
.
traceconfig
:
def
mywriter
(
tags
,
args
):
msg
=
" "
.
join
(
map
(
str
,
args
))
reporter
.
write_line
(
"[traceconfig] "
+
msg
)
config
.
trace
.
root
.
setprocessor
(
"pytest:config"
,
mywriter
)
def
getreportopt
(
config
:
Config
)
->
str
:
reportchars
:
str
=
config
.
option
.
reportchars
old_aliases
=
{
"F"
,
"S"
}
reportopts
=
""
for
char
in
reportchars
:
if
char
in
old_aliases
:
char
=
char
.
lower
()
if
char
==
"a"
:
reportopts
=
"sxXEf"
elif
char
==
"A"
:
reportopts
=
"PpsxXEf"
elif
char
==
"N"
:
reportopts
=
""
elif
char
not
in
reportopts
:
reportopts
+=
char
if
not
config
.
option
.
disable_warnings
and
"w"
not
in
reportopts
:
reportopts
=
"w"
+
reportopts
elif
config
.
option
.
disable_warnings
and
"w"
in
reportopts
:
reportopts
=
reportopts
.
replace
(
"w"
,
""
)
return
reportopts
@hookimpl
(
trylast
=
True
)
# after _pytest.runner
def
pytest_report_teststatus
(
report
:
BaseReport
)
->
tuple
[
str
,
str
,
str
]:
letter
=
"F"
if
report
.
passed
:
letter
=
"."
elif
report
.
skipped
:
letter
=
"s"
outcome
:
str
=
report
.
outcome
if
report
.
when
in
(
"collect"
,
"setup"
,
"teardown"
)
and
outcome
==
"failed"
:
outcome
=
"error"
letter
=
"E"
return
outcome
,
letter
,
outcome
.
upper
()
@dataclasses
.
dataclass
class
WarningReport
:
"""Simple structure to hold warnings information captured by ``pytest_warning_recorded``.
:ivar str message:
User friendly message about the warning.
:ivar str|None nodeid:
nodeid that generated the warning (see ``get_location``).
:ivar tuple fslocation:
File system location of the source of the warning (see ``get_location``).
"""
message
:
str
nodeid
:
str
|
None
=
None
fslocation
:
tuple
[
str
,
int
]
|
None
=
None
count_towards_summary
:
ClassVar
=
True
def
get_location
(
self
,
config
:
Config
)
->
str
|
None
:
"""Return the more user-friendly information about the location of a warning, or None."""
if
self
.
nodeid
:
return
self
.
nodeid
if
self
.
fslocation
:
filename
,
linenum
=
self
.
fslocation
relpath
=
bestrelpath
(
config
.
invocation_params
.
dir
,
absolutepath
(
filename
))
return
f
"
{
relpath
}
:
{
linenum
}
"
return
None
@final
class
TerminalReporter
:
def
__init__
(
self
,
config
:
Config
,
file
:
TextIO
|
None
=
None
)
->
None
:
import
_pytest.config
self
.
config
=
config
self
.
_numcollected
=
0
self
.
_session
:
Session
|
None
=
None
self
.
_showfspath
:
bool
|
None
=
None
self
.
stats
:
dict
[
str
,
list
[
Any
]]
=
{}
self
.
_main_color
:
str
|
None
=
None
self
.
_known_types
:
list
[
str
]
|
None
=
None
self
.
startpath
=
config
.
invocation_params
.
dir
if
file
is
None
:
file
=
sys
.
stdout
self
.
_tw
=
_pytest
.
config
.
create_terminal_writer
(
config
,
file
)
self
.
_screen_width
=
self
.
_tw
.
fullwidth
self
.
currentfspath
:
None
|
Path
|
str
|
int
=
None
self
.
reportchars
=
getreportopt
(
config
)
self
.
foldskipped
=
config
.
option
.
fold_skipped
self
.
hasmarkup
=
self
.
_tw
.
hasmarkup
self
.
isatty
=
file
.
isatty
()
self
.
_progress_nodeids_reported
:
set
[
str
]
=
set
()
self
.
_show_progress_info
=
self
.
_determine_show_progress_info
()
self
.
_collect_report_last_write
:
float
|
None
=
None
self
.
_already_displayed_warnings
:
int
|
None
=
None
self
.
_keyboardinterrupt_memo
:
ExceptionRepr
|
None
=
None
def
_determine_show_progress_info
(
self
)
->
Literal
[
"progress"
,
"count"
,
False
]:
"""Return whether we should display progress information based on the current config."""
# do not show progress if we are not capturing output (#3038) unless explicitly
# overridden by progress-even-when-capture-no
if
(
self
.
config
.
getoption
(
"capture"
,
"no"
)
==
"no"
and
self
.
config
.
getini
(
"console_output_style"
)
!=
"progress-even-when-capture-no"
):
return
False
# do not show progress if we are showing fixture setup/teardown
if
self
.
config
.
getoption
(
"setupshow"
,
False
):
return
False
cfg
:
str
=
self
.
config
.
getini
(
"console_output_style"
)
if
cfg
in
{
"progress"
,
"progress-even-when-capture-no"
}:
return
"progress"
elif
cfg
==
"count"
:
return
"count"
else
:
return
False
@property
def
verbosity
(
self
)
->
int
:
verbosity
:
int
=
self
.
config
.
option
.
verbose
return
verbosity
@property
def
showheader
(
self
)
->
bool
:
return
self
.
verbosity
>=
0
@property
def
no_header
(
self
)
->
bool
:
return
bool
(
self
.
config
.
option
.
no_header
)
@property
def
no_summary
(
self
)
->
bool
:
return
bool
(
self
.
config
.
option
.
no_summary
)
@property
def
showfspath
(
self
)
->
bool
:
if
self
.
_showfspath
is
None
:
return
self
.
config
.
get_verbosity
(
Config
.
VERBOSITY_TEST_CASES
)
>=
0
return
self
.
_showfspath
@showfspath
.
setter
def
showfspath
(
self
,
value
:
bool
|
None
)
->
None
:
self
.
_showfspath
=
value
@property
def
showlongtestinfo
(
self
)
->
bool
:
return
self
.
config
.
get_verbosity
(
Config
.
VERBOSITY_TEST_CASES
)
>
0
def
hasopt
(
self
,
char
:
str
)
->
bool
:
char
=
{
"xfailed"
:
"x"
,
"skipped"
:
"s"
}
.
get
(
char
,
char
)
return
char
in
self
.
reportchars
def
write_fspath_result
(
self
,
nodeid
:
str
,
res
:
str
,
**
markup
:
bool
)
->
None
:
fspath
=
self
.
config
.
rootpath
/
nodeid
.
split
(
"::"
)[
0
]
if
self
.
currentfspath
is
None
or
fspath
!=
self
.
currentfspath
:
if
self
.
currentfspath
is
not
None
and
self
.
_show_progress_info
:
self
.
_write_progress_information_filling_space
()
self
.
currentfspath
=
fspath
relfspath
=
bestrelpath
(
self
.
startpath
,
fspath
)
self
.
_tw
.
line
()
self
.
_tw
.
write
(
relfspath
+
" "
)
self
.
_tw
.
write
(
res
,
flush
=
True
,
**
markup
)
def
write_ensure_prefix
(
self
,
prefix
:
str
,
extra
:
str
=
""
,
**
kwargs
)
->
None
:
if
self
.
currentfspath
!=
prefix
:
self
.
_tw
.
line
()
self
.
currentfspath
=
prefix
self
.
_tw
.
write
(
prefix
)
if
extra
:
self
.
_tw
.
write
(
extra
,
**
kwargs
)
self
.
currentfspath
=
-
2
def
ensure_newline
(
self
)
->
None
:
if
self
.
currentfspath
:
self
.
_tw
.
line
()
self
.
currentfspath
=
None
def
wrap_write
(
self
,
content
:
str
,
*
,
flush
:
bool
=
False
,
margin
:
int
=
8
,
line_sep
:
str
=
"
\n
"
,
**
markup
:
bool
,
)
->
None
:
"""Wrap message with margin for progress info."""
width_of_current_line
=
self
.
_tw
.
width_of_current_line
wrapped
=
line_sep
.
join
(
textwrap
.
wrap
(
" "
*
width_of_current_line
+
content
,
width
=
self
.
_screen_width
-
margin
,
drop_whitespace
=
True
,
replace_whitespace
=
False
,
),
)
wrapped
=
wrapped
[
width_of_current_line
:]
self
.
_tw
.
write
(
wrapped
,
flush
=
flush
,
**
markup
)
def
write
(
self
,
content
:
str
,
*
,
flush
:
bool
=
False
,
**
markup
:
bool
)
->
None
:
self
.
_tw
.
write
(
content
,
flush
=
flush
,
**
markup
)
def
flush
(
self
)
->
None
:
self
.
_tw
.
flush
()
def
write_line
(
self
,
line
:
str
|
bytes
,
**
markup
:
bool
)
->
None
:
if
not
isinstance
(
line
,
str
):
line
=
str
(
line
,
errors
=
"replace"
)
self
.
ensure_newline
()
self
.
_tw
.
line
(
line
,
**
markup
)
def
rewrite
(
self
,
line
:
str
,
**
markup
:
bool
)
->
None
:
"""Rewinds the terminal cursor to the beginning and writes the given line.
:param erase:
If True, will also add spaces until the full terminal width to ensure
previous lines are properly erased.
The rest of the keyword arguments are markup instructions.
"""
erase
=
markup
.
pop
(
"erase"
,
False
)
if
erase
:
fill_count
=
self
.
_tw
.
fullwidth
-
len
(
line
)
-
1
fill
=
" "
*
fill_count
else
:
fill
=
""
line
=
str
(
line
)
self
.
_tw
.
write
(
"
\r
"
+
line
+
fill
,
**
markup
)
def
write_sep
(
self
,
sep
:
str
,
title
:
str
|
None
=
None
,
fullwidth
:
int
|
None
=
None
,
**
markup
:
bool
,
)
->
None
:
self
.
ensure_newline
()
self
.
_tw
.
sep
(
sep
,
title
,
fullwidth
,
**
markup
)
def
section
(
self
,
title
:
str
,
sep
:
str
=
"="
,
**
kw
:
bool
)
->
None
:
self
.
_tw
.
sep
(
sep
,
title
,
**
kw
)
def
line
(
self
,
msg
:
str
,
**
kw
:
bool
)
->
None
:
self
.
_tw
.
line
(
msg
,
**
kw
)
def
_add_stats
(
self
,
category
:
str
,
items
:
Sequence
[
Any
])
->
None
:
set_main_color
=
category
not
in
self
.
stats
self
.
stats
.
setdefault
(
category
,
[])
.
extend
(
items
)
if
set_main_color
:
self
.
_set_main_color
()
def
pytest_internalerror
(
self
,
excrepr
:
ExceptionRepr
)
->
bool
:
for
line
in
str
(
excrepr
)
.
split
(
"
\n
"
):
self
.
write_line
(
"INTERNALERROR> "
+
line
)
return
True
def
pytest_warning_recorded
(
self
,
warning_message
:
warnings
.
WarningMessage
,
nodeid
:
str
,
)
->
None
:
from
_pytest.warnings
import
warning_record_to_str
fslocation
=
warning_message
.
filename
,
warning_message
.
lineno
message
=
warning_record_to_str
(
warning_message
)
warning_report
=
WarningReport
(
fslocation
=
fslocation
,
message
=
message
,
nodeid
=
nodeid
)
self
.
_add_stats
(
"warnings"
,
[
warning_report
])
def
pytest_plugin_registered
(
self
,
plugin
:
_PluggyPlugin
)
->
None
:
if
self
.
config
.
option
.
traceconfig
:
msg
=
f
"PLUGIN registered:
{
plugin
}
"
# XXX This event may happen during setup/teardown time
#     which unfortunately captures our output here
#     which garbles our output if we use self.write_line.
self
.
write_line
(
msg
)
def
pytest_deselected
(
self
,
items
:
Sequence
[
Item
])
->
None
:
self
.
_add_stats
(
"deselected"
,
items
)
def
pytest_runtest_logstart
(
self
,
nodeid
:
str
,
location
:
tuple
[
str
,
int
|
None
,
str
]
)
->
None
:
fspath
,
lineno
,
domain
=
location
# Ensure that the path is printed before the
# 1st test of a module starts running.
if
self
.
showlongtestinfo
:
line
=
self
.
_locationline
(
nodeid
,
fspath
,
lineno
,
domain
)
self
.
write_ensure_prefix
(
line
,
""
)
self
.
flush
()
elif
self
.
showfspath
:
self
.
write_fspath_result
(
nodeid
,
""
)
self
.
flush
()
def
pytest_runtest_logreport
(
self
,
report
:
TestReport
)
->
None
:
self
.
_tests_ran
=
True
rep
=
report
res
=
TestShortLogReport
(
*
self
.
config
.
hook
.
pytest_report_teststatus
(
report
=
rep
,
config
=
self
.
config
)
)
category
,
letter
,
word
=
res
.
category
,
res
.
letter
,
res
.
word
if
not
isinstance
(
word
,
tuple
):
markup
=
None
else
:
word
,
markup
=
word
self
.
_add_stats
(
category
,
[
rep
])
if
not
letter
and
not
word
:
# Probably passed setup/teardown.
return
if
markup
is
None
:
was_xfail
=
hasattr
(
report
,
"wasxfail"
)
if
rep
.
passed
and
not
was_xfail
:
markup
=
{
"green"
:
True
}
elif
rep
.
passed
and
was_xfail
:
markup
=
{
"yellow"
:
True
}
elif
rep
.
failed
:
markup
=
{
"red"
:
True
}
elif
rep
.
skipped
:
markup
=
{
"yellow"
:
True
}
else
:
markup
=
{}
self
.
_progress_nodeids_reported
.
add
(
rep
.
nodeid
)
if
self
.
config
.
get_verbosity
(
Config
.
VERBOSITY_TEST_CASES
)
<=
0
:
self
.
_tw
.
write
(
letter
,
**
markup
)
# When running in xdist, the logreport and logfinish of multiple
# items are interspersed, e.g. `logreport`, `logreport`,
# `logfinish`, `logfinish`. To avoid the "past edge" calculation
# from getting confused and overflowing (#7166), do the past edge
# printing here and not in logfinish, except for the 100% which
# should only be printed after all teardowns are finished.
if
self
.
_show_progress_info
and
not
self
.
_is_last_item
:
self
.
_write_progress_information_if_past_edge
()
else
:
line
=
self
.
_locationline
(
rep
.
nodeid
,
*
rep
.
location
)
running_xdist
=
hasattr
(
rep
,
"node"
)
if
not
running_xdist
:
self
.
write_ensure_prefix
(
line
,
word
,
**
markup
)
if
rep
.
skipped
or
hasattr
(
report
,
"wasxfail"
):
reason
=
_get_raw_skip_reason
(
rep
)
if
self
.
config
.
get_verbosity
(
Config
.
VERBOSITY_TEST_CASES
)
<
2
:
available_width
=
(
(
self
.
_tw
.
fullwidth
-
self
.
_tw
.
width_of_current_line
)
-
len
(
" [100%]"
)
-
1
)
formatted_reason
=
_format_trimmed
(
" (
{}
)"
,
reason
,
available_width
)
else
:
formatted_reason
=
f
" (
{
reason
}
)"
if
reason
and
formatted_reason
is
not
None
:
self
.
wrap_write
(
formatted_reason
)
if
self
.
_show_progress_info
:
self
.
_write_progress_information_filling_space
()
else
:
self
.
ensure_newline
()
self
.
_tw
.
write
(
f
"[
{
rep
.
node
.
gateway
.
id
}
]"
)
if
self
.
_show_progress_info
:
self
.
_tw
.
write
(
self
.
_get_progress_information_message
()
+
" "
,
cyan
=
True
)
else
:
self
.
_tw
.
write
(
" "
)
self
.
_tw
.
write
(
word
,
**
markup
)
self
.
_tw
.
write
(
" "
+
line
)
self
.
currentfspath
=
-
2
self
.
flush
()
@property
def
_is_last_item
(
self
)
->
bool
:
assert
self
.
_session
is
not
None
return
len
(
self
.
_progress_nodeids_reported
)
==
self
.
_session
.
testscollected
@hookimpl
(
wrapper
=
True
)
def
pytest_runtestloop
(
self
)
->
Generator
[
None
,
object
,
object
]:
result
=
yield
# Write the final/100% progress -- deferred until the loop is complete.
if
(
self
.
config
.
get_verbosity
(
Config
.
VERBOSITY_TEST_CASES
)
<=
0
and
self
.
_show_progress_info
and
self
.
_progress_nodeids_reported
):
self
.
_write_progress_information_filling_space
()
return
result
def
_get_progress_information_message
(
self
)
->
str
:
assert
self
.
_session
collected
=
self
.
_session
.
testscollected
if
self
.
_show_progress_info
==
"count"
:
if
collected
:
progress
=
len
(
self
.
_progress_nodeids_reported
)
counter_format
=
f
"
{{
:
{
len
(
str
(
collected
))
}
d
}}
"
format_string
=
f
" [
{
counter_format
}
/
{{}}
]"
return
format_string
.
format
(
progress
,
collected
)
return
f
" [
{
collected
}
/
{
collected
}
]"
else
:
if
collected
:
return
(
f
" [
{
len
(
self
.
_progress_nodeids_reported
)
*
100
//
collected
:
3d
}
%]"
)
return
" [100%]"
def
_write_progress_information_if_past_edge
(
self
)
->
None
:
w
=
self
.
_width_of_current_line
if
self
.
_show_progress_info
==
"count"
:
assert
self
.
_session
num_tests
=
self
.
_session
.
testscollected
progress_length
=
len
(
f
" [
{
num_tests
}
/
{
num_tests
}
]"
)
else
:
progress_length
=
len
(
" [100%]"
)
past_edge
=
w
+
progress_length
+
1
>=
self
.
_screen_width
if
past_edge
:
main_color
,
_
=
self
.
_get_main_color
()
msg
=
self
.
_get_progress_information_message
()
self
.
_tw
.
write
(
msg
+
"
\n
"
,
**
{
main_color
:
True
})
def
_write_progress_information_filling_space
(
self
)
->
None
:
color
,
_
=
self
.
_get_main_color
()
msg
=
self
.
_get_progress_information_message
()
w
=
self
.
_width_of_current_line
fill
=
self
.
_tw
.
fullwidth
-
w
-
1
self
.
write
(
msg
.
rjust
(
fill
),
flush
=
True
,
**
{
color
:
True
})
@property
def
_width_of_current_line
(
self
)
->
int
:
"""Return the width of the current line."""
return
self
.
_tw
.
width_of_current_line
def
pytest_collection
(
self
)
->
None
:
if
self
.
isatty
:
if
self
.
config
.
option
.
verbose
>=
0
:
self
.
write
(
"collecting ... "
,
flush
=
True
,
bold
=
True
)
self
.
_collect_report_last_write
=
timing
.
time
()
elif
self
.
config
.
option
.
verbose
>=
1
:
self
.
write
(
"collecting ... "
,
flush
=
True
,
bold
=
True
)
def
pytest_collectreport
(
self
,
report
:
CollectReport
)
->
None
:
if
report
.
failed
:
self
.
_add_stats
(
"error"
,
[
report
])
elif
report
.
skipped
:
self
.
_add_stats
(
"skipped"
,
[
report
])
items
=
[
x
for
x
in
report
.
result
if
isinstance
(
x
,
Item
)]
self
.
_numcollected
+=
len
(
items
)
if
self
.
isatty
:
self
.
report_collect
()
def
report_collect
(
self
,
final
:
bool
=
False
)
->
None
:
if
self
.
config
.
option
.
verbose
<
0
:
return
if
not
final
:
# Only write "collecting" report every 0.5s.
t
=
timing
.
time
()
if
(
self
.
_collect_report_last_write
is
not
None
and
self
.
_collect_report_last_write
>
t
-
REPORT_COLLECTING_RESOLUTION
):
return
self
.
_collect_report_last_write
=
t
errors
=
len
(
self
.
stats
.
get
(
"error"
,
[]))
skipped
=
len
(
self
.
stats
.
get
(
"skipped"
,
[]))
deselected
=
len
(
self
.
stats
.
get
(
"deselected"
,
[]))
selected
=
self
.
_numcollected
-
deselected
line
=
"collected "
if
final
else
"collecting "
line
+=
(
str
(
self
.
_numcollected
)
+
" item"
+
(
""
if
self
.
_numcollected
==
1
else
"s"
)
)
if
errors
:
line
+=
" /
%d
error
%s
"
%
(
errors
,
"s"
if
errors
!=
1
else
""
)
if
deselected
:
line
+=
" /
%d
deselected"
%
deselected
if
skipped
:
line
+=
" /
%d
skipped"
%
skipped
if
self
.
_numcollected
>
selected
:
line
+=
" /
%d
selected"
%
selected
if
self
.
isatty
:
self
.
rewrite
(
line
,
bold
=
True
,
erase
=
True
)
if
final
:
self
.
write
(
"
\n
"
)
else
:
self
.
write_line
(
line
)
@hookimpl
(
trylast
=
True
)
def
pytest_sessionstart
(
self
,
session
:
Session
)
->
None
:
self
.
_session
=
session
self
.
_sessionstarttime
=
timing
.
time
()
if
not
self
.
showheader
:
return
self
.
write_sep
(
"="
,
"test session starts"
,
bold
=
True
)
verinfo
=
platform
.
python_version
()
if
not
self
.
no_header
:
msg
=
f
"platform
{
sys
.
platform
}
-- Python
{
verinfo
}
"
pypy_version_info
=
getattr
(
sys
,
"pypy_version_info"
,
None
)
if
pypy_version_info
:
verinfo
=
"."
.
join
(
map
(
str
,
pypy_version_info
[:
3
]))
msg
+=
f
"[pypy-
{
verinfo
}
-
{
pypy_version_info
[
3
]
}
]"
msg
+=
f
", pytest-
{
_pytest
.
_version
.
version
}
, pluggy-
{
pluggy
.
__version__
}
"
if
(
self
.
verbosity
>
0
or
self
.
config
.
option
.
debug
or
getattr
(
self
.
config
.
option
,
"pastebin"
,
None
)
):
msg
+=
" -- "
+
str
(
sys
.
executable
)
self
.
write_line
(
msg
)
lines
=
self
.
config
.
hook
.
pytest_report_header
(
config
=
self
.
config
,
start_path
=
self
.
startpath
)
self
.
_write_report_lines_from_hooks
(
lines
)
def
_write_report_lines_from_hooks
(
self
,
lines
:
Sequence
[
str
|
Sequence
[
str
]]
)
->
None
:
for
line_or_lines
in
reversed
(
lines
):
if
isinstance
(
line_or_lines
,
str
):
self
.
write_line
(
line_or_lines
)
else
:
for
line
in
line_or_lines
:
self
.
write_line
(
line
)
def
pytest_report_header
(
self
,
config
:
Config
)
->
list
[
str
]:
result
=
[
f
"rootdir:
{
config
.
rootpath
}
"
]
if
config
.
inipath
:
result
.
append
(
"configfile: "
+
bestrelpath
(
config
.
rootpath
,
config
.
inipath
))
if
config
.
args_source
==
Config
.
ArgsSource
.
TESTPATHS
:
testpaths
:
list
[
str
]
=
config
.
getini
(
"testpaths"
)
result
.
append
(
"testpaths:
{}
"
.
format
(
", "
.
join
(
testpaths
)))
plugininfo
=
config
.
pluginmanager
.
list_plugin_distinfo
()
if
plugininfo
:
result
.
append
(
"plugins:
{}
"
.
format
(
", "
.
join
(
_plugin_nameversions
(
plugininfo
)))
)
return
result
def
pytest_collection_finish
(
self
,
session
:
Session
)
->
None
:
self
.
report_collect
(
True
)
lines
=
self
.
config
.
hook
.
pytest_report_collectionfinish
(
config
=
self
.
config
,
start_path
=
self
.
startpath
,
items
=
session
.
items
,
)
self
.
_write_report_lines_from_hooks
(
lines
)
if
self
.
config
.
getoption
(
"collectonly"
):
if
session
.
items
:
if
self
.
config
.
option
.
verbose
>
-
1
:
self
.
_tw
.
line
(
""
)
self
.
_printcollecteditems
(
session
.
items
)
failed
=
self
.
stats
.
get
(
"failed"
)
if
failed
:
self
.
_tw
.
sep
(
"!"
,
"collection failures"
)
for
rep
in
failed
:
rep
.
toterminal
(
self
.
_tw
)
def
_printcollecteditems
(
self
,
items
:
Sequence
[
Item
])
->
None
:
test_cases_verbosity
=
self
.
config
.
get_verbosity
(
Config
.
VERBOSITY_TEST_CASES
)
if
test_cases_verbosity
<
0
:
if
test_cases_verbosity
<
-
1
:
counts
=
Counter
(
item
.
nodeid
.
split
(
"::"
,
1
)[
0
]
for
item
in
items
)
for
name
,
count
in
sorted
(
counts
.
items
()):
self
.
_tw
.
line
(
"
%s
:
%d
"
%
(
name
,
count
))
else
:
for
item
in
items
:
self
.
_tw
.
line
(
item
.
nodeid
)
return
stack
:
list
[
Node
]
=
[]
indent
=
""
for
item
in
items
:
needed_collectors
=
item
.
listchain
()[
1
:]
# strip root node
while
stack
:
if
stack
==
needed_collectors
[:
len
(
stack
)]:
break
stack
.
pop
()
for
col
in
needed_collectors
[
len
(
stack
)
:]:
stack
.
append
(
col
)
indent
=
(
len
(
stack
)
-
1
)
*
"  "
self
.
_tw
.
line
(
f
"
{
indent
}{
col
}
"
)
if
test_cases_verbosity
>=
1
:
obj
=
getattr
(
col
,
"obj"
,
None
)
doc
=
inspect
.
getdoc
(
obj
)
if
obj
else
None
if
doc
:
for
line
in
doc
.
splitlines
():
self
.
_tw
.
line
(
"
{}{}
"
.
format
(
indent
+
"  "
,
line
))
@hookimpl
(
wrapper
=
True
)
def
pytest_sessionfinish
(
self
,
session
:
Session
,
exitstatus
:
int
|
ExitCode
)
->
Generator
[
None
]:
result
=
yield
self
.
_tw
.
line
(
""
)
summary_exit_codes
=
(
ExitCode
.
OK
,
ExitCode
.
TESTS_FAILED
,
ExitCode
.
INTERRUPTED
,
ExitCode
.
USAGE_ERROR
,
ExitCode
.
NO_TESTS_COLLECTED
,
)
if
exitstatus
in
summary_exit_codes
and
not
self
.
no_summary
:
self
.
config
.
hook
.
pytest_terminal_summary
(
terminalreporter
=
self
,
exitstatus
=
exitstatus
,
config
=
self
.
config
)
if
session
.
shouldfail
:
self
.
write_sep
(
"!"
,
str
(
session
.
shouldfail
),
red
=
True
)
if
exitstatus
==
ExitCode
.
INTERRUPTED
:
self
.
_report_keyboardinterrupt
()
self
.
_keyboardinterrupt_memo
=
None
elif
session
.
shouldstop
:
self
.
write_sep
(
"!"
,
str
(
session
.
shouldstop
),
red
=
True
)
self
.
summary_stats
()
return
result
@hookimpl
(
wrapper
=
True
)
def
pytest_terminal_summary
(
self
)
->
Generator
[
None
]:
self
.
summary_errors
()
self
.
summary_failures
()
self
.
summary_xfailures
()
self
.
summary_warnings
()
self
.
summary_passes
()
self
.
summary_xpasses
()
try
:
return
(
yield
)
finally
:
self
.
short_test_summary
()
# Display any extra warnings from teardown here (if any).
self
.
summary_warnings
()
def
pytest_keyboard_interrupt
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
])
->
None
:
self
.
_keyboardinterrupt_memo
=
excinfo
.
getrepr
(
funcargs
=
True
)
def
pytest_unconfigure
(
self
)
->
None
:
if
self
.
_keyboardinterrupt_memo
is
not
None
:
self
.
_report_keyboardinterrupt
()
def
_report_keyboardinterrupt
(
self
)
->
None
:
excrepr
=
self
.
_keyboardinterrupt_memo
assert
excrepr
is
not
None
assert
excrepr
.
reprcrash
is
not
None
msg
=
excrepr
.
reprcrash
.
message
self
.
write_sep
(
"!"
,
msg
)
if
"KeyboardInterrupt"
in
msg
:
if
self
.
config
.
option
.
fulltrace
:
excrepr
.
toterminal
(
self
.
_tw
)
else
:
excrepr
.
reprcrash
.
toterminal
(
self
.
_tw
)
self
.
_tw
.
line
(
"(to show a full traceback on KeyboardInterrupt use --full-trace)"
,
yellow
=
True
,
)
def
_locationline
(
self
,
nodeid
:
str
,
fspath
:
str
,
lineno
:
int
|
None
,
domain
:
str
)
->
str
:
def
mkrel
(
nodeid
:
str
)
->
str
:
line
=
self
.
config
.
cwd_relative_nodeid
(
nodeid
)
if
domain
and
line
.
endswith
(
domain
):
line
=
line
[:
-
len
(
domain
)]
values
=
domain
.
split
(
"["
)
values
[
0
]
=
values
[
0
]
.
replace
(
"."
,
"::"
)
# don't replace '.' in params
line
+=
"["
.
join
(
values
)
return
line
# fspath comes from testid which has a "/"-normalized path.
if
fspath
:
res
=
mkrel
(
nodeid
)
if
self
.
verbosity
>=
2
and
nodeid
.
split
(
"::"
)[
0
]
!=
fspath
.
replace
(
"
\\
"
,
nodes
.
SEP
):
res
+=
" <- "
+
bestrelpath
(
self
.
startpath
,
Path
(
fspath
))
else
:
res
=
"[location]"
return
res
+
" "
def
_getfailureheadline
(
self
,
rep
):
head_line
=
rep
.
head_line
if
head_line
:
return
head_line
return
"test session"
# XXX?
def
_getcrashline
(
self
,
rep
):
try
:
return
str
(
rep
.
longrepr
.
reprcrash
)
except
AttributeError
:
try
:
return
str
(
rep
.
longrepr
)[:
50
]
except
AttributeError
:
return
""
#
# Summaries for sessionfinish.
#
def
getreports
(
self
,
name
:
str
):
return
[
x
for
x
in
self
.
stats
.
get
(
name
,
())
if
not
hasattr
(
x
,
"_pdbshown"
)]
def
summary_warnings
(
self
)
->
None
:
if
self
.
hasopt
(
"w"
):
all_warnings
:
list
[
WarningReport
]
|
None
=
self
.
stats
.
get
(
"warnings"
)
if
not
all_warnings
:
return
final
=
self
.
_already_displayed_warnings
is
not
None
if
final
:
warning_reports
=
all_warnings
[
self
.
_already_displayed_warnings
:]
else
:
warning_reports
=
all_warnings
self
.
_already_displayed_warnings
=
len
(
warning_reports
)
if
not
warning_reports
:
return
reports_grouped_by_message
:
dict
[
str
,
list
[
WarningReport
]]
=
{}
for
wr
in
warning_reports
:
reports_grouped_by_message
.
setdefault
(
wr
.
message
,
[])
.
append
(
wr
)
def
collapsed_location_report
(
reports
:
list
[
WarningReport
])
->
str
:
locations
=
[]
for
w
in
reports
:
location
=
w
.
get_location
(
self
.
config
)
if
location
:
locations
.
append
(
location
)
if
len
(
locations
)
<
10
:
return
"
\n
"
.
join
(
map
(
str
,
locations
))
counts_by_filename
=
Counter
(
str
(
loc
)
.
split
(
"::"
,
1
)[
0
]
for
loc
in
locations
)
return
"
\n
"
.
join
(
"
{}
:
{}
warning
{}
"
.
format
(
k
,
v
,
"s"
if
v
>
1
else
""
)
for
k
,
v
in
counts_by_filename
.
items
()
)
title
=
"warnings summary (final)"
if
final
else
"warnings summary"
self
.
write_sep
(
"="
,
title
,
yellow
=
True
,
bold
=
False
)
for
message
,
message_reports
in
reports_grouped_by_message
.
items
():
maybe_location
=
collapsed_location_report
(
message_reports
)
if
maybe_location
:
self
.
_tw
.
line
(
maybe_location
)
lines
=
message
.
splitlines
()
indented
=
"
\n
"
.
join
(
"  "
+
x
for
x
in
lines
)
message
=
indented
.
rstrip
()
else
:
message
=
message
.
rstrip
()
self
.
_tw
.
line
(
message
)
self
.
_tw
.
line
()
self
.
_tw
.
line
(
"-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html"
)
def
summary_passes
(
self
)
->
None
:
self
.
summary_passes_combined
(
"passed"
,
"PASSES"
,
"P"
)
def
summary_xpasses
(
self
)
->
None
:
self
.
summary_passes_combined
(
"xpassed"
,
"XPASSES"
,
"X"
)
def
summary_passes_combined
(
self
,
which_reports
:
str
,
sep_title
:
str
,
needed_opt
:
str
)
->
None
:
if
self
.
config
.
option
.
tbstyle
!=
"no"
:
if
self
.
hasopt
(
needed_opt
):
reports
:
list
[
TestReport
]
=
self
.
getreports
(
which_reports
)
if
not
reports
:
return
self
.
write_sep
(
"="
,
sep_title
)
for
rep
in
reports
:
if
rep
.
sections
:
msg
=
self
.
_getfailureheadline
(
rep
)
self
.
write_sep
(
"_"
,
msg
,
green
=
True
,
bold
=
True
)
self
.
_outrep_summary
(
rep
)
self
.
_handle_teardown_sections
(
rep
.
nodeid
)
def
_get_teardown_reports
(
self
,
nodeid
:
str
)
->
list
[
TestReport
]:
reports
=
self
.
getreports
(
""
)
return
[
report
for
report
in
reports
if
report
.
when
==
"teardown"
and
report
.
nodeid
==
nodeid
]
def
_handle_teardown_sections
(
self
,
nodeid
:
str
)
->
None
:
for
report
in
self
.
_get_teardown_reports
(
nodeid
):
self
.
print_teardown_sections
(
report
)
def
print_teardown_sections
(
self
,
rep
:
TestReport
)
->
None
:
showcapture
=
self
.
config
.
option
.
showcapture
if
showcapture
==
"no"
:
return
for
secname
,
content
in
rep
.
sections
:
if
showcapture
!=
"all"
and
showcapture
not
in
secname
:
continue
if
"teardown"
in
secname
:
self
.
_tw
.
sep
(
"-"
,
secname
)
if
content
[
-
1
:]
==
"
\n
"
:
content
=
content
[:
-
1
]
self
.
_tw
.
line
(
content
)
def
summary_failures
(
self
)
->
None
:
style
=
self
.
config
.
option
.
tbstyle
self
.
summary_failures_combined
(
"failed"
,
"FAILURES"
,
style
=
style
)
def
summary_xfailures
(
self
)
->
None
:
show_tb
=
self
.
config
.
option
.
xfail_tb
style
=
self
.
config
.
option
.
tbstyle
if
show_tb
else
"no"
self
.
summary_failures_combined
(
"xfailed"
,
"XFAILURES"
,
style
=
style
)
def
summary_failures_combined
(
self
,
which_reports
:
str
,
sep_title
:
str
,
*
,
style
:
str
,
needed_opt
:
str
|
None
=
None
,
)
->
None
:
if
style
!=
"no"
:
if
not
needed_opt
or
self
.
hasopt
(
needed_opt
):
reports
:
list
[
BaseReport
]
=
self
.
getreports
(
which_reports
)
if
not
reports
:
return
self
.
write_sep
(
"="
,
sep_title
)
if
style
==
"line"
:
for
rep
in
reports
:
line
=
self
.
_getcrashline
(
rep
)
self
.
write_line
(
line
)
else
:
for
rep
in
reports
:
msg
=
self
.
_getfailureheadline
(
rep
)
self
.
write_sep
(
"_"
,
msg
,
red
=
True
,
bold
=
True
)
self
.
_outrep_summary
(
rep
)
self
.
_handle_teardown_sections
(
rep
.
nodeid
)
def
summary_errors
(
self
)
->
None
:
if
self
.
config
.
option
.
tbstyle
!=
"no"
:
reports
:
list
[
BaseReport
]
=
self
.
getreports
(
"error"
)
if
not
reports
:
return
self
.
write_sep
(
"="
,
"ERRORS"
)
for
rep
in
self
.
stats
[
"error"
]:
msg
=
self
.
_getfailureheadline
(
rep
)
if
rep
.
when
==
"collect"
:
msg
=
"ERROR collecting "
+
msg
else
:
msg
=
f
"ERROR at
{
rep
.
when
}
of
{
msg
}
"
self
.
write_sep
(
"_"
,
msg
,
red
=
True
,
bold
=
True
)
self
.
_outrep_summary
(
rep
)
def
_outrep_summary
(
self
,
rep
:
BaseReport
)
->
None
:
rep
.
toterminal
(
self
.
_tw
)
showcapture
=
self
.
config
.
option
.
showcapture
if
showcapture
==
"no"
:
return
for
secname
,
content
in
rep
.
sections
:
if
showcapture
!=
"all"
and
showcapture
not
in
secname
:
continue
self
.
_tw
.
sep
(
"-"
,
secname
)
if
content
[
-
1
:]
==
"
\n
"
:
content
=
content
[:
-
1
]
self
.
_tw
.
line
(
content
)
def
summary_stats
(
self
)
->
None
:
if
self
.
verbosity
<
-
1
:
return
session_duration
=
timing
.
time
()
-
self
.
_sessionstarttime
(
parts
,
main_color
)
=
self
.
build_summary_stats_line
()
line_parts
=
[]
display_sep
=
self
.
verbosity
>=
0
if
display_sep
:
fullwidth
=
self
.
_tw
.
fullwidth
for
text
,
markup
in
parts
:
with_markup
=
self
.
_tw
.
markup
(
text
,
**
markup
)
if
display_sep
:
fullwidth
+=
len
(
with_markup
)
-
len
(
text
)
line_parts
.
append
(
with_markup
)
msg
=
", "
.
join
(
line_parts
)
main_markup
=
{
main_color
:
True
}
duration
=
f
" in
{
format_session_duration
(
session_duration
)
}
"
duration_with_markup
=
self
.
_tw
.
markup
(
duration
,
**
main_markup
)
if
display_sep
:
fullwidth
+=
len
(
duration_with_markup
)
-
len
(
duration
)
msg
+=
duration_with_markup
if
display_sep
:
markup_for_end_sep
=
self
.
_tw
.
markup
(
""
,
**
main_markup
)
if
markup_for_end_sep
.
endswith
(
"
\x1b
[0m"
):
markup_for_end_sep
=
markup_for_end_sep
[:
-
4
]
fullwidth
+=
len
(
markup_for_end_sep
)
msg
+=
markup_for_end_sep
if
display_sep
:
self
.
write_sep
(
"="
,
msg
,
fullwidth
=
fullwidth
,
**
main_markup
)
else
:
self
.
write_line
(
msg
,
**
main_markup
)
def
short_test_summary
(
self
)
->
None
:
if
not
self
.
reportchars
:
return
def
show_simple
(
lines
:
list
[
str
],
*
,
stat
:
str
)
->
None
:
failed
=
self
.
stats
.
get
(
stat
,
[])
if
not
failed
:
return
config
=
self
.
config
for
rep
in
failed
:
color
=
_color_for_type
.
get
(
stat
,
_color_for_type_default
)
line
=
_get_line_with_reprcrash_message
(
config
,
rep
,
self
.
_tw
,
{
color
:
True
}
)
lines
.
append
(
line
)
def
show_xfailed
(
lines
:
list
[
str
])
->
None
:
xfailed
=
self
.
stats
.
get
(
"xfailed"
,
[])
for
rep
in
xfailed
:
verbose_word
,
verbose_markup
=
rep
.
_get_verbose_word_with_markup
(
self
.
config
,
{
_color_for_type
[
"warnings"
]:
True
}
)
markup_word
=
self
.
_tw
.
markup
(
verbose_word
,
**
verbose_markup
)
nodeid
=
_get_node_id_with_markup
(
self
.
_tw
,
self
.
config
,
rep
)
line
=
f
"
{
markup_word
}
{
nodeid
}
"
reason
=
rep
.
wasxfail
if
reason
:
line
+=
" - "
+
str
(
reason
)
lines
.
append
(
line
)
def
show_xpassed
(
lines
:
list
[
str
])
->
None
:
xpassed
=
self
.
stats
.
get
(
"xpassed"
,
[])
for
rep
in
xpassed
:
verbose_word
,
verbose_markup
=
rep
.
_get_verbose_word_with_markup
(
self
.
config
,
{
_color_for_type
[
"warnings"
]:
True
}
)
markup_word
=
self
.
_tw
.
markup
(
verbose_word
,
**
verbose_markup
)
nodeid
=
_get_node_id_with_markup
(
self
.
_tw
,
self
.
config
,
rep
)
line
=
f
"
{
markup_word
}
{
nodeid
}
"
reason
=
rep
.
wasxfail
if
reason
:
line
+=
" - "
+
str
(
reason
)
lines
.
append
(
line
)
def
show_skipped_folded
(
lines
:
list
[
str
])
->
None
:
skipped
:
list
[
CollectReport
]
=
self
.
stats
.
get
(
"skipped"
,
[])
fskips
=
_folded_skips
(
self
.
startpath
,
skipped
)
if
skipped
else
[]
if
not
fskips
:
return
verbose_word
,
verbose_markup
=
skipped
[
0
]
.
_get_verbose_word_with_markup
(
self
.
config
,
{
_color_for_type
[
"warnings"
]:
True
}
)
markup_word
=
self
.
_tw
.
markup
(
verbose_word
,
**
verbose_markup
)
prefix
=
"Skipped: "
for
num
,
fspath
,
lineno
,
reason
in
fskips
:
if
reason
.
startswith
(
prefix
):
reason
=
reason
[
len
(
prefix
)
:]
if
lineno
is
not
None
:
lines
.
append
(
"
%s
[
%d
]
%s
:
%d
:
%s
"
%
(
markup_word
,
num
,
fspath
,
lineno
,
reason
)
)
else
:
lines
.
append
(
"
%s
[
%d
]
%s
:
%s
"
%
(
markup_word
,
num
,
fspath
,
reason
))
def
show_skipped_unfolded
(
lines
:
list
[
str
])
->
None
:
skipped
:
list
[
CollectReport
]
=
self
.
stats
.
get
(
"skipped"
,
[])
for
rep
in
skipped
:
assert
rep
.
longrepr
is
not
None
assert
isinstance
(
rep
.
longrepr
,
tuple
),
(
rep
,
rep
.
longrepr
)
assert
len
(
rep
.
longrepr
)
==
3
,
(
rep
,
rep
.
longrepr
)
verbose_word
,
verbose_markup
=
rep
.
_get_verbose_word_with_markup
(
self
.
config
,
{
_color_for_type
[
"warnings"
]:
True
}
)
markup_word
=
self
.
_tw
.
markup
(
verbose_word
,
**
verbose_markup
)
nodeid
=
_get_node_id_with_markup
(
self
.
_tw
,
self
.
config
,
rep
)
line
=
f
"
{
markup_word
}
{
nodeid
}
"
reason
=
rep
.
longrepr
[
2
]
if
reason
:
line
+=
" - "
+
str
(
reason
)
lines
.
append
(
line
)
def
show_skipped
(
lines
:
list
[
str
])
->
None
:
if
self
.
foldskipped
:
show_skipped_folded
(
lines
)
else
:
show_skipped_unfolded
(
lines
)
REPORTCHAR_ACTIONS
:
Mapping
[
str
,
Callable
[[
list
[
str
]],
None
]]
=
{
"x"
:
show_xfailed
,
"X"
:
show_xpassed
,
"f"
:
partial
(
show_simple
,
stat
=
"failed"
),
"s"
:
show_skipped
,
"p"
:
partial
(
show_simple
,
stat
=
"passed"
),
"E"
:
partial
(
show_simple
,
stat
=
"error"
),
}
lines
:
list
[
str
]
=
[]
for
char
in
self
.
reportchars
:
action
=
REPORTCHAR_ACTIONS
.
get
(
char
)
if
action
:
# skipping e.g. "P" (passed with output) here.
action
(
lines
)
if
lines
:
self
.
write_sep
(
"="
,
"short test summary info"
,
cyan
=
True
,
bold
=
True
)
for
line
in
lines
:
self
.
write_line
(
line
)
def
_get_main_color
(
self
)
->
tuple
[
str
,
list
[
str
]]:
if
self
.
_main_color
is
None
or
self
.
_known_types
is
None
or
self
.
_is_last_item
:
self
.
_set_main_color
()
assert
self
.
_main_color
assert
self
.
_known_types
return
self
.
_main_color
,
self
.
_known_types
def
_determine_main_color
(
self
,
unknown_type_seen
:
bool
)
->
str
:
stats
=
self
.
stats
if
"failed"
in
stats
or
"error"
in
stats
:
main_color
=
"red"
elif
"warnings"
in
stats
or
"xpassed"
in
stats
or
unknown_type_seen
:
main_color
=
"yellow"
elif
"passed"
in
stats
or
not
self
.
_is_last_item
:
main_color
=
"green"
else
:
main_color
=
"yellow"
return
main_color
def
_set_main_color
(
self
)
->
None
:
unknown_types
:
list
[
str
]
=
[]
for
found_type
in
self
.
stats
:
if
found_type
:
# setup/teardown reports have an empty key, ignore them
if
found_type
not
in
KNOWN_TYPES
and
found_type
not
in
unknown_types
:
unknown_types
.
append
(
found_type
)
self
.
_known_types
=
list
(
KNOWN_TYPES
)
+
unknown_types
self
.
_main_color
=
self
.
_determine_main_color
(
bool
(
unknown_types
))
def
build_summary_stats_line
(
self
)
->
tuple
[
list
[
tuple
[
str
,
dict
[
str
,
bool
]]],
str
]:
"""
Build the parts used in the last summary stats line.
The summary stats line is the line shown at the end, "=== 12 passed, 2 errors in Xs===".
This function builds a list of the "parts" that make up for the text in that line, in
the example above it would be:
[
("12 passed", {"green": True}),
("2 errors", {"red": True}
]
That last dict for each line is a "markup dictionary", used by TerminalWriter to
color output.
The final color of the line is also determined by this function, and is the second
element of the returned tuple.
"""
if
self
.
config
.
getoption
(
"collectonly"
):
return
self
.
_build_collect_only_summary_stats_line
()
else
:
return
self
.
_build_normal_summary_stats_line
()
def
_get_reports_to_display
(
self
,
key
:
str
)
->
list
[
Any
]:
"""Get test/collection reports for the given status key, such as `passed` or `error`."""
reports
=
self
.
stats
.
get
(
key
,
[])
return
[
x
for
x
in
reports
if
getattr
(
x
,
"count_towards_summary"
,
True
)]
def
_build_normal_summary_stats_line
(
self
,
)
->
tuple
[
list
[
tuple
[
str
,
dict
[
str
,
bool
]]],
str
]:
main_color
,
known_types
=
self
.
_get_main_color
()
parts
=
[]
for
key
in
known_types
:
reports
=
self
.
_get_reports_to_display
(
key
)
if
reports
:
count
=
len
(
reports
)
color
=
_color_for_type
.
get
(
key
,
_color_for_type_default
)
markup
=
{
color
:
True
,
"bold"
:
color
==
main_color
}
parts
.
append
((
"
%d
%s
"
%
pluralize
(
count
,
key
),
markup
))
if
not
parts
:
parts
=
[(
"no tests ran"
,
{
_color_for_type_default
:
True
})]
return
parts
,
main_color
def
_build_collect_only_summary_stats_line
(
self
,
)
->
tuple
[
list
[
tuple
[
str
,
dict
[
str
,
bool
]]],
str
]:
deselected
=
len
(
self
.
_get_reports_to_display
(
"deselected"
))
errors
=
len
(
self
.
_get_reports_to_display
(
"error"
))
if
self
.
_numcollected
==
0
:
parts
=
[(
"no tests collected"
,
{
"yellow"
:
True
})]
main_color
=
"yellow"
elif
deselected
==
0
:
main_color
=
"green"
collected_output
=
"
%d
%s
collected"
%
pluralize
(
self
.
_numcollected
,
"test"
)
parts
=
[(
collected_output
,
{
main_color
:
True
})]
else
:
all_tests_were_deselected
=
self
.
_numcollected
==
deselected
if
all_tests_were_deselected
:
main_color
=
"yellow"
collected_output
=
f
"no tests collected (
{
deselected
}
deselected)"
else
:
main_color
=
"green"
selected
=
self
.
_numcollected
-
deselected
collected_output
=
f
"
{
selected
}
/
{
self
.
_numcollected
}
tests collected (
{
deselected
}
deselected)"
parts
=
[(
collected_output
,
{
main_color
:
True
})]
if
errors
:
main_color
=
_color_for_type
[
"error"
]
parts
+=
[(
"
%d
%s
"
%
pluralize
(
errors
,
"error"
),
{
main_color
:
True
})]
return
parts
,
main_color
def
_get_node_id_with_markup
(
tw
:
TerminalWriter
,
config
:
Config
,
rep
:
BaseReport
):
nodeid
=
config
.
cwd_relative_nodeid
(
rep
.
nodeid
)
path
,
*
parts
=
nodeid
.
split
(
"::"
)
if
parts
:
parts_markup
=
tw
.
markup
(
"::"
.
join
(
parts
),
bold
=
True
)
return
path
+
"::"
+
parts_markup
else
:
return
path
def
_format_trimmed
(
format
:
str
,
msg
:
str
,
available_width
:
int
)
->
str
|
None
:
"""Format msg into format, ellipsizing it if doesn't fit in available_width.
Returns None if even the ellipsis can't fit.
"""
# Only use the first line.
i
=
msg
.
find
(
"
\n
"
)
if
i
!=
-
1
:
msg
=
msg
[:
i
]
ellipsis
=
"..."
format_width
=
wcswidth
(
format
.
format
(
""
))
if
format_width
+
len
(
ellipsis
)
>
available_width
:
return
None
if
format_width
+
wcswidth
(
msg
)
>
available_width
:
available_width
-=
len
(
ellipsis
)
msg
=
msg
[:
available_width
]
while
format_width
+
wcswidth
(
msg
)
>
available_width
:
msg
=
msg
[:
-
1
]
msg
+=
ellipsis
return
format
.
format
(
msg
)
def
_get_line_with_reprcrash_message
(
config
:
Config
,
rep
:
BaseReport
,
tw
:
TerminalWriter
,
word_markup
:
dict
[
str
,
bool
]
)
->
str
:
"""Get summary line for a report, trying to add reprcrash message."""
verbose_word
,
verbose_markup
=
rep
.
_get_verbose_word_with_markup
(
config
,
word_markup
)
word
=
tw
.
markup
(
verbose_word
,
**
verbose_markup
)
node
=
_get_node_id_with_markup
(
tw
,
config
,
rep
)
line
=
f
"
{
word
}
{
node
}
"
line_width
=
wcswidth
(
line
)
try
:
# Type ignored intentionally -- possible AttributeError expected.
msg
=
rep
.
longrepr
.
reprcrash
.
message
# type: ignore[union-attr]
except
AttributeError
:
pass
else
:
if
running_on_ci
()
or
config
.
option
.
verbose
>=
2
:
msg
=
f
" -
{
msg
}
"
else
:
available_width
=
tw
.
fullwidth
-
line_width
msg
=
_format_trimmed
(
" -
{}
"
,
msg
,
available_width
)
if
msg
is
not
None
:
line
+=
msg
return
line
def
_folded_skips
(
startpath
:
Path
,
skipped
:
Sequence
[
CollectReport
],
)
->
list
[
tuple
[
int
,
str
,
int
|
None
,
str
]]:
d
:
dict
[
tuple
[
str
,
int
|
None
,
str
],
list
[
CollectReport
]]
=
{}
for
event
in
skipped
:
assert
event
.
longrepr
is
not
None
assert
isinstance
(
event
.
longrepr
,
tuple
),
(
event
,
event
.
longrepr
)
assert
len
(
event
.
longrepr
)
==
3
,
(
event
,
event
.
longrepr
)
fspath
,
lineno
,
reason
=
event
.
longrepr
# For consistency, report all fspaths in relative form.
fspath
=
bestrelpath
(
startpath
,
Path
(
fspath
))
keywords
=
getattr
(
event
,
"keywords"
,
{})
# Folding reports with global pytestmark variable.
# This is a workaround, because for now we cannot identify the scope of a skip marker
# TODO: Revisit after marks scope would be fixed.
if
(
event
.
when
==
"setup"
and
"skip"
in
keywords
and
"pytestmark"
not
in
keywords
):
key
:
tuple
[
str
,
int
|
None
,
str
]
=
(
fspath
,
None
,
reason
)
else
:
key
=
(
fspath
,
lineno
,
reason
)
d
.
setdefault
(
key
,
[])
.
append
(
event
)
values
:
list
[
tuple
[
int
,
str
,
int
|
None
,
str
]]
=
[]
for
key
,
events
in
d
.
items
():
values
.
append
((
len
(
events
),
*
key
))
return
values
_color_for_type
=
{
"failed"
:
"red"
,
"error"
:
"red"
,
"warnings"
:
"yellow"
,
"passed"
:
"green"
,
}
_color_for_type_default
=
"yellow"
def
pluralize
(
count
:
int
,
noun
:
str
)
->
tuple
[
int
,
str
]:
# No need to pluralize words such as `failed` or `passed`.
if
noun
not
in
[
"error"
,
"warnings"
,
"test"
]:
return
count
,
noun
# The `warnings` key is plural. To avoid API breakage, we keep it that way but
# set it to singular here so we can determine plurality in the same way as we do
# for `error`.
noun
=
noun
.
replace
(
"warnings"
,
"warning"
)
return
count
,
noun
+
"s"
if
count
!=
1
else
noun
def
_plugin_nameversions
(
plugininfo
)
->
list
[
str
]:
values
:
list
[
str
]
=
[]
for
plugin
,
dist
in
plugininfo
:
# Gets us name and version!
name
=
f
"
{
dist
.
project_name
}
-
{
dist
.
version
}
"
# Questionable convenience, but it keeps things short.
if
name
.
startswith
(
"pytest-"
):
name
=
name
[
7
:]
# We decided to print python package names they can have more than one plugin.
if
name
not
in
values
:
values
.
append
(
name
)
return
values
def
format_session_duration
(
seconds
:
float
)
->
str
:
"""Format the given seconds in a human readable manner to show in the final summary."""
if
seconds
<
60
:
return
f
"
{
seconds
:
.2f
}
s"
else
:
dt
=
datetime
.
timedelta
(
seconds
=
int
(
seconds
))
return
f
"
{
seconds
:
.2f
}
s (
{
dt
}
)"
def
_get_raw_skip_reason
(
report
:
TestReport
)
->
str
:
"""Get the reason string of a skip/xfail/xpass test report.
The string is just the part given by the user.
"""
if
hasattr
(
report
,
"wasxfail"
):
reason
=
report
.
wasxfail
if
reason
.
startswith
(
"reason: "
):
reason
=
reason
[
len
(
"reason: "
)
:]
return
reason
else
:
assert
report
.
skipped
assert
isinstance
(
report
.
longrepr
,
tuple
)
_
,
_
,
reason
=
report
.
longrepr
if
reason
.
startswith
(
"Skipped: "
):
reason
=
reason
[
len
(
"Skipped: "
)
:]
elif
reason
==
"Skipped"
:
reason
=
""
return
reason

```


---


# _pytest.legacypath - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/legacypath.html


# Source code for _pytest.legacypath

```

# mypy: allow-untyped-defs
"""Add backward compatibility support for the legacy py path type."""
from
__future__
import
annotations
import
dataclasses
from
pathlib
import
Path
import
shlex
import
subprocess
from
typing
import
Final
from
typing
import
final
from
typing
import
TYPE_CHECKING
from
iniconfig
import
SectionWrapper
from
_pytest.cacheprovider
import
Cache
from
_pytest.compat
import
LEGACY_PATH
from
_pytest.compat
import
legacy_path
from
_pytest.config
import
Config
from
_pytest.config
import
hookimpl
from
_pytest.config
import
PytestPluginManager
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.main
import
Session
from
_pytest.monkeypatch
import
MonkeyPatch
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
Item
from
_pytest.nodes
import
Node
from
_pytest.pytester
import
HookRecorder
from
_pytest.pytester
import
Pytester
from
_pytest.pytester
import
RunResult
from
_pytest.terminal
import
TerminalReporter
from
_pytest.tmpdir
import
TempPathFactory
if
TYPE_CHECKING
:
import
pexpect
[docs]
@final
class
Testdir
:
"""
Similar to :class:`Pytester`, but this class works with legacy legacy_path objects instead.
All methods just forward to an internal :class:`Pytester` instance, converting results
to `legacy_path` objects as necessary.
"""
__test__
=
False
CLOSE_STDIN
:
Final
=
Pytester
.
CLOSE_STDIN
TimeoutExpired
:
Final
=
Pytester
.
TimeoutExpired
def
__init__
(
self
,
pytester
:
Pytester
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_pytester
=
pytester
@property
def
tmpdir
(
self
)
->
LEGACY_PATH
:
"""Temporary directory where tests are executed."""
return
legacy_path
(
self
.
_pytester
.
path
)
@property
def
test_tmproot
(
self
)
->
LEGACY_PATH
:
return
legacy_path
(
self
.
_pytester
.
_test_tmproot
)
@property
def
request
(
self
):
return
self
.
_pytester
.
_request
@property
def
plugins
(
self
):
return
self
.
_pytester
.
plugins
@plugins
.
setter
def
plugins
(
self
,
plugins
):
self
.
_pytester
.
plugins
=
plugins
@property
def
monkeypatch
(
self
)
->
MonkeyPatch
:
return
self
.
_pytester
.
_monkeypatch
[docs]
def
make_hook_recorder
(
self
,
pluginmanager
)
->
HookRecorder
:
"""See :meth:`Pytester.make_hook_recorder`."""
return
self
.
_pytester
.
make_hook_recorder
(
pluginmanager
)
[docs]
def
chdir
(
self
)
->
None
:
"""See :meth:`Pytester.chdir`."""
return
self
.
_pytester
.
chdir
()
def
finalize
(
self
)
->
None
:
return
self
.
_pytester
.
_finalize
()
[docs]
def
makefile
(
self
,
ext
,
*
args
,
**
kwargs
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.makefile`."""
if
ext
and
not
ext
.
startswith
(
"."
):
# pytester.makefile is going to throw a ValueError in a way that
# testdir.makefile did not, because
# pathlib.Path is stricter suffixes than py.path
# This ext arguments is likely user error, but since testdir has
# allowed this, we will prepend "." as a workaround to avoid breaking
# testdir usage that worked before
ext
=
"."
+
ext
return
legacy_path
(
self
.
_pytester
.
makefile
(
ext
,
*
args
,
**
kwargs
))
[docs]
def
makeconftest
(
self
,
source
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.makeconftest`."""
return
legacy_path
(
self
.
_pytester
.
makeconftest
(
source
))
[docs]
def
makeini
(
self
,
source
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.makeini`."""
return
legacy_path
(
self
.
_pytester
.
makeini
(
source
))
[docs]
def
getinicfg
(
self
,
source
:
str
)
->
SectionWrapper
:
"""See :meth:`Pytester.getinicfg`."""
return
self
.
_pytester
.
getinicfg
(
source
)
[docs]
def
makepyprojecttoml
(
self
,
source
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.makepyprojecttoml`."""
return
legacy_path
(
self
.
_pytester
.
makepyprojecttoml
(
source
))
[docs]
def
makepyfile
(
self
,
*
args
,
**
kwargs
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.makepyfile`."""
return
legacy_path
(
self
.
_pytester
.
makepyfile
(
*
args
,
**
kwargs
))
[docs]
def
maketxtfile
(
self
,
*
args
,
**
kwargs
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.maketxtfile`."""
return
legacy_path
(
self
.
_pytester
.
maketxtfile
(
*
args
,
**
kwargs
))
[docs]
def
syspathinsert
(
self
,
path
=
None
)
->
None
:
"""See :meth:`Pytester.syspathinsert`."""
return
self
.
_pytester
.
syspathinsert
(
path
)
[docs]
def
mkdir
(
self
,
name
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.mkdir`."""
return
legacy_path
(
self
.
_pytester
.
mkdir
(
name
))
[docs]
def
mkpydir
(
self
,
name
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.mkpydir`."""
return
legacy_path
(
self
.
_pytester
.
mkpydir
(
name
))
[docs]
def
copy_example
(
self
,
name
=
None
)
->
LEGACY_PATH
:
"""See :meth:`Pytester.copy_example`."""
return
legacy_path
(
self
.
_pytester
.
copy_example
(
name
))
[docs]
def
getnode
(
self
,
config
:
Config
,
arg
)
->
Item
|
Collector
|
None
:
"""See :meth:`Pytester.getnode`."""
return
self
.
_pytester
.
getnode
(
config
,
arg
)
[docs]
def
getpathnode
(
self
,
path
):
"""See :meth:`Pytester.getpathnode`."""
return
self
.
_pytester
.
getpathnode
(
path
)
[docs]
def
genitems
(
self
,
colitems
:
list
[
Item
|
Collector
])
->
list
[
Item
]:
"""See :meth:`Pytester.genitems`."""
return
self
.
_pytester
.
genitems
(
colitems
)
[docs]
def
runitem
(
self
,
source
):
"""See :meth:`Pytester.runitem`."""
return
self
.
_pytester
.
runitem
(
source
)
[docs]
def
inline_runsource
(
self
,
source
,
*
cmdlineargs
):
"""See :meth:`Pytester.inline_runsource`."""
return
self
.
_pytester
.
inline_runsource
(
source
,
*
cmdlineargs
)
[docs]
def
inline_genitems
(
self
,
*
args
):
"""See :meth:`Pytester.inline_genitems`."""
return
self
.
_pytester
.
inline_genitems
(
*
args
)
[docs]
def
inline_run
(
self
,
*
args
,
plugins
=
(),
no_reraise_ctrlc
:
bool
=
False
):
"""See :meth:`Pytester.inline_run`."""
return
self
.
_pytester
.
inline_run
(
*
args
,
plugins
=
plugins
,
no_reraise_ctrlc
=
no_reraise_ctrlc
)
[docs]
def
runpytest_inprocess
(
self
,
*
args
,
**
kwargs
)
->
RunResult
:
"""See :meth:`Pytester.runpytest_inprocess`."""
return
self
.
_pytester
.
runpytest_inprocess
(
*
args
,
**
kwargs
)
[docs]
def
runpytest
(
self
,
*
args
,
**
kwargs
)
->
RunResult
:
"""See :meth:`Pytester.runpytest`."""
return
self
.
_pytester
.
runpytest
(
*
args
,
**
kwargs
)
[docs]
def
parseconfig
(
self
,
*
args
)
->
Config
:
"""See :meth:`Pytester.parseconfig`."""
return
self
.
_pytester
.
parseconfig
(
*
args
)
[docs]
def
parseconfigure
(
self
,
*
args
)
->
Config
:
"""See :meth:`Pytester.parseconfigure`."""
return
self
.
_pytester
.
parseconfigure
(
*
args
)
[docs]
def
getitem
(
self
,
source
,
funcname
=
"test_func"
):
"""See :meth:`Pytester.getitem`."""
return
self
.
_pytester
.
getitem
(
source
,
funcname
)
[docs]
def
getitems
(
self
,
source
):
"""See :meth:`Pytester.getitems`."""
return
self
.
_pytester
.
getitems
(
source
)
[docs]
def
getmodulecol
(
self
,
source
,
configargs
=
(),
withinit
=
False
):
"""See :meth:`Pytester.getmodulecol`."""
return
self
.
_pytester
.
getmodulecol
(
source
,
configargs
=
configargs
,
withinit
=
withinit
)
[docs]
def
collect_by_name
(
self
,
modcol
:
Collector
,
name
:
str
)
->
Item
|
Collector
|
None
:
"""See :meth:`Pytester.collect_by_name`."""
return
self
.
_pytester
.
collect_by_name
(
modcol
,
name
)
[docs]
def
popen
(
self
,
cmdargs
,
stdout
=
subprocess
.
PIPE
,
stderr
=
subprocess
.
PIPE
,
stdin
=
CLOSE_STDIN
,
**
kw
,
):
"""See :meth:`Pytester.popen`."""
return
self
.
_pytester
.
popen
(
cmdargs
,
stdout
,
stderr
,
stdin
,
**
kw
)
[docs]
def
run
(
self
,
*
cmdargs
,
timeout
=
None
,
stdin
=
CLOSE_STDIN
)
->
RunResult
:
"""See :meth:`Pytester.run`."""
return
self
.
_pytester
.
run
(
*
cmdargs
,
timeout
=
timeout
,
stdin
=
stdin
)
[docs]
def
runpython
(
self
,
script
)
->
RunResult
:
"""See :meth:`Pytester.runpython`."""
return
self
.
_pytester
.
runpython
(
script
)
[docs]
def
runpython_c
(
self
,
command
):
"""See :meth:`Pytester.runpython_c`."""
return
self
.
_pytester
.
runpython_c
(
command
)
[docs]
def
runpytest_subprocess
(
self
,
*
args
,
timeout
=
None
)
->
RunResult
:
"""See :meth:`Pytester.runpytest_subprocess`."""
return
self
.
_pytester
.
runpytest_subprocess
(
*
args
,
timeout
=
timeout
)
[docs]
def
spawn_pytest
(
self
,
string
:
str
,
expect_timeout
:
float
=
10.0
)
->
pexpect
.
spawn
:
"""See :meth:`Pytester.spawn_pytest`."""
return
self
.
_pytester
.
spawn_pytest
(
string
,
expect_timeout
=
expect_timeout
)
[docs]
def
spawn
(
self
,
cmd
:
str
,
expect_timeout
:
float
=
10.0
)
->
pexpect
.
spawn
:
"""See :meth:`Pytester.spawn`."""
return
self
.
_pytester
.
spawn
(
cmd
,
expect_timeout
=
expect_timeout
)
def
__repr__
(
self
)
->
str
:
return
f
"<Testdir
{
self
.
tmpdir
!r}
>"
def
__str__
(
self
)
->
str
:
return
str
(
self
.
tmpdir
)
class
LegacyTestdirPlugin
:
@staticmethod
@fixture
def
testdir
(
pytester
:
Pytester
)
->
Testdir
:
"""
Identical to :fixture:`pytester`, and provides an instance whose methods return
legacy ``LEGACY_PATH`` objects instead when applicable.
New code should avoid using :fixture:`testdir` in favor of :fixture:`pytester`.
"""
return
Testdir
(
pytester
,
_ispytest
=
True
)
[docs]
@final
@dataclasses
.
dataclass
class
TempdirFactory
:
"""Backward compatibility wrapper that implements ``py.path.local``
for :class:`TempPathFactory`.
.. note::
These days, it is preferred to use ``tmp_path_factory``.
:ref:`About the tmpdir and tmpdir_factory fixtures<tmpdir and tmpdir_factory>`.
"""
_tmppath_factory
:
TempPathFactory
def
__init__
(
self
,
tmppath_factory
:
TempPathFactory
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_tmppath_factory
=
tmppath_factory
[docs]
def
mktemp
(
self
,
basename
:
str
,
numbered
:
bool
=
True
)
->
LEGACY_PATH
:
"""Same as :meth:`TempPathFactory.mktemp`, but returns a ``py.path.local`` object."""
return
legacy_path
(
self
.
_tmppath_factory
.
mktemp
(
basename
,
numbered
)
.
resolve
())
[docs]
def
getbasetemp
(
self
)
->
LEGACY_PATH
:
"""Same as :meth:`TempPathFactory.getbasetemp`, but returns a ``py.path.local`` object."""
return
legacy_path
(
self
.
_tmppath_factory
.
getbasetemp
()
.
resolve
())
class
LegacyTmpdirPlugin
:
@staticmethod
@fixture
(
scope
=
"session"
)
def
tmpdir_factory
(
request
:
FixtureRequest
)
->
TempdirFactory
:
"""Return a :class:`pytest.TempdirFactory` instance for the test session."""
# Set dynamically by pytest_configure().
return
request
.
config
.
_tmpdirhandler
# type: ignore
@staticmethod
@fixture
def
tmpdir
(
tmp_path
:
Path
)
->
LEGACY_PATH
:
"""Return a temporary directory (as `legacy_path`_ object)
which is unique to each test function invocation.
The temporary directory is created as a subdirectory
of the base temporary directory, with configurable retention,
as discussed in :ref:`temporary directory location and retention`.
.. note::
These days, it is preferred to use ``tmp_path``.
:ref:`About the tmpdir and tmpdir_factory fixtures<tmpdir and tmpdir_factory>`.
.. _legacy_path: https://py.readthedocs.io/en/latest/path.html
"""
return
legacy_path
(
tmp_path
)
def
Cache_makedir
(
self
:
Cache
,
name
:
str
)
->
LEGACY_PATH
:
"""Return a directory path object with the given name.
Same as :func:`mkdir`, but returns a legacy py path instance.
"""
return
legacy_path
(
self
.
mkdir
(
name
))
def
FixtureRequest_fspath
(
self
:
FixtureRequest
)
->
LEGACY_PATH
:
"""(deprecated) The file system path of the test module which collected this test."""
return
legacy_path
(
self
.
path
)
def
TerminalReporter_startdir
(
self
:
TerminalReporter
)
->
LEGACY_PATH
:
"""The directory from which pytest was invoked.
Prefer to use ``startpath`` which is a :class:`pathlib.Path`.
:type: LEGACY_PATH
"""
return
legacy_path
(
self
.
startpath
)
def
Config_invocation_dir
(
self
:
Config
)
->
LEGACY_PATH
:
"""The directory from which pytest was invoked.
Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,
which is a :class:`pathlib.Path`.
:type: LEGACY_PATH
"""
return
legacy_path
(
str
(
self
.
invocation_params
.
dir
))
def
Config_rootdir
(
self
:
Config
)
->
LEGACY_PATH
:
"""The path to the :ref:`rootdir <rootdir>`.
Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.
:type: LEGACY_PATH
"""
return
legacy_path
(
str
(
self
.
rootpath
))
def
Config_inifile
(
self
:
Config
)
->
LEGACY_PATH
|
None
:
"""The path to the :ref:`configfile <configfiles>`.
Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.
:type: Optional[LEGACY_PATH]
"""
return
legacy_path
(
str
(
self
.
inipath
))
if
self
.
inipath
else
None
def
Session_startdir
(
self
:
Session
)
->
LEGACY_PATH
:
"""The path from which pytest was invoked.
Prefer to use ``startpath`` which is a :class:`pathlib.Path`.
:type: LEGACY_PATH
"""
return
legacy_path
(
self
.
startpath
)
def
Config__getini_unknown_type
(
self
,
name
:
str
,
type
:
str
,
value
:
str
|
list
[
str
]):
if
type
==
"pathlist"
:
# TODO: This assert is probably not valid in all cases.
assert
self
.
inipath
is
not
None
dp
=
self
.
inipath
.
parent
input_values
=
shlex
.
split
(
value
)
if
isinstance
(
value
,
str
)
else
value
return
[
legacy_path
(
str
(
dp
/
x
))
for
x
in
input_values
]
else
:
raise
ValueError
(
f
"unknown configuration type:
{
type
}
"
,
value
)
def
Node_fspath
(
self
:
Node
)
->
LEGACY_PATH
:
"""(deprecated) returns a legacy_path copy of self.path"""
return
legacy_path
(
self
.
path
)
def
Node_fspath_set
(
self
:
Node
,
value
:
LEGACY_PATH
)
->
None
:
self
.
path
=
Path
(
value
)
@hookimpl
(
tryfirst
=
True
)
def
pytest_load_initial_conftests
(
early_config
:
Config
)
->
None
:
"""Monkeypatch legacy path attributes in several classes, as early as possible."""
mp
=
MonkeyPatch
()
early_config
.
add_cleanup
(
mp
.
undo
)
# Add Cache.makedir().
mp
.
setattr
(
Cache
,
"makedir"
,
Cache_makedir
,
raising
=
False
)
# Add FixtureRequest.fspath property.
mp
.
setattr
(
FixtureRequest
,
"fspath"
,
property
(
FixtureRequest_fspath
),
raising
=
False
)
# Add TerminalReporter.startdir property.
mp
.
setattr
(
TerminalReporter
,
"startdir"
,
property
(
TerminalReporter_startdir
),
raising
=
False
)
# Add Config.{invocation_dir,rootdir,inifile} properties.
mp
.
setattr
(
Config
,
"invocation_dir"
,
property
(
Config_invocation_dir
),
raising
=
False
)
mp
.
setattr
(
Config
,
"rootdir"
,
property
(
Config_rootdir
),
raising
=
False
)
mp
.
setattr
(
Config
,
"inifile"
,
property
(
Config_inifile
),
raising
=
False
)
# Add Session.startdir property.
mp
.
setattr
(
Session
,
"startdir"
,
property
(
Session_startdir
),
raising
=
False
)
# Add pathlist configuration type.
mp
.
setattr
(
Config
,
"_getini_unknown_type"
,
Config__getini_unknown_type
)
# Add Node.fspath property.
mp
.
setattr
(
Node
,
"fspath"
,
property
(
Node_fspath
,
Node_fspath_set
),
raising
=
False
)
@hookimpl
def
pytest_configure
(
config
:
Config
)
->
None
:
"""Installs the LegacyTmpdirPlugin if the ``tmpdir`` plugin is also installed."""
if
config
.
pluginmanager
.
has_plugin
(
"tmpdir"
):
mp
=
MonkeyPatch
()
config
.
add_cleanup
(
mp
.
undo
)
# Create TmpdirFactory and attach it to the config object.
#
# This is to comply with existing plugins which expect the handler to be
# available at pytest_configure time, but ideally should be moved entirely
# to the tmpdir_factory session fixture.
try
:
tmp_path_factory
=
config
.
_tmp_path_factory
# type: ignore[attr-defined]
except
AttributeError
:
# tmpdir plugin is blocked.
pass
else
:
_tmpdirhandler
=
TempdirFactory
(
tmp_path_factory
,
_ispytest
=
True
)
mp
.
setattr
(
config
,
"_tmpdirhandler"
,
_tmpdirhandler
,
raising
=
False
)
config
.
pluginmanager
.
register
(
LegacyTmpdirPlugin
,
"legacypath-tmpdir"
)
@hookimpl
def
pytest_plugin_registered
(
plugin
:
object
,
manager
:
PytestPluginManager
)
->
None
:
# pytester is not loaded by default and is commonly loaded from a conftest,
# so checking for it in `pytest_configure` is not enough.
is_pytester
=
plugin
is
manager
.
get_plugin
(
"pytester"
)
if
is_pytester
and
not
manager
.
is_registered
(
LegacyTestdirPlugin
):
manager
.
register
(
LegacyTestdirPlugin
,
"legacypath-pytester"
)

```


---


# _pytest.main - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/main.html


# Source code for _pytest.main

```

"""Core implementation of the testing process: init, session, runtest loop."""
from
__future__
import
annotations
import
argparse
import
dataclasses
import
fnmatch
import
functools
import
importlib
import
importlib.util
import
os
from
pathlib
import
Path
import
sys
from
typing
import
AbstractSet
from
typing
import
Callable
from
typing
import
Dict
from
typing
import
final
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Literal
from
typing
import
overload
from
typing
import
Sequence
from
typing
import
TYPE_CHECKING
import
warnings
import
pluggy
from
_pytest
import
nodes
import
_pytest._code
from
_pytest.config
import
Config
from
_pytest.config
import
directory_arg
from
_pytest.config
import
ExitCode
from
_pytest.config
import
hookimpl
from
_pytest.config
import
PytestPluginManager
from
_pytest.config
import
UsageError
from
_pytest.config.argparsing
import
Parser
from
_pytest.config.compat
import
PathAwareHookProxy
from
_pytest.outcomes
import
exit
from
_pytest.pathlib
import
absolutepath
from
_pytest.pathlib
import
bestrelpath
from
_pytest.pathlib
import
fnmatch_ex
from
_pytest.pathlib
import
safe_exists
from
_pytest.pathlib
import
scandir
from
_pytest.reports
import
CollectReport
from
_pytest.reports
import
TestReport
from
_pytest.runner
import
collect_one_node
from
_pytest.runner
import
SetupState
from
_pytest.warning_types
import
PytestWarning
if
TYPE_CHECKING
:
from
typing_extensions
import
Self
from
_pytest.fixtures
import
FixtureManager
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
parser
.
addini
(
"norecursedirs"
,
"Directory patterns to avoid for recursion"
,
type
=
"args"
,
default
=
[
"*.egg"
,
".*"
,
"_darcs"
,
"build"
,
"CVS"
,
"dist"
,
"node_modules"
,
"venv"
,
"
{arch}
"
,
],
)
parser
.
addini
(
"testpaths"
,
"Directories to search for tests when no files or directories are given on the "
"command line"
,
type
=
"args"
,
default
=
[],
)
group
=
parser
.
getgroup
(
"general"
,
"Running and selection options"
)
group
.
_addoption
(
"-x"
,
"--exitfirst"
,
action
=
"store_const"
,
dest
=
"maxfail"
,
const
=
1
,
help
=
"Exit instantly on first error or failed test"
,
)
group
=
parser
.
getgroup
(
"pytest-warnings"
)
group
.
addoption
(
"-W"
,
"--pythonwarnings"
,
action
=
"append"
,
help
=
"Set which warnings to report, see -W option of Python itself"
,
)
parser
.
addini
(
"filterwarnings"
,
type
=
"linelist"
,
help
=
"Each line specifies a pattern for "
"warnings.filterwarnings. "
"Processed after -W/--pythonwarnings."
,
)
group
.
_addoption
(
"--maxfail"
,
metavar
=
"num"
,
action
=
"store"
,
type
=
int
,
dest
=
"maxfail"
,
default
=
0
,
help
=
"Exit after first num failures or errors"
,
)
group
.
_addoption
(
"--strict-config"
,
action
=
"store_true"
,
help
=
"Any warnings encountered while parsing the `pytest` section of the "
"configuration file raise errors"
,
)
group
.
_addoption
(
"--strict-markers"
,
action
=
"store_true"
,
help
=
"Markers not registered in the `markers` section of the configuration "
"file raise errors"
,
)
group
.
_addoption
(
"--strict"
,
action
=
"store_true"
,
help
=
"(Deprecated) alias to --strict-markers"
,
)
group
.
_addoption
(
"-c"
,
"--config-file"
,
metavar
=
"FILE"
,
type
=
str
,
dest
=
"inifilename"
,
help
=
"Load configuration from `FILE` instead of trying to locate one of the "
"implicit configuration files."
,
)
group
.
_addoption
(
"--continue-on-collection-errors"
,
action
=
"store_true"
,
default
=
False
,
dest
=
"continue_on_collection_errors"
,
help
=
"Force test execution even if collection errors occur"
,
)
group
.
_addoption
(
"--rootdir"
,
action
=
"store"
,
dest
=
"rootdir"
,
help
=
"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', "
"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: "
"'$HOME/root_dir'."
,
)
group
=
parser
.
getgroup
(
"collect"
,
"collection"
)
group
.
addoption
(
"--collectonly"
,
"--collect-only"
,
"--co"
,
action
=
"store_true"
,
help
=
"Only collect tests, don't execute them"
,
)
group
.
addoption
(
"--pyargs"
,
action
=
"store_true"
,
help
=
"Try to interpret all arguments as Python packages"
,
)
group
.
addoption
(
"--ignore"
,
action
=
"append"
,
metavar
=
"path"
,
help
=
"Ignore path during collection (multi-allowed)"
,
)
group
.
addoption
(
"--ignore-glob"
,
action
=
"append"
,
metavar
=
"path"
,
help
=
"Ignore path pattern during collection (multi-allowed)"
,
)
group
.
addoption
(
"--deselect"
,
action
=
"append"
,
metavar
=
"nodeid_prefix"
,
help
=
"Deselect item (via node id prefix) during collection (multi-allowed)"
,
)
group
.
addoption
(
"--confcutdir"
,
dest
=
"confcutdir"
,
default
=
None
,
metavar
=
"dir"
,
type
=
functools
.
partial
(
directory_arg
,
optname
=
"--confcutdir"
),
help
=
"Only load conftest.py's relative to specified dir"
,
)
group
.
addoption
(
"--noconftest"
,
action
=
"store_true"
,
dest
=
"noconftest"
,
default
=
False
,
help
=
"Don't load any conftest.py files"
,
)
group
.
addoption
(
"--keepduplicates"
,
"--keep-duplicates"
,
action
=
"store_true"
,
dest
=
"keepduplicates"
,
default
=
False
,
help
=
"Keep duplicate tests"
,
)
group
.
addoption
(
"--collect-in-virtualenv"
,
action
=
"store_true"
,
dest
=
"collect_in_virtualenv"
,
default
=
False
,
help
=
"Don't ignore tests in a local virtualenv directory"
,
)
group
.
addoption
(
"--import-mode"
,
default
=
"prepend"
,
choices
=
[
"prepend"
,
"append"
,
"importlib"
],
dest
=
"importmode"
,
help
=
"Prepend/append to sys.path when importing test modules and conftest "
"files. Default: prepend."
,
)
parser
.
addini
(
"consider_namespace_packages"
,
type
=
"bool"
,
default
=
False
,
help
=
"Consider namespace packages when resolving module names during import"
,
)
group
=
parser
.
getgroup
(
"debugconfig"
,
"test session debugging and configuration"
)
group
.
addoption
(
"--basetemp"
,
dest
=
"basetemp"
,
default
=
None
,
type
=
validate_basetemp
,
metavar
=
"dir"
,
help
=
(
"Base temporary directory for this test run. "
"(Warning: this directory is removed if it exists.)"
),
)
def
validate_basetemp
(
path
:
str
)
->
str
:
# GH 7119
msg
=
"basetemp must not be empty, the current working directory or any parent directory of it"
# empty path
if
not
path
:
raise
argparse
.
ArgumentTypeError
(
msg
)
def
is_ancestor
(
base
:
Path
,
query
:
Path
)
->
bool
:
"""Return whether query is an ancestor of base."""
if
base
==
query
:
return
True
return
query
in
base
.
parents
# check if path is an ancestor of cwd
if
is_ancestor
(
Path
.
cwd
(),
Path
(
path
)
.
absolute
()):
raise
argparse
.
ArgumentTypeError
(
msg
)
# check symlinks for ancestors
if
is_ancestor
(
Path
.
cwd
()
.
resolve
(),
Path
(
path
)
.
resolve
()):
raise
argparse
.
ArgumentTypeError
(
msg
)
return
path
def
wrap_session
(
config
:
Config
,
doit
:
Callable
[[
Config
,
Session
],
int
|
ExitCode
|
None
]
)
->
int
|
ExitCode
:
"""Skeleton command line program."""
session
=
Session
.
from_config
(
config
)
session
.
exitstatus
=
ExitCode
.
OK
initstate
=
0
try
:
try
:
config
.
_do_configure
()
initstate
=
1
config
.
hook
.
pytest_sessionstart
(
session
=
session
)
initstate
=
2
session
.
exitstatus
=
doit
(
config
,
session
)
or
0
except
UsageError
:
session
.
exitstatus
=
ExitCode
.
USAGE_ERROR
raise
except
Failed
:
session
.
exitstatus
=
ExitCode
.
TESTS_FAILED
except
(
KeyboardInterrupt
,
exit
.
Exception
):
excinfo
=
_pytest
.
_code
.
ExceptionInfo
.
from_current
()
exitstatus
:
int
|
ExitCode
=
ExitCode
.
INTERRUPTED
if
isinstance
(
excinfo
.
value
,
exit
.
Exception
):
if
excinfo
.
value
.
returncode
is
not
None
:
exitstatus
=
excinfo
.
value
.
returncode
if
initstate
<
2
:
sys
.
stderr
.
write
(
f
"
{
excinfo
.
typename
}
:
{
excinfo
.
value
.
msg
}
\n
"
)
config
.
hook
.
pytest_keyboard_interrupt
(
excinfo
=
excinfo
)
session
.
exitstatus
=
exitstatus
except
BaseException
:
session
.
exitstatus
=
ExitCode
.
INTERNAL_ERROR
excinfo
=
_pytest
.
_code
.
ExceptionInfo
.
from_current
()
try
:
config
.
notify_exception
(
excinfo
,
config
.
option
)
except
exit
.
Exception
as
exc
:
if
exc
.
returncode
is
not
None
:
session
.
exitstatus
=
exc
.
returncode
sys
.
stderr
.
write
(
f
"
{
type
(
exc
)
.
__name__
}
:
{
exc
}
\n
"
)
else
:
if
isinstance
(
excinfo
.
value
,
SystemExit
):
sys
.
stderr
.
write
(
"mainloop: caught unexpected SystemExit!
\n
"
)
finally
:
# Explicitly break reference cycle.
excinfo
=
None
# type: ignore
os
.
chdir
(
session
.
startpath
)
if
initstate
>=
2
:
try
:
config
.
hook
.
pytest_sessionfinish
(
session
=
session
,
exitstatus
=
session
.
exitstatus
)
except
exit
.
Exception
as
exc
:
if
exc
.
returncode
is
not
None
:
session
.
exitstatus
=
exc
.
returncode
sys
.
stderr
.
write
(
f
"
{
type
(
exc
)
.
__name__
}
:
{
exc
}
\n
"
)
config
.
_ensure_unconfigure
()
return
session
.
exitstatus
def
pytest_cmdline_main
(
config
:
Config
)
->
int
|
ExitCode
:
return
wrap_session
(
config
,
_main
)
def
_main
(
config
:
Config
,
session
:
Session
)
->
int
|
ExitCode
|
None
:
"""Default command line protocol for initialization, session,
running tests and reporting."""
config
.
hook
.
pytest_collection
(
session
=
session
)
config
.
hook
.
pytest_runtestloop
(
session
=
session
)
if
session
.
testsfailed
:
return
ExitCode
.
TESTS_FAILED
elif
session
.
testscollected
==
0
:
return
ExitCode
.
NO_TESTS_COLLECTED
return
None
def
pytest_collection
(
session
:
Session
)
->
None
:
session
.
perform_collect
()
def
pytest_runtestloop
(
session
:
Session
)
->
bool
:
if
session
.
testsfailed
and
not
session
.
config
.
option
.
continue_on_collection_errors
:
raise
session
.
Interrupted
(
"
%d
error
%s
during collection"
%
(
session
.
testsfailed
,
"s"
if
session
.
testsfailed
!=
1
else
""
)
)
if
session
.
config
.
option
.
collectonly
:
return
True
for
i
,
item
in
enumerate
(
session
.
items
):
nextitem
=
session
.
items
[
i
+
1
]
if
i
+
1
<
len
(
session
.
items
)
else
None
item
.
config
.
hook
.
pytest_runtest_protocol
(
item
=
item
,
nextitem
=
nextitem
)
if
session
.
shouldfail
:
raise
session
.
Failed
(
session
.
shouldfail
)
if
session
.
shouldstop
:
raise
session
.
Interrupted
(
session
.
shouldstop
)
return
True
def
_in_venv
(
path
:
Path
)
->
bool
:
"""Attempt to detect if ``path`` is the root of a Virtual Environment by
checking for the existence of the pyvenv.cfg file.
[https://peps.python.org/pep-0405/]
For regression protection we also check for conda environments that do not include pyenv.cfg yet --
https://github.com/conda/conda/issues/13337 is the conda issue tracking adding pyenv.cfg.
Checking for the `conda-meta/history` file per https://github.com/pytest-dev/pytest/issues/12652#issuecomment-2246336902.
"""
try
:
return
(
path
.
joinpath
(
"pyvenv.cfg"
)
.
is_file
()
or
path
.
joinpath
(
"conda-meta"
,
"history"
)
.
is_file
()
)
except
OSError
:
return
False
def
pytest_ignore_collect
(
collection_path
:
Path
,
config
:
Config
)
->
bool
|
None
:
if
collection_path
.
name
==
"__pycache__"
:
return
True
ignore_paths
=
config
.
_getconftest_pathlist
(
"collect_ignore"
,
path
=
collection_path
.
parent
)
ignore_paths
=
ignore_paths
or
[]
excludeopt
=
config
.
getoption
(
"ignore"
)
if
excludeopt
:
ignore_paths
.
extend
(
absolutepath
(
x
)
for
x
in
excludeopt
)
if
collection_path
in
ignore_paths
:
return
True
ignore_globs
=
config
.
_getconftest_pathlist
(
"collect_ignore_glob"
,
path
=
collection_path
.
parent
)
ignore_globs
=
ignore_globs
or
[]
excludeglobopt
=
config
.
getoption
(
"ignore_glob"
)
if
excludeglobopt
:
ignore_globs
.
extend
(
absolutepath
(
x
)
for
x
in
excludeglobopt
)
if
any
(
fnmatch
.
fnmatch
(
str
(
collection_path
),
str
(
glob
))
for
glob
in
ignore_globs
):
return
True
allow_in_venv
=
config
.
getoption
(
"collect_in_virtualenv"
)
if
not
allow_in_venv
and
_in_venv
(
collection_path
):
return
True
if
collection_path
.
is_dir
():
norecursepatterns
=
config
.
getini
(
"norecursedirs"
)
if
any
(
fnmatch_ex
(
pat
,
collection_path
)
for
pat
in
norecursepatterns
):
return
True
return
None
def
pytest_collect_directory
(
path
:
Path
,
parent
:
nodes
.
Collector
)
->
nodes
.
Collector
|
None
:
return
Dir
.
from_parent
(
parent
,
path
=
path
)
def
pytest_collection_modifyitems
(
items
:
list
[
nodes
.
Item
],
config
:
Config
)
->
None
:
deselect_prefixes
=
tuple
(
config
.
getoption
(
"deselect"
)
or
[])
if
not
deselect_prefixes
:
return
remaining
=
[]
deselected
=
[]
for
colitem
in
items
:
if
colitem
.
nodeid
.
startswith
(
deselect_prefixes
):
deselected
.
append
(
colitem
)
else
:
remaining
.
append
(
colitem
)
if
deselected
:
config
.
hook
.
pytest_deselected
(
items
=
deselected
)
items
[:]
=
remaining
class
FSHookProxy
:
def
__init__
(
self
,
pm
:
PytestPluginManager
,
remove_mods
:
AbstractSet
[
object
],
)
->
None
:
self
.
pm
=
pm
self
.
remove_mods
=
remove_mods
def
__getattr__
(
self
,
name
:
str
)
->
pluggy
.
HookCaller
:
x
=
self
.
pm
.
subset_hook_caller
(
name
,
remove_plugins
=
self
.
remove_mods
)
self
.
__dict__
[
name
]
=
x
return
x
class
Interrupted
(
KeyboardInterrupt
):
"""Signals that the test run was interrupted."""
__module__
=
"builtins"
# For py3.
class
Failed
(
Exception
):
"""Signals a stop as failed test run."""
@dataclasses
.
dataclass
class
_bestrelpath_cache
(
Dict
[
Path
,
str
]):
__slots__
=
(
"path"
,)
path
:
Path
def
__missing__
(
self
,
path
:
Path
)
->
str
:
r
=
bestrelpath
(
self
.
path
,
path
)
self
[
path
]
=
r
return
r
[docs]
@final
class
Dir
(
nodes
.
Directory
):
"""Collector of files in a file system directory.
.. versionadded:: 8.0
.. note::
Python directories with an `__init__.py` file are instead collected by
:class:`~pytest.Package` by default. Both are :class:`~pytest.Directory`
collectors.
"""
[docs]
@classmethod
def
from_parent
(
# type: ignore[override]
cls
,
parent
:
nodes
.
Collector
,
*
,
path
:
Path
,
)
->
Self
:
"""The public constructor.
:param parent: The parent collector of this Dir.
:param path: The directory's path.
:type path: pathlib.Path
"""
return
super
()
.
from_parent
(
parent
=
parent
,
path
=
path
)
[docs]
def
collect
(
self
)
->
Iterable
[
nodes
.
Item
|
nodes
.
Collector
]:
config
=
self
.
config
col
:
nodes
.
Collector
|
None
cols
:
Sequence
[
nodes
.
Collector
]
ihook
=
self
.
ihook
for
direntry
in
scandir
(
self
.
path
):
if
direntry
.
is_dir
():
path
=
Path
(
direntry
.
path
)
if
not
self
.
session
.
isinitpath
(
path
,
with_parents
=
True
):
if
ihook
.
pytest_ignore_collect
(
collection_path
=
path
,
config
=
config
):
continue
col
=
ihook
.
pytest_collect_directory
(
path
=
path
,
parent
=
self
)
if
col
is
not
None
:
yield
col
elif
direntry
.
is_file
():
path
=
Path
(
direntry
.
path
)
if
not
self
.
session
.
isinitpath
(
path
):
if
ihook
.
pytest_ignore_collect
(
collection_path
=
path
,
config
=
config
):
continue
cols
=
ihook
.
pytest_collect_file
(
file_path
=
path
,
parent
=
self
)
yield from
cols
[docs]
@final
class
Session
(
nodes
.
Collector
):
"""The root of the collection tree.
``Session`` collects the initial paths given as arguments to pytest.
"""
Interrupted
=
Interrupted
Failed
=
Failed
# Set on the session by runner.pytest_sessionstart.
_setupstate
:
SetupState
# Set on the session by fixtures.pytest_sessionstart.
_fixturemanager
:
FixtureManager
exitstatus
:
int
|
ExitCode
def
__init__
(
self
,
config
:
Config
)
->
None
:
super
()
.
__init__
(
name
=
""
,
path
=
config
.
rootpath
,
fspath
=
None
,
parent
=
None
,
config
=
config
,
session
=
self
,
nodeid
=
""
,
)
self
.
testsfailed
=
0
self
.
testscollected
=
0
self
.
_shouldstop
:
bool
|
str
=
False
self
.
_shouldfail
:
bool
|
str
=
False
self
.
trace
=
config
.
trace
.
root
.
get
(
"collection"
)
self
.
_initialpaths
:
frozenset
[
Path
]
=
frozenset
()
self
.
_initialpaths_with_parents
:
frozenset
[
Path
]
=
frozenset
()
self
.
_notfound
:
list
[
tuple
[
str
,
Sequence
[
nodes
.
Collector
]]]
=
[]
self
.
_initial_parts
:
list
[
CollectionArgument
]
=
[]
self
.
_collection_cache
:
dict
[
nodes
.
Collector
,
CollectReport
]
=
{}
self
.
items
:
list
[
nodes
.
Item
]
=
[]
self
.
_bestrelpathcache
:
dict
[
Path
,
str
]
=
_bestrelpath_cache
(
config
.
rootpath
)
self
.
config
.
pluginmanager
.
register
(
self
,
name
=
"session"
)
@classmethod
def
from_config
(
cls
,
config
:
Config
)
->
Session
:
session
:
Session
=
cls
.
_create
(
config
=
config
)
return
session
def
__repr__
(
self
)
->
str
:
return
"<
%s
%s
exitstatus=
%r
testsfailed=
%d
testscollected=
%d
>"
%
(
self
.
__class__
.
__name__
,
self
.
name
,
getattr
(
self
,
"exitstatus"
,
"<UNSET>"
),
self
.
testsfailed
,
self
.
testscollected
,
)
@property
def
shouldstop
(
self
)
->
bool
|
str
:
return
self
.
_shouldstop
@shouldstop
.
setter
def
shouldstop
(
self
,
value
:
bool
|
str
)
->
None
:
# The runner checks shouldfail and assumes that if it is set we are
# definitely stopping, so prevent unsetting it.
if
value
is
False
and
self
.
_shouldstop
:
warnings
.
warn
(
PytestWarning
(
"session.shouldstop cannot be unset after it has been set; ignoring."
),
stacklevel
=
2
,
)
return
self
.
_shouldstop
=
value
@property
def
shouldfail
(
self
)
->
bool
|
str
:
return
self
.
_shouldfail
@shouldfail
.
setter
def
shouldfail
(
self
,
value
:
bool
|
str
)
->
None
:
# The runner checks shouldfail and assumes that if it is set we are
# definitely stopping, so prevent unsetting it.
if
value
is
False
and
self
.
_shouldfail
:
warnings
.
warn
(
PytestWarning
(
"session.shouldfail cannot be unset after it has been set; ignoring."
),
stacklevel
=
2
,
)
return
self
.
_shouldfail
=
value
@property
def
startpath
(
self
)
->
Path
:
"""The path from which pytest was invoked.
.. versionadded:: 7.0.0
"""
return
self
.
config
.
invocation_params
.
dir
def
_node_location_to_relpath
(
self
,
node_path
:
Path
)
->
str
:
# bestrelpath is a quite slow function.
return
self
.
_bestrelpathcache
[
node_path
]
@hookimpl
(
tryfirst
=
True
)
def
pytest_collectstart
(
self
)
->
None
:
if
self
.
shouldfail
:
raise
self
.
Failed
(
self
.
shouldfail
)
if
self
.
shouldstop
:
raise
self
.
Interrupted
(
self
.
shouldstop
)
@hookimpl
(
tryfirst
=
True
)
def
pytest_runtest_logreport
(
self
,
report
:
TestReport
|
CollectReport
)
->
None
:
if
report
.
failed
and
not
hasattr
(
report
,
"wasxfail"
):
self
.
testsfailed
+=
1
maxfail
=
self
.
config
.
getvalue
(
"maxfail"
)
if
maxfail
and
self
.
testsfailed
>=
maxfail
:
self
.
shouldfail
=
"stopping after
%d
failures"
%
(
self
.
testsfailed
)
pytest_collectreport
=
pytest_runtest_logreport
[docs]
def
isinitpath
(
self
,
path
:
str
|
os
.
PathLike
[
str
],
*
,
with_parents
:
bool
=
False
,
)
->
bool
:
"""Is path an initial path?
An initial path is a path explicitly given to pytest on the command
line.
:param with_parents:
If set, also return True if the path is a parent of an initial path.
.. versionchanged:: 8.0
Added the ``with_parents`` parameter.
"""
# Optimization: Path(Path(...)) is much slower than isinstance.
path_
=
path
if
isinstance
(
path
,
Path
)
else
Path
(
path
)
if
with_parents
:
return
path_
in
self
.
_initialpaths_with_parents
else
:
return
path_
in
self
.
_initialpaths
def
gethookproxy
(
self
,
fspath
:
os
.
PathLike
[
str
])
->
pluggy
.
HookRelay
:
# Optimization: Path(Path(...)) is much slower than isinstance.
path
=
fspath
if
isinstance
(
fspath
,
Path
)
else
Path
(
fspath
)
pm
=
self
.
config
.
pluginmanager
# Check if we have the common case of running
# hooks with all conftest.py files.
my_conftestmodules
=
pm
.
_getconftestmodules
(
path
)
remove_mods
=
pm
.
_conftest_plugins
.
difference
(
my_conftestmodules
)
proxy
:
pluggy
.
HookRelay
if
remove_mods
:
# One or more conftests are not in use at this path.
proxy
=
PathAwareHookProxy
(
FSHookProxy
(
pm
,
remove_mods
))
# type: ignore[arg-type,assignment]
else
:
# All plugins are active for this fspath.
proxy
=
self
.
config
.
hook
return
proxy
def
_collect_path
(
self
,
path
:
Path
,
path_cache
:
dict
[
Path
,
Sequence
[
nodes
.
Collector
]],
)
->
Sequence
[
nodes
.
Collector
]:
"""Create a Collector for the given path.
`path_cache` makes it so the same Collectors are returned for the same
path.
"""
if
path
in
path_cache
:
return
path_cache
[
path
]
if
path
.
is_dir
():
ihook
=
self
.
gethookproxy
(
path
.
parent
)
col
:
nodes
.
Collector
|
None
=
ihook
.
pytest_collect_directory
(
path
=
path
,
parent
=
self
)
cols
:
Sequence
[
nodes
.
Collector
]
=
(
col
,)
if
col
is
not
None
else
()
elif
path
.
is_file
():
ihook
=
self
.
gethookproxy
(
path
)
cols
=
ihook
.
pytest_collect_file
(
file_path
=
path
,
parent
=
self
)
else
:
# Broken symlink or invalid/missing file.
cols
=
()
path_cache
[
path
]
=
cols
return
cols
@overload
def
perform_collect
(
self
,
args
:
Sequence
[
str
]
|
None
=
...
,
genitems
:
Literal
[
True
]
=
...
)
->
Sequence
[
nodes
.
Item
]:
...
@overload
def
perform_collect
(
self
,
args
:
Sequence
[
str
]
|
None
=
...
,
genitems
:
bool
=
...
)
->
Sequence
[
nodes
.
Item
|
nodes
.
Collector
]:
...
[docs]
def
perform_collect
(
self
,
args
:
Sequence
[
str
]
|
None
=
None
,
genitems
:
bool
=
True
)
->
Sequence
[
nodes
.
Item
|
nodes
.
Collector
]:
"""Perform the collection phase for this session.
This is called by the default :hook:`pytest_collection` hook
implementation; see the documentation of this hook for more details.
For testing purposes, it may also be called directly on a fresh
``Session``.
This function normally recursively expands any collectors collected
from the session to their items, and only items are returned. For
testing purposes, this may be suppressed by passing ``genitems=False``,
in which case the return value contains these collectors unexpanded,
and ``session.items`` is empty.
"""
if
args
is
None
:
args
=
self
.
config
.
args
self
.
trace
(
"perform_collect"
,
self
,
args
)
self
.
trace
.
root
.
indent
+=
1
hook
=
self
.
config
.
hook
self
.
_notfound
=
[]
self
.
_initial_parts
=
[]
self
.
_collection_cache
=
{}
self
.
items
=
[]
items
:
Sequence
[
nodes
.
Item
|
nodes
.
Collector
]
=
self
.
items
try
:
initialpaths
:
list
[
Path
]
=
[]
initialpaths_with_parents
:
list
[
Path
]
=
[]
for
arg
in
args
:
collection_argument
=
resolve_collection_argument
(
self
.
config
.
invocation_params
.
dir
,
arg
,
as_pypath
=
self
.
config
.
option
.
pyargs
,
)
self
.
_initial_parts
.
append
(
collection_argument
)
initialpaths
.
append
(
collection_argument
.
path
)
initialpaths_with_parents
.
append
(
collection_argument
.
path
)
initialpaths_with_parents
.
extend
(
collection_argument
.
path
.
parents
)
self
.
_initialpaths
=
frozenset
(
initialpaths
)
self
.
_initialpaths_with_parents
=
frozenset
(
initialpaths_with_parents
)
rep
=
collect_one_node
(
self
)
self
.
ihook
.
pytest_collectreport
(
report
=
rep
)
self
.
trace
.
root
.
indent
-=
1
if
self
.
_notfound
:
errors
=
[]
for
arg
,
collectors
in
self
.
_notfound
:
if
collectors
:
errors
.
append
(
f
"not found:
{
arg
}
\n
(no match in any of
{
collectors
!r}
)"
)
else
:
errors
.
append
(
f
"found no collectors for
{
arg
}
"
)
raise
UsageError
(
*
errors
)
if
not
genitems
:
items
=
rep
.
result
else
:
if
rep
.
passed
:
for
node
in
rep
.
result
:
self
.
items
.
extend
(
self
.
genitems
(
node
))
self
.
config
.
pluginmanager
.
check_pending
()
hook
.
pytest_collection_modifyitems
(
session
=
self
,
config
=
self
.
config
,
items
=
items
)
finally
:
self
.
_notfound
=
[]
self
.
_initial_parts
=
[]
self
.
_collection_cache
=
{}
hook
.
pytest_collection_finish
(
session
=
self
)
if
genitems
:
self
.
testscollected
=
len
(
items
)
return
items
def
_collect_one_node
(
self
,
node
:
nodes
.
Collector
,
handle_dupes
:
bool
=
True
,
)
->
tuple
[
CollectReport
,
bool
]:
if
node
in
self
.
_collection_cache
and
handle_dupes
:
rep
=
self
.
_collection_cache
[
node
]
return
rep
,
True
else
:
rep
=
collect_one_node
(
node
)
self
.
_collection_cache
[
node
]
=
rep
return
rep
,
False
[docs]
def
collect
(
self
)
->
Iterator
[
nodes
.
Item
|
nodes
.
Collector
]:
# This is a cache for the root directories of the initial paths.
# We can't use collection_cache for Session because of its special
# role as the bootstrapping collector.
path_cache
:
dict
[
Path
,
Sequence
[
nodes
.
Collector
]]
=
{}
pm
=
self
.
config
.
pluginmanager
for
collection_argument
in
self
.
_initial_parts
:
self
.
trace
(
"processing argument"
,
collection_argument
)
self
.
trace
.
root
.
indent
+=
1
argpath
=
collection_argument
.
path
names
=
collection_argument
.
parts
module_name
=
collection_argument
.
module_name
# resolve_collection_argument() ensures this.
if
argpath
.
is_dir
():
assert
not
names
,
f
"invalid arg
{
(
argpath
,
names
)
!r}
"
paths
=
[
argpath
]
# Add relevant parents of the path, from the root, e.g.
#   /a/b/c.py -> [/, /a, /a/b, /a/b/c.py]
if
module_name
is
None
:
# Paths outside of the confcutdir should not be considered.
for
path
in
argpath
.
parents
:
if
not
pm
.
_is_in_confcutdir
(
path
):
break
paths
.
insert
(
0
,
path
)
else
:
# For --pyargs arguments, only consider paths matching the module
# name. Paths beyond the package hierarchy are not included.
module_name_parts
=
module_name
.
split
(
"."
)
for
i
,
path
in
enumerate
(
argpath
.
parents
,
2
):
if
i
>
len
(
module_name_parts
)
or
path
.
stem
!=
module_name_parts
[
-
i
]:
break
paths
.
insert
(
0
,
path
)
# Start going over the parts from the root, collecting each level
# and discarding all nodes which don't match the level's part.
any_matched_in_initial_part
=
False
notfound_collectors
=
[]
work
:
list
[
tuple
[
nodes
.
Collector
|
nodes
.
Item
,
list
[
Path
|
str
]]]
=
[
(
self
,
[
*
paths
,
*
names
])
]
while
work
:
matchnode
,
matchparts
=
work
.
pop
()
# Pop'd all of the parts, this is a match.
if
not
matchparts
:
yield
matchnode
any_matched_in_initial_part
=
True
continue
# Should have been matched by now, discard.
if
not
isinstance
(
matchnode
,
nodes
.
Collector
):
continue
# Collect this level of matching.
# Collecting Session (self) is done directly to avoid endless
# recursion to this function.
subnodes
:
Sequence
[
nodes
.
Collector
|
nodes
.
Item
]
if
isinstance
(
matchnode
,
Session
):
assert
isinstance
(
matchparts
[
0
],
Path
)
subnodes
=
matchnode
.
_collect_path
(
matchparts
[
0
],
path_cache
)
else
:
# For backward compat, files given directly multiple
# times on the command line should not be deduplicated.
handle_dupes
=
not
(
len
(
matchparts
)
==
1
and
isinstance
(
matchparts
[
0
],
Path
)
and
matchparts
[
0
]
.
is_file
()
)
rep
,
duplicate
=
self
.
_collect_one_node
(
matchnode
,
handle_dupes
)
if
not
duplicate
and
not
rep
.
passed
:
# Report collection failures here to avoid failing to
# run some test specified in the command line because
# the module could not be imported (#134).
matchnode
.
ihook
.
pytest_collectreport
(
report
=
rep
)
if
not
rep
.
passed
:
continue
subnodes
=
rep
.
result
# Prune this level.
any_matched_in_collector
=
False
for
node
in
reversed
(
subnodes
):
# Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.
if
isinstance
(
matchparts
[
0
],
Path
):
is_match
=
node
.
path
==
matchparts
[
0
]
if
sys
.
platform
==
"win32"
and
not
is_match
:
# In case the file paths do not match, fallback to samefile() to
# account for short-paths on Windows (#11895).
same_file
=
os
.
path
.
samefile
(
node
.
path
,
matchparts
[
0
])
# We don't want to match links to the current node,
# otherwise we would match the same file more than once (#12039).
is_match
=
same_file
and
(
os
.
path
.
islink
(
node
.
path
)
==
os
.
path
.
islink
(
matchparts
[
0
])
)
# Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.
else
:
# TODO: Remove parametrized workaround once collection structure contains
# parametrization.
is_match
=
(
node
.
name
==
matchparts
[
0
]
or
node
.
name
.
split
(
"["
)[
0
]
==
matchparts
[
0
]
)
if
is_match
:
work
.
append
((
node
,
matchparts
[
1
:]))
any_matched_in_collector
=
True
if
not
any_matched_in_collector
:
notfound_collectors
.
append
(
matchnode
)
if
not
any_matched_in_initial_part
:
report_arg
=
"::"
.
join
((
str
(
argpath
),
*
names
))
self
.
_notfound
.
append
((
report_arg
,
notfound_collectors
))
self
.
trace
.
root
.
indent
-=
1
def
genitems
(
self
,
node
:
nodes
.
Item
|
nodes
.
Collector
)
->
Iterator
[
nodes
.
Item
]:
self
.
trace
(
"genitems"
,
node
)
if
isinstance
(
node
,
nodes
.
Item
):
node
.
ihook
.
pytest_itemcollected
(
item
=
node
)
yield
node
else
:
assert
isinstance
(
node
,
nodes
.
Collector
)
keepduplicates
=
self
.
config
.
getoption
(
"keepduplicates"
)
# For backward compat, dedup only applies to files.
handle_dupes
=
not
(
keepduplicates
and
isinstance
(
node
,
nodes
.
File
))
rep
,
duplicate
=
self
.
_collect_one_node
(
node
,
handle_dupes
)
if
duplicate
and
not
keepduplicates
:
return
if
rep
.
passed
:
for
subnode
in
rep
.
result
:
yield from
self
.
genitems
(
subnode
)
if
not
duplicate
:
node
.
ihook
.
pytest_collectreport
(
report
=
rep
)
def
search_pypath
(
module_name
:
str
)
->
str
|
None
:
"""Search sys.path for the given a dotted module name, and return its file
system path if found."""
try
:
spec
=
importlib
.
util
.
find_spec
(
module_name
)
# AttributeError: looks like package module, but actually filename
# ImportError: module does not exist
# ValueError: not a module name
except
(
AttributeError
,
ImportError
,
ValueError
):
return
None
if
spec
is
None
or
spec
.
origin
is
None
or
spec
.
origin
==
"namespace"
:
return
None
elif
spec
.
submodule_search_locations
:
return
os
.
path
.
dirname
(
spec
.
origin
)
else
:
return
spec
.
origin
@dataclasses
.
dataclass
(
frozen
=
True
)
class
CollectionArgument
:
"""A resolved collection argument."""
path
:
Path
parts
:
Sequence
[
str
]
module_name
:
str
|
None
def
resolve_collection_argument
(
invocation_path
:
Path
,
arg
:
str
,
*
,
as_pypath
:
bool
=
False
)
->
CollectionArgument
:
"""Parse path arguments optionally containing selection parts and return (fspath, names).
Command-line arguments can point to files and/or directories, and optionally contain
parts for specific tests selection, for example:
"pkg/tests/test_foo.py::TestClass::test_foo"
This function ensures the path exists, and returns a resolved `CollectionArgument`:
CollectionArgument(
path=Path("/full/path/to/pkg/tests/test_foo.py"),
parts=["TestClass", "test_foo"],
module_name=None,
)
When as_pypath is True, expects that the command-line argument actually contains
module paths instead of file-system paths:
"pkg.tests.test_foo::TestClass::test_foo"
In which case we search sys.path for a matching module, and then return the *path* to the
found module, which may look like this:
CollectionArgument(
path=Path("/home/u/myvenv/lib/site-packages/pkg/tests/test_foo.py"),
parts=["TestClass", "test_foo"],
module_name="pkg.tests.test_foo",
)
If the path doesn't exist, raise UsageError.
If the path is a directory and selection parts are present, raise UsageError.
"""
base
,
squacket
,
rest
=
str
(
arg
)
.
partition
(
"["
)
strpath
,
*
parts
=
base
.
split
(
"::"
)
if
parts
:
parts
[
-
1
]
=
f
"
{
parts
[
-
1
]
}{
squacket
}{
rest
}
"
module_name
=
None
if
as_pypath
:
pyarg_strpath
=
search_pypath
(
strpath
)
if
pyarg_strpath
is
not
None
:
module_name
=
strpath
strpath
=
pyarg_strpath
fspath
=
invocation_path
/
strpath
fspath
=
absolutepath
(
fspath
)
if
not
safe_exists
(
fspath
):
msg
=
(
"module or package not found:
{arg}
(missing __init__.py?)"
if
as_pypath
else
"file or directory not found:
{arg}
"
)
raise
UsageError
(
msg
.
format
(
arg
=
arg
))
if
parts
and
fspath
.
is_dir
():
msg
=
(
"package argument cannot contain :: selection parts:
{arg}
"
if
as_pypath
else
"directory argument cannot contain :: selection parts:
{arg}
"
)
raise
UsageError
(
msg
.
format
(
arg
=
arg
))
return
CollectionArgument
(
path
=
fspath
,
parts
=
parts
,
module_name
=
module_name
,
)

```


---


# _pytest.runner - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/runner.html


# Source code for _pytest.runner

```

# mypy: allow-untyped-defs
"""Basic collect and runtest protocol implementations."""
from
__future__
import
annotations
import
bdb
import
dataclasses
import
os
import
sys
import
types
from
typing
import
Callable
from
typing
import
cast
from
typing
import
final
from
typing
import
Generic
from
typing
import
Literal
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
from
.reports
import
BaseReport
from
.reports
import
CollectErrorRepr
from
.reports
import
CollectReport
from
.reports
import
TestReport
from
_pytest
import
timing
from
_pytest._code.code
import
ExceptionChainRepr
from
_pytest._code.code
import
ExceptionInfo
from
_pytest._code.code
import
TerminalRepr
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
Directory
from
_pytest.nodes
import
Item
from
_pytest.nodes
import
Node
from
_pytest.outcomes
import
Exit
from
_pytest.outcomes
import
OutcomeException
from
_pytest.outcomes
import
Skipped
from
_pytest.outcomes
import
TEST_OUTCOME
if
sys
.
version_info
<
(
3
,
11
):
from
exceptiongroup
import
BaseExceptionGroup
if
TYPE_CHECKING
:
from
_pytest.main
import
Session
from
_pytest.terminal
import
TerminalReporter
#
# pytest plugin hooks.
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"terminal reporting"
,
"Reporting"
,
after
=
"general"
)
group
.
addoption
(
"--durations"
,
action
=
"store"
,
type
=
int
,
default
=
None
,
metavar
=
"N"
,
help
=
"Show N slowest setup/test durations (N=0 for all)"
,
)
group
.
addoption
(
"--durations-min"
,
action
=
"store"
,
type
=
float
,
default
=
0.005
,
metavar
=
"N"
,
help
=
"Minimal duration in seconds for inclusion in slowest list. "
"Default: 0.005."
,
)
def
pytest_terminal_summary
(
terminalreporter
:
TerminalReporter
)
->
None
:
durations
=
terminalreporter
.
config
.
option
.
durations
durations_min
=
terminalreporter
.
config
.
option
.
durations_min
verbose
=
terminalreporter
.
config
.
get_verbosity
()
if
durations
is
None
:
return
tr
=
terminalreporter
dlist
=
[]
for
replist
in
tr
.
stats
.
values
():
for
rep
in
replist
:
if
hasattr
(
rep
,
"duration"
):
dlist
.
append
(
rep
)
if
not
dlist
:
return
dlist
.
sort
(
key
=
lambda
x
:
x
.
duration
,
reverse
=
True
)
if
not
durations
:
tr
.
write_sep
(
"="
,
"slowest durations"
)
else
:
tr
.
write_sep
(
"="
,
f
"slowest
{
durations
}
durations"
)
dlist
=
dlist
[:
durations
]
for
i
,
rep
in
enumerate
(
dlist
):
if
verbose
<
2
and
rep
.
duration
<
durations_min
:
tr
.
write_line
(
""
)
tr
.
write_line
(
f
"(
{
len
(
dlist
)
-
i
}
durations <
{
durations_min
:
g
}
s hidden.  Use -vv to show these durations.)"
)
break
tr
.
write_line
(
f
"
{
rep
.
duration
:
02.2f
}
s
{
rep
.
when
:
<8
}
{
rep
.
nodeid
}
"
)
def
pytest_sessionstart
(
session
:
Session
)
->
None
:
session
.
_setupstate
=
SetupState
()
def
pytest_sessionfinish
(
session
:
Session
)
->
None
:
session
.
_setupstate
.
teardown_exact
(
None
)
def
pytest_runtest_protocol
(
item
:
Item
,
nextitem
:
Item
|
None
)
->
bool
:
ihook
=
item
.
ihook
ihook
.
pytest_runtest_logstart
(
nodeid
=
item
.
nodeid
,
location
=
item
.
location
)
runtestprotocol
(
item
,
nextitem
=
nextitem
)
ihook
.
pytest_runtest_logfinish
(
nodeid
=
item
.
nodeid
,
location
=
item
.
location
)
return
True
def
runtestprotocol
(
item
:
Item
,
log
:
bool
=
True
,
nextitem
:
Item
|
None
=
None
)
->
list
[
TestReport
]:
hasrequest
=
hasattr
(
item
,
"_request"
)
if
hasrequest
and
not
item
.
_request
:
# type: ignore[attr-defined]
# This only happens if the item is re-run, as is done by
# pytest-rerunfailures.
item
.
_initrequest
()
# type: ignore[attr-defined]
rep
=
call_and_report
(
item
,
"setup"
,
log
)
reports
=
[
rep
]
if
rep
.
passed
:
if
item
.
config
.
getoption
(
"setupshow"
,
False
):
show_test_item
(
item
)
if
not
item
.
config
.
getoption
(
"setuponly"
,
False
):
reports
.
append
(
call_and_report
(
item
,
"call"
,
log
))
# If the session is about to fail or stop, teardown everything - this is
# necessary to correctly report fixture teardown errors (see #11706)
if
item
.
session
.
shouldfail
or
item
.
session
.
shouldstop
:
nextitem
=
None
reports
.
append
(
call_and_report
(
item
,
"teardown"
,
log
,
nextitem
=
nextitem
))
# After all teardown hooks have been called
# want funcargs and request info to go away.
if
hasrequest
:
item
.
_request
=
False
# type: ignore[attr-defined]
item
.
funcargs
=
None
# type: ignore[attr-defined]
return
reports
def
show_test_item
(
item
:
Item
)
->
None
:
"""Show test function, parameters and the fixtures of the test item."""
tw
=
item
.
config
.
get_terminal_writer
()
tw
.
line
()
tw
.
write
(
" "
*
8
)
tw
.
write
(
item
.
nodeid
)
used_fixtures
=
sorted
(
getattr
(
item
,
"fixturenames"
,
[]))
if
used_fixtures
:
tw
.
write
(
" (fixtures used:
{}
)"
.
format
(
", "
.
join
(
used_fixtures
)))
tw
.
flush
()
def
pytest_runtest_setup
(
item
:
Item
)
->
None
:
_update_current_test_var
(
item
,
"setup"
)
item
.
session
.
_setupstate
.
setup
(
item
)
def
pytest_runtest_call
(
item
:
Item
)
->
None
:
_update_current_test_var
(
item
,
"call"
)
try
:
del
sys
.
last_type
del
sys
.
last_value
del
sys
.
last_traceback
if
sys
.
version_info
>=
(
3
,
12
,
0
):
del
sys
.
last_exc
# type:ignore[attr-defined]
except
AttributeError
:
pass
try
:
item
.
runtest
()
except
Exception
as
e
:
# Store trace info to allow postmortem debugging
sys
.
last_type
=
type
(
e
)
sys
.
last_value
=
e
if
sys
.
version_info
>=
(
3
,
12
,
0
):
sys
.
last_exc
=
e
# type:ignore[attr-defined]
assert
e
.
__traceback__
is
not
None
# Skip *this* frame
sys
.
last_traceback
=
e
.
__traceback__
.
tb_next
raise
def
pytest_runtest_teardown
(
item
:
Item
,
nextitem
:
Item
|
None
)
->
None
:
_update_current_test_var
(
item
,
"teardown"
)
item
.
session
.
_setupstate
.
teardown_exact
(
nextitem
)
_update_current_test_var
(
item
,
None
)
def
_update_current_test_var
(
item
:
Item
,
when
:
Literal
[
"setup"
,
"call"
,
"teardown"
]
|
None
)
->
None
:
"""Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
"""
var_name
=
"PYTEST_CURRENT_TEST"
if
when
:
value
=
f
"
{
item
.
nodeid
}
(
{
when
}
)"
# don't allow null bytes on environment variables (see #2644, #2957)
value
=
value
.
replace
(
"
\x00
"
,
"(null)"
)
os
.
environ
[
var_name
]
=
value
else
:
os
.
environ
.
pop
(
var_name
)
def
pytest_report_teststatus
(
report
:
BaseReport
)
->
tuple
[
str
,
str
,
str
]
|
None
:
if
report
.
when
in
(
"setup"
,
"teardown"
):
if
report
.
failed
:
#      category, shortletter, verbose-word
return
"error"
,
"E"
,
"ERROR"
elif
report
.
skipped
:
return
"skipped"
,
"s"
,
"SKIPPED"
else
:
return
""
,
""
,
""
return
None
#
# Implementation
def
call_and_report
(
item
:
Item
,
when
:
Literal
[
"setup"
,
"call"
,
"teardown"
],
log
:
bool
=
True
,
**
kwds
)
->
TestReport
:
ihook
=
item
.
ihook
if
when
==
"setup"
:
runtest_hook
:
Callable
[
...
,
None
]
=
ihook
.
pytest_runtest_setup
elif
when
==
"call"
:
runtest_hook
=
ihook
.
pytest_runtest_call
elif
when
==
"teardown"
:
runtest_hook
=
ihook
.
pytest_runtest_teardown
else
:
assert
False
,
f
"Unhandled runtest hook case:
{
when
}
"
reraise
:
tuple
[
type
[
BaseException
],
...
]
=
(
Exit
,)
if
not
item
.
config
.
getoption
(
"usepdb"
,
False
):
reraise
+=
(
KeyboardInterrupt
,)
call
=
CallInfo
.
from_call
(
lambda
:
runtest_hook
(
item
=
item
,
**
kwds
),
when
=
when
,
reraise
=
reraise
)
report
:
TestReport
=
ihook
.
pytest_runtest_makereport
(
item
=
item
,
call
=
call
)
if
log
:
ihook
.
pytest_runtest_logreport
(
report
=
report
)
if
check_interactive_exception
(
call
,
report
):
ihook
.
pytest_exception_interact
(
node
=
item
,
call
=
call
,
report
=
report
)
return
report
def
check_interactive_exception
(
call
:
CallInfo
[
object
],
report
:
BaseReport
)
->
bool
:
"""Check whether the call raised an exception that should be reported as
interactive."""
if
call
.
excinfo
is
None
:
# Didn't raise.
return
False
if
hasattr
(
report
,
"wasxfail"
):
# Exception was expected.
return
False
if
isinstance
(
call
.
excinfo
.
value
,
(
Skipped
,
bdb
.
BdbQuit
)):
# Special control flow exception.
return
False
return
True
TResult
=
TypeVar
(
"TResult"
,
covariant
=
True
)
[docs]
@final
@dataclasses
.
dataclass
class
CallInfo
(
Generic
[
TResult
]):
"""Result/Exception info of a function invocation."""
_result
:
TResult
|
None
#: The captured exception of the call, if it raised.
excinfo
:
ExceptionInfo
[
BaseException
]
|
None
#: The system time when the call started, in seconds since the epoch.
start
:
float
#: The system time when the call ended, in seconds since the epoch.
stop
:
float
#: The call duration, in seconds.
duration
:
float
#: The context of invocation: "collect", "setup", "call" or "teardown".
when
:
Literal
[
"collect"
,
"setup"
,
"call"
,
"teardown"
]
def
__init__
(
self
,
result
:
TResult
|
None
,
excinfo
:
ExceptionInfo
[
BaseException
]
|
None
,
start
:
float
,
stop
:
float
,
duration
:
float
,
when
:
Literal
[
"collect"
,
"setup"
,
"call"
,
"teardown"
],
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_result
=
result
self
.
excinfo
=
excinfo
self
.
start
=
start
self
.
stop
=
stop
self
.
duration
=
duration
self
.
when
=
when
@property
def
result
(
self
)
->
TResult
:
"""The return value of the call, if it didn't raise.
Can only be accessed if excinfo is None.
"""
if
self
.
excinfo
is
not
None
:
raise
AttributeError
(
f
"
{
self
!r}
has no valid result"
)
# The cast is safe because an exception wasn't raised, hence
# _result has the expected function return type (which may be
#  None, that's why a cast and not an assert).
return
cast
(
TResult
,
self
.
_result
)
[docs]
@classmethod
def
from_call
(
cls
,
func
:
Callable
[[],
TResult
],
when
:
Literal
[
"collect"
,
"setup"
,
"call"
,
"teardown"
],
reraise
:
type
[
BaseException
]
|
tuple
[
type
[
BaseException
],
...
]
|
None
=
None
,
)
->
CallInfo
[
TResult
]:
"""Call func, wrapping the result in a CallInfo.
:param func:
The function to call. Called without arguments.
:type func: Callable[[], _pytest.runner.TResult]
:param when:
The phase in which the function is called.
:param reraise:
Exception or exceptions that shall propagate if raised by the
function, instead of being wrapped in the CallInfo.
"""
excinfo
=
None
start
=
timing
.
time
()
precise_start
=
timing
.
perf_counter
()
try
:
result
:
TResult
|
None
=
func
()
except
BaseException
:
excinfo
=
ExceptionInfo
.
from_current
()
if
reraise
is
not
None
and
isinstance
(
excinfo
.
value
,
reraise
):
raise
result
=
None
# use the perf counter
precise_stop
=
timing
.
perf_counter
()
duration
=
precise_stop
-
precise_start
stop
=
timing
.
time
()
return
cls
(
start
=
start
,
stop
=
stop
,
duration
=
duration
,
when
=
when
,
result
=
result
,
excinfo
=
excinfo
,
_ispytest
=
True
,
)
def
__repr__
(
self
)
->
str
:
if
self
.
excinfo
is
None
:
return
f
"<CallInfo when=
{
self
.
when
!r}
result:
{
self
.
_result
!r}
>"
return
f
"<CallInfo when=
{
self
.
when
!r}
excinfo=
{
self
.
excinfo
!r}
>"
def
pytest_runtest_makereport
(
item
:
Item
,
call
:
CallInfo
[
None
])
->
TestReport
:
return
TestReport
.
from_item_and_call
(
item
,
call
)
def
pytest_make_collect_report
(
collector
:
Collector
)
->
CollectReport
:
def
collect
()
->
list
[
Item
|
Collector
]:
# Before collecting, if this is a Directory, load the conftests.
# If a conftest import fails to load, it is considered a collection
# error of the Directory collector. This is why it's done inside of the
# CallInfo wrapper.
#
# Note: initial conftests are loaded early, not here.
if
isinstance
(
collector
,
Directory
):
collector
.
config
.
pluginmanager
.
_loadconftestmodules
(
collector
.
path
,
collector
.
config
.
getoption
(
"importmode"
),
rootpath
=
collector
.
config
.
rootpath
,
consider_namespace_packages
=
collector
.
config
.
getini
(
"consider_namespace_packages"
),
)
return
list
(
collector
.
collect
())
call
=
CallInfo
.
from_call
(
collect
,
"collect"
,
reraise
=
(
KeyboardInterrupt
,
SystemExit
)
)
longrepr
:
None
|
tuple
[
str
,
int
,
str
]
|
str
|
TerminalRepr
=
None
if
not
call
.
excinfo
:
outcome
:
Literal
[
"passed"
,
"skipped"
,
"failed"
]
=
"passed"
else
:
skip_exceptions
=
[
Skipped
]
unittest
=
sys
.
modules
.
get
(
"unittest"
)
if
unittest
is
not
None
:
skip_exceptions
.
append
(
unittest
.
SkipTest
)
if
isinstance
(
call
.
excinfo
.
value
,
tuple
(
skip_exceptions
)):
outcome
=
"skipped"
r_
=
collector
.
_repr_failure_py
(
call
.
excinfo
,
"line"
)
assert
isinstance
(
r_
,
ExceptionChainRepr
),
repr
(
r_
)
r
=
r_
.
reprcrash
assert
r
longrepr
=
(
str
(
r
.
path
),
r
.
lineno
,
r
.
message
)
else
:
outcome
=
"failed"
errorinfo
=
collector
.
repr_failure
(
call
.
excinfo
)
if
not
hasattr
(
errorinfo
,
"toterminal"
):
assert
isinstance
(
errorinfo
,
str
)
errorinfo
=
CollectErrorRepr
(
errorinfo
)
longrepr
=
errorinfo
result
=
call
.
result
if
not
call
.
excinfo
else
None
rep
=
CollectReport
(
collector
.
nodeid
,
outcome
,
longrepr
,
result
)
rep
.
call
=
call
# type: ignore # see collect_one_node
return
rep
class
SetupState
:
"""Shared state for setting up/tearing down test items or collectors
in a session.
Suppose we have a collection tree as follows:
<Session session>
<Module mod1>
<Function item1>
<Module mod2>
<Function item2>
The SetupState maintains a stack. The stack starts out empty:
[]
During the setup phase of item1, setup(item1) is called. What it does
is:
push session to stack, run session.setup()
push mod1 to stack, run mod1.setup()
push item1 to stack, run item1.setup()
The stack is:
[session, mod1, item1]
While the stack is in this shape, it is allowed to add finalizers to
each of session, mod1, item1 using addfinalizer().
During the teardown phase of item1, teardown_exact(item2) is called,
where item2 is the next item to item1. What it does is:
pop item1 from stack, run its teardowns
pop mod1 from stack, run its teardowns
mod1 was popped because it ended its purpose with item1. The stack is:
[session]
During the setup phase of item2, setup(item2) is called. What it does
is:
push mod2 to stack, run mod2.setup()
push item2 to stack, run item2.setup()
Stack:
[session, mod2, item2]
During the teardown phase of item2, teardown_exact(None) is called,
because item2 is the last item. What it does is:
pop item2 from stack, run its teardowns
pop mod2 from stack, run its teardowns
pop session from stack, run its teardowns
Stack:
[]
The end!
"""
def
__init__
(
self
)
->
None
:
# The stack is in the dict insertion order.
self
.
stack
:
dict
[
Node
,
tuple
[
# Node's finalizers.
list
[
Callable
[[],
object
]],
# Node's exception and original traceback, if its setup raised.
tuple
[
OutcomeException
|
Exception
,
types
.
TracebackType
|
None
]
|
None
,
],
]
=
{}
def
setup
(
self
,
item
:
Item
)
->
None
:
"""Setup objects along the collector chain to the item."""
needed_collectors
=
item
.
listchain
()
# If a collector fails its setup, fail its entire subtree of items.
# The setup is not retried for each item - the same exception is used.
for
col
,
(
finalizers
,
exc
)
in
self
.
stack
.
items
():
assert
col
in
needed_collectors
,
"previous item was not torn down properly"
if
exc
:
raise
exc
[
0
]
.
with_traceback
(
exc
[
1
])
for
col
in
needed_collectors
[
len
(
self
.
stack
)
:]:
assert
col
not
in
self
.
stack
# Push onto the stack.
self
.
stack
[
col
]
=
([
col
.
teardown
],
None
)
try
:
col
.
setup
()
except
TEST_OUTCOME
as
exc
:
self
.
stack
[
col
]
=
(
self
.
stack
[
col
][
0
],
(
exc
,
exc
.
__traceback__
))
raise
def
addfinalizer
(
self
,
finalizer
:
Callable
[[],
object
],
node
:
Node
)
->
None
:
"""Attach a finalizer to the given node.
The node must be currently active in the stack.
"""
assert
node
and
not
isinstance
(
node
,
tuple
)
assert
callable
(
finalizer
)
assert
node
in
self
.
stack
,
(
node
,
self
.
stack
)
self
.
stack
[
node
][
0
]
.
append
(
finalizer
)
def
teardown_exact
(
self
,
nextitem
:
Item
|
None
)
->
None
:
"""Teardown the current stack up until reaching nodes that nextitem
also descends from.
When nextitem is None (meaning we're at the last item), the entire
stack is torn down.
"""
needed_collectors
=
nextitem
and
nextitem
.
listchain
()
or
[]
exceptions
:
list
[
BaseException
]
=
[]
while
self
.
stack
:
if
list
(
self
.
stack
.
keys
())
==
needed_collectors
[:
len
(
self
.
stack
)]:
break
node
,
(
finalizers
,
_
)
=
self
.
stack
.
popitem
()
these_exceptions
=
[]
while
finalizers
:
fin
=
finalizers
.
pop
()
try
:
fin
()
except
TEST_OUTCOME
as
e
:
these_exceptions
.
append
(
e
)
if
len
(
these_exceptions
)
==
1
:
exceptions
.
extend
(
these_exceptions
)
elif
these_exceptions
:
msg
=
f
"errors while tearing down
{
node
!r}
"
exceptions
.
append
(
BaseExceptionGroup
(
msg
,
these_exceptions
[::
-
1
]))
if
len
(
exceptions
)
==
1
:
raise
exceptions
[
0
]
elif
exceptions
:
raise
BaseExceptionGroup
(
"errors during test teardown"
,
exceptions
[::
-
1
])
if
nextitem
is
None
:
assert
not
self
.
stack
def
collect_one_node
(
collector
:
Collector
)
->
CollectReport
:
ihook
=
collector
.
ihook
ihook
.
pytest_collectstart
(
collector
=
collector
)
rep
:
CollectReport
=
ihook
.
pytest_make_collect_report
(
collector
=
collector
)
call
=
rep
.
__dict__
.
pop
(
"call"
,
None
)
if
call
and
check_interactive_exception
(
call
,
rep
):
ihook
.
pytest_exception_interact
(
node
=
collector
,
call
=
call
,
report
=
rep
)
return
rep

```


---


# _pytest._code.code - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/_code/code.html


# Source code for _pytest._code.code

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
import
ast
import
dataclasses
import
inspect
from
inspect
import
CO_VARARGS
from
inspect
import
CO_VARKEYWORDS
from
io
import
StringIO
import
os
from
pathlib
import
Path
import
re
import
sys
import
traceback
from
traceback
import
format_exception_only
from
types
import
CodeType
from
types
import
FrameType
from
types
import
TracebackType
from
typing
import
Any
from
typing
import
Callable
from
typing
import
ClassVar
from
typing
import
Final
from
typing
import
final
from
typing
import
Generic
from
typing
import
Iterable
from
typing
import
List
from
typing
import
Literal
from
typing
import
Mapping
from
typing
import
overload
from
typing
import
Pattern
from
typing
import
Sequence
from
typing
import
SupportsIndex
from
typing
import
Tuple
from
typing
import
Type
from
typing
import
TypeVar
from
typing
import
Union
import
pluggy
import
_pytest
from
_pytest._code.source
import
findsource
from
_pytest._code.source
import
getrawcode
from
_pytest._code.source
import
getstatementrange_ast
from
_pytest._code.source
import
Source
from
_pytest._io
import
TerminalWriter
from
_pytest._io.saferepr
import
safeformat
from
_pytest._io.saferepr
import
saferepr
from
_pytest.compat
import
get_real_func
from
_pytest.deprecated
import
check_ispytest
from
_pytest.pathlib
import
absolutepath
from
_pytest.pathlib
import
bestrelpath
if
sys
.
version_info
<
(
3
,
11
):
from
exceptiongroup
import
BaseExceptionGroup
TracebackStyle
=
Literal
[
"long"
,
"short"
,
"line"
,
"no"
,
"native"
,
"value"
,
"auto"
]
EXCEPTION_OR_MORE
=
Union
[
Type
[
BaseException
],
Tuple
[
Type
[
BaseException
],
...
]]
class
Code
:
"""Wrapper around Python code objects."""
__slots__
=
(
"raw"
,)
def
__init__
(
self
,
obj
:
CodeType
)
->
None
:
self
.
raw
=
obj
@classmethod
def
from_function
(
cls
,
obj
:
object
)
->
Code
:
return
cls
(
getrawcode
(
obj
))
def
__eq__
(
self
,
other
):
return
self
.
raw
==
other
.
raw
# Ignore type because of https://github.com/python/mypy/issues/4266.
__hash__
=
None
# type: ignore
@property
def
firstlineno
(
self
)
->
int
:
return
self
.
raw
.
co_firstlineno
-
1
@property
def
name
(
self
)
->
str
:
return
self
.
raw
.
co_name
@property
def
path
(
self
)
->
Path
|
str
:
"""Return a path object pointing to source code, or an ``str`` in
case of ``OSError`` / non-existing file."""
if
not
self
.
raw
.
co_filename
:
return
""
try
:
p
=
absolutepath
(
self
.
raw
.
co_filename
)
# maybe don't try this checking
if
not
p
.
exists
():
raise
OSError
(
"path check failed."
)
return
p
except
OSError
:
# XXX maybe try harder like the weird logic
# in the standard lib [linecache.updatecache] does?
return
self
.
raw
.
co_filename
@property
def
fullsource
(
self
)
->
Source
|
None
:
"""Return a _pytest._code.Source object for the full source file of the code."""
full
,
_
=
findsource
(
self
.
raw
)
return
full
def
source
(
self
)
->
Source
:
"""Return a _pytest._code.Source object for the code object's source only."""
# return source only for that part of code
return
Source
(
self
.
raw
)
def
getargs
(
self
,
var
:
bool
=
False
)
->
tuple
[
str
,
...
]:
"""Return a tuple with the argument names for the code object.
If 'var' is set True also return the names of the variable and
keyword arguments when present.
"""
# Handy shortcut for getting args.
raw
=
self
.
raw
argcount
=
raw
.
co_argcount
if
var
:
argcount
+=
raw
.
co_flags
&
CO_VARARGS
argcount
+=
raw
.
co_flags
&
CO_VARKEYWORDS
return
raw
.
co_varnames
[:
argcount
]
class
Frame
:
"""Wrapper around a Python frame holding f_locals and f_globals
in which expressions can be evaluated."""
__slots__
=
(
"raw"
,)
def
__init__
(
self
,
frame
:
FrameType
)
->
None
:
self
.
raw
=
frame
@property
def
lineno
(
self
)
->
int
:
return
self
.
raw
.
f_lineno
-
1
@property
def
f_globals
(
self
)
->
dict
[
str
,
Any
]:
return
self
.
raw
.
f_globals
@property
def
f_locals
(
self
)
->
dict
[
str
,
Any
]:
return
self
.
raw
.
f_locals
@property
def
code
(
self
)
->
Code
:
return
Code
(
self
.
raw
.
f_code
)
@property
def
statement
(
self
)
->
Source
:
"""Statement this frame is at."""
if
self
.
code
.
fullsource
is
None
:
return
Source
(
""
)
return
self
.
code
.
fullsource
.
getstatement
(
self
.
lineno
)
def
eval
(
self
,
code
,
**
vars
):
"""Evaluate 'code' in the frame.
'vars' are optional additional local variables.
Returns the result of the evaluation.
"""
f_locals
=
self
.
f_locals
.
copy
()
f_locals
.
update
(
vars
)
return
eval
(
code
,
self
.
f_globals
,
f_locals
)
def
repr
(
self
,
object
:
object
)
->
str
:
"""Return a 'safe' (non-recursive, one-line) string repr for 'object'."""
return
saferepr
(
object
)
def
getargs
(
self
,
var
:
bool
=
False
):
"""Return a list of tuples (name, value) for all arguments.
If 'var' is set True, also include the variable and keyword arguments
when present.
"""
retval
=
[]
for
arg
in
self
.
code
.
getargs
(
var
):
try
:
retval
.
append
((
arg
,
self
.
f_locals
[
arg
]))
except
KeyError
:
pass
# this can occur when using Psyco
return
retval
class
TracebackEntry
:
"""A single entry in a Traceback."""
__slots__
=
(
"_rawentry"
,
"_repr_style"
)
def
__init__
(
self
,
rawentry
:
TracebackType
,
repr_style
:
Literal
[
"short"
,
"long"
]
|
None
=
None
,
)
->
None
:
self
.
_rawentry
:
Final
=
rawentry
self
.
_repr_style
:
Final
=
repr_style
def
with_repr_style
(
self
,
repr_style
:
Literal
[
"short"
,
"long"
]
|
None
)
->
TracebackEntry
:
return
TracebackEntry
(
self
.
_rawentry
,
repr_style
)
@property
def
lineno
(
self
)
->
int
:
return
self
.
_rawentry
.
tb_lineno
-
1
@property
def
frame
(
self
)
->
Frame
:
return
Frame
(
self
.
_rawentry
.
tb_frame
)
@property
def
relline
(
self
)
->
int
:
return
self
.
lineno
-
self
.
frame
.
code
.
firstlineno
def
__repr__
(
self
)
->
str
:
return
"<TracebackEntry
%s
:
%d
>"
%
(
self
.
frame
.
code
.
path
,
self
.
lineno
+
1
)
@property
def
statement
(
self
)
->
Source
:
"""_pytest._code.Source object for the current statement."""
source
=
self
.
frame
.
code
.
fullsource
assert
source
is
not
None
return
source
.
getstatement
(
self
.
lineno
)
@property
def
path
(
self
)
->
Path
|
str
:
"""Path to the source code."""
return
self
.
frame
.
code
.
path
@property
def
locals
(
self
)
->
dict
[
str
,
Any
]:
"""Locals of underlying frame."""
return
self
.
frame
.
f_locals
def
getfirstlinesource
(
self
)
->
int
:
return
self
.
frame
.
code
.
firstlineno
def
getsource
(
self
,
astcache
:
dict
[
str
|
Path
,
ast
.
AST
]
|
None
=
None
)
->
Source
|
None
:
"""Return failing source code."""
# we use the passed in astcache to not reparse asttrees
# within exception info printing
source
=
self
.
frame
.
code
.
fullsource
if
source
is
None
:
return
None
key
=
astnode
=
None
if
astcache
is
not
None
:
key
=
self
.
frame
.
code
.
path
if
key
is
not
None
:
astnode
=
astcache
.
get
(
key
,
None
)
start
=
self
.
getfirstlinesource
()
try
:
astnode
,
_
,
end
=
getstatementrange_ast
(
self
.
lineno
,
source
,
astnode
=
astnode
)
except
SyntaxError
:
end
=
self
.
lineno
+
1
else
:
if
key
is
not
None
and
astcache
is
not
None
:
astcache
[
key
]
=
astnode
return
source
[
start
:
end
]
source
=
property
(
getsource
)
def
ishidden
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
]
|
None
)
->
bool
:
"""Return True if the current frame has a var __tracebackhide__
resolving to True.
If __tracebackhide__ is a callable, it gets called with the
ExceptionInfo instance and can decide whether to hide the traceback.
Mostly for internal use.
"""
tbh
:
bool
|
Callable
[[
ExceptionInfo
[
BaseException
]
|
None
],
bool
]
=
False
for
maybe_ns_dct
in
(
self
.
frame
.
f_locals
,
self
.
frame
.
f_globals
):
# in normal cases, f_locals and f_globals are dictionaries
# however via `exec(...)` / `eval(...)` they can be other types
# (even incorrect types!).
# as such, we suppress all exceptions while accessing __tracebackhide__
try
:
tbh
=
maybe_ns_dct
[
"__tracebackhide__"
]
except
Exception
:
pass
else
:
break
if
tbh
and
callable
(
tbh
):
return
tbh
(
excinfo
)
return
tbh
def
__str__
(
self
)
->
str
:
name
=
self
.
frame
.
code
.
name
try
:
line
=
str
(
self
.
statement
)
.
lstrip
()
except
KeyboardInterrupt
:
raise
except
BaseException
:
line
=
"???"
# This output does not quite match Python's repr for traceback entries,
# but changing it to do so would break certain plugins.  See
# https://github.com/pytest-dev/pytest/pull/7535/ for details.
return
"  File
%r
:
%d
in
%s
\n
%s
\n
"
%
(
str
(
self
.
path
),
self
.
lineno
+
1
,
name
,
line
,
)
@property
def
name
(
self
)
->
str
:
"""co_name of underlying code."""
return
self
.
frame
.
code
.
raw
.
co_name
class
Traceback
(
List
[
TracebackEntry
]):
"""Traceback objects encapsulate and offer higher level access to Traceback entries."""
def
__init__
(
self
,
tb
:
TracebackType
|
Iterable
[
TracebackEntry
],
)
->
None
:
"""Initialize from given python traceback object and ExceptionInfo."""
if
isinstance
(
tb
,
TracebackType
):
def
f
(
cur
:
TracebackType
)
->
Iterable
[
TracebackEntry
]:
cur_
:
TracebackType
|
None
=
cur
while
cur_
is
not
None
:
yield
TracebackEntry
(
cur_
)
cur_
=
cur_
.
tb_next
super
()
.
__init__
(
f
(
tb
))
else
:
super
()
.
__init__
(
tb
)
def
cut
(
self
,
path
:
os
.
PathLike
[
str
]
|
str
|
None
=
None
,
lineno
:
int
|
None
=
None
,
firstlineno
:
int
|
None
=
None
,
excludepath
:
os
.
PathLike
[
str
]
|
None
=
None
,
)
->
Traceback
:
"""Return a Traceback instance wrapping part of this Traceback.
By providing any combination of path, lineno and firstlineno, the
first frame to start the to-be-returned traceback is determined.
This allows cutting the first part of a Traceback instance e.g.
for formatting reasons (removing some uninteresting bits that deal
with handling of the exception/traceback).
"""
path_
=
None
if
path
is
None
else
os
.
fspath
(
path
)
excludepath_
=
None
if
excludepath
is
None
else
os
.
fspath
(
excludepath
)
for
x
in
self
:
code
=
x
.
frame
.
code
codepath
=
code
.
path
if
path
is
not
None
and
str
(
codepath
)
!=
path_
:
continue
if
(
excludepath
is
not
None
and
isinstance
(
codepath
,
Path
)
and
excludepath_
in
(
str
(
p
)
for
p
in
codepath
.
parents
)
# type: ignore[operator]
):
continue
if
lineno
is
not
None
and
x
.
lineno
!=
lineno
:
continue
if
firstlineno
is
not
None
and
x
.
frame
.
code
.
firstlineno
!=
firstlineno
:
continue
return
Traceback
(
x
.
_rawentry
)
return
self
@overload
def
__getitem__
(
self
,
key
:
SupportsIndex
)
->
TracebackEntry
:
...
@overload
def
__getitem__
(
self
,
key
:
slice
)
->
Traceback
:
...
def
__getitem__
(
self
,
key
:
SupportsIndex
|
slice
)
->
TracebackEntry
|
Traceback
:
if
isinstance
(
key
,
slice
):
return
self
.
__class__
(
super
()
.
__getitem__
(
key
))
else
:
return
super
()
.
__getitem__
(
key
)
def
filter
(
self
,
excinfo_or_fn
:
ExceptionInfo
[
BaseException
]
|
Callable
[[
TracebackEntry
],
bool
],
/
,
)
->
Traceback
:
"""Return a Traceback instance with certain items removed.
If the filter is an `ExceptionInfo`, removes all the ``TracebackEntry``s
which are hidden (see ishidden() above).
Otherwise, the filter is a function that gets a single argument, a
``TracebackEntry`` instance, and should return True when the item should
be added to the ``Traceback``, False when not.
"""
if
isinstance
(
excinfo_or_fn
,
ExceptionInfo
):
fn
=
lambda
x
:
not
x
.
ishidden
(
excinfo_or_fn
)
# noqa: E731
else
:
fn
=
excinfo_or_fn
return
Traceback
(
filter
(
fn
,
self
))
def
recursionindex
(
self
)
->
int
|
None
:
"""Return the index of the frame/TracebackEntry where recursion originates if
appropriate, None if no recursion occurred."""
cache
:
dict
[
tuple
[
Any
,
int
,
int
],
list
[
dict
[
str
,
Any
]]]
=
{}
for
i
,
entry
in
enumerate
(
self
):
# id for the code.raw is needed to work around
# the strange metaprogramming in the decorator lib from pypi
# which generates code objects that have hash/value equality
# XXX needs a test
key
=
entry
.
frame
.
code
.
path
,
id
(
entry
.
frame
.
code
.
raw
),
entry
.
lineno
values
=
cache
.
setdefault
(
key
,
[])
# Since Python 3.13 f_locals is a proxy, freeze it.
loc
=
dict
(
entry
.
frame
.
f_locals
)
if
values
:
for
otherloc
in
values
:
if
otherloc
==
loc
:
return
i
values
.
append
(
loc
)
return
None
E
=
TypeVar
(
"E"
,
bound
=
BaseException
,
covariant
=
True
)
[docs]
@final
@dataclasses
.
dataclass
class
ExceptionInfo
(
Generic
[
E
]):
"""Wraps sys.exc_info() objects and offers help for navigating the traceback."""
_assert_start_repr
:
ClassVar
=
"AssertionError('assert "
_excinfo
:
tuple
[
type
[
E
],
E
,
TracebackType
]
|
None
_striptext
:
str
_traceback
:
Traceback
|
None
def
__init__
(
self
,
excinfo
:
tuple
[
type
[
E
],
E
,
TracebackType
]
|
None
,
striptext
:
str
=
""
,
traceback
:
Traceback
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_excinfo
=
excinfo
self
.
_striptext
=
striptext
self
.
_traceback
=
traceback
[docs]
@classmethod
def
from_exception
(
cls
,
# Ignoring error: "Cannot use a covariant type variable as a parameter".
# This is OK to ignore because this class is (conceptually) readonly.
# See https://github.com/python/mypy/issues/7049.
exception
:
E
,
# type: ignore[misc]
exprinfo
:
str
|
None
=
None
,
)
->
ExceptionInfo
[
E
]:
"""Return an ExceptionInfo for an existing exception.
The exception must have a non-``None`` ``__traceback__`` attribute,
otherwise this function fails with an assertion error. This means that
the exception must have been raised, or added a traceback with the
:py:meth:`~BaseException.with_traceback()` method.
:param exprinfo:
A text string helping to determine if we should strip
``AssertionError`` from the output. Defaults to the exception
message/``__str__()``.
.. versionadded:: 7.4
"""
assert
exception
.
__traceback__
,
(
"Exceptions passed to ExcInfo.from_exception(...)"
" must have a non-None __traceback__."
)
exc_info
=
(
type
(
exception
),
exception
,
exception
.
__traceback__
)
return
cls
.
from_exc_info
(
exc_info
,
exprinfo
)
[docs]
@classmethod
def
from_exc_info
(
cls
,
exc_info
:
tuple
[
type
[
E
],
E
,
TracebackType
],
exprinfo
:
str
|
None
=
None
,
)
->
ExceptionInfo
[
E
]:
"""Like :func:`from_exception`, but using old-style exc_info tuple."""
_striptext
=
""
if
exprinfo
is
None
and
isinstance
(
exc_info
[
1
],
AssertionError
):
exprinfo
=
getattr
(
exc_info
[
1
],
"msg"
,
None
)
if
exprinfo
is
None
:
exprinfo
=
saferepr
(
exc_info
[
1
])
if
exprinfo
and
exprinfo
.
startswith
(
cls
.
_assert_start_repr
):
_striptext
=
"AssertionError: "
return
cls
(
exc_info
,
_striptext
,
_ispytest
=
True
)
[docs]
@classmethod
def
from_current
(
cls
,
exprinfo
:
str
|
None
=
None
)
->
ExceptionInfo
[
BaseException
]:
"""Return an ExceptionInfo matching the current traceback.
.. warning::
Experimental API
:param exprinfo:
A text string helping to determine if we should strip
``AssertionError`` from the output. Defaults to the exception
message/``__str__()``.
"""
tup
=
sys
.
exc_info
()
assert
tup
[
0
]
is
not
None
,
"no current exception"
assert
tup
[
1
]
is
not
None
,
"no current exception"
assert
tup
[
2
]
is
not
None
,
"no current exception"
exc_info
=
(
tup
[
0
],
tup
[
1
],
tup
[
2
])
return
ExceptionInfo
.
from_exc_info
(
exc_info
,
exprinfo
)
[docs]
@classmethod
def
for_later
(
cls
)
->
ExceptionInfo
[
E
]:
"""Return an unfilled ExceptionInfo."""
return
cls
(
None
,
_ispytest
=
True
)
[docs]
def
fill_unfilled
(
self
,
exc_info
:
tuple
[
type
[
E
],
E
,
TracebackType
])
->
None
:
"""Fill an unfilled ExceptionInfo created with ``for_later()``."""
assert
self
.
_excinfo
is
None
,
"ExceptionInfo was already filled"
self
.
_excinfo
=
exc_info
@property
def
type
(
self
)
->
type
[
E
]:
"""The exception class."""
assert
(
self
.
_excinfo
is
not
None
),
".type can only be used after the context manager exits"
return
self
.
_excinfo
[
0
]
@property
def
value
(
self
)
->
E
:
"""The exception value."""
assert
(
self
.
_excinfo
is
not
None
),
".value can only be used after the context manager exits"
return
self
.
_excinfo
[
1
]
@property
def
tb
(
self
)
->
TracebackType
:
"""The exception raw traceback."""
assert
(
self
.
_excinfo
is
not
None
),
".tb can only be used after the context manager exits"
return
self
.
_excinfo
[
2
]
@property
def
typename
(
self
)
->
str
:
"""The type name of the exception."""
assert
(
self
.
_excinfo
is
not
None
),
".typename can only be used after the context manager exits"
return
self
.
type
.
__name__
@property
def
traceback
(
self
)
->
Traceback
:
"""The traceback."""
if
self
.
_traceback
is
None
:
self
.
_traceback
=
Traceback
(
self
.
tb
)
return
self
.
_traceback
@traceback
.
setter
def
traceback
(
self
,
value
:
Traceback
)
->
None
:
self
.
_traceback
=
value
def
__repr__
(
self
)
->
str
:
if
self
.
_excinfo
is
None
:
return
"<ExceptionInfo for raises contextmanager>"
return
f
"<
{
self
.
__class__
.
__name__
}
{
saferepr
(
self
.
_excinfo
[
1
])
}
tblen=
{
len
(
self
.
traceback
)
}
>"
[docs]
def
exconly
(
self
,
tryshort
:
bool
=
False
)
->
str
:
"""Return the exception as a string.
When 'tryshort' resolves to True, and the exception is an
AssertionError, only the actual exception part of the exception
representation is returned (so 'AssertionError: ' is removed from
the beginning).
"""
lines
=
format_exception_only
(
self
.
type
,
self
.
value
)
text
=
""
.
join
(
lines
)
text
=
text
.
rstrip
()
if
tryshort
:
if
text
.
startswith
(
self
.
_striptext
):
text
=
text
[
len
(
self
.
_striptext
)
:]
return
text
[docs]
def
errisinstance
(
self
,
exc
:
EXCEPTION_OR_MORE
)
->
bool
:
"""Return True if the exception is an instance of exc.
Consider using ``isinstance(excinfo.value, exc)`` instead.
"""
return
isinstance
(
self
.
value
,
exc
)
def
_getreprcrash
(
self
)
->
ReprFileLocation
|
None
:
# Find last non-hidden traceback entry that led to the exception of the
# traceback, or None if all hidden.
for
i
in
range
(
-
1
,
-
len
(
self
.
traceback
)
-
1
,
-
1
):
entry
=
self
.
traceback
[
i
]
if
not
entry
.
ishidden
(
self
):
path
,
lineno
=
entry
.
frame
.
code
.
raw
.
co_filename
,
entry
.
lineno
exconly
=
self
.
exconly
(
tryshort
=
True
)
return
ReprFileLocation
(
path
,
lineno
+
1
,
exconly
)
return
None
[docs]
def
getrepr
(
self
,
showlocals
:
bool
=
False
,
style
:
TracebackStyle
=
"long"
,
abspath
:
bool
=
False
,
tbfilter
:
bool
|
Callable
[[
ExceptionInfo
[
BaseException
]],
_pytest
.
_code
.
code
.
Traceback
]
=
True
,
funcargs
:
bool
=
False
,
truncate_locals
:
bool
=
True
,
truncate_args
:
bool
=
True
,
chain
:
bool
=
True
,
)
->
ReprExceptionInfo
|
ExceptionChainRepr
:
"""Return str()able representation of this exception info.
:param bool showlocals:
Show locals per traceback entry.
Ignored if ``style=="native"``.
:param str style:
long|short|line|no|native|value traceback style.
:param bool abspath:
If paths should be changed to absolute or left unchanged.
:param tbfilter:
A filter for traceback entries.
* If false, don't hide any entries.
* If true, hide internal entries and entries that contain a local
variable ``__tracebackhide__ = True``.
* If a callable, delegates the filtering to the callable.
Ignored if ``style`` is ``"native"``.
:param bool funcargs:
Show fixtures ("funcargs" for legacy purposes) per traceback entry.
:param bool truncate_locals:
With ``showlocals==True``, make sure locals can be safely represented as strings.
:param bool truncate_args:
With ``showargs==True``, make sure args can be safely represented as strings.
:param bool chain:
If chained exceptions in Python 3 should be shown.
.. versionchanged:: 3.9
Added the ``chain`` parameter.
"""
if
style
==
"native"
:
return
ReprExceptionInfo
(
reprtraceback
=
ReprTracebackNative
(
traceback
.
format_exception
(
self
.
type
,
self
.
value
,
self
.
traceback
[
0
]
.
_rawentry
if
self
.
traceback
else
None
,
)
),
reprcrash
=
self
.
_getreprcrash
(),
)
fmt
=
FormattedExcinfo
(
showlocals
=
showlocals
,
style
=
style
,
abspath
=
abspath
,
tbfilter
=
tbfilter
,
funcargs
=
funcargs
,
truncate_locals
=
truncate_locals
,
truncate_args
=
truncate_args
,
chain
=
chain
,
)
return
fmt
.
repr_excinfo
(
self
)
def
_stringify_exception
(
self
,
exc
:
BaseException
)
->
str
:
try
:
notes
=
getattr
(
exc
,
"__notes__"
,
[])
except
KeyError
:
# Workaround for https://github.com/python/cpython/issues/98778 on
# Python <= 3.9, and some 3.10 and 3.11 patch versions.
HTTPError
=
getattr
(
sys
.
modules
.
get
(
"urllib.error"
,
None
),
"HTTPError"
,
())
if
sys
.
version_info
<
(
3
,
12
)
and
isinstance
(
exc
,
HTTPError
):
notes
=
[]
else
:
raise
return
"
\n
"
.
join
(
[
str
(
exc
),
*
notes
,
]
)
[docs]
def
match
(
self
,
regexp
:
str
|
Pattern
[
str
])
->
Literal
[
True
]:
"""Check whether the regular expression `regexp` matches the string
representation of the exception using :func:`python:re.search`.
If it matches `True` is returned, otherwise an `AssertionError` is raised.
"""
__tracebackhide__
=
True
value
=
self
.
_stringify_exception
(
self
.
value
)
msg
=
f
"Regex pattern did not match.
\n
Regex:
{
regexp
!r}
\n
Input:
{
value
!r}
"
if
regexp
==
value
:
msg
+=
"
\n
Did you mean to `re.escape()` the regex?"
assert
re
.
search
(
regexp
,
value
),
msg
# Return True to allow for "assert excinfo.match()".
return
True
def
_group_contains
(
self
,
exc_group
:
BaseExceptionGroup
[
BaseException
],
expected_exception
:
EXCEPTION_OR_MORE
,
match
:
str
|
Pattern
[
str
]
|
None
,
target_depth
:
int
|
None
=
None
,
current_depth
:
int
=
1
,
)
->
bool
:
"""Return `True` if a `BaseExceptionGroup` contains a matching exception."""
if
(
target_depth
is
not
None
)
and
(
current_depth
>
target_depth
):
# already descended past the target depth
return
False
for
exc
in
exc_group
.
exceptions
:
if
isinstance
(
exc
,
BaseExceptionGroup
):
if
self
.
_group_contains
(
exc
,
expected_exception
,
match
,
target_depth
,
current_depth
+
1
):
return
True
if
(
target_depth
is
not
None
)
and
(
current_depth
!=
target_depth
):
# not at the target depth, no match
continue
if
not
isinstance
(
exc
,
expected_exception
):
continue
if
match
is
not
None
:
value
=
self
.
_stringify_exception
(
exc
)
if
not
re
.
search
(
match
,
value
):
continue
return
True
return
False
[docs]
def
group_contains
(
self
,
expected_exception
:
EXCEPTION_OR_MORE
,
*
,
match
:
str
|
Pattern
[
str
]
|
None
=
None
,
depth
:
int
|
None
=
None
,
)
->
bool
:
"""Check whether a captured exception group contains a matching exception.
:param Type[BaseException] | Tuple[Type[BaseException]] expected_exception:
The expected exception type, or a tuple if one of multiple possible
exception types are expected.
:param str | Pattern[str] | None match:
If specified, a string containing a regular expression,
or a regular expression object, that is tested against the string
representation of the exception and its `PEP-678 <https://peps.python.org/pep-0678/>` `__notes__`
using :func:`re.search`.
To match a literal string that may contain :ref:`special characters
<re-syntax>`, the pattern can first be escaped with :func:`re.escape`.
:param Optional[int] depth:
If `None`, will search for a matching exception at any nesting depth.
If >= 1, will only match an exception if it's at the specified depth (depth = 1 being
the exceptions contained within the topmost exception group).
.. versionadded:: 8.0
"""
msg
=
"Captured exception is not an instance of `BaseExceptionGroup`"
assert
isinstance
(
self
.
value
,
BaseExceptionGroup
),
msg
msg
=
"`depth` must be >= 1 if specified"
assert
(
depth
is
None
)
or
(
depth
>=
1
),
msg
return
self
.
_group_contains
(
self
.
value
,
expected_exception
,
match
,
depth
)
@dataclasses
.
dataclass
class
FormattedExcinfo
:
"""Presenting information about failing Functions and Generators."""
# for traceback entries
flow_marker
:
ClassVar
=
">"
fail_marker
:
ClassVar
=
"E"
showlocals
:
bool
=
False
style
:
TracebackStyle
=
"long"
abspath
:
bool
=
True
tbfilter
:
bool
|
Callable
[[
ExceptionInfo
[
BaseException
]],
Traceback
]
=
True
funcargs
:
bool
=
False
truncate_locals
:
bool
=
True
truncate_args
:
bool
=
True
chain
:
bool
=
True
astcache
:
dict
[
str
|
Path
,
ast
.
AST
]
=
dataclasses
.
field
(
default_factory
=
dict
,
init
=
False
,
repr
=
False
)
def
_getindent
(
self
,
source
:
Source
)
->
int
:
# Figure out indent for the given source.
try
:
s
=
str
(
source
.
getstatement
(
len
(
source
)
-
1
))
except
KeyboardInterrupt
:
raise
except
BaseException
:
try
:
s
=
str
(
source
[
-
1
])
except
KeyboardInterrupt
:
raise
except
BaseException
:
return
0
return
4
+
(
len
(
s
)
-
len
(
s
.
lstrip
()))
def
_getentrysource
(
self
,
entry
:
TracebackEntry
)
->
Source
|
None
:
source
=
entry
.
getsource
(
self
.
astcache
)
if
source
is
not
None
:
source
=
source
.
deindent
()
return
source
def
repr_args
(
self
,
entry
:
TracebackEntry
)
->
ReprFuncArgs
|
None
:
if
self
.
funcargs
:
args
=
[]
for
argname
,
argvalue
in
entry
.
frame
.
getargs
(
var
=
True
):
if
self
.
truncate_args
:
str_repr
=
saferepr
(
argvalue
)
else
:
str_repr
=
saferepr
(
argvalue
,
maxsize
=
None
)
args
.
append
((
argname
,
str_repr
))
return
ReprFuncArgs
(
args
)
return
None
def
get_source
(
self
,
source
:
Source
|
None
,
line_index
:
int
=
-
1
,
excinfo
:
ExceptionInfo
[
BaseException
]
|
None
=
None
,
short
:
bool
=
False
,
)
->
list
[
str
]:
"""Return formatted and marked up source lines."""
lines
=
[]
if
source
is
not
None
and
line_index
<
0
:
line_index
+=
len
(
source
)
if
source
is
None
or
line_index
>=
len
(
source
.
lines
)
or
line_index
<
0
:
# `line_index` could still be outside `range(len(source.lines))` if
# we're processing AST with pathological position attributes.
source
=
Source
(
"???"
)
line_index
=
0
space_prefix
=
"    "
if
short
:
lines
.
append
(
space_prefix
+
source
.
lines
[
line_index
]
.
strip
())
else
:
for
line
in
source
.
lines
[:
line_index
]:
lines
.
append
(
space_prefix
+
line
)
lines
.
append
(
self
.
flow_marker
+
"   "
+
source
.
lines
[
line_index
])
for
line
in
source
.
lines
[
line_index
+
1
:]:
lines
.
append
(
space_prefix
+
line
)
if
excinfo
is
not
None
:
indent
=
4
if
short
else
self
.
_getindent
(
source
)
lines
.
extend
(
self
.
get_exconly
(
excinfo
,
indent
=
indent
,
markall
=
True
))
return
lines
def
get_exconly
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
],
indent
:
int
=
4
,
markall
:
bool
=
False
,
)
->
list
[
str
]:
lines
=
[]
indentstr
=
" "
*
indent
# Get the real exception information out.
exlines
=
excinfo
.
exconly
(
tryshort
=
True
)
.
split
(
"
\n
"
)
failindent
=
self
.
fail_marker
+
indentstr
[
1
:]
for
line
in
exlines
:
lines
.
append
(
failindent
+
line
)
if
not
markall
:
failindent
=
indentstr
return
lines
def
repr_locals
(
self
,
locals
:
Mapping
[
str
,
object
])
->
ReprLocals
|
None
:
if
self
.
showlocals
:
lines
=
[]
keys
=
[
loc
for
loc
in
locals
if
loc
[
0
]
!=
"@"
]
keys
.
sort
()
for
name
in
keys
:
value
=
locals
[
name
]
if
name
==
"__builtins__"
:
lines
.
append
(
"__builtins__ = <builtins>"
)
else
:
# This formatting could all be handled by the
# _repr() function, which is only reprlib.Repr in
# disguise, so is very configurable.
if
self
.
truncate_locals
:
str_repr
=
saferepr
(
value
)
else
:
str_repr
=
safeformat
(
value
)
# if len(str_repr) < 70 or not isinstance(value, (list, tuple, dict)):
lines
.
append
(
f
"
{
name
:
<10
}
=
{
str_repr
}
"
)
# else:
#    self._line("%-10s =\\" % (name,))
#    # XXX
#    pprint.pprint(value, stream=self.excinfowriter)
return
ReprLocals
(
lines
)
return
None
def
repr_traceback_entry
(
self
,
entry
:
TracebackEntry
|
None
,
excinfo
:
ExceptionInfo
[
BaseException
]
|
None
=
None
,
)
->
ReprEntry
:
lines
:
list
[
str
]
=
[]
style
=
(
entry
.
_repr_style
if
entry
is
not
None
and
entry
.
_repr_style
is
not
None
else
self
.
style
)
if
style
in
(
"short"
,
"long"
)
and
entry
is
not
None
:
source
=
self
.
_getentrysource
(
entry
)
if
source
is
None
:
source
=
Source
(
"???"
)
line_index
=
0
else
:
line_index
=
entry
.
lineno
-
entry
.
getfirstlinesource
()
short
=
style
==
"short"
reprargs
=
self
.
repr_args
(
entry
)
if
not
short
else
None
s
=
self
.
get_source
(
source
,
line_index
,
excinfo
,
short
=
short
)
lines
.
extend
(
s
)
if
short
:
message
=
f
"in
{
entry
.
name
}
"
else
:
message
=
excinfo
and
excinfo
.
typename
or
""
entry_path
=
entry
.
path
path
=
self
.
_makepath
(
entry_path
)
reprfileloc
=
ReprFileLocation
(
path
,
entry
.
lineno
+
1
,
message
)
localsrepr
=
self
.
repr_locals
(
entry
.
locals
)
return
ReprEntry
(
lines
,
reprargs
,
localsrepr
,
reprfileloc
,
style
)
elif
style
==
"value"
:
if
excinfo
:
lines
.
extend
(
str
(
excinfo
.
value
)
.
split
(
"
\n
"
))
return
ReprEntry
(
lines
,
None
,
None
,
None
,
style
)
else
:
if
excinfo
:
lines
.
extend
(
self
.
get_exconly
(
excinfo
,
indent
=
4
))
return
ReprEntry
(
lines
,
None
,
None
,
None
,
style
)
def
_makepath
(
self
,
path
:
Path
|
str
)
->
str
:
if
not
self
.
abspath
and
isinstance
(
path
,
Path
):
try
:
np
=
bestrelpath
(
Path
.
cwd
(),
path
)
except
OSError
:
return
str
(
path
)
if
len
(
np
)
<
len
(
str
(
path
)):
return
np
return
str
(
path
)
def
repr_traceback
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
])
->
ReprTraceback
:
traceback
=
excinfo
.
traceback
if
callable
(
self
.
tbfilter
):
traceback
=
self
.
tbfilter
(
excinfo
)
elif
self
.
tbfilter
:
traceback
=
traceback
.
filter
(
excinfo
)
if
isinstance
(
excinfo
.
value
,
RecursionError
):
traceback
,
extraline
=
self
.
_truncate_recursive_traceback
(
traceback
)
else
:
extraline
=
None
if
not
traceback
:
if
extraline
is
None
:
extraline
=
"All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames."
entries
=
[
self
.
repr_traceback_entry
(
None
,
excinfo
)]
return
ReprTraceback
(
entries
,
extraline
,
style
=
self
.
style
)
last
=
traceback
[
-
1
]
if
self
.
style
==
"value"
:
entries
=
[
self
.
repr_traceback_entry
(
last
,
excinfo
)]
return
ReprTraceback
(
entries
,
None
,
style
=
self
.
style
)
entries
=
[
self
.
repr_traceback_entry
(
entry
,
excinfo
if
last
==
entry
else
None
)
for
entry
in
traceback
]
return
ReprTraceback
(
entries
,
extraline
,
style
=
self
.
style
)
def
_truncate_recursive_traceback
(
self
,
traceback
:
Traceback
)
->
tuple
[
Traceback
,
str
|
None
]:
"""Truncate the given recursive traceback trying to find the starting
point of the recursion.
The detection is done by going through each traceback entry and
finding the point in which the locals of the frame are equal to the
locals of a previous frame (see ``recursionindex()``).
Handle the situation where the recursion process might raise an
exception (for example comparing numpy arrays using equality raises a
TypeError), in which case we do our best to warn the user of the
error and show a limited traceback.
"""
try
:
recursionindex
=
traceback
.
recursionindex
()
except
Exception
as
e
:
max_frames
=
10
extraline
:
str
|
None
=
(
"!!! Recursion error detected, but an error occurred locating the origin of recursion.
\n
"
"  The following exception happened when comparing locals in the stack frame:
\n
"
f
"
{
type
(
e
)
.
__name__
}
:
{
e
!s}
\n
"
f
"  Displaying first and last
{
max_frames
}
stack frames out of
{
len
(
traceback
)
}
."
)
# Type ignored because adding two instances of a List subtype
# currently incorrectly has type List instead of the subtype.
traceback
=
traceback
[:
max_frames
]
+
traceback
[
-
max_frames
:]
# type: ignore
else
:
if
recursionindex
is
not
None
:
extraline
=
"!!! Recursion detected (same locals & position)"
traceback
=
traceback
[:
recursionindex
+
1
]
else
:
extraline
=
None
return
traceback
,
extraline
def
repr_excinfo
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
])
->
ExceptionChainRepr
:
repr_chain
:
list
[
tuple
[
ReprTraceback
,
ReprFileLocation
|
None
,
str
|
None
]]
=
[]
e
:
BaseException
|
None
=
excinfo
.
value
excinfo_
:
ExceptionInfo
[
BaseException
]
|
None
=
excinfo
descr
=
None
seen
:
set
[
int
]
=
set
()
while
e
is
not
None
and
id
(
e
)
not
in
seen
:
seen
.
add
(
id
(
e
))
if
excinfo_
:
# Fall back to native traceback as a temporary workaround until
# full support for exception groups added to ExceptionInfo.
# See https://github.com/pytest-dev/pytest/issues/9159
if
isinstance
(
e
,
BaseExceptionGroup
):
reprtraceback
:
ReprTracebackNative
|
ReprTraceback
=
(
ReprTracebackNative
(
traceback
.
format_exception
(
type
(
excinfo_
.
value
),
excinfo_
.
value
,
excinfo_
.
traceback
[
0
]
.
_rawentry
,
)
)
)
else
:
reprtraceback
=
self
.
repr_traceback
(
excinfo_
)
reprcrash
=
excinfo_
.
_getreprcrash
()
else
:
# Fallback to native repr if the exception doesn't have a traceback:
# ExceptionInfo objects require a full traceback to work.
reprtraceback
=
ReprTracebackNative
(
traceback
.
format_exception
(
type
(
e
),
e
,
None
)
)
reprcrash
=
None
repr_chain
+=
[(
reprtraceback
,
reprcrash
,
descr
)]
if
e
.
__cause__
is
not
None
and
self
.
chain
:
e
=
e
.
__cause__
excinfo_
=
ExceptionInfo
.
from_exception
(
e
)
if
e
.
__traceback__
else
None
descr
=
"The above exception was the direct cause of the following exception:"
elif
(
e
.
__context__
is
not
None
and
not
e
.
__suppress_context__
and
self
.
chain
):
e
=
e
.
__context__
excinfo_
=
ExceptionInfo
.
from_exception
(
e
)
if
e
.
__traceback__
else
None
descr
=
"During handling of the above exception, another exception occurred:"
else
:
e
=
None
repr_chain
.
reverse
()
return
ExceptionChainRepr
(
repr_chain
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
TerminalRepr
:
def
__str__
(
self
)
->
str
:
# FYI this is called from pytest-xdist's serialization of exception
# information.
io
=
StringIO
()
tw
=
TerminalWriter
(
file
=
io
)
self
.
toterminal
(
tw
)
return
io
.
getvalue
()
.
strip
()
def
__repr__
(
self
)
->
str
:
return
f
"<
{
self
.
__class__
}
instance at
{
id
(
self
)
:
0x
}
>"
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
raise
NotImplementedError
()
# This class is abstract -- only subclasses are instantiated.
@dataclasses
.
dataclass
(
eq
=
False
)
class
ExceptionRepr
(
TerminalRepr
):
# Provided by subclasses.
reprtraceback
:
ReprTraceback
reprcrash
:
ReprFileLocation
|
None
sections
:
list
[
tuple
[
str
,
str
,
str
]]
=
dataclasses
.
field
(
init
=
False
,
default_factory
=
list
)
def
addsection
(
self
,
name
:
str
,
content
:
str
,
sep
:
str
=
"-"
)
->
None
:
self
.
sections
.
append
((
name
,
content
,
sep
))
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
for
name
,
content
,
sep
in
self
.
sections
:
tw
.
sep
(
sep
,
name
)
tw
.
line
(
content
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
ExceptionChainRepr
(
ExceptionRepr
):
chain
:
Sequence
[
tuple
[
ReprTraceback
,
ReprFileLocation
|
None
,
str
|
None
]]
def
__init__
(
self
,
chain
:
Sequence
[
tuple
[
ReprTraceback
,
ReprFileLocation
|
None
,
str
|
None
]],
)
->
None
:
# reprcrash and reprtraceback of the outermost (the newest) exception
# in the chain.
super
()
.
__init__
(
reprtraceback
=
chain
[
-
1
][
0
],
reprcrash
=
chain
[
-
1
][
1
],
)
self
.
chain
=
chain
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
for
element
in
self
.
chain
:
element
[
0
]
.
toterminal
(
tw
)
if
element
[
2
]
is
not
None
:
tw
.
line
(
""
)
tw
.
line
(
element
[
2
],
yellow
=
True
)
super
()
.
toterminal
(
tw
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprExceptionInfo
(
ExceptionRepr
):
reprtraceback
:
ReprTraceback
reprcrash
:
ReprFileLocation
|
None
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
self
.
reprtraceback
.
toterminal
(
tw
)
super
()
.
toterminal
(
tw
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprTraceback
(
TerminalRepr
):
reprentries
:
Sequence
[
ReprEntry
|
ReprEntryNative
]
extraline
:
str
|
None
style
:
TracebackStyle
entrysep
:
ClassVar
=
"_ "
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
# The entries might have different styles.
for
i
,
entry
in
enumerate
(
self
.
reprentries
):
if
entry
.
style
==
"long"
:
tw
.
line
(
""
)
entry
.
toterminal
(
tw
)
if
i
<
len
(
self
.
reprentries
)
-
1
:
next_entry
=
self
.
reprentries
[
i
+
1
]
if
(
entry
.
style
==
"long"
or
entry
.
style
==
"short"
and
next_entry
.
style
==
"long"
):
tw
.
sep
(
self
.
entrysep
)
if
self
.
extraline
:
tw
.
line
(
self
.
extraline
)
class
ReprTracebackNative
(
ReprTraceback
):
def
__init__
(
self
,
tblines
:
Sequence
[
str
])
->
None
:
self
.
reprentries
=
[
ReprEntryNative
(
tblines
)]
self
.
extraline
=
None
self
.
style
=
"native"
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprEntryNative
(
TerminalRepr
):
lines
:
Sequence
[
str
]
style
:
ClassVar
[
TracebackStyle
]
=
"native"
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
tw
.
write
(
""
.
join
(
self
.
lines
))
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprEntry
(
TerminalRepr
):
lines
:
Sequence
[
str
]
reprfuncargs
:
ReprFuncArgs
|
None
reprlocals
:
ReprLocals
|
None
reprfileloc
:
ReprFileLocation
|
None
style
:
TracebackStyle
def
_write_entry_lines
(
self
,
tw
:
TerminalWriter
)
->
None
:
"""Write the source code portions of a list of traceback entries with syntax highlighting.
Usually entries are lines like these:
"     x = 1"
">    assert x == 2"
"E    assert 1 == 2"
This function takes care of rendering the "source" portions of it (the lines without
the "E" prefix) using syntax highlighting, taking care to not highlighting the ">"
character, as doing so might break line continuations.
"""
if
not
self
.
lines
:
return
if
self
.
style
==
"value"
:
# Using tw.write instead of tw.line for testing purposes due to TWMock implementation;
# lines written with TWMock.line and TWMock._write_source cannot be distinguished
# from each other, whereas lines written with TWMock.write are marked with TWMock.WRITE
for
line
in
self
.
lines
:
tw
.
write
(
line
)
tw
.
write
(
"
\n
"
)
return
# separate indents and source lines that are not failures: we want to
# highlight the code but not the indentation, which may contain markers
# such as ">   assert 0"
fail_marker
=
f
"
{
FormattedExcinfo
.
fail_marker
}
"
indent_size
=
len
(
fail_marker
)
indents
:
list
[
str
]
=
[]
source_lines
:
list
[
str
]
=
[]
failure_lines
:
list
[
str
]
=
[]
for
index
,
line
in
enumerate
(
self
.
lines
):
is_failure_line
=
line
.
startswith
(
fail_marker
)
if
is_failure_line
:
# from this point on all lines are considered part of the failure
failure_lines
.
extend
(
self
.
lines
[
index
:])
break
else
:
indents
.
append
(
line
[:
indent_size
])
source_lines
.
append
(
line
[
indent_size
:])
tw
.
_write_source
(
source_lines
,
indents
)
# failure lines are always completely red and bold
for
line
in
failure_lines
:
tw
.
line
(
line
,
bold
=
True
,
red
=
True
)
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
if
self
.
style
==
"short"
:
if
self
.
reprfileloc
:
self
.
reprfileloc
.
toterminal
(
tw
)
self
.
_write_entry_lines
(
tw
)
if
self
.
reprlocals
:
self
.
reprlocals
.
toterminal
(
tw
,
indent
=
" "
*
8
)
return
if
self
.
reprfuncargs
:
self
.
reprfuncargs
.
toterminal
(
tw
)
self
.
_write_entry_lines
(
tw
)
if
self
.
reprlocals
:
tw
.
line
(
""
)
self
.
reprlocals
.
toterminal
(
tw
)
if
self
.
reprfileloc
:
if
self
.
lines
:
tw
.
line
(
""
)
self
.
reprfileloc
.
toterminal
(
tw
)
def
__str__
(
self
)
->
str
:
return
"
{}
\n
{}
\n
{}
"
.
format
(
"
\n
"
.
join
(
self
.
lines
),
self
.
reprlocals
,
self
.
reprfileloc
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprFileLocation
(
TerminalRepr
):
path
:
str
lineno
:
int
message
:
str
def
__post_init__
(
self
)
->
None
:
self
.
path
=
str
(
self
.
path
)
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
# Filename and lineno output for each entry, using an output format
# that most editors understand.
msg
=
self
.
message
i
=
msg
.
find
(
"
\n
"
)
if
i
!=
-
1
:
msg
=
msg
[:
i
]
tw
.
write
(
self
.
path
,
bold
=
True
,
red
=
True
)
tw
.
line
(
f
":
{
self
.
lineno
}
:
{
msg
}
"
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprLocals
(
TerminalRepr
):
lines
:
Sequence
[
str
]
def
toterminal
(
self
,
tw
:
TerminalWriter
,
indent
=
""
)
->
None
:
for
line
in
self
.
lines
:
tw
.
line
(
indent
+
line
)
@dataclasses
.
dataclass
(
eq
=
False
)
class
ReprFuncArgs
(
TerminalRepr
):
args
:
Sequence
[
tuple
[
str
,
object
]]
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
if
self
.
args
:
linesofar
=
""
for
name
,
value
in
self
.
args
:
ns
=
f
"
{
name
}
=
{
value
}
"
if
len
(
ns
)
+
len
(
linesofar
)
+
2
>
tw
.
fullwidth
:
if
linesofar
:
tw
.
line
(
linesofar
)
linesofar
=
ns
else
:
if
linesofar
:
linesofar
+=
", "
+
ns
else
:
linesofar
=
ns
if
linesofar
:
tw
.
line
(
linesofar
)
tw
.
line
(
""
)
def
getfslineno
(
obj
:
object
)
->
tuple
[
str
|
Path
,
int
]:
"""Return source location (path, lineno) for the given object.
If the source cannot be determined return ("", -1).
The line number is 0-based.
"""
# xxx let decorators etc specify a sane ordering
# NOTE: this used to be done in _pytest.compat.getfslineno, initially added
#       in 6ec13a2b9.  It ("place_as") appears to be something very custom.
obj
=
get_real_func
(
obj
)
if
hasattr
(
obj
,
"place_as"
):
obj
=
obj
.
place_as
try
:
code
=
Code
.
from_function
(
obj
)
except
TypeError
:
try
:
fn
=
inspect
.
getsourcefile
(
obj
)
or
inspect
.
getfile
(
obj
)
# type: ignore[arg-type]
except
TypeError
:
return
""
,
-
1
fspath
=
fn
and
absolutepath
(
fn
)
or
""
lineno
=
-
1
if
fspath
:
try
:
_
,
lineno
=
findsource
(
obj
)
except
OSError
:
pass
return
fspath
,
lineno
return
code
.
path
,
code
.
firstlineno
# Relative paths that we use to filter traceback entries from appearing to the user;
# see filter_traceback.
# note: if we need to add more paths than what we have now we should probably use a list
# for better maintenance.
_PLUGGY_DIR
=
Path
(
pluggy
.
__file__
.
rstrip
(
"oc"
))
# pluggy is either a package or a single module depending on the version
if
_PLUGGY_DIR
.
name
==
"__init__.py"
:
_PLUGGY_DIR
=
_PLUGGY_DIR
.
parent
_PYTEST_DIR
=
Path
(
_pytest
.
__file__
)
.
parent
def
filter_traceback
(
entry
:
TracebackEntry
)
->
bool
:
"""Return True if a TracebackEntry instance should be included in tracebacks.
We hide traceback entries of:
* dynamically generated code (no code to show up for it);
* internal traceback from pytest or its internal libraries, py and pluggy.
"""
# entry.path might sometimes return a str object when the entry
# points to dynamically generated code.
# See https://bitbucket.org/pytest-dev/py/issues/71.
raw_filename
=
entry
.
frame
.
code
.
raw
.
co_filename
is_generated
=
"<"
in
raw_filename
and
">"
in
raw_filename
if
is_generated
:
return
False
# entry.path might point to a non-existing file, in which case it will
# also return a str object. See #1133.
p
=
Path
(
entry
.
path
)
parents
=
p
.
parents
if
_PLUGGY_DIR
in
parents
:
return
False
if
_PYTEST_DIR
in
parents
:
return
False
return
True

```


---


# _pytest.tmpdir - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/tmpdir.html


# Source code for _pytest.tmpdir

```

# mypy: allow-untyped-defs
"""Support for providing temporary directories to test functions."""
from
__future__
import
annotations
import
dataclasses
import
os
from
pathlib
import
Path
import
re
from
shutil
import
rmtree
import
tempfile
from
typing
import
Any
from
typing
import
Dict
from
typing
import
final
from
typing
import
Generator
from
typing
import
Literal
from
.pathlib
import
cleanup_dead_symlinks
from
.pathlib
import
LOCK_TIMEOUT
from
.pathlib
import
make_numbered_dir
from
.pathlib
import
make_numbered_dir_with_cleanup
from
.pathlib
import
rm_rf
from
_pytest.compat
import
get_user_id
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config
import
hookimpl
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.monkeypatch
import
MonkeyPatch
from
_pytest.nodes
import
Item
from
_pytest.reports
import
TestReport
from
_pytest.stash
import
StashKey
tmppath_result_key
=
StashKey
[
Dict
[
str
,
bool
]]()
RetentionType
=
Literal
[
"all"
,
"failed"
,
"none"
]
[docs]
@final
@dataclasses
.
dataclass
class
TempPathFactory
:
"""Factory for temporary directories under the common base temp directory,
as discussed at :ref:`temporary directory location and retention`.
"""
_given_basetemp
:
Path
|
None
# pluggy TagTracerSub, not currently exposed, so Any.
_trace
:
Any
_basetemp
:
Path
|
None
_retention_count
:
int
_retention_policy
:
RetentionType
def
__init__
(
self
,
given_basetemp
:
Path
|
None
,
retention_count
:
int
,
retention_policy
:
RetentionType
,
trace
,
basetemp
:
Path
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
if
given_basetemp
is
None
:
self
.
_given_basetemp
=
None
else
:
# Use os.path.abspath() to get absolute path instead of resolve() as it
# does not work the same in all platforms (see #4427).
# Path.absolute() exists, but it is not public (see https://bugs.python.org/issue25012).
self
.
_given_basetemp
=
Path
(
os
.
path
.
abspath
(
str
(
given_basetemp
)))
self
.
_trace
=
trace
self
.
_retention_count
=
retention_count
self
.
_retention_policy
=
retention_policy
self
.
_basetemp
=
basetemp
@classmethod
def
from_config
(
cls
,
config
:
Config
,
*
,
_ispytest
:
bool
=
False
,
)
->
TempPathFactory
:
"""Create a factory according to pytest configuration.
:meta private:
"""
check_ispytest
(
_ispytest
)
count
=
int
(
config
.
getini
(
"tmp_path_retention_count"
))
if
count
<
0
:
raise
ValueError
(
f
"tmp_path_retention_count must be >= 0. Current input:
{
count
}
."
)
policy
=
config
.
getini
(
"tmp_path_retention_policy"
)
if
policy
not
in
(
"all"
,
"failed"
,
"none"
):
raise
ValueError
(
f
"tmp_path_retention_policy must be either all, failed, none. Current input:
{
policy
}
."
)
return
cls
(
given_basetemp
=
config
.
option
.
basetemp
,
trace
=
config
.
trace
.
get
(
"tmpdir"
),
retention_count
=
count
,
retention_policy
=
policy
,
_ispytest
=
True
,
)
def
_ensure_relative_to_basetemp
(
self
,
basename
:
str
)
->
str
:
basename
=
os
.
path
.
normpath
(
basename
)
if
(
self
.
getbasetemp
()
/
basename
)
.
resolve
()
.
parent
!=
self
.
getbasetemp
():
raise
ValueError
(
f
"
{
basename
}
is not a normalized and relative path"
)
return
basename
[docs]
def
mktemp
(
self
,
basename
:
str
,
numbered
:
bool
=
True
)
->
Path
:
"""Create a new temporary directory managed by the factory.
:param basename:
Directory base name, must be a relative path.
:param numbered:
If ``True``, ensure the directory is unique by adding a numbered
suffix greater than any existing one: ``basename="foo-"`` and ``numbered=True``
means that this function will create directories named ``"foo-0"``,
``"foo-1"``, ``"foo-2"`` and so on.
:returns:
The path to the new directory.
"""
basename
=
self
.
_ensure_relative_to_basetemp
(
basename
)
if
not
numbered
:
p
=
self
.
getbasetemp
()
.
joinpath
(
basename
)
p
.
mkdir
(
mode
=
0o700
)
else
:
p
=
make_numbered_dir
(
root
=
self
.
getbasetemp
(),
prefix
=
basename
,
mode
=
0o700
)
self
.
_trace
(
"mktemp"
,
p
)
return
p
[docs]
def
getbasetemp
(
self
)
->
Path
:
"""Return the base temporary directory, creating it if needed.
:returns:
The base temporary directory.
"""
if
self
.
_basetemp
is
not
None
:
return
self
.
_basetemp
if
self
.
_given_basetemp
is
not
None
:
basetemp
=
self
.
_given_basetemp
if
basetemp
.
exists
():
rm_rf
(
basetemp
)
basetemp
.
mkdir
(
mode
=
0o700
)
basetemp
=
basetemp
.
resolve
()
else
:
from_env
=
os
.
environ
.
get
(
"PYTEST_DEBUG_TEMPROOT"
)
temproot
=
Path
(
from_env
or
tempfile
.
gettempdir
())
.
resolve
()
user
=
get_user
()
or
"unknown"
# use a sub-directory in the temproot to speed-up
# make_numbered_dir() call
rootdir
=
temproot
.
joinpath
(
f
"pytest-of-
{
user
}
"
)
try
:
rootdir
.
mkdir
(
mode
=
0o700
,
exist_ok
=
True
)
except
OSError
:
# getuser() likely returned illegal characters for the platform, use unknown back off mechanism
rootdir
=
temproot
.
joinpath
(
"pytest-of-unknown"
)
rootdir
.
mkdir
(
mode
=
0o700
,
exist_ok
=
True
)
# Because we use exist_ok=True with a predictable name, make sure
# we are the owners, to prevent any funny business (on unix, where
# temproot is usually shared).
# Also, to keep things private, fixup any world-readable temp
# rootdir's permissions. Historically 0o755 was used, so we can't
# just error out on this, at least for a while.
uid
=
get_user_id
()
if
uid
is
not
None
:
rootdir_stat
=
rootdir
.
stat
()
if
rootdir_stat
.
st_uid
!=
uid
:
raise
OSError
(
f
"The temporary directory
{
rootdir
}
is not owned by the current user. "
"Fix this and try again."
)
if
(
rootdir_stat
.
st_mode
&
0o077
)
!=
0
:
os
.
chmod
(
rootdir
,
rootdir_stat
.
st_mode
&
~
0o077
)
keep
=
self
.
_retention_count
if
self
.
_retention_policy
==
"none"
:
keep
=
0
basetemp
=
make_numbered_dir_with_cleanup
(
prefix
=
"pytest-"
,
root
=
rootdir
,
keep
=
keep
,
lock_timeout
=
LOCK_TIMEOUT
,
mode
=
0o700
,
)
assert
basetemp
is
not
None
,
basetemp
self
.
_basetemp
=
basetemp
self
.
_trace
(
"new basetemp"
,
basetemp
)
return
basetemp
def
get_user
()
->
str
|
None
:
"""Return the current user name, or None if getuser() does not work
in the current environment (see #1010)."""
try
:
# In some exotic environments, getpass may not be importable.
import
getpass
return
getpass
.
getuser
()
except
(
ImportError
,
OSError
,
KeyError
):
return
None
def
pytest_configure
(
config
:
Config
)
->
None
:
"""Create a TempPathFactory and attach it to the config object.
This is to comply with existing plugins which expect the handler to be
available at pytest_configure time, but ideally should be moved entirely
to the tmp_path_factory session fixture.
"""
mp
=
MonkeyPatch
()
config
.
add_cleanup
(
mp
.
undo
)
_tmp_path_factory
=
TempPathFactory
.
from_config
(
config
,
_ispytest
=
True
)
mp
.
setattr
(
config
,
"_tmp_path_factory"
,
_tmp_path_factory
,
raising
=
False
)
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
parser
.
addini
(
"tmp_path_retention_count"
,
help
=
"How many sessions should we keep the `tmp_path` directories, according to `tmp_path_retention_policy`."
,
default
=
3
,
)
parser
.
addini
(
"tmp_path_retention_policy"
,
help
=
"Controls which directories created by the `tmp_path` fixture are kept around, based on test outcome. "
"(all/failed/none)"
,
default
=
"all"
,
)
@fixture
(
scope
=
"session"
)
def
tmp_path_factory
(
request
:
FixtureRequest
)
->
TempPathFactory
:
"""Return a :class:`pytest.TempPathFactory` instance for the test session."""
# Set dynamically by pytest_configure() above.
return
request
.
config
.
_tmp_path_factory
# type: ignore
def
_mk_tmp
(
request
:
FixtureRequest
,
factory
:
TempPathFactory
)
->
Path
:
name
=
request
.
node
.
name
name
=
re
.
sub
(
r
"[\W]"
,
"_"
,
name
)
MAXVAL
=
30
name
=
name
[:
MAXVAL
]
return
factory
.
mktemp
(
name
,
numbered
=
True
)
[docs]
@fixture
def
tmp_path
(
request
:
FixtureRequest
,
tmp_path_factory
:
TempPathFactory
)
->
Generator
[
Path
]:
"""Return a temporary directory (as :class:`pathlib.Path` object)
which is unique to each test function invocation.
The temporary directory is created as a subdirectory
of the base temporary directory, with configurable retention,
as discussed in :ref:`temporary directory location and retention`.
"""
path
=
_mk_tmp
(
request
,
tmp_path_factory
)
yield
path
# Remove the tmpdir if the policy is "failed" and the test passed.
tmp_path_factory
:
TempPathFactory
=
request
.
session
.
config
.
_tmp_path_factory
# type: ignore
policy
=
tmp_path_factory
.
_retention_policy
result_dict
=
request
.
node
.
stash
[
tmppath_result_key
]
if
policy
==
"failed"
and
result_dict
.
get
(
"call"
,
True
):
# We do a "best effort" to remove files, but it might not be possible due to some leaked resource,
# permissions, etc, in which case we ignore it.
rmtree
(
path
,
ignore_errors
=
True
)
del
request
.
node
.
stash
[
tmppath_result_key
]
def
pytest_sessionfinish
(
session
,
exitstatus
:
int
|
ExitCode
):
"""After each session, remove base directory if all the tests passed,
the policy is "failed", and the basetemp is not specified by a user.
"""
tmp_path_factory
:
TempPathFactory
=
session
.
config
.
_tmp_path_factory
basetemp
=
tmp_path_factory
.
_basetemp
if
basetemp
is
None
:
return
policy
=
tmp_path_factory
.
_retention_policy
if
(
exitstatus
==
0
and
policy
==
"failed"
and
tmp_path_factory
.
_given_basetemp
is
None
):
if
basetemp
.
is_dir
():
# We do a "best effort" to remove files, but it might not be possible due to some leaked resource,
# permissions, etc, in which case we ignore it.
rmtree
(
basetemp
,
ignore_errors
=
True
)
# Remove dead symlinks.
if
basetemp
.
is_dir
():
cleanup_dead_symlinks
(
basetemp
)
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_runtest_makereport
(
item
:
Item
,
call
)
->
Generator
[
None
,
TestReport
,
TestReport
]:
rep
=
yield
assert
rep
.
when
is
not
None
empty
:
dict
[
str
,
bool
]
=
{}
item
.
stash
.
setdefault
(
tmppath_result_key
,
empty
)[
rep
.
when
]
=
rep
.
passed
return
rep

```


---


# _pytest.reports - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/reports.html


# Source code for _pytest.reports

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
import
dataclasses
from
io
import
StringIO
import
os
from
pprint
import
pprint
from
typing
import
Any
from
typing
import
cast
from
typing
import
final
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Literal
from
typing
import
Mapping
from
typing
import
NoReturn
from
typing
import
Sequence
from
typing
import
TYPE_CHECKING
from
_pytest._code.code
import
ExceptionChainRepr
from
_pytest._code.code
import
ExceptionInfo
from
_pytest._code.code
import
ExceptionRepr
from
_pytest._code.code
import
ReprEntry
from
_pytest._code.code
import
ReprEntryNative
from
_pytest._code.code
import
ReprExceptionInfo
from
_pytest._code.code
import
ReprFileLocation
from
_pytest._code.code
import
ReprFuncArgs
from
_pytest._code.code
import
ReprLocals
from
_pytest._code.code
import
ReprTraceback
from
_pytest._code.code
import
TerminalRepr
from
_pytest._io
import
TerminalWriter
from
_pytest.config
import
Config
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
Item
from
_pytest.outcomes
import
fail
from
_pytest.outcomes
import
skip
if
TYPE_CHECKING
:
from
typing_extensions
import
Self
from
_pytest.runner
import
CallInfo
def
getworkerinfoline
(
node
):
try
:
return
node
.
_workerinfocache
except
AttributeError
:
d
=
node
.
workerinfo
ver
=
"
{}
.
{}
.
{}
"
.
format
(
*
d
[
"version_info"
][:
3
])
node
.
_workerinfocache
=
s
=
"[
{}
]
{}
-- Python
{}
{}
"
.
format
(
d
[
"id"
],
d
[
"sysplatform"
],
ver
,
d
[
"executable"
]
)
return
s
class
BaseReport
:
when
:
str
|
None
location
:
tuple
[
str
,
int
|
None
,
str
]
|
None
longrepr
:
(
None
|
ExceptionInfo
[
BaseException
]
|
tuple
[
str
,
int
,
str
]
|
str
|
TerminalRepr
)
sections
:
list
[
tuple
[
str
,
str
]]
nodeid
:
str
outcome
:
Literal
[
"passed"
,
"failed"
,
"skipped"
]
def
__init__
(
self
,
**
kw
:
Any
)
->
None
:
self
.
__dict__
.
update
(
kw
)
if
TYPE_CHECKING
:
# Can have arbitrary fields given to __init__().
def
__getattr__
(
self
,
key
:
str
)
->
Any
:
...
def
toterminal
(
self
,
out
:
TerminalWriter
)
->
None
:
if
hasattr
(
self
,
"node"
):
worker_info
=
getworkerinfoline
(
self
.
node
)
if
worker_info
:
out
.
line
(
worker_info
)
longrepr
=
self
.
longrepr
if
longrepr
is
None
:
return
if
hasattr
(
longrepr
,
"toterminal"
):
longrepr_terminal
=
cast
(
TerminalRepr
,
longrepr
)
longrepr_terminal
.
toterminal
(
out
)
else
:
try
:
s
=
str
(
longrepr
)
except
UnicodeEncodeError
:
s
=
"<unprintable longrepr>"
out
.
line
(
s
)
def
get_sections
(
self
,
prefix
:
str
)
->
Iterator
[
tuple
[
str
,
str
]]:
for
name
,
content
in
self
.
sections
:
if
name
.
startswith
(
prefix
):
yield
prefix
,
content
@property
def
longreprtext
(
self
)
->
str
:
"""Read-only property that returns the full string representation of
``longrepr``.
.. versionadded:: 3.0
"""
file
=
StringIO
()
tw
=
TerminalWriter
(
file
)
tw
.
hasmarkup
=
False
self
.
toterminal
(
tw
)
exc
=
file
.
getvalue
()
return
exc
.
strip
()
@property
def
caplog
(
self
)
->
str
:
"""Return captured log lines, if log capturing is enabled.
.. versionadded:: 3.5
"""
return
"
\n
"
.
join
(
content
for
(
prefix
,
content
)
in
self
.
get_sections
(
"Captured log"
)
)
@property
def
capstdout
(
self
)
->
str
:
"""Return captured text from stdout, if capturing is enabled.
.. versionadded:: 3.0
"""
return
""
.
join
(
content
for
(
prefix
,
content
)
in
self
.
get_sections
(
"Captured stdout"
)
)
@property
def
capstderr
(
self
)
->
str
:
"""Return captured text from stderr, if capturing is enabled.
.. versionadded:: 3.0
"""
return
""
.
join
(
content
for
(
prefix
,
content
)
in
self
.
get_sections
(
"Captured stderr"
)
)
@property
def
passed
(
self
)
->
bool
:
"""Whether the outcome is passed."""
return
self
.
outcome
==
"passed"
@property
def
failed
(
self
)
->
bool
:
"""Whether the outcome is failed."""
return
self
.
outcome
==
"failed"
@property
def
skipped
(
self
)
->
bool
:
"""Whether the outcome is skipped."""
return
self
.
outcome
==
"skipped"
@property
def
fspath
(
self
)
->
str
:
"""The path portion of the reported node, as a string."""
return
self
.
nodeid
.
split
(
"::"
)[
0
]
@property
def
count_towards_summary
(
self
)
->
bool
:
"""**Experimental** Whether this report should be counted towards the
totals shown at the end of the test session: "1 passed, 1 failure, etc".
.. note::
This function is considered **experimental**, so beware that it is subject to changes
even in patch releases.
"""
return
True
@property
def
head_line
(
self
)
->
str
|
None
:
"""**Experimental** The head line shown with longrepr output for this
report, more commonly during traceback representation during
failures::
________ Test.foo ________
In the example above, the head_line is "Test.foo".
.. note::
This function is considered **experimental**, so beware that it is subject to changes
even in patch releases.
"""
if
self
.
location
is
not
None
:
fspath
,
lineno
,
domain
=
self
.
location
return
domain
return
None
def
_get_verbose_word_with_markup
(
self
,
config
:
Config
,
default_markup
:
Mapping
[
str
,
bool
]
)
->
tuple
[
str
,
Mapping
[
str
,
bool
]]:
_category
,
_short
,
verbose
=
config
.
hook
.
pytest_report_teststatus
(
report
=
self
,
config
=
config
)
if
isinstance
(
verbose
,
str
):
return
verbose
,
default_markup
if
isinstance
(
verbose
,
Sequence
)
and
len
(
verbose
)
==
2
:
word
,
markup
=
verbose
if
isinstance
(
word
,
str
)
and
isinstance
(
markup
,
Mapping
):
return
word
,
markup
fail
(
# pragma: no cover
"pytest_report_teststatus() hook (from a plugin) returned "
f
"an invalid verbose value:
{
verbose
!r}
.
\n
Expected either a string "
"or a tuple of (word, markup)."
)
def
_to_json
(
self
)
->
dict
[
str
,
Any
]:
"""Return the contents of this report as a dict of builtin entries,
suitable for serialization.
This was originally the serialize_report() function from xdist (ca03269).
Experimental method.
"""
return
_report_to_json
(
self
)
@classmethod
def
_from_json
(
cls
,
reportdict
:
dict
[
str
,
object
])
->
Self
:
"""Create either a TestReport or CollectReport, depending on the calling class.
It is the callers responsibility to know which class to pass here.
This was originally the serialize_report() function from xdist (ca03269).
Experimental method.
"""
kwargs
=
_report_kwargs_from_json
(
reportdict
)
return
cls
(
**
kwargs
)
def
_report_unserialization_failure
(
type_name
:
str
,
report_class
:
type
[
BaseReport
],
reportdict
)
->
NoReturn
:
url
=
"https://github.com/pytest-dev/pytest/issues"
stream
=
StringIO
()
pprint
(
"-"
*
100
,
stream
=
stream
)
pprint
(
f
"INTERNALERROR: Unknown entry type returned:
{
type_name
}
"
,
stream
=
stream
)
pprint
(
f
"report_name:
{
report_class
}
"
,
stream
=
stream
)
pprint
(
reportdict
,
stream
=
stream
)
pprint
(
f
"Please report this bug at
{
url
}
"
,
stream
=
stream
)
pprint
(
"-"
*
100
,
stream
=
stream
)
raise
RuntimeError
(
stream
.
getvalue
())
[docs]
@final
class
TestReport
(
BaseReport
):
"""Basic test report object (also used for setup and teardown calls if
they fail).
Reports can contain arbitrary extra attributes.
"""
__test__
=
False
# Defined by skipping plugin.
# xfail reason if xfailed, otherwise not defined. Use hasattr to distinguish.
wasxfail
:
str
def
__init__
(
self
,
nodeid
:
str
,
location
:
tuple
[
str
,
int
|
None
,
str
],
keywords
:
Mapping
[
str
,
Any
],
outcome
:
Literal
[
"passed"
,
"failed"
,
"skipped"
],
longrepr
:
None
|
ExceptionInfo
[
BaseException
]
|
tuple
[
str
,
int
,
str
]
|
str
|
TerminalRepr
,
when
:
Literal
[
"setup"
,
"call"
,
"teardown"
],
sections
:
Iterable
[
tuple
[
str
,
str
]]
=
(),
duration
:
float
=
0
,
start
:
float
=
0
,
stop
:
float
=
0
,
user_properties
:
Iterable
[
tuple
[
str
,
object
]]
|
None
=
None
,
**
extra
,
)
->
None
:
#: Normalized collection nodeid.
self
.
nodeid
=
nodeid
#: A (filesystempath, lineno, domaininfo) tuple indicating the
#: actual location of a test item - it might be different from the
#: collected one e.g. if a method is inherited from a different module.
#: The filesystempath may be relative to ``config.rootdir``.
#: The line number is 0-based.
self
.
location
:
tuple
[
str
,
int
|
None
,
str
]
=
location
#: A name -> value dictionary containing all keywords and
#: markers associated with a test invocation.
self
.
keywords
:
Mapping
[
str
,
Any
]
=
keywords
#: Test outcome, always one of "passed", "failed", "skipped".
self
.
outcome
=
outcome
#: None or a failure representation.
self
.
longrepr
=
longrepr
#: One of 'setup', 'call', 'teardown' to indicate runtest phase.
self
.
when
=
when
#: User properties is a list of tuples (name, value) that holds user
#: defined properties of the test.
self
.
user_properties
=
list
(
user_properties
or
[])
#: Tuples of str ``(heading, content)`` with extra information
#: for the test report. Used by pytest to add text captured
#: from ``stdout``, ``stderr``, and intercepted logging events. May
#: be used by other plugins to add arbitrary information to reports.
self
.
sections
=
list
(
sections
)
#: Time it took to run just the test.
self
.
duration
:
float
=
duration
#: The system time when the call started, in seconds since the epoch.
self
.
start
:
float
=
start
#: The system time when the call ended, in seconds since the epoch.
self
.
stop
:
float
=
stop
self
.
__dict__
.
update
(
extra
)
def
__repr__
(
self
)
->
str
:
return
f
"<
{
self
.
__class__
.
__name__
}
{
self
.
nodeid
!r}
when=
{
self
.
when
!r}
outcome=
{
self
.
outcome
!r}
>"
[docs]
@classmethod
def
from_item_and_call
(
cls
,
item
:
Item
,
call
:
CallInfo
[
None
])
->
TestReport
:
"""Create and fill a TestReport with standard item and call info.
:param item: The item.
:param call: The call info.
"""
when
=
call
.
when
# Remove "collect" from the Literal type -- only for collection calls.
assert
when
!=
"collect"
duration
=
call
.
duration
start
=
call
.
start
stop
=
call
.
stop
keywords
=
{
x
:
1
for
x
in
item
.
keywords
}
excinfo
=
call
.
excinfo
sections
=
[]
if
not
call
.
excinfo
:
outcome
:
Literal
[
"passed"
,
"failed"
,
"skipped"
]
=
"passed"
longrepr
:
(
None
|
ExceptionInfo
[
BaseException
]
|
tuple
[
str
,
int
,
str
]
|
str
|
TerminalRepr
)
=
None
else
:
if
not
isinstance
(
excinfo
,
ExceptionInfo
):
outcome
=
"failed"
longrepr
=
excinfo
elif
isinstance
(
excinfo
.
value
,
skip
.
Exception
):
outcome
=
"skipped"
r
=
excinfo
.
_getreprcrash
()
assert
(
r
is
not
None
),
"There should always be a traceback entry for skipping a test."
if
excinfo
.
value
.
_use_item_location
:
path
,
line
=
item
.
reportinfo
()[:
2
]
assert
line
is
not
None
longrepr
=
os
.
fspath
(
path
),
line
+
1
,
r
.
message
else
:
longrepr
=
(
str
(
r
.
path
),
r
.
lineno
,
r
.
message
)
else
:
outcome
=
"failed"
if
call
.
when
==
"call"
:
longrepr
=
item
.
repr_failure
(
excinfo
)
else
:
# exception in setup or teardown
longrepr
=
item
.
_repr_failure_py
(
excinfo
,
style
=
item
.
config
.
getoption
(
"tbstyle"
,
"auto"
)
)
for
rwhen
,
key
,
content
in
item
.
_report_sections
:
sections
.
append
((
f
"Captured
{
key
}
{
rwhen
}
"
,
content
))
return
cls
(
item
.
nodeid
,
item
.
location
,
keywords
,
outcome
,
longrepr
,
when
,
sections
,
duration
,
start
,
stop
,
user_properties
=
item
.
user_properties
,
)
[docs]
@final
class
CollectReport
(
BaseReport
):
"""Collection report object.
Reports can contain arbitrary extra attributes.
"""
when
=
"collect"
def
__init__
(
self
,
nodeid
:
str
,
outcome
:
Literal
[
"passed"
,
"failed"
,
"skipped"
],
longrepr
:
None
|
ExceptionInfo
[
BaseException
]
|
tuple
[
str
,
int
,
str
]
|
str
|
TerminalRepr
,
result
:
list
[
Item
|
Collector
]
|
None
,
sections
:
Iterable
[
tuple
[
str
,
str
]]
=
(),
**
extra
,
)
->
None
:
#: Normalized collection nodeid.
self
.
nodeid
=
nodeid
#: Test outcome, always one of "passed", "failed", "skipped".
self
.
outcome
=
outcome
#: None or a failure representation.
self
.
longrepr
=
longrepr
#: The collected items and collection nodes.
self
.
result
=
result
or
[]
#: Tuples of str ``(heading, content)`` with extra information
#: for the test report. Used by pytest to add text captured
#: from ``stdout``, ``stderr``, and intercepted logging events. May
#: be used by other plugins to add arbitrary information to reports.
self
.
sections
=
list
(
sections
)
self
.
__dict__
.
update
(
extra
)
@property
def
location
(
# type:ignore[override]
self
,
)
->
tuple
[
str
,
int
|
None
,
str
]
|
None
:
return
(
self
.
fspath
,
None
,
self
.
fspath
)
def
__repr__
(
self
)
->
str
:
return
f
"<CollectReport
{
self
.
nodeid
!r}
lenresult=
{
len
(
self
.
result
)
}
outcome=
{
self
.
outcome
!r}
>"
class
CollectErrorRepr
(
TerminalRepr
):
def
__init__
(
self
,
msg
:
str
)
->
None
:
self
.
longrepr
=
msg
def
toterminal
(
self
,
out
:
TerminalWriter
)
->
None
:
out
.
line
(
self
.
longrepr
,
red
=
True
)
def
pytest_report_to_serializable
(
report
:
CollectReport
|
TestReport
,
)
->
dict
[
str
,
Any
]
|
None
:
if
isinstance
(
report
,
(
TestReport
,
CollectReport
)):
data
=
report
.
_to_json
()
data
[
"$report_type"
]
=
report
.
__class__
.
__name__
return
data
# TODO: Check if this is actually reachable.
return
None
# type: ignore[unreachable]
def
pytest_report_from_serializable
(
data
:
dict
[
str
,
Any
],
)
->
CollectReport
|
TestReport
|
None
:
if
"$report_type"
in
data
:
if
data
[
"$report_type"
]
==
"TestReport"
:
return
TestReport
.
_from_json
(
data
)
elif
data
[
"$report_type"
]
==
"CollectReport"
:
return
CollectReport
.
_from_json
(
data
)
assert
False
,
"Unknown report_type unserialize data:
{}
"
.
format
(
data
[
"$report_type"
]
)
return
None
def
_report_to_json
(
report
:
BaseReport
)
->
dict
[
str
,
Any
]:
"""Return the contents of this report as a dict of builtin entries,
suitable for serialization.
This was originally the serialize_report() function from xdist (ca03269).
"""
def
serialize_repr_entry
(
entry
:
ReprEntry
|
ReprEntryNative
,
)
->
dict
[
str
,
Any
]:
data
=
dataclasses
.
asdict
(
entry
)
for
key
,
value
in
data
.
items
():
if
hasattr
(
value
,
"__dict__"
):
data
[
key
]
=
dataclasses
.
asdict
(
value
)
entry_data
=
{
"type"
:
type
(
entry
)
.
__name__
,
"data"
:
data
}
return
entry_data
def
serialize_repr_traceback
(
reprtraceback
:
ReprTraceback
)
->
dict
[
str
,
Any
]:
result
=
dataclasses
.
asdict
(
reprtraceback
)
result
[
"reprentries"
]
=
[
serialize_repr_entry
(
x
)
for
x
in
reprtraceback
.
reprentries
]
return
result
def
serialize_repr_crash
(
reprcrash
:
ReprFileLocation
|
None
,
)
->
dict
[
str
,
Any
]
|
None
:
if
reprcrash
is
not
None
:
return
dataclasses
.
asdict
(
reprcrash
)
else
:
return
None
def
serialize_exception_longrepr
(
rep
:
BaseReport
)
->
dict
[
str
,
Any
]:
assert
rep
.
longrepr
is
not
None
# TODO: Investigate whether the duck typing is really necessary here.
longrepr
=
cast
(
ExceptionRepr
,
rep
.
longrepr
)
result
:
dict
[
str
,
Any
]
=
{
"reprcrash"
:
serialize_repr_crash
(
longrepr
.
reprcrash
),
"reprtraceback"
:
serialize_repr_traceback
(
longrepr
.
reprtraceback
),
"sections"
:
longrepr
.
sections
,
}
if
isinstance
(
longrepr
,
ExceptionChainRepr
):
result
[
"chain"
]
=
[]
for
repr_traceback
,
repr_crash
,
description
in
longrepr
.
chain
:
result
[
"chain"
]
.
append
(
(
serialize_repr_traceback
(
repr_traceback
),
serialize_repr_crash
(
repr_crash
),
description
,
)
)
else
:
result
[
"chain"
]
=
None
return
result
d
=
report
.
__dict__
.
copy
()
if
hasattr
(
report
.
longrepr
,
"toterminal"
):
if
hasattr
(
report
.
longrepr
,
"reprtraceback"
)
and
hasattr
(
report
.
longrepr
,
"reprcrash"
):
d
[
"longrepr"
]
=
serialize_exception_longrepr
(
report
)
else
:
d
[
"longrepr"
]
=
str
(
report
.
longrepr
)
else
:
d
[
"longrepr"
]
=
report
.
longrepr
for
name
in
d
:
if
isinstance
(
d
[
name
],
os
.
PathLike
):
d
[
name
]
=
os
.
fspath
(
d
[
name
])
elif
name
==
"result"
:
d
[
name
]
=
None
# for now
return
d
def
_report_kwargs_from_json
(
reportdict
:
dict
[
str
,
Any
])
->
dict
[
str
,
Any
]:
"""Return **kwargs that can be used to construct a TestReport or
CollectReport instance.
This was originally the serialize_report() function from xdist (ca03269).
"""
def
deserialize_repr_entry
(
entry_data
):
data
=
entry_data
[
"data"
]
entry_type
=
entry_data
[
"type"
]
if
entry_type
==
"ReprEntry"
:
reprfuncargs
=
None
reprfileloc
=
None
reprlocals
=
None
if
data
[
"reprfuncargs"
]:
reprfuncargs
=
ReprFuncArgs
(
**
data
[
"reprfuncargs"
])
if
data
[
"reprfileloc"
]:
reprfileloc
=
ReprFileLocation
(
**
data
[
"reprfileloc"
])
if
data
[
"reprlocals"
]:
reprlocals
=
ReprLocals
(
data
[
"reprlocals"
][
"lines"
])
reprentry
:
ReprEntry
|
ReprEntryNative
=
ReprEntry
(
lines
=
data
[
"lines"
],
reprfuncargs
=
reprfuncargs
,
reprlocals
=
reprlocals
,
reprfileloc
=
reprfileloc
,
style
=
data
[
"style"
],
)
elif
entry_type
==
"ReprEntryNative"
:
reprentry
=
ReprEntryNative
(
data
[
"lines"
])
else
:
_report_unserialization_failure
(
entry_type
,
TestReport
,
reportdict
)
return
reprentry
def
deserialize_repr_traceback
(
repr_traceback_dict
):
repr_traceback_dict
[
"reprentries"
]
=
[
deserialize_repr_entry
(
x
)
for
x
in
repr_traceback_dict
[
"reprentries"
]
]
return
ReprTraceback
(
**
repr_traceback_dict
)
def
deserialize_repr_crash
(
repr_crash_dict
:
dict
[
str
,
Any
]
|
None
):
if
repr_crash_dict
is
not
None
:
return
ReprFileLocation
(
**
repr_crash_dict
)
else
:
return
None
if
(
reportdict
[
"longrepr"
]
and
"reprcrash"
in
reportdict
[
"longrepr"
]
and
"reprtraceback"
in
reportdict
[
"longrepr"
]
):
reprtraceback
=
deserialize_repr_traceback
(
reportdict
[
"longrepr"
][
"reprtraceback"
]
)
reprcrash
=
deserialize_repr_crash
(
reportdict
[
"longrepr"
][
"reprcrash"
])
if
reportdict
[
"longrepr"
][
"chain"
]:
chain
=
[]
for
repr_traceback_data
,
repr_crash_data
,
description
in
reportdict
[
"longrepr"
][
"chain"
]:
chain
.
append
(
(
deserialize_repr_traceback
(
repr_traceback_data
),
deserialize_repr_crash
(
repr_crash_data
),
description
,
)
)
exception_info
:
ExceptionChainRepr
|
ReprExceptionInfo
=
ExceptionChainRepr
(
chain
)
else
:
exception_info
=
ReprExceptionInfo
(
reprtraceback
=
reprtraceback
,
reprcrash
=
reprcrash
,
)
for
section
in
reportdict
[
"longrepr"
][
"sections"
]:
exception_info
.
addsection
(
*
section
)
reportdict
[
"longrepr"
]
=
exception_info
return
reportdict

```


---


# _pytest.freeze_support - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/freeze_support.html


# Source code for _pytest.freeze_support

```

"""Provides a function to report all internal modules for using freezing
tools."""
from
__future__
import
annotations
import
types
from
typing
import
Iterator
[docs]
def
freeze_includes
()
->
list
[
str
]:
"""Return a list of module names used by pytest that should be
included by cx_freeze."""
import
_pytest
result
=
list
(
_iter_all_modules
(
_pytest
))
return
result
def
_iter_all_modules
(
package
:
str
|
types
.
ModuleType
,
prefix
:
str
=
""
,
)
->
Iterator
[
str
]:
"""Iterate over the names of all modules that can be found in the given
package, recursively.
>>> import _pytest
>>> list(_iter_all_modules(_pytest))
['_pytest._argcomplete', '_pytest._code.code', ...]
"""
import
os
import
pkgutil
if
isinstance
(
package
,
str
):
path
=
package
else
:
# Type ignored because typeshed doesn't define ModuleType.__path__
# (only defined on packages).
package_path
=
package
.
__path__
path
,
prefix
=
package_path
[
0
],
package
.
__name__
+
"."
for
_
,
name
,
is_package
in
pkgutil
.
iter_modules
([
path
]):
if
is_package
:
for
m
in
_iter_all_modules
(
os
.
path
.
join
(
path
,
name
),
prefix
=
name
+
"."
):
yield
prefix
+
m
else
:
yield
prefix
+
name

```


---


# _pytest.mark - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/mark.html


# Source code for _pytest.mark

```

"""Generic mechanism for marking and selecting python functions."""
from
__future__
import
annotations
import
collections
import
dataclasses
from
typing
import
AbstractSet
from
typing
import
Collection
from
typing
import
Iterable
from
typing
import
Optional
from
typing
import
TYPE_CHECKING
from
.expression
import
Expression
from
.expression
import
ParseError
from
.structures
import
EMPTY_PARAMETERSET_OPTION
from
.structures
import
get_empty_parameterset_mark
from
.structures
import
Mark
from
.structures
import
MARK_GEN
from
.structures
import
MarkDecorator
from
.structures
import
MarkGenerator
from
.structures
import
ParameterSet
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config
import
hookimpl
from
_pytest.config
import
UsageError
from
_pytest.config.argparsing
import
NOT_SET
from
_pytest.config.argparsing
import
Parser
from
_pytest.stash
import
StashKey
if
TYPE_CHECKING
:
from
_pytest.nodes
import
Item
__all__
=
[
"MARK_GEN"
,
"Mark"
,
"MarkDecorator"
,
"MarkGenerator"
,
"ParameterSet"
,
"get_empty_parameterset_mark"
,
]
old_mark_config_key
=
StashKey
[
Optional
[
Config
]]()
[docs]
def
param
(
*
values
:
object
,
marks
:
MarkDecorator
|
Collection
[
MarkDecorator
|
Mark
]
=
(),
id
:
str
|
None
=
None
,
)
->
ParameterSet
:
"""Specify a parameter in `pytest.mark.parametrize`_ calls or
:ref:`parametrized fixtures <fixture-parametrize-marks>`.
.. code-block:: python
@pytest.mark.parametrize(
"test_input,expected",
[
("3+5", 8),
pytest.param("6*9", 42, marks=pytest.mark.xfail),
],
)
def test_eval(test_input, expected):
assert eval(test_input) == expected
:param values: Variable args of the values of the parameter set, in order.
:param marks: A single mark or a list of marks to be applied to this parameter set.
:param id: The id to attribute to this parameter set.
"""
return
ParameterSet
.
param
(
*
values
,
marks
=
marks
,
id
=
id
)
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"general"
)
group
.
_addoption
(
"-k"
,
action
=
"store"
,
dest
=
"keyword"
,
default
=
""
,
metavar
=
"EXPRESSION"
,
help
=
"Only run tests which match the given substring expression. "
"An expression is a Python evaluable expression "
"where all names are substring-matched against test names "
"and their parent classes. Example: -k 'test_method or test_"
"other' matches all test functions and classes whose name "
"contains 'test_method' or 'test_other', while -k 'not test_method' "
"matches those that don't contain 'test_method' in their names. "
"-k 'not test_method and not test_other' will eliminate the matches. "
"Additionally keywords are matched to classes and functions "
"containing extra names in their 'extra_keyword_matches' set, "
"as well as functions which have names assigned directly to them. "
"The matching is case-insensitive."
,
)
group
.
_addoption
(
"-m"
,
action
=
"store"
,
dest
=
"markexpr"
,
default
=
""
,
metavar
=
"MARKEXPR"
,
help
=
"Only run tests matching given mark expression. "
"For example: -m 'mark1 and not mark2'."
,
)
group
.
addoption
(
"--markers"
,
action
=
"store_true"
,
help
=
"show markers (builtin, plugin and per-project ones)."
,
)
parser
.
addini
(
"markers"
,
"Register new markers for test functions"
,
"linelist"
)
parser
.
addini
(
EMPTY_PARAMETERSET_OPTION
,
"Default marker for empty parametersets"
)
@hookimpl
(
tryfirst
=
True
)
def
pytest_cmdline_main
(
config
:
Config
)
->
int
|
ExitCode
|
None
:
import
_pytest.config
if
config
.
option
.
markers
:
config
.
_do_configure
()
tw
=
_pytest
.
config
.
create_terminal_writer
(
config
)
for
line
in
config
.
getini
(
"markers"
):
parts
=
line
.
split
(
":"
,
1
)
name
=
parts
[
0
]
rest
=
parts
[
1
]
if
len
(
parts
)
==
2
else
""
tw
.
write
(
f
"@pytest.mark.
{
name
}
:"
,
bold
=
True
)
tw
.
line
(
rest
)
tw
.
line
()
config
.
_ensure_unconfigure
()
return
0
return
None
@dataclasses
.
dataclass
class
KeywordMatcher
:
"""A matcher for keywords.
Given a list of names, matches any substring of one of these names. The
string inclusion check is case-insensitive.
Will match on the name of colitem, including the names of its parents.
Only matches names of items which are either a :class:`Class` or a
:class:`Function`.
Additionally, matches on names in the 'extra_keyword_matches' set of
any item, as well as names directly assigned to test functions.
"""
__slots__
=
(
"_names"
,)
_names
:
AbstractSet
[
str
]
@classmethod
def
from_item
(
cls
,
item
:
Item
)
->
KeywordMatcher
:
mapped_names
=
set
()
# Add the names of the current item and any parent items,
# except the Session and root Directory's which are not
# interesting for matching.
import
pytest
for
node
in
item
.
listchain
():
if
isinstance
(
node
,
pytest
.
Session
):
continue
if
isinstance
(
node
,
pytest
.
Directory
)
and
isinstance
(
node
.
parent
,
pytest
.
Session
):
continue
mapped_names
.
add
(
node
.
name
)
# Add the names added as extra keywords to current or parent items.
mapped_names
.
update
(
item
.
listextrakeywords
())
# Add the names attached to the current function through direct assignment.
function_obj
=
getattr
(
item
,
"function"
,
None
)
if
function_obj
:
mapped_names
.
update
(
function_obj
.
__dict__
)
# Add the markers to the keywords as we no longer handle them correctly.
mapped_names
.
update
(
mark
.
name
for
mark
in
item
.
iter_markers
())
return
cls
(
mapped_names
)
def
__call__
(
self
,
subname
:
str
,
/
,
**
kwargs
:
str
|
int
|
bool
|
None
)
->
bool
:
if
kwargs
:
raise
UsageError
(
"Keyword expressions do not support call parameters."
)
subname
=
subname
.
lower
()
names
=
(
name
.
lower
()
for
name
in
self
.
_names
)
for
name
in
names
:
if
subname
in
name
:
return
True
return
False
def
deselect_by_keyword
(
items
:
list
[
Item
],
config
:
Config
)
->
None
:
keywordexpr
=
config
.
option
.
keyword
.
lstrip
()
if
not
keywordexpr
:
return
expr
=
_parse_expression
(
keywordexpr
,
"Wrong expression passed to '-k'"
)
remaining
=
[]
deselected
=
[]
for
colitem
in
items
:
if
not
expr
.
evaluate
(
KeywordMatcher
.
from_item
(
colitem
)):
deselected
.
append
(
colitem
)
else
:
remaining
.
append
(
colitem
)
if
deselected
:
config
.
hook
.
pytest_deselected
(
items
=
deselected
)
items
[:]
=
remaining
@dataclasses
.
dataclass
class
MarkMatcher
:
"""A matcher for markers which are present.
Tries to match on any marker names, attached to the given colitem.
"""
__slots__
=
(
"own_mark_name_mapping"
,)
own_mark_name_mapping
:
dict
[
str
,
list
[
Mark
]]
@classmethod
def
from_markers
(
cls
,
markers
:
Iterable
[
Mark
])
->
MarkMatcher
:
mark_name_mapping
=
collections
.
defaultdict
(
list
)
for
mark
in
markers
:
mark_name_mapping
[
mark
.
name
]
.
append
(
mark
)
return
cls
(
mark_name_mapping
)
def
__call__
(
self
,
name
:
str
,
/
,
**
kwargs
:
str
|
int
|
bool
|
None
)
->
bool
:
if
not
(
matches
:=
self
.
own_mark_name_mapping
.
get
(
name
,
[])):
return
False
for
mark
in
matches
:
if
all
(
mark
.
kwargs
.
get
(
k
,
NOT_SET
)
==
v
for
k
,
v
in
kwargs
.
items
()):
return
True
return
False
def
deselect_by_mark
(
items
:
list
[
Item
],
config
:
Config
)
->
None
:
matchexpr
=
config
.
option
.
markexpr
if
not
matchexpr
:
return
expr
=
_parse_expression
(
matchexpr
,
"Wrong expression passed to '-m'"
)
remaining
:
list
[
Item
]
=
[]
deselected
:
list
[
Item
]
=
[]
for
item
in
items
:
if
expr
.
evaluate
(
MarkMatcher
.
from_markers
(
item
.
iter_markers
())):
remaining
.
append
(
item
)
else
:
deselected
.
append
(
item
)
if
deselected
:
config
.
hook
.
pytest_deselected
(
items
=
deselected
)
items
[:]
=
remaining
def
_parse_expression
(
expr
:
str
,
exc_message
:
str
)
->
Expression
:
try
:
return
Expression
.
compile
(
expr
)
except
ParseError
as
e
:
raise
UsageError
(
f
"
{
exc_message
}
:
{
expr
}
:
{
e
}
"
)
from
None
def
pytest_collection_modifyitems
(
items
:
list
[
Item
],
config
:
Config
)
->
None
:
deselect_by_keyword
(
items
,
config
)
deselect_by_mark
(
items
,
config
)
def
pytest_configure
(
config
:
Config
)
->
None
:
config
.
stash
[
old_mark_config_key
]
=
MARK_GEN
.
_config
MARK_GEN
.
_config
=
config
empty_parameterset
=
config
.
getini
(
EMPTY_PARAMETERSET_OPTION
)
if
empty_parameterset
not
in
(
"skip"
,
"xfail"
,
"fail_at_collect"
,
None
,
""
):
raise
UsageError
(
f
"
{
EMPTY_PARAMETERSET_OPTION
!s}
must be one of skip, xfail or fail_at_collect"
f
" but it is
{
empty_parameterset
!r}
"
)
def
pytest_unconfigure
(
config
:
Config
)
->
None
:
MARK_GEN
.
_config
=
config
.
stash
.
get
(
old_mark_config_key
,
None
)

```


---


# _pytest.nodes - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/nodes.html


# Source code for _pytest.nodes

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
import
abc
from
functools
import
cached_property
from
inspect
import
signature
import
os
import
pathlib
from
pathlib
import
Path
from
typing
import
Any
from
typing
import
Callable
from
typing
import
cast
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
MutableMapping
from
typing
import
NoReturn
from
typing
import
overload
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
import
warnings
import
pluggy
import
_pytest._code
from
_pytest._code
import
getfslineno
from
_pytest._code.code
import
ExceptionInfo
from
_pytest._code.code
import
TerminalRepr
from
_pytest._code.code
import
Traceback
from
_pytest._code.code
import
TracebackStyle
from
_pytest.compat
import
LEGACY_PATH
from
_pytest.config
import
Config
from
_pytest.config
import
ConftestImportFailure
from
_pytest.config.compat
import
_check_path
from
_pytest.deprecated
import
NODE_CTOR_FSPATH_ARG
from
_pytest.mark.structures
import
Mark
from
_pytest.mark.structures
import
MarkDecorator
from
_pytest.mark.structures
import
NodeKeywords
from
_pytest.outcomes
import
fail
from
_pytest.pathlib
import
absolutepath
from
_pytest.pathlib
import
commonpath
from
_pytest.stash
import
Stash
from
_pytest.warning_types
import
PytestWarning
if
TYPE_CHECKING
:
from
typing_extensions
import
Self
# Imported here due to circular import.
from
_pytest.main
import
Session
SEP
=
"/"
tracebackcutdir
=
Path
(
_pytest
.
__file__
)
.
parent
_T
=
TypeVar
(
"_T"
)
def
_imply_path
(
node_type
:
type
[
Node
],
path
:
Path
|
None
,
fspath
:
LEGACY_PATH
|
None
,
)
->
Path
:
if
fspath
is
not
None
:
warnings
.
warn
(
NODE_CTOR_FSPATH_ARG
.
format
(
node_type_name
=
node_type
.
__name__
,
),
stacklevel
=
6
,
)
if
path
is
not
None
:
if
fspath
is
not
None
:
_check_path
(
path
,
fspath
)
return
path
else
:
assert
fspath
is
not
None
return
Path
(
fspath
)
_NodeType
=
TypeVar
(
"_NodeType"
,
bound
=
"Node"
)
class
NodeMeta
(
abc
.
ABCMeta
):
"""Metaclass used by :class:`Node` to enforce that direct construction raises
:class:`Failed`.
This behaviour supports the indirection introduced with :meth:`Node.from_parent`,
the named constructor to be used instead of direct construction. The design
decision to enforce indirection with :class:`NodeMeta` was made as a
temporary aid for refactoring the collection tree, which was diagnosed to
have :class:`Node` objects whose creational patterns were overly entangled.
Once the refactoring is complete, this metaclass can be removed.
See https://github.com/pytest-dev/pytest/projects/3 for an overview of the
progress on detangling the :class:`Node` classes.
"""
def
__call__
(
cls
,
*
k
,
**
kw
)
->
NoReturn
:
msg
=
(
"Direct construction of
{name}
has been deprecated, please use
{name}
.from_parent.
\n
"
"See "
"https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent"
" for more details."
)
.
format
(
name
=
f
"
{
cls
.
__module__
}
.
{
cls
.
__name__
}
"
)
fail
(
msg
,
pytrace
=
False
)
def
_create
(
cls
:
type
[
_T
],
*
k
,
**
kw
)
->
_T
:
try
:
return
super
()
.
__call__
(
*
k
,
**
kw
)
# type: ignore[no-any-return,misc]
except
TypeError
:
sig
=
signature
(
getattr
(
cls
,
"__init__"
))
known_kw
=
{
k
:
v
for
k
,
v
in
kw
.
items
()
if
k
in
sig
.
parameters
}
from
.warning_types
import
PytestDeprecationWarning
warnings
.
warn
(
PytestDeprecationWarning
(
f
"
{
cls
}
is not using a cooperative constructor and only takes
{
set
(
known_kw
)
}
.
\n
"
"See https://docs.pytest.org/en/stable/deprecations.html"
"#constructors-of-custom-pytest-node-subclasses-should-take-kwargs "
"for more details."
)
)
return
super
()
.
__call__
(
*
k
,
**
known_kw
)
# type: ignore[no-any-return,misc]
[docs]
class
Node
(
abc
.
ABC
,
metaclass
=
NodeMeta
):
r
"""Base class of :class:`Collector` and :class:`Item`, the components of
the test collection tree.
``Collector``\'s are the internal nodes of the tree, and ``Item``\'s are the
leaf nodes.
"""
# Implemented in the legacypath plugin.
#: A ``LEGACY_PATH`` copy of the :attr:`path` attribute. Intended for usage
#: for methods not migrated to ``pathlib.Path`` yet, such as
#: :meth:`Item.reportinfo <pytest.Item.reportinfo>`. Will be deprecated in
#: a future release, prefer using :attr:`path` instead.
fspath
:
LEGACY_PATH
# Use __slots__ to make attribute access faster.
# Note that __dict__ is still available.
__slots__
=
(
"name"
,
"parent"
,
"config"
,
"session"
,
"path"
,
"_nodeid"
,
"_store"
,
"__dict__"
,
)
def
__init__
(
self
,
name
:
str
,
parent
:
Node
|
None
=
None
,
config
:
Config
|
None
=
None
,
session
:
Session
|
None
=
None
,
fspath
:
LEGACY_PATH
|
None
=
None
,
path
:
Path
|
None
=
None
,
nodeid
:
str
|
None
=
None
,
)
->
None
:
#: A unique name within the scope of the parent node.
self
.
name
:
str
=
name
#: The parent collector node.
self
.
parent
=
parent
if
config
:
#: The pytest config object.
self
.
config
:
Config
=
config
else
:
if
not
parent
:
raise
TypeError
(
"config or parent must be provided"
)
self
.
config
=
parent
.
config
if
session
:
#: The pytest session this node is part of.
self
.
session
:
Session
=
session
else
:
if
not
parent
:
raise
TypeError
(
"session or parent must be provided"
)
self
.
session
=
parent
.
session
if
path
is
None
and
fspath
is
None
:
path
=
getattr
(
parent
,
"path"
,
None
)
#: Filesystem path where this node was collected from (can be None).
self
.
path
:
pathlib
.
Path
=
_imply_path
(
type
(
self
),
path
,
fspath
=
fspath
)
# The explicit annotation is to avoid publicly exposing NodeKeywords.
#: Keywords/markers collected from all scopes.
self
.
keywords
:
MutableMapping
[
str
,
Any
]
=
NodeKeywords
(
self
)
#: The marker objects belonging to this node.
self
.
own_markers
:
list
[
Mark
]
=
[]
#: Allow adding of extra keywords to use for matching.
self
.
extra_keyword_matches
:
set
[
str
]
=
set
()
if
nodeid
is
not
None
:
assert
"::()"
not
in
nodeid
self
.
_nodeid
=
nodeid
else
:
if
not
self
.
parent
:
raise
TypeError
(
"nodeid or parent must be provided"
)
self
.
_nodeid
=
self
.
parent
.
nodeid
+
"::"
+
self
.
name
#: A place where plugins can store information on the node for their
#: own use.
self
.
stash
:
Stash
=
Stash
()
# Deprecated alias. Was never public. Can be removed in a few releases.
self
.
_store
=
self
.
stash
[docs]
@classmethod
def
from_parent
(
cls
,
parent
:
Node
,
**
kw
)
->
Self
:
"""Public constructor for Nodes.
This indirection got introduced in order to enable removing
the fragile logic from the node constructors.
Subclasses can use ``super().from_parent(...)`` when overriding the
construction.
:param parent: The parent node of this Node.
"""
if
"config"
in
kw
:
raise
TypeError
(
"config is not a valid argument for from_parent"
)
if
"session"
in
kw
:
raise
TypeError
(
"session is not a valid argument for from_parent"
)
return
cls
.
_create
(
parent
=
parent
,
**
kw
)
@property
def
ihook
(
self
)
->
pluggy
.
HookRelay
:
"""fspath-sensitive hook proxy used to call pytest hooks."""
return
self
.
session
.
gethookproxy
(
self
.
path
)
def
__repr__
(
self
)
->
str
:
return
"<
{}
{}
>"
.
format
(
self
.
__class__
.
__name__
,
getattr
(
self
,
"name"
,
None
))
[docs]
def
warn
(
self
,
warning
:
Warning
)
->
None
:
"""Issue a warning for this Node.
Warnings will be displayed after the test session, unless explicitly suppressed.
:param Warning warning:
The warning instance to issue.
:raises ValueError: If ``warning`` instance is not a subclass of Warning.
Example usage:
.. code-block:: python
node.warn(PytestWarning("some message"))
node.warn(UserWarning("some message"))
.. versionchanged:: 6.2
Any subclass of :class:`Warning` is now accepted, rather than only
:class:`PytestWarning <pytest.PytestWarning>` subclasses.
"""
# enforce type checks here to avoid getting a generic type error later otherwise.
if
not
isinstance
(
warning
,
Warning
):
raise
ValueError
(
f
"warning must be an instance of Warning or subclass, got
{
warning
!r}
"
)
path
,
lineno
=
get_fslocation_from_item
(
self
)
assert
lineno
is
not
None
warnings
.
warn_explicit
(
warning
,
category
=
None
,
filename
=
str
(
path
),
lineno
=
lineno
+
1
,
)
# Methods for ordering nodes.
@property
def
nodeid
(
self
)
->
str
:
"""A ::-separated string denoting its collection tree address."""
return
self
.
_nodeid
def
__hash__
(
self
)
->
int
:
return
hash
(
self
.
_nodeid
)
def
setup
(
self
)
->
None
:
pass
def
teardown
(
self
)
->
None
:
pass
[docs]
def
iter_parents
(
self
)
->
Iterator
[
Node
]:
"""Iterate over all parent collectors starting from and including self
up to the root of the collection tree.
.. versionadded:: 8.1
"""
parent
:
Node
|
None
=
self
while
parent
is
not
None
:
yield
parent
parent
=
parent
.
parent
[docs]
def
listchain
(
self
)
->
list
[
Node
]:
"""Return a list of all parent collectors starting from the root of the
collection tree down to and including self."""
chain
=
[]
item
:
Node
|
None
=
self
while
item
is
not
None
:
chain
.
append
(
item
)
item
=
item
.
parent
chain
.
reverse
()
return
chain
[docs]
def
add_marker
(
self
,
marker
:
str
|
MarkDecorator
,
append
:
bool
=
True
)
->
None
:
"""Dynamically add a marker object to the node.
:param marker:
The marker.
:param append:
Whether to append the marker, or prepend it.
"""
from
_pytest.mark
import
MARK_GEN
if
isinstance
(
marker
,
MarkDecorator
):
marker_
=
marker
elif
isinstance
(
marker
,
str
):
marker_
=
getattr
(
MARK_GEN
,
marker
)
else
:
raise
ValueError
(
"is not a string or pytest.mark.* Marker"
)
self
.
keywords
[
marker_
.
name
]
=
marker_
if
append
:
self
.
own_markers
.
append
(
marker_
.
mark
)
else
:
self
.
own_markers
.
insert
(
0
,
marker_
.
mark
)
[docs]
def
iter_markers
(
self
,
name
:
str
|
None
=
None
)
->
Iterator
[
Mark
]:
"""Iterate over all markers of the node.
:param name: If given, filter the results by the name attribute.
:returns: An iterator of the markers of the node.
"""
return
(
x
[
1
]
for
x
in
self
.
iter_markers_with_node
(
name
=
name
))
[docs]
def
iter_markers_with_node
(
self
,
name
:
str
|
None
=
None
)
->
Iterator
[
tuple
[
Node
,
Mark
]]:
"""Iterate over all markers of the node.
:param name: If given, filter the results by the name attribute.
:returns: An iterator of (node, mark) tuples.
"""
for
node
in
self
.
iter_parents
():
for
mark
in
node
.
own_markers
:
if
name
is
None
or
getattr
(
mark
,
"name"
,
None
)
==
name
:
yield
node
,
mark
@overload
def
get_closest_marker
(
self
,
name
:
str
)
->
Mark
|
None
:
...
@overload
def
get_closest_marker
(
self
,
name
:
str
,
default
:
Mark
)
->
Mark
:
...
[docs]
def
get_closest_marker
(
self
,
name
:
str
,
default
:
Mark
|
None
=
None
)
->
Mark
|
None
:
"""Return the first marker matching the name, from closest (for
example function) to farther level (for example module level).
:param default: Fallback return value if no marker was found.
:param name: Name to filter by.
"""
return
next
(
self
.
iter_markers
(
name
=
name
),
default
)
[docs]
def
listextrakeywords
(
self
)
->
set
[
str
]:
"""Return a set of all extra keywords in self and any parents."""
extra_keywords
:
set
[
str
]
=
set
()
for
item
in
self
.
listchain
():
extra_keywords
.
update
(
item
.
extra_keyword_matches
)
return
extra_keywords
def
listnames
(
self
)
->
list
[
str
]:
return
[
x
.
name
for
x
in
self
.
listchain
()]
[docs]
def
addfinalizer
(
self
,
fin
:
Callable
[[],
object
])
->
None
:
"""Register a function to be called without arguments when this node is
finalized.
This method can only be called when this node is active
in a setup chain, for example during self.setup().
"""
self
.
session
.
_setupstate
.
addfinalizer
(
fin
,
self
)
[docs]
def
getparent
(
self
,
cls
:
type
[
_NodeType
])
->
_NodeType
|
None
:
"""Get the closest parent node (including self) which is an instance of
the given class.
:param cls: The node class to search for.
:returns: The node, if found.
"""
for
node
in
self
.
iter_parents
():
if
isinstance
(
node
,
cls
):
return
node
return
None
def
_traceback_filter
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
])
->
Traceback
:
return
excinfo
.
traceback
def
_repr_failure_py
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
],
style
:
TracebackStyle
|
None
=
None
,
)
->
TerminalRepr
:
from
_pytest.fixtures
import
FixtureLookupError
if
isinstance
(
excinfo
.
value
,
ConftestImportFailure
):
excinfo
=
ExceptionInfo
.
from_exception
(
excinfo
.
value
.
cause
)
if
isinstance
(
excinfo
.
value
,
fail
.
Exception
):
if
not
excinfo
.
value
.
pytrace
:
style
=
"value"
if
isinstance
(
excinfo
.
value
,
FixtureLookupError
):
return
excinfo
.
value
.
formatrepr
()
tbfilter
:
bool
|
Callable
[[
ExceptionInfo
[
BaseException
]],
Traceback
]
if
self
.
config
.
getoption
(
"fulltrace"
,
False
):
style
=
"long"
tbfilter
=
False
else
:
tbfilter
=
self
.
_traceback_filter
if
style
==
"auto"
:
style
=
"long"
# XXX should excinfo.getrepr record all data and toterminal() process it?
if
style
is
None
:
if
self
.
config
.
getoption
(
"tbstyle"
,
"auto"
)
==
"short"
:
style
=
"short"
else
:
style
=
"long"
if
self
.
config
.
get_verbosity
()
>
1
:
truncate_locals
=
False
else
:
truncate_locals
=
True
truncate_args
=
False
if
self
.
config
.
get_verbosity
()
>
2
else
True
# excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.
# It is possible for a fixture/test to change the CWD while this code runs, which
# would then result in the user seeing confusing paths in the failure message.
# To fix this, if the CWD changed, always display the full absolute path.
# It will be better to just always display paths relative to invocation_dir, but
# this requires a lot of plumbing (#6428).
try
:
abspath
=
Path
(
os
.
getcwd
())
!=
self
.
config
.
invocation_params
.
dir
except
OSError
:
abspath
=
True
return
excinfo
.
getrepr
(
funcargs
=
True
,
abspath
=
abspath
,
showlocals
=
self
.
config
.
getoption
(
"showlocals"
,
False
),
style
=
style
,
tbfilter
=
tbfilter
,
truncate_locals
=
truncate_locals
,
truncate_args
=
truncate_args
,
)
[docs]
def
repr_failure
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
],
style
:
TracebackStyle
|
None
=
None
,
)
->
str
|
TerminalRepr
:
"""Return a representation of a collection or test failure.
.. seealso:: :ref:`non-python tests`
:param excinfo: Exception information for the failure.
"""
return
self
.
_repr_failure_py
(
excinfo
,
style
)
def
get_fslocation_from_item
(
node
:
Node
)
->
tuple
[
str
|
Path
,
int
|
None
]:
"""Try to extract the actual location from a node, depending on available attributes:
* "location": a pair (path, lineno)
* "obj": a Python object that the node wraps.
* "path": just a path
:rtype: A tuple of (str|Path, int) with filename and 0-based line number.
"""
# See Item.location.
location
:
tuple
[
str
,
int
|
None
,
str
]
|
None
=
getattr
(
node
,
"location"
,
None
)
if
location
is
not
None
:
return
location
[:
2
]
obj
=
getattr
(
node
,
"obj"
,
None
)
if
obj
is
not
None
:
return
getfslineno
(
obj
)
return
getattr
(
node
,
"path"
,
"unknown location"
),
-
1
[docs]
class
Collector
(
Node
,
abc
.
ABC
):
"""Base class of all collectors.
Collector create children through `collect()` and thus iteratively build
the collection tree.
"""
[docs]
class
CollectError
(
Exception
):
"""An error during collection, contains a custom message."""
[docs]
@abc
.
abstractmethod
def
collect
(
self
)
->
Iterable
[
Item
|
Collector
]:
"""Collect children (items and collectors) for this collector."""
raise
NotImplementedError
(
"abstract"
)
# TODO: This omits the style= parameter which breaks Liskov Substitution.
[docs]
def
repr_failure
(
# type: ignore[override]
self
,
excinfo
:
ExceptionInfo
[
BaseException
]
)
->
str
|
TerminalRepr
:
"""Return a representation of a collection failure.
:param excinfo: Exception information for the failure.
"""
if
isinstance
(
excinfo
.
value
,
self
.
CollectError
)
and
not
self
.
config
.
getoption
(
"fulltrace"
,
False
):
exc
=
excinfo
.
value
return
str
(
exc
.
args
[
0
])
# Respect explicit tbstyle option, but default to "short"
# (_repr_failure_py uses "long" with "fulltrace" option always).
tbstyle
=
self
.
config
.
getoption
(
"tbstyle"
,
"auto"
)
if
tbstyle
==
"auto"
:
tbstyle
=
"short"
return
self
.
_repr_failure_py
(
excinfo
,
style
=
tbstyle
)
def
_traceback_filter
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
])
->
Traceback
:
if
hasattr
(
self
,
"path"
):
traceback
=
excinfo
.
traceback
ntraceback
=
traceback
.
cut
(
path
=
self
.
path
)
if
ntraceback
==
traceback
:
ntraceback
=
ntraceback
.
cut
(
excludepath
=
tracebackcutdir
)
return
ntraceback
.
filter
(
excinfo
)
return
excinfo
.
traceback
def
_check_initialpaths_for_relpath
(
session
:
Session
,
path
:
Path
)
->
str
|
None
:
for
initial_path
in
session
.
_initialpaths
:
if
commonpath
(
path
,
initial_path
)
==
initial_path
:
rel
=
str
(
path
.
relative_to
(
initial_path
))
return
""
if
rel
==
"."
else
rel
return
None
[docs]
class
FSCollector
(
Collector
,
abc
.
ABC
):
"""Base class for filesystem collectors."""
def
__init__
(
self
,
fspath
:
LEGACY_PATH
|
None
=
None
,
path_or_parent
:
Path
|
Node
|
None
=
None
,
path
:
Path
|
None
=
None
,
name
:
str
|
None
=
None
,
parent
:
Node
|
None
=
None
,
config
:
Config
|
None
=
None
,
session
:
Session
|
None
=
None
,
nodeid
:
str
|
None
=
None
,
)
->
None
:
if
path_or_parent
:
if
isinstance
(
path_or_parent
,
Node
):
assert
parent
is
None
parent
=
cast
(
FSCollector
,
path_or_parent
)
elif
isinstance
(
path_or_parent
,
Path
):
assert
path
is
None
path
=
path_or_parent
path
=
_imply_path
(
type
(
self
),
path
,
fspath
=
fspath
)
if
name
is
None
:
name
=
path
.
name
if
parent
is
not
None
and
parent
.
path
!=
path
:
try
:
rel
=
path
.
relative_to
(
parent
.
path
)
except
ValueError
:
pass
else
:
name
=
str
(
rel
)
name
=
name
.
replace
(
os
.
sep
,
SEP
)
self
.
path
=
path
if
session
is
None
:
assert
parent
is
not
None
session
=
parent
.
session
if
nodeid
is
None
:
try
:
nodeid
=
str
(
self
.
path
.
relative_to
(
session
.
config
.
rootpath
))
except
ValueError
:
nodeid
=
_check_initialpaths_for_relpath
(
session
,
path
)
if
nodeid
and
os
.
sep
!=
SEP
:
nodeid
=
nodeid
.
replace
(
os
.
sep
,
SEP
)
super
()
.
__init__
(
name
=
name
,
parent
=
parent
,
config
=
config
,
session
=
session
,
nodeid
=
nodeid
,
path
=
path
,
)
[docs]
@classmethod
def
from_parent
(
cls
,
parent
,
*
,
fspath
:
LEGACY_PATH
|
None
=
None
,
path
:
Path
|
None
=
None
,
**
kw
,
)
->
Self
:
"""The public constructor."""
return
super
()
.
from_parent
(
parent
=
parent
,
fspath
=
fspath
,
path
=
path
,
**
kw
)
[docs]
class
File
(
FSCollector
,
abc
.
ABC
):
"""Base class for collecting tests from a file.
:ref:`non-python tests`.
"""
[docs]
class
Directory
(
FSCollector
,
abc
.
ABC
):
"""Base class for collecting files from a directory.
A basic directory collector does the following: goes over the files and
sub-directories in the directory and creates collectors for them by calling
the hooks :hook:`pytest_collect_directory` and :hook:`pytest_collect_file`,
after checking that they are not ignored using
:hook:`pytest_ignore_collect`.
The default directory collectors are :class:`~pytest.Dir` and
:class:`~pytest.Package`.
.. versionadded:: 8.0
:ref:`custom directory collectors`.
"""
[docs]
class
Item
(
Node
,
abc
.
ABC
):
"""Base class of all test invocation items.
Note that for a single function there might be multiple test invocation items.
"""
nextitem
=
None
def
__init__
(
self
,
name
,
parent
=
None
,
config
:
Config
|
None
=
None
,
session
:
Session
|
None
=
None
,
nodeid
:
str
|
None
=
None
,
**
kw
,
)
->
None
:
# The first two arguments are intentionally passed positionally,
# to keep plugins who define a node type which inherits from
# (pytest.Item, pytest.File) working (see issue #8435).
# They can be made kwargs when the deprecation above is done.
super
()
.
__init__
(
name
,
parent
,
config
=
config
,
session
=
session
,
nodeid
=
nodeid
,
**
kw
,
)
self
.
_report_sections
:
list
[
tuple
[
str
,
str
,
str
]]
=
[]
#: A list of tuples (name, value) that holds user defined properties
#: for this test.
self
.
user_properties
:
list
[
tuple
[
str
,
object
]]
=
[]
self
.
_check_item_and_collector_diamond_inheritance
()
def
_check_item_and_collector_diamond_inheritance
(
self
)
->
None
:
"""
Check if the current type inherits from both File and Collector
at the same time, emitting a warning accordingly (#8447).
"""
cls
=
type
(
self
)
# We inject an attribute in the type to avoid issuing this warning
# for the same class more than once, which is not helpful.
# It is a hack, but was deemed acceptable in order to avoid
# flooding the user in the common case.
attr_name
=
"_pytest_diamond_inheritance_warning_shown"
if
getattr
(
cls
,
attr_name
,
False
):
return
setattr
(
cls
,
attr_name
,
True
)
problems
=
", "
.
join
(
base
.
__name__
for
base
in
cls
.
__bases__
if
issubclass
(
base
,
Collector
)
)
if
problems
:
warnings
.
warn
(
f
"
{
cls
.
__name__
}
is an Item subclass and should not be a collector, "
f
"however its bases
{
problems
}
are collectors.
\n
"
"Please split the Collectors and the Item into separate node types.
\n
"
"Pytest Doc example: https://docs.pytest.org/en/latest/example/nonpython.html
\n
"
"example pull request on a plugin: https://github.com/asmeurer/pytest-flakes/pull/40/"
,
PytestWarning
,
)
[docs]
@abc
.
abstractmethod
def
runtest
(
self
)
->
None
:
"""Run the test case for this item.
Must be implemented by subclasses.
.. seealso:: :ref:`non-python tests`
"""
raise
NotImplementedError
(
"runtest must be implemented by Item subclass"
)
[docs]
def
add_report_section
(
self
,
when
:
str
,
key
:
str
,
content
:
str
)
->
None
:
"""Add a new report section, similar to what's done internally to add
stdout and stderr captured output::
item.add_report_section("call", "stdout", "report section contents")
:param str when:
One of the possible capture states, ``"setup"``, ``"call"``, ``"teardown"``.
:param str key:
Name of the section, can be customized at will. Pytest uses ``"stdout"`` and
``"stderr"`` internally.
:param str content:
The full contents as a string.
"""
if
content
:
self
.
_report_sections
.
append
((
when
,
key
,
content
))
[docs]
def
reportinfo
(
self
)
->
tuple
[
os
.
PathLike
[
str
]
|
str
,
int
|
None
,
str
]:
"""Get location information for this item for test reports.
Returns a tuple with three elements:
- The path of the test (default ``self.path``)
- The 0-based line number of the test (default ``None``)
- A name of the test to be shown (default ``""``)
.. seealso:: :ref:`non-python tests`
"""
return
self
.
path
,
None
,
""
@cached_property
def
location
(
self
)
->
tuple
[
str
,
int
|
None
,
str
]:
"""
Returns a tuple of ``(relfspath, lineno, testname)`` for this item
where ``relfspath`` is file path relative to ``config.rootpath``
and lineno is a 0-based line number.
"""
location
=
self
.
reportinfo
()
path
=
absolutepath
(
location
[
0
])
relfspath
=
self
.
session
.
_node_location_to_relpath
(
path
)
assert
type
(
location
[
2
])
is
str
return
(
relfspath
,
location
[
1
],
location
[
2
])

```


---


# _pytest.monkeypatch - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/monkeypatch.html


# Source code for _pytest.monkeypatch

```

# mypy: allow-untyped-defs
"""Monkeypatching and mocking functionality."""
from
__future__
import
annotations
from
contextlib
import
contextmanager
import
os
import
re
import
sys
from
typing
import
Any
from
typing
import
final
from
typing
import
Generator
from
typing
import
Mapping
from
typing
import
MutableMapping
from
typing
import
overload
from
typing
import
TypeVar
import
warnings
from
_pytest.fixtures
import
fixture
from
_pytest.warning_types
import
PytestWarning
RE_IMPORT_ERROR_NAME
=
re
.
compile
(
r
"^No module named (.*)$"
)
K
=
TypeVar
(
"K"
)
V
=
TypeVar
(
"V"
)
[docs]
@fixture
def
monkeypatch
()
->
Generator
[
MonkeyPatch
]:
"""A convenient fixture for monkey-patching.
The fixture provides these methods to modify objects, dictionaries, or
:data:`os.environ`:
* :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`
* :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`
* :meth:`monkeypatch.setitem(mapping, name, value) <pytest.MonkeyPatch.setitem>`
* :meth:`monkeypatch.delitem(obj, name, raising=True) <pytest.MonkeyPatch.delitem>`
* :meth:`monkeypatch.setenv(name, value, prepend=None) <pytest.MonkeyPatch.setenv>`
* :meth:`monkeypatch.delenv(name, raising=True) <pytest.MonkeyPatch.delenv>`
* :meth:`monkeypatch.syspath_prepend(path) <pytest.MonkeyPatch.syspath_prepend>`
* :meth:`monkeypatch.chdir(path) <pytest.MonkeyPatch.chdir>`
* :meth:`monkeypatch.context() <pytest.MonkeyPatch.context>`
All modifications will be undone after the requesting test function or
fixture has finished. The ``raising`` parameter determines if a :class:`KeyError`
or :class:`AttributeError` will be raised if the set/deletion operation does not have the
specified target.
To undo modifications done by the fixture in a contained scope,
use :meth:`context() <pytest.MonkeyPatch.context>`.
"""
mpatch
=
MonkeyPatch
()
yield
mpatch
mpatch
.
undo
()
def
resolve
(
name
:
str
)
->
object
:
# Simplified from zope.dottedname.
parts
=
name
.
split
(
"."
)
used
=
parts
.
pop
(
0
)
found
:
object
=
__import__
(
used
)
for
part
in
parts
:
used
+=
"."
+
part
try
:
found
=
getattr
(
found
,
part
)
except
AttributeError
:
pass
else
:
continue
# We use explicit un-nesting of the handling block in order
# to avoid nested exceptions.
try
:
__import__
(
used
)
except
ImportError
as
ex
:
expected
=
str
(
ex
)
.
split
()[
-
1
]
if
expected
==
used
:
raise
else
:
raise
ImportError
(
f
"import error in
{
used
}
:
{
ex
}
"
)
from
ex
found
=
annotated_getattr
(
found
,
part
,
used
)
return
found
def
annotated_getattr
(
obj
:
object
,
name
:
str
,
ann
:
str
)
->
object
:
try
:
obj
=
getattr
(
obj
,
name
)
except
AttributeError
as
e
:
raise
AttributeError
(
f
"
{
type
(
obj
)
.
__name__
!r}
object at
{
ann
}
has no attribute
{
name
!r}
"
)
from
e
return
obj
def
derive_importpath
(
import_path
:
str
,
raising
:
bool
)
->
tuple
[
str
,
object
]:
if
not
isinstance
(
import_path
,
str
)
or
"."
not
in
import_path
:
raise
TypeError
(
f
"must be absolute import path string, not
{
import_path
!r}
"
)
module
,
attr
=
import_path
.
rsplit
(
"."
,
1
)
target
=
resolve
(
module
)
if
raising
:
annotated_getattr
(
target
,
attr
,
ann
=
module
)
return
attr
,
target
class
Notset
:
def
__repr__
(
self
)
->
str
:
return
"<notset>"
notset
=
Notset
()
[docs]
@final
class
MonkeyPatch
:
"""Helper to conveniently monkeypatch attributes/items/environment
variables/syspath.
Returned by the :fixture:`monkeypatch` fixture.
.. versionchanged:: 6.2
Can now also be used directly as `pytest.MonkeyPatch()`, for when
the fixture is not available. In this case, use
:meth:`with MonkeyPatch.context() as mp: <context>` or remember to call
:meth:`undo` explicitly.
"""
def
__init__
(
self
)
->
None
:
self
.
_setattr
:
list
[
tuple
[
object
,
str
,
object
]]
=
[]
self
.
_setitem
:
list
[
tuple
[
Mapping
[
Any
,
Any
],
object
,
object
]]
=
[]
self
.
_cwd
:
str
|
None
=
None
self
.
_savesyspath
:
list
[
str
]
|
None
=
None
[docs]
@classmethod
@contextmanager
def
context
(
cls
)
->
Generator
[
MonkeyPatch
]:
"""Context manager that returns a new :class:`MonkeyPatch` object
which undoes any patching done inside the ``with`` block upon exit.
Example:
.. code-block:: python
import functools
def test_partial(monkeypatch):
with monkeypatch.context() as m:
m.setattr(functools, "partial", 3)
Useful in situations where it is desired to undo some patches before the test ends,
such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples
of this see :issue:`3290`).
"""
m
=
cls
()
try
:
yield
m
finally
:
m
.
undo
()
@overload
def
setattr
(
self
,
target
:
str
,
name
:
object
,
value
:
Notset
=
...
,
raising
:
bool
=
...
,
)
->
None
:
...
@overload
def
setattr
(
self
,
target
:
object
,
name
:
str
,
value
:
object
,
raising
:
bool
=
...
,
)
->
None
:
...
[docs]
def
setattr
(
self
,
target
:
str
|
object
,
name
:
object
|
str
,
value
:
object
=
notset
,
raising
:
bool
=
True
,
)
->
None
:
"""
Set attribute value on target, memorizing the old value.
For example:
.. code-block:: python
import os
monkeypatch.setattr(os, "getcwd", lambda: "/")
The code above replaces the :func:`os.getcwd` function by a ``lambda`` which
always returns ``"/"``.
For convenience, you can specify a string as ``target`` which
will be interpreted as a dotted import path, with the last part
being the attribute name:
.. code-block:: python
monkeypatch.setattr("os.getcwd", lambda: "/")
Raises :class:`AttributeError` if the attribute does not exist, unless
``raising`` is set to False.
**Where to patch**
``monkeypatch.setattr`` works by (temporarily) changing the object that a name points to with another one.
There can be many names pointing to any individual object, so for patching to work you must ensure
that you patch the name used by the system under test.
See the section :ref:`Where to patch <python:where-to-patch>` in the :mod:`unittest.mock`
docs for a complete explanation, which is meant for :func:`unittest.mock.patch` but
applies to ``monkeypatch.setattr`` as well.
"""
__tracebackhide__
=
True
import
inspect
if
isinstance
(
value
,
Notset
):
if
not
isinstance
(
target
,
str
):
raise
TypeError
(
"use setattr(target, name, value) or "
"setattr(target, value) with target being a dotted "
"import string"
)
value
=
name
name
,
target
=
derive_importpath
(
target
,
raising
)
else
:
if
not
isinstance
(
name
,
str
):
raise
TypeError
(
"use setattr(target, name, value) with name being a string or "
"setattr(target, value) with target being a dotted "
"import string"
)
oldval
=
getattr
(
target
,
name
,
notset
)
if
raising
and
oldval
is
notset
:
raise
AttributeError
(
f
"
{
target
!r}
has no attribute
{
name
!r}
"
)
# avoid class descriptors like staticmethod/classmethod
if
inspect
.
isclass
(
target
):
oldval
=
target
.
__dict__
.
get
(
name
,
notset
)
self
.
_setattr
.
append
((
target
,
name
,
oldval
))
setattr
(
target
,
name
,
value
)
[docs]
def
delattr
(
self
,
target
:
object
|
str
,
name
:
str
|
Notset
=
notset
,
raising
:
bool
=
True
,
)
->
None
:
"""Delete attribute ``name`` from ``target``.
If no ``name`` is specified and ``target`` is a string
it will be interpreted as a dotted import path with the
last part being the attribute name.
Raises AttributeError it the attribute does not exist, unless
``raising`` is set to False.
"""
__tracebackhide__
=
True
import
inspect
if
isinstance
(
name
,
Notset
):
if
not
isinstance
(
target
,
str
):
raise
TypeError
(
"use delattr(target, name) or "
"delattr(target) with target being a dotted "
"import string"
)
name
,
target
=
derive_importpath
(
target
,
raising
)
if
not
hasattr
(
target
,
name
):
if
raising
:
raise
AttributeError
(
name
)
else
:
oldval
=
getattr
(
target
,
name
,
notset
)
# Avoid class descriptors like staticmethod/classmethod.
if
inspect
.
isclass
(
target
):
oldval
=
target
.
__dict__
.
get
(
name
,
notset
)
self
.
_setattr
.
append
((
target
,
name
,
oldval
))
delattr
(
target
,
name
)
[docs]
def
setitem
(
self
,
dic
:
Mapping
[
K
,
V
],
name
:
K
,
value
:
V
)
->
None
:
"""Set dictionary entry ``name`` to value."""
self
.
_setitem
.
append
((
dic
,
name
,
dic
.
get
(
name
,
notset
)))
# Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict
dic
[
name
]
=
value
# type: ignore[index]
[docs]
def
delitem
(
self
,
dic
:
Mapping
[
K
,
V
],
name
:
K
,
raising
:
bool
=
True
)
->
None
:
"""Delete ``name`` from dict.
Raises ``KeyError`` if it doesn't exist, unless ``raising`` is set to
False.
"""
if
name
not
in
dic
:
if
raising
:
raise
KeyError
(
name
)
else
:
self
.
_setitem
.
append
((
dic
,
name
,
dic
.
get
(
name
,
notset
)))
# Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict
del
dic
[
name
]
# type: ignore[attr-defined]
[docs]
def
setenv
(
self
,
name
:
str
,
value
:
str
,
prepend
:
str
|
None
=
None
)
->
None
:
"""Set environment variable ``name`` to ``value``.
If ``prepend`` is a character, read the current environment variable
value and prepend the ``value`` adjoined with the ``prepend``
character.
"""
if
not
isinstance
(
value
,
str
):
warnings
.
warn
(
# type: ignore[unreachable]
PytestWarning
(
f
"Value of environment variable
{
name
}
type should be str, but got "
f
"
{
value
!r}
(type:
{
type
(
value
)
.
__name__
}
); converted to str implicitly"
),
stacklevel
=
2
,
)
value
=
str
(
value
)
if
prepend
and
name
in
os
.
environ
:
value
=
value
+
prepend
+
os
.
environ
[
name
]
self
.
setitem
(
os
.
environ
,
name
,
value
)
[docs]
def
delenv
(
self
,
name
:
str
,
raising
:
bool
=
True
)
->
None
:
"""Delete ``name`` from the environment.
Raises ``KeyError`` if it does not exist, unless ``raising`` is set to
False.
"""
environ
:
MutableMapping
[
str
,
str
]
=
os
.
environ
self
.
delitem
(
environ
,
name
,
raising
=
raising
)
[docs]
def
syspath_prepend
(
self
,
path
)
->
None
:
"""Prepend ``path`` to ``sys.path`` list of import locations."""
if
self
.
_savesyspath
is
None
:
self
.
_savesyspath
=
sys
.
path
[:]
sys
.
path
.
insert
(
0
,
str
(
path
))
# https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171
# this is only needed when pkg_resources was already loaded by the namespace package
if
"pkg_resources"
in
sys
.
modules
:
from
pkg_resources
import
fixup_namespace_packages
fixup_namespace_packages
(
str
(
path
))
# A call to syspathinsert() usually means that the caller wants to
# import some dynamically created files, thus with python3 we
# invalidate its import caches.
# This is especially important when any namespace package is in use,
# since then the mtime based FileFinder cache (that gets created in
# this case already) gets not invalidated when writing the new files
# quickly afterwards.
from
importlib
import
invalidate_caches
invalidate_caches
()
[docs]
def
chdir
(
self
,
path
:
str
|
os
.
PathLike
[
str
])
->
None
:
"""Change the current working directory to the specified path.
:param path:
The path to change into.
"""
if
self
.
_cwd
is
None
:
self
.
_cwd
=
os
.
getcwd
()
os
.
chdir
(
path
)
[docs]
def
undo
(
self
)
->
None
:
"""Undo previous changes.
This call consumes the undo stack. Calling it a second time has no
effect unless you do more monkeypatching after the undo call.
There is generally no need to call `undo()`, since it is
called automatically during tear-down.
.. note::
The same `monkeypatch` fixture is used across a
single test function invocation. If `monkeypatch` is used both by
the test function itself and one of the test fixtures,
calling `undo()` will undo all of the changes made in
both functions.
Prefer to use :meth:`context() <pytest.MonkeyPatch.context>` instead.
"""
for
obj
,
name
,
value
in
reversed
(
self
.
_setattr
):
if
value
is
not
notset
:
setattr
(
obj
,
name
,
value
)
else
:
delattr
(
obj
,
name
)
self
.
_setattr
[:]
=
[]
for
dictionary
,
key
,
value
in
reversed
(
self
.
_setitem
):
if
value
is
notset
:
try
:
# Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict
del
dictionary
[
key
]
# type: ignore[attr-defined]
except
KeyError
:
pass
# Was already deleted, so we have the desired state.
else
:
# Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict
dictionary
[
key
]
=
value
# type: ignore[index]
self
.
_setitem
[:]
=
[]
if
self
.
_savesyspath
is
not
None
:
sys
.
path
[:]
=
self
.
_savesyspath
self
.
_savesyspath
=
None
if
self
.
_cwd
is
not
None
:
os
.
chdir
(
self
.
_cwd
)
self
.
_cwd
=
None

```


---


# _pytest.cacheprovider - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/cacheprovider.html


# Source code for _pytest.cacheprovider

```

# mypy: allow-untyped-defs
"""Implementation of the cache provider."""
# This plugin was not named "cache" to avoid conflicts with the external
# pytest-cache version.
from
__future__
import
annotations
import
dataclasses
import
errno
import
json
import
os
from
pathlib
import
Path
import
tempfile
from
typing
import
final
from
typing
import
Generator
from
typing
import
Iterable
from
.pathlib
import
resolve_from_str
from
.pathlib
import
rm_rf
from
.reports
import
CollectReport
from
_pytest
import
nodes
from
_pytest._io
import
TerminalWriter
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config
import
hookimpl
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.main
import
Session
from
_pytest.nodes
import
Directory
from
_pytest.nodes
import
File
from
_pytest.reports
import
TestReport
README_CONTENT
=
"""
\
# pytest cache directory #
This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.
**Do not** commit this to version control.
See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.
"""
CACHEDIR_TAG_CONTENT
=
b
"""
\
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html
"""
[docs]
@final
@dataclasses
.
dataclass
class
Cache
:
"""Instance of the `cache` fixture."""
_cachedir
:
Path
=
dataclasses
.
field
(
repr
=
False
)
_config
:
Config
=
dataclasses
.
field
(
repr
=
False
)
# Sub-directory under cache-dir for directories created by `mkdir()`.
_CACHE_PREFIX_DIRS
=
"d"
# Sub-directory under cache-dir for values created by `set()`.
_CACHE_PREFIX_VALUES
=
"v"
def
__init__
(
self
,
cachedir
:
Path
,
config
:
Config
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_cachedir
=
cachedir
self
.
_config
=
config
@classmethod
def
for_config
(
cls
,
config
:
Config
,
*
,
_ispytest
:
bool
=
False
)
->
Cache
:
"""Create the Cache instance for a Config.
:meta private:
"""
check_ispytest
(
_ispytest
)
cachedir
=
cls
.
cache_dir_from_config
(
config
,
_ispytest
=
True
)
if
config
.
getoption
(
"cacheclear"
)
and
cachedir
.
is_dir
():
cls
.
clear_cache
(
cachedir
,
_ispytest
=
True
)
return
cls
(
cachedir
,
config
,
_ispytest
=
True
)
@classmethod
def
clear_cache
(
cls
,
cachedir
:
Path
,
_ispytest
:
bool
=
False
)
->
None
:
"""Clear the sub-directories used to hold cached directories and values.
:meta private:
"""
check_ispytest
(
_ispytest
)
for
prefix
in
(
cls
.
_CACHE_PREFIX_DIRS
,
cls
.
_CACHE_PREFIX_VALUES
):
d
=
cachedir
/
prefix
if
d
.
is_dir
():
rm_rf
(
d
)
@staticmethod
def
cache_dir_from_config
(
config
:
Config
,
*
,
_ispytest
:
bool
=
False
)
->
Path
:
"""Get the path to the cache directory for a Config.
:meta private:
"""
check_ispytest
(
_ispytest
)
return
resolve_from_str
(
config
.
getini
(
"cache_dir"
),
config
.
rootpath
)
def
warn
(
self
,
fmt
:
str
,
*
,
_ispytest
:
bool
=
False
,
**
args
:
object
)
->
None
:
"""Issue a cache warning.
:meta private:
"""
check_ispytest
(
_ispytest
)
import
warnings
from
_pytest.warning_types
import
PytestCacheWarning
warnings
.
warn
(
PytestCacheWarning
(
fmt
.
format
(
**
args
)
if
args
else
fmt
),
self
.
_config
.
hook
,
stacklevel
=
3
,
)
def
_mkdir
(
self
,
path
:
Path
)
->
None
:
self
.
_ensure_cache_dir_and_supporting_files
()
path
.
mkdir
(
exist_ok
=
True
,
parents
=
True
)
[docs]
def
mkdir
(
self
,
name
:
str
)
->
Path
:
"""Return a directory path object with the given name.
If the directory does not yet exist, it will be created. You can use
it to manage files to e.g. store/retrieve database dumps across test
sessions.
.. versionadded:: 7.0
:param name:
Must be a string not containing a ``/`` separator.
Make sure the name contains your plugin or application
identifiers to prevent clashes with other cache users.
"""
path
=
Path
(
name
)
if
len
(
path
.
parts
)
>
1
:
raise
ValueError
(
"name is not allowed to contain path separators"
)
res
=
self
.
_cachedir
.
joinpath
(
self
.
_CACHE_PREFIX_DIRS
,
path
)
self
.
_mkdir
(
res
)
return
res
def
_getvaluepath
(
self
,
key
:
str
)
->
Path
:
return
self
.
_cachedir
.
joinpath
(
self
.
_CACHE_PREFIX_VALUES
,
Path
(
key
))
[docs]
def
get
(
self
,
key
:
str
,
default
):
"""Return the cached value for the given key.
If no value was yet cached or the value cannot be read, the specified
default is returned.
:param key:
Must be a ``/`` separated value. Usually the first
name is the name of your plugin or your application.
:param default:
The value to return in case of a cache-miss or invalid cache value.
"""
path
=
self
.
_getvaluepath
(
key
)
try
:
with
path
.
open
(
"r"
,
encoding
=
"UTF-8"
)
as
f
:
return
json
.
load
(
f
)
except
(
ValueError
,
OSError
):
return
default
[docs]
def
set
(
self
,
key
:
str
,
value
:
object
)
->
None
:
"""Save value for the given key.
:param key:
Must be a ``/`` separated value. Usually the first
name is the name of your plugin or your application.
:param value:
Must be of any combination of basic python types,
including nested types like lists of dictionaries.
"""
path
=
self
.
_getvaluepath
(
key
)
try
:
self
.
_mkdir
(
path
.
parent
)
except
OSError
as
exc
:
self
.
warn
(
f
"could not create cache path
{
path
}
:
{
exc
}
"
,
_ispytest
=
True
,
)
return
data
=
json
.
dumps
(
value
,
ensure_ascii
=
False
,
indent
=
2
)
try
:
f
=
path
.
open
(
"w"
,
encoding
=
"UTF-8"
)
except
OSError
as
exc
:
self
.
warn
(
f
"cache could not write path
{
path
}
:
{
exc
}
"
,
_ispytest
=
True
,
)
else
:
with
f
:
f
.
write
(
data
)
def
_ensure_cache_dir_and_supporting_files
(
self
)
->
None
:
"""Create the cache dir and its supporting files."""
if
self
.
_cachedir
.
is_dir
():
return
self
.
_cachedir
.
parent
.
mkdir
(
parents
=
True
,
exist_ok
=
True
)
with
tempfile
.
TemporaryDirectory
(
prefix
=
"pytest-cache-files-"
,
dir
=
self
.
_cachedir
.
parent
,
)
as
newpath
:
path
=
Path
(
newpath
)
# Reset permissions to the default, see #12308.
# Note: there's no way to get the current umask atomically, eek.
umask
=
os
.
umask
(
0o022
)
os
.
umask
(
umask
)
path
.
chmod
(
0o777
-
umask
)
with
open
(
path
.
joinpath
(
"README.md"
),
"x"
,
encoding
=
"UTF-8"
)
as
f
:
f
.
write
(
README_CONTENT
)
with
open
(
path
.
joinpath
(
".gitignore"
),
"x"
,
encoding
=
"UTF-8"
)
as
f
:
f
.
write
(
"# Created by pytest automatically.
\n
*
\n
"
)
with
open
(
path
.
joinpath
(
"CACHEDIR.TAG"
),
"xb"
)
as
f
:
f
.
write
(
CACHEDIR_TAG_CONTENT
)
try
:
path
.
rename
(
self
.
_cachedir
)
except
OSError
as
e
:
# If 2 concurrent pytests both race to the rename, the loser
# gets "Directory not empty" from the rename. In this case,
# everything is handled so just continue (while letting the
# temporary directory be cleaned up).
# On Windows, the error is a FileExistsError which translates to EEXIST.
if
e
.
errno
not
in
(
errno
.
ENOTEMPTY
,
errno
.
EEXIST
):
raise
else
:
# Create a directory in place of the one we just moved so that
# `TemporaryDirectory`'s cleanup doesn't complain.
#
# TODO: pass ignore_cleanup_errors=True when we no longer support python < 3.10.
# See https://github.com/python/cpython/issues/74168. Note that passing
# delete=False would do the wrong thing in case of errors and isn't supported
# until python 3.12.
path
.
mkdir
()
class
LFPluginCollWrapper
:
def
__init__
(
self
,
lfplugin
:
LFPlugin
)
->
None
:
self
.
lfplugin
=
lfplugin
self
.
_collected_at_least_one_failure
=
False
@hookimpl
(
wrapper
=
True
)
def
pytest_make_collect_report
(
self
,
collector
:
nodes
.
Collector
)
->
Generator
[
None
,
CollectReport
,
CollectReport
]:
res
=
yield
if
isinstance
(
collector
,
(
Session
,
Directory
)):
# Sort any lf-paths to the beginning.
lf_paths
=
self
.
lfplugin
.
_last_failed_paths
# Use stable sort to prioritize last failed.
def
sort_key
(
node
:
nodes
.
Item
|
nodes
.
Collector
)
->
bool
:
return
node
.
path
in
lf_paths
res
.
result
=
sorted
(
res
.
result
,
key
=
sort_key
,
reverse
=
True
,
)
elif
isinstance
(
collector
,
File
):
if
collector
.
path
in
self
.
lfplugin
.
_last_failed_paths
:
result
=
res
.
result
lastfailed
=
self
.
lfplugin
.
lastfailed
# Only filter with known failures.
if
not
self
.
_collected_at_least_one_failure
:
if
not
any
(
x
.
nodeid
in
lastfailed
for
x
in
result
):
return
res
self
.
lfplugin
.
config
.
pluginmanager
.
register
(
LFPluginCollSkipfiles
(
self
.
lfplugin
),
"lfplugin-collskip"
)
self
.
_collected_at_least_one_failure
=
True
session
=
collector
.
session
result
[:]
=
[
x
for
x
in
result
if
x
.
nodeid
in
lastfailed
# Include any passed arguments (not trivial to filter).
or
session
.
isinitpath
(
x
.
path
)
# Keep all sub-collectors.
or
isinstance
(
x
,
nodes
.
Collector
)
]
return
res
class
LFPluginCollSkipfiles
:
def
__init__
(
self
,
lfplugin
:
LFPlugin
)
->
None
:
self
.
lfplugin
=
lfplugin
@hookimpl
def
pytest_make_collect_report
(
self
,
collector
:
nodes
.
Collector
)
->
CollectReport
|
None
:
if
isinstance
(
collector
,
File
):
if
collector
.
path
not
in
self
.
lfplugin
.
_last_failed_paths
:
self
.
lfplugin
.
_skipped_files
+=
1
return
CollectReport
(
collector
.
nodeid
,
"passed"
,
longrepr
=
None
,
result
=
[]
)
return
None
class
LFPlugin
:
"""Plugin which implements the --lf (run last-failing) option."""
def
__init__
(
self
,
config
:
Config
)
->
None
:
self
.
config
=
config
active_keys
=
"lf"
,
"failedfirst"
self
.
active
=
any
(
config
.
getoption
(
key
)
for
key
in
active_keys
)
assert
config
.
cache
self
.
lastfailed
:
dict
[
str
,
bool
]
=
config
.
cache
.
get
(
"cache/lastfailed"
,
{})
self
.
_previously_failed_count
:
int
|
None
=
None
self
.
_report_status
:
str
|
None
=
None
self
.
_skipped_files
=
0
# count skipped files during collection due to --lf
if
config
.
getoption
(
"lf"
):
self
.
_last_failed_paths
=
self
.
get_last_failed_paths
()
config
.
pluginmanager
.
register
(
LFPluginCollWrapper
(
self
),
"lfplugin-collwrapper"
)
def
get_last_failed_paths
(
self
)
->
set
[
Path
]:
"""Return a set with all Paths of the previously failed nodeids and
their parents."""
rootpath
=
self
.
config
.
rootpath
result
=
set
()
for
nodeid
in
self
.
lastfailed
:
path
=
rootpath
/
nodeid
.
split
(
"::"
)[
0
]
result
.
add
(
path
)
result
.
update
(
path
.
parents
)
return
{
x
for
x
in
result
if
x
.
exists
()}
def
pytest_report_collectionfinish
(
self
)
->
str
|
None
:
if
self
.
active
and
self
.
config
.
get_verbosity
()
>=
0
:
return
f
"run-last-failure:
{
self
.
_report_status
}
"
return
None
def
pytest_runtest_logreport
(
self
,
report
:
TestReport
)
->
None
:
if
(
report
.
when
==
"call"
and
report
.
passed
)
or
report
.
skipped
:
self
.
lastfailed
.
pop
(
report
.
nodeid
,
None
)
elif
report
.
failed
:
self
.
lastfailed
[
report
.
nodeid
]
=
True
def
pytest_collectreport
(
self
,
report
:
CollectReport
)
->
None
:
passed
=
report
.
outcome
in
(
"passed"
,
"skipped"
)
if
passed
:
if
report
.
nodeid
in
self
.
lastfailed
:
self
.
lastfailed
.
pop
(
report
.
nodeid
)
self
.
lastfailed
.
update
((
item
.
nodeid
,
True
)
for
item
in
report
.
result
)
else
:
self
.
lastfailed
[
report
.
nodeid
]
=
True
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_collection_modifyitems
(
self
,
config
:
Config
,
items
:
list
[
nodes
.
Item
]
)
->
Generator
[
None
]:
res
=
yield
if
not
self
.
active
:
return
res
if
self
.
lastfailed
:
previously_failed
=
[]
previously_passed
=
[]
for
item
in
items
:
if
item
.
nodeid
in
self
.
lastfailed
:
previously_failed
.
append
(
item
)
else
:
previously_passed
.
append
(
item
)
self
.
_previously_failed_count
=
len
(
previously_failed
)
if
not
previously_failed
:
# Running a subset of all tests with recorded failures
# only outside of it.
self
.
_report_status
=
"
%d
known failures not in selected tests"
%
(
len
(
self
.
lastfailed
),
)
else
:
if
self
.
config
.
getoption
(
"lf"
):
items
[:]
=
previously_failed
config
.
hook
.
pytest_deselected
(
items
=
previously_passed
)
else
:
# --failedfirst
items
[:]
=
previously_failed
+
previously_passed
noun
=
"failure"
if
self
.
_previously_failed_count
==
1
else
"failures"
suffix
=
" first"
if
self
.
config
.
getoption
(
"failedfirst"
)
else
""
self
.
_report_status
=
(
f
"rerun previous
{
self
.
_previously_failed_count
}
{
noun
}{
suffix
}
"
)
if
self
.
_skipped_files
>
0
:
files_noun
=
"file"
if
self
.
_skipped_files
==
1
else
"files"
self
.
_report_status
+=
f
" (skipped
{
self
.
_skipped_files
}
{
files_noun
}
)"
else
:
self
.
_report_status
=
"no previously failed tests, "
if
self
.
config
.
getoption
(
"last_failed_no_failures"
)
==
"none"
:
self
.
_report_status
+=
"deselecting all items."
config
.
hook
.
pytest_deselected
(
items
=
items
[:])
items
[:]
=
[]
else
:
self
.
_report_status
+=
"not deselecting items."
return
res
def
pytest_sessionfinish
(
self
,
session
:
Session
)
->
None
:
config
=
self
.
config
if
config
.
getoption
(
"cacheshow"
)
or
hasattr
(
config
,
"workerinput"
):
return
assert
config
.
cache
is
not
None
saved_lastfailed
=
config
.
cache
.
get
(
"cache/lastfailed"
,
{})
if
saved_lastfailed
!=
self
.
lastfailed
:
config
.
cache
.
set
(
"cache/lastfailed"
,
self
.
lastfailed
)
class
NFPlugin
:
"""Plugin which implements the --nf (run new-first) option."""
def
__init__
(
self
,
config
:
Config
)
->
None
:
self
.
config
=
config
self
.
active
=
config
.
option
.
newfirst
assert
config
.
cache
is
not
None
self
.
cached_nodeids
=
set
(
config
.
cache
.
get
(
"cache/nodeids"
,
[]))
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_collection_modifyitems
(
self
,
items
:
list
[
nodes
.
Item
])
->
Generator
[
None
]:
res
=
yield
if
self
.
active
:
new_items
:
dict
[
str
,
nodes
.
Item
]
=
{}
other_items
:
dict
[
str
,
nodes
.
Item
]
=
{}
for
item
in
items
:
if
item
.
nodeid
not
in
self
.
cached_nodeids
:
new_items
[
item
.
nodeid
]
=
item
else
:
other_items
[
item
.
nodeid
]
=
item
items
[:]
=
self
.
_get_increasing_order
(
new_items
.
values
()
)
+
self
.
_get_increasing_order
(
other_items
.
values
())
self
.
cached_nodeids
.
update
(
new_items
)
else
:
self
.
cached_nodeids
.
update
(
item
.
nodeid
for
item
in
items
)
return
res
def
_get_increasing_order
(
self
,
items
:
Iterable
[
nodes
.
Item
])
->
list
[
nodes
.
Item
]:
return
sorted
(
items
,
key
=
lambda
item
:
item
.
path
.
stat
()
.
st_mtime
,
reverse
=
True
)
def
pytest_sessionfinish
(
self
)
->
None
:
config
=
self
.
config
if
config
.
getoption
(
"cacheshow"
)
or
hasattr
(
config
,
"workerinput"
):
return
if
config
.
getoption
(
"collectonly"
):
return
assert
config
.
cache
is
not
None
config
.
cache
.
set
(
"cache/nodeids"
,
sorted
(
self
.
cached_nodeids
))
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"general"
)
group
.
addoption
(
"--lf"
,
"--last-failed"
,
action
=
"store_true"
,
dest
=
"lf"
,
help
=
"Rerun only the tests that failed "
"at the last run (or all if none failed)"
,
)
group
.
addoption
(
"--ff"
,
"--failed-first"
,
action
=
"store_true"
,
dest
=
"failedfirst"
,
help
=
"Run all tests, but run the last failures first. "
"This may re-order tests and thus lead to "
"repeated fixture setup/teardown."
,
)
group
.
addoption
(
"--nf"
,
"--new-first"
,
action
=
"store_true"
,
dest
=
"newfirst"
,
help
=
"Run tests from new files first, then the rest of the tests "
"sorted by file mtime"
,
)
group
.
addoption
(
"--cache-show"
,
action
=
"append"
,
nargs
=
"?"
,
dest
=
"cacheshow"
,
help
=
(
"Show cache contents, don't perform collection or tests. "
"Optional argument: glob (default: '*')."
),
)
group
.
addoption
(
"--cache-clear"
,
action
=
"store_true"
,
dest
=
"cacheclear"
,
help
=
"Remove all cache contents at start of test run"
,
)
cache_dir_default
=
".pytest_cache"
if
"TOX_ENV_DIR"
in
os
.
environ
:
cache_dir_default
=
os
.
path
.
join
(
os
.
environ
[
"TOX_ENV_DIR"
],
cache_dir_default
)
parser
.
addini
(
"cache_dir"
,
default
=
cache_dir_default
,
help
=
"Cache directory path"
)
group
.
addoption
(
"--lfnf"
,
"--last-failed-no-failures"
,
action
=
"store"
,
dest
=
"last_failed_no_failures"
,
choices
=
(
"all"
,
"none"
),
default
=
"all"
,
help
=
"With ``--lf``, determines whether to execute tests when there "
"are no previously (known) failures or when no "
"cached ``lastfailed`` data was found. "
"``all`` (the default) runs the full test suite again. "
"``none`` just emits a message about no known failures and exits successfully."
,
)
def
pytest_cmdline_main
(
config
:
Config
)
->
int
|
ExitCode
|
None
:
if
config
.
option
.
cacheshow
and
not
config
.
option
.
help
:
from
_pytest.main
import
wrap_session
return
wrap_session
(
config
,
cacheshow
)
return
None
@hookimpl
(
tryfirst
=
True
)
def
pytest_configure
(
config
:
Config
)
->
None
:
config
.
cache
=
Cache
.
for_config
(
config
,
_ispytest
=
True
)
config
.
pluginmanager
.
register
(
LFPlugin
(
config
),
"lfplugin"
)
config
.
pluginmanager
.
register
(
NFPlugin
(
config
),
"nfplugin"
)
@fixture
def
cache
(
request
:
FixtureRequest
)
->
Cache
:
"""Return a cache object that can persist state between testing sessions.
cache.get(key, default)
cache.set(key, value)
Keys must be ``/`` separated strings, where the first part is usually the
name of your plugin or application to avoid clashes with other cache users.
Values can be any object handled by the json stdlib module.
"""
assert
request
.
config
.
cache
is
not
None
return
request
.
config
.
cache
def
pytest_report_header
(
config
:
Config
)
->
str
|
None
:
"""Display cachedir with --cache-show and if non-default."""
if
config
.
option
.
verbose
>
0
or
config
.
getini
(
"cache_dir"
)
!=
".pytest_cache"
:
assert
config
.
cache
is
not
None
cachedir
=
config
.
cache
.
_cachedir
# TODO: evaluate generating upward relative paths
# starting with .., ../.. if sensible
try
:
displaypath
=
cachedir
.
relative_to
(
config
.
rootpath
)
except
ValueError
:
displaypath
=
cachedir
return
f
"cachedir:
{
displaypath
}
"
return
None
def
cacheshow
(
config
:
Config
,
session
:
Session
)
->
int
:
from
pprint
import
pformat
assert
config
.
cache
is
not
None
tw
=
TerminalWriter
()
tw
.
line
(
"cachedir: "
+
str
(
config
.
cache
.
_cachedir
))
if
not
config
.
cache
.
_cachedir
.
is_dir
():
tw
.
line
(
"cache is empty"
)
return
0
glob
=
config
.
option
.
cacheshow
[
0
]
if
glob
is
None
:
glob
=
"*"
dummy
=
object
()
basedir
=
config
.
cache
.
_cachedir
vdir
=
basedir
/
Cache
.
_CACHE_PREFIX_VALUES
tw
.
sep
(
"-"
,
f
"cache values for
{
glob
!r}
"
)
for
valpath
in
sorted
(
x
for
x
in
vdir
.
rglob
(
glob
)
if
x
.
is_file
()):
key
=
str
(
valpath
.
relative_to
(
vdir
))
val
=
config
.
cache
.
get
(
key
,
dummy
)
if
val
is
dummy
:
tw
.
line
(
f
"
{
key
}
contains unreadable content, will be ignored"
)
else
:
tw
.
line
(
f
"
{
key
}
contains:"
)
for
line
in
pformat
(
val
)
.
splitlines
():
tw
.
line
(
"  "
+
line
)
ddir
=
basedir
/
Cache
.
_CACHE_PREFIX_DIRS
if
ddir
.
is_dir
():
contents
=
sorted
(
ddir
.
rglob
(
glob
))
tw
.
sep
(
"-"
,
f
"cache directories for
{
glob
!r}
"
)
for
p
in
contents
:
# if p.is_dir():
#    print("%s/" % p.relative_to(basedir))
if
p
.
is_file
():
key
=
str
(
p
.
relative_to
(
basedir
))
tw
.
line
(
f
"
{
key
}
is a file of length
{
p
.
stat
()
.
st_size
:
d
}
"
)
return
0

```


---


# _pytest.recwarn - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/recwarn.html


# Source code for _pytest.recwarn

```

# mypy: allow-untyped-defs
"""Record warnings during test function execution."""
from
__future__
import
annotations
from
pprint
import
pformat
import
re
from
types
import
TracebackType
from
typing
import
Any
from
typing
import
Callable
from
typing
import
final
from
typing
import
Generator
from
typing
import
Iterator
from
typing
import
overload
from
typing
import
Pattern
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
if
TYPE_CHECKING
:
from
typing_extensions
import
Self
import
warnings
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.outcomes
import
Exit
from
_pytest.outcomes
import
fail
T
=
TypeVar
(
"T"
)
[docs]
@fixture
def
recwarn
()
->
Generator
[
WarningsRecorder
]:
"""Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.
See :ref:`warnings` for information on warning categories.
"""
wrec
=
WarningsRecorder
(
_ispytest
=
True
)
with
wrec
:
warnings
.
simplefilter
(
"default"
)
yield
wrec
@overload
def
deprecated_call
(
*
,
match
:
str
|
Pattern
[
str
]
|
None
=
...
)
->
WarningsRecorder
:
...
@overload
def
deprecated_call
(
func
:
Callable
[
...
,
T
],
*
args
:
Any
,
**
kwargs
:
Any
)
->
T
:
...
[docs]
def
deprecated_call
(
func
:
Callable
[
...
,
Any
]
|
None
=
None
,
*
args
:
Any
,
**
kwargs
:
Any
)
->
WarningsRecorder
|
Any
:
"""Assert that code produces a ``DeprecationWarning`` or ``PendingDeprecationWarning`` or ``FutureWarning``.
This function can be used as a context manager::
>>> import warnings
>>> def api_call_v2():
...     warnings.warn('use v3 of this api', DeprecationWarning)
...     return 200
>>> import pytest
>>> with pytest.deprecated_call():
...    assert api_call_v2() == 200
It can also be used by passing a function and ``*args`` and ``**kwargs``,
in which case it will ensure calling ``func(*args, **kwargs)`` produces one of
the warnings types above. The return value is the return value of the function.
In the context manager form you may use the keyword argument ``match`` to assert
that the warning matches a text or regex.
The context manager produces a list of :class:`warnings.WarningMessage` objects,
one for each warning raised.
"""
__tracebackhide__
=
True
if
func
is
not
None
:
args
=
(
func
,
*
args
)
return
warns
(
(
DeprecationWarning
,
PendingDeprecationWarning
,
FutureWarning
),
*
args
,
**
kwargs
)
@overload
def
warns
(
expected_warning
:
type
[
Warning
]
|
tuple
[
type
[
Warning
],
...
]
=
...
,
*
,
match
:
str
|
Pattern
[
str
]
|
None
=
...
,
)
->
WarningsChecker
:
...
@overload
def
warns
(
expected_warning
:
type
[
Warning
]
|
tuple
[
type
[
Warning
],
...
],
func
:
Callable
[
...
,
T
],
*
args
:
Any
,
**
kwargs
:
Any
,
)
->
T
:
...
[docs]
def
warns
(
expected_warning
:
type
[
Warning
]
|
tuple
[
type
[
Warning
],
...
]
=
Warning
,
*
args
:
Any
,
match
:
str
|
Pattern
[
str
]
|
None
=
None
,
**
kwargs
:
Any
,
)
->
WarningsChecker
|
Any
:
r
"""Assert that code raises a particular class of warning.
Specifically, the parameter ``expected_warning`` can be a warning class or tuple
of warning classes, and the code inside the ``with`` block must issue at least one
warning of that class or classes.
This helper produces a list of :class:`warnings.WarningMessage` objects, one for
each warning emitted (regardless of whether it is an ``expected_warning`` or not).
Since pytest 8.0, unmatched warnings are also re-emitted when the context closes.
This function can be used as a context manager::
>>> import pytest
>>> with pytest.warns(RuntimeWarning):
...    warnings.warn("my warning", RuntimeWarning)
In the context manager form you may use the keyword argument ``match`` to assert
that the warning matches a text or regex::
>>> with pytest.warns(UserWarning, match='must be 0 or None'):
...     warnings.warn("value must be 0 or None", UserWarning)
>>> with pytest.warns(UserWarning, match=r'must be \d+$'):
...     warnings.warn("value must be 42", UserWarning)
>>> with pytest.warns(UserWarning):  # catch re-emitted warning
...     with pytest.warns(UserWarning, match=r'must be \d+$'):
...         warnings.warn("this is not here", UserWarning)
Traceback (most recent call last):
...
Failed: DID NOT WARN. No warnings of type ...UserWarning... were emitted...
**Using with** ``pytest.mark.parametrize``
When using :ref:`pytest.mark.parametrize ref` it is possible to parametrize tests
such that some runs raise a warning and others do not.
This could be achieved in the same way as with exceptions, see
:ref:`parametrizing_conditional_raising` for an example.
"""
__tracebackhide__
=
True
if
not
args
:
if
kwargs
:
argnames
=
", "
.
join
(
sorted
(
kwargs
))
raise
TypeError
(
f
"Unexpected keyword arguments passed to pytest.warns:
{
argnames
}
"
"
\n
Use context-manager form instead?"
)
return
WarningsChecker
(
expected_warning
,
match_expr
=
match
,
_ispytest
=
True
)
else
:
func
=
args
[
0
]
if
not
callable
(
func
):
raise
TypeError
(
f
"
{
func
!r}
object (type:
{
type
(
func
)
}
) must be callable"
)
with
WarningsChecker
(
expected_warning
,
_ispytest
=
True
):
return
func
(
*
args
[
1
:],
**
kwargs
)
[docs]
class
WarningsRecorder
(
warnings
.
catch_warnings
):
# type:ignore[type-arg]
"""A context manager to record raised warnings.
Each recorded warning is an instance of :class:`warnings.WarningMessage`.
Adapted from `warnings.catch_warnings`.
.. note::
``DeprecationWarning`` and ``PendingDeprecationWarning`` are treated
differently; see :ref:`ensuring_function_triggers`.
"""
def
__init__
(
self
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
super
()
.
__init__
(
record
=
True
)
self
.
_entered
=
False
self
.
_list
:
list
[
warnings
.
WarningMessage
]
=
[]
@property
def
list
(
self
)
->
list
[
warnings
.
WarningMessage
]:
"""The list of recorded warnings."""
return
self
.
_list
[docs]
def
__getitem__
(
self
,
i
:
int
)
->
warnings
.
WarningMessage
:
"""Get a recorded warning by index."""
return
self
.
_list
[
i
]
[docs]
def
__iter__
(
self
)
->
Iterator
[
warnings
.
WarningMessage
]:
"""Iterate through the recorded warnings."""
return
iter
(
self
.
_list
)
[docs]
def
__len__
(
self
)
->
int
:
"""The number of recorded warnings."""
return
len
(
self
.
_list
)
[docs]
def
pop
(
self
,
cls
:
type
[
Warning
]
=
Warning
)
->
warnings
.
WarningMessage
:
"""Pop the first recorded warning which is an instance of ``cls``,
but not an instance of a child class of any other match.
Raises ``AssertionError`` if there is no match.
"""
best_idx
:
int
|
None
=
None
for
i
,
w
in
enumerate
(
self
.
_list
):
if
w
.
category
==
cls
:
return
self
.
_list
.
pop
(
i
)
# exact match, stop looking
if
issubclass
(
w
.
category
,
cls
)
and
(
best_idx
is
None
or
not
issubclass
(
w
.
category
,
self
.
_list
[
best_idx
]
.
category
)
):
best_idx
=
i
if
best_idx
is
not
None
:
return
self
.
_list
.
pop
(
best_idx
)
__tracebackhide__
=
True
raise
AssertionError
(
f
"
{
cls
!r}
not found in warning list"
)
[docs]
def
clear
(
self
)
->
None
:
"""Clear the list of recorded warnings."""
self
.
_list
[:]
=
[]
def
__enter__
(
self
)
->
Self
:
if
self
.
_entered
:
__tracebackhide__
=
True
raise
RuntimeError
(
f
"Cannot enter
{
self
!r}
twice"
)
_list
=
super
()
.
__enter__
()
# record=True means it's None.
assert
_list
is
not
None
self
.
_list
=
_list
warnings
.
simplefilter
(
"always"
)
return
self
def
__exit__
(
self
,
exc_type
:
type
[
BaseException
]
|
None
,
exc_val
:
BaseException
|
None
,
exc_tb
:
TracebackType
|
None
,
)
->
None
:
if
not
self
.
_entered
:
__tracebackhide__
=
True
raise
RuntimeError
(
f
"Cannot exit
{
self
!r}
without entering first"
)
super
()
.
__exit__
(
exc_type
,
exc_val
,
exc_tb
)
# Built-in catch_warnings does not reset entered state so we do it
# manually here for this context manager to become reusable.
self
.
_entered
=
False
@final
class
WarningsChecker
(
WarningsRecorder
):
def
__init__
(
self
,
expected_warning
:
type
[
Warning
]
|
tuple
[
type
[
Warning
],
...
]
=
Warning
,
match_expr
:
str
|
Pattern
[
str
]
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
super
()
.
__init__
(
_ispytest
=
True
)
msg
=
"exceptions must be derived from Warning, not
%s
"
if
isinstance
(
expected_warning
,
tuple
):
for
exc
in
expected_warning
:
if
not
issubclass
(
exc
,
Warning
):
raise
TypeError
(
msg
%
type
(
exc
))
expected_warning_tup
=
expected_warning
elif
isinstance
(
expected_warning
,
type
)
and
issubclass
(
expected_warning
,
Warning
):
expected_warning_tup
=
(
expected_warning
,)
else
:
raise
TypeError
(
msg
%
type
(
expected_warning
))
self
.
expected_warning
=
expected_warning_tup
self
.
match_expr
=
match_expr
def
matches
(
self
,
warning
:
warnings
.
WarningMessage
)
->
bool
:
assert
self
.
expected_warning
is
not
None
return
issubclass
(
warning
.
category
,
self
.
expected_warning
)
and
bool
(
self
.
match_expr
is
None
or
re
.
search
(
self
.
match_expr
,
str
(
warning
.
message
))
)
def
__exit__
(
self
,
exc_type
:
type
[
BaseException
]
|
None
,
exc_val
:
BaseException
|
None
,
exc_tb
:
TracebackType
|
None
,
)
->
None
:
super
()
.
__exit__
(
exc_type
,
exc_val
,
exc_tb
)
__tracebackhide__
=
True
# BaseExceptions like pytest.{skip,fail,xfail,exit} or Ctrl-C within
# pytest.warns should *not* trigger "DID NOT WARN" and get suppressed
# when the warning doesn't happen. Control-flow exceptions should always
# propagate.
if
exc_val
is
not
None
and
(
not
isinstance
(
exc_val
,
Exception
)
# Exit is an Exception, not a BaseException, for some reason.
or
isinstance
(
exc_val
,
Exit
)
):
return
def
found_str
()
->
str
:
return
pformat
([
record
.
message
for
record
in
self
],
indent
=
2
)
try
:
if
not
any
(
issubclass
(
w
.
category
,
self
.
expected_warning
)
for
w
in
self
):
fail
(
f
"DID NOT WARN. No warnings of type
{
self
.
expected_warning
}
were emitted.
\n
"
f
" Emitted warnings:
{
found_str
()
}
."
)
elif
not
any
(
self
.
matches
(
w
)
for
w
in
self
):
fail
(
f
"DID NOT WARN. No warnings of type
{
self
.
expected_warning
}
matching the regex were emitted.
\n
"
f
" Regex:
{
self
.
match_expr
}
\n
"
f
" Emitted warnings:
{
found_str
()
}
."
)
finally
:
# Whether or not any warnings matched, we want to re-emit all unmatched warnings.
for
w
in
self
:
if
not
self
.
matches
(
w
):
warnings
.
warn_explicit
(
message
=
w
.
message
,
category
=
w
.
category
,
filename
=
w
.
filename
,
lineno
=
w
.
lineno
,
module
=
w
.
__module__
,
source
=
w
.
source
,
)
# Currently in Python it is possible to pass other types than an
# `str` message when creating `Warning` instances, however this
# causes an exception when :func:`warnings.filterwarnings` is used
# to filter those warnings. See
# https://github.com/python/cpython/issues/103577 for a discussion.
# While this can be considered a bug in CPython, we put guards in
# pytest as the error message produced without this check in place
# is confusing (#10865).
for
w
in
self
:
if
type
(
w
.
message
)
is
not
UserWarning
:
# If the warning was of an incorrect type then `warnings.warn()`
# creates a UserWarning. Any other warning must have been specified
# explicitly.
continue
if
not
w
.
message
.
args
:
# UserWarning() without arguments must have been specified explicitly.
continue
msg
=
w
.
message
.
args
[
0
]
if
isinstance
(
msg
,
str
):
continue
# It's possible that UserWarning was explicitly specified, and
# its first argument was not a string. But that case can't be
# distinguished from an invalid type.
raise
TypeError
(
f
"Warning must be str or Warning, got
{
msg
!r}
(type
{
type
(
msg
)
.
__name__
}
)"
)

```


---


# _pytest.junitxml - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/junitxml.html


# Source code for _pytest.junitxml

```

# mypy: allow-untyped-defs
"""Report test results in JUnit-XML format, for use with Jenkins and build
integration servers.
Based on initial code from Ross Lawley.
Output conforms to
https://github.com/jenkinsci/xunit-plugin/blob/master/src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd
"""
from
__future__
import
annotations
from
datetime
import
datetime
from
datetime
import
timezone
import
functools
import
os
import
platform
import
re
from
typing
import
Callable
from
typing
import
Match
import
xml.etree.ElementTree
as
ET
from
_pytest
import
nodes
from
_pytest
import
timing
from
_pytest._code.code
import
ExceptionRepr
from
_pytest._code.code
import
ReprFileLocation
from
_pytest.config
import
Config
from
_pytest.config
import
filename_arg
from
_pytest.config.argparsing
import
Parser
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.reports
import
TestReport
from
_pytest.stash
import
StashKey
from
_pytest.terminal
import
TerminalReporter
import
pytest
xml_key
=
StashKey
[
"LogXML"
]()
def
bin_xml_escape
(
arg
:
object
)
->
str
:
r
"""Visually escape invalid XML characters.
For example, transforms
'hello\aworld\b'
into
'hello#x07world#x08'
Note that the #xABs are *not* XML escapes - missing the ampersand &#xAB.
The idea is to escape visually for the user rather than for XML itself.
"""
def
repl
(
matchobj
:
Match
[
str
])
->
str
:
i
=
ord
(
matchobj
.
group
())
if
i
<=
0xFF
:
return
f
"#x
{
i
:
02X
}
"
else
:
return
f
"#x
{
i
:
04X
}
"
# The spec range of valid chars is:
# Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
# For an unknown(?) reason, we disallow #x7F (DEL) as well.
illegal_xml_re
=
(
"[^
\u0009\u000a\u000d\u0020
-
\u007e\u0080
-
\ud7ff\ue000
-
\ufffd\u1000
0-
\u10ff
ff]"
)
return
re
.
sub
(
illegal_xml_re
,
repl
,
str
(
arg
))
def
merge_family
(
left
,
right
)
->
None
:
result
=
{}
for
kl
,
vl
in
left
.
items
():
for
kr
,
vr
in
right
.
items
():
if
not
isinstance
(
vl
,
list
):
raise
TypeError
(
type
(
vl
))
result
[
kl
]
=
vl
+
vr
left
.
update
(
result
)
families
=
{}
families
[
"_base"
]
=
{
"testcase"
:
[
"classname"
,
"name"
]}
families
[
"_base_legacy"
]
=
{
"testcase"
:
[
"file"
,
"line"
,
"url"
]}
# xUnit 1.x inherits legacy attributes.
families
[
"xunit1"
]
=
families
[
"_base"
]
.
copy
()
merge_family
(
families
[
"xunit1"
],
families
[
"_base_legacy"
])
# xUnit 2.x uses strict base attributes.
families
[
"xunit2"
]
=
families
[
"_base"
]
class
_NodeReporter
:
def
__init__
(
self
,
nodeid
:
str
|
TestReport
,
xml
:
LogXML
)
->
None
:
self
.
id
=
nodeid
self
.
xml
=
xml
self
.
add_stats
=
self
.
xml
.
add_stats
self
.
family
=
self
.
xml
.
family
self
.
duration
=
0.0
self
.
properties
:
list
[
tuple
[
str
,
str
]]
=
[]
self
.
nodes
:
list
[
ET
.
Element
]
=
[]
self
.
attrs
:
dict
[
str
,
str
]
=
{}
def
append
(
self
,
node
:
ET
.
Element
)
->
None
:
self
.
xml
.
add_stats
(
node
.
tag
)
self
.
nodes
.
append
(
node
)
def
add_property
(
self
,
name
:
str
,
value
:
object
)
->
None
:
self
.
properties
.
append
((
str
(
name
),
bin_xml_escape
(
value
)))
def
add_attribute
(
self
,
name
:
str
,
value
:
object
)
->
None
:
self
.
attrs
[
str
(
name
)]
=
bin_xml_escape
(
value
)
def
make_properties_node
(
self
)
->
ET
.
Element
|
None
:
"""Return a Junit node containing custom properties, if any."""
if
self
.
properties
:
properties
=
ET
.
Element
(
"properties"
)
for
name
,
value
in
self
.
properties
:
properties
.
append
(
ET
.
Element
(
"property"
,
name
=
name
,
value
=
value
))
return
properties
return
None
def
record_testreport
(
self
,
testreport
:
TestReport
)
->
None
:
names
=
mangle_test_address
(
testreport
.
nodeid
)
existing_attrs
=
self
.
attrs
classnames
=
names
[:
-
1
]
if
self
.
xml
.
prefix
:
classnames
.
insert
(
0
,
self
.
xml
.
prefix
)
attrs
:
dict
[
str
,
str
]
=
{
"classname"
:
"."
.
join
(
classnames
),
"name"
:
bin_xml_escape
(
names
[
-
1
]),
"file"
:
testreport
.
location
[
0
],
}
if
testreport
.
location
[
1
]
is
not
None
:
attrs
[
"line"
]
=
str
(
testreport
.
location
[
1
])
if
hasattr
(
testreport
,
"url"
):
attrs
[
"url"
]
=
testreport
.
url
self
.
attrs
=
attrs
self
.
attrs
.
update
(
existing_attrs
)
# Restore any user-defined attributes.
# Preserve legacy testcase behavior.
if
self
.
family
==
"xunit1"
:
return
# Filter out attributes not permitted by this test family.
# Including custom attributes because they are not valid here.
temp_attrs
=
{}
for
key
in
self
.
attrs
:
if
key
in
families
[
self
.
family
][
"testcase"
]:
temp_attrs
[
key
]
=
self
.
attrs
[
key
]
self
.
attrs
=
temp_attrs
def
to_xml
(
self
)
->
ET
.
Element
:
testcase
=
ET
.
Element
(
"testcase"
,
self
.
attrs
,
time
=
f
"
{
self
.
duration
:
.3f
}
"
)
properties
=
self
.
make_properties_node
()
if
properties
is
not
None
:
testcase
.
append
(
properties
)
testcase
.
extend
(
self
.
nodes
)
return
testcase
def
_add_simple
(
self
,
tag
:
str
,
message
:
str
,
data
:
str
|
None
=
None
)
->
None
:
node
=
ET
.
Element
(
tag
,
message
=
message
)
node
.
text
=
bin_xml_escape
(
data
)
self
.
append
(
node
)
def
write_captured_output
(
self
,
report
:
TestReport
)
->
None
:
if
not
self
.
xml
.
log_passing_tests
and
report
.
passed
:
return
content_out
=
report
.
capstdout
content_log
=
report
.
caplog
content_err
=
report
.
capstderr
if
self
.
xml
.
logging
==
"no"
:
return
content_all
=
""
if
self
.
xml
.
logging
in
[
"log"
,
"all"
]:
content_all
=
self
.
_prepare_content
(
content_log
,
" Captured Log "
)
if
self
.
xml
.
logging
in
[
"system-out"
,
"out-err"
,
"all"
]:
content_all
+=
self
.
_prepare_content
(
content_out
,
" Captured Out "
)
self
.
_write_content
(
report
,
content_all
,
"system-out"
)
content_all
=
""
if
self
.
xml
.
logging
in
[
"system-err"
,
"out-err"
,
"all"
]:
content_all
+=
self
.
_prepare_content
(
content_err
,
" Captured Err "
)
self
.
_write_content
(
report
,
content_all
,
"system-err"
)
content_all
=
""
if
content_all
:
self
.
_write_content
(
report
,
content_all
,
"system-out"
)
def
_prepare_content
(
self
,
content
:
str
,
header
:
str
)
->
str
:
return
"
\n
"
.
join
([
header
.
center
(
80
,
"-"
),
content
,
""
])
def
_write_content
(
self
,
report
:
TestReport
,
content
:
str
,
jheader
:
str
)
->
None
:
tag
=
ET
.
Element
(
jheader
)
tag
.
text
=
bin_xml_escape
(
content
)
self
.
append
(
tag
)
def
append_pass
(
self
,
report
:
TestReport
)
->
None
:
self
.
add_stats
(
"passed"
)
def
append_failure
(
self
,
report
:
TestReport
)
->
None
:
# msg = str(report.longrepr.reprtraceback.extraline)
if
hasattr
(
report
,
"wasxfail"
):
self
.
_add_simple
(
"skipped"
,
"xfail-marked test passes unexpectedly"
)
else
:
assert
report
.
longrepr
is
not
None
reprcrash
:
ReprFileLocation
|
None
=
getattr
(
report
.
longrepr
,
"reprcrash"
,
None
)
if
reprcrash
is
not
None
:
message
=
reprcrash
.
message
else
:
message
=
str
(
report
.
longrepr
)
message
=
bin_xml_escape
(
message
)
self
.
_add_simple
(
"failure"
,
message
,
str
(
report
.
longrepr
))
def
append_collect_error
(
self
,
report
:
TestReport
)
->
None
:
# msg = str(report.longrepr.reprtraceback.extraline)
assert
report
.
longrepr
is
not
None
self
.
_add_simple
(
"error"
,
"collection failure"
,
str
(
report
.
longrepr
))
def
append_collect_skipped
(
self
,
report
:
TestReport
)
->
None
:
self
.
_add_simple
(
"skipped"
,
"collection skipped"
,
str
(
report
.
longrepr
))
def
append_error
(
self
,
report
:
TestReport
)
->
None
:
assert
report
.
longrepr
is
not
None
reprcrash
:
ReprFileLocation
|
None
=
getattr
(
report
.
longrepr
,
"reprcrash"
,
None
)
if
reprcrash
is
not
None
:
reason
=
reprcrash
.
message
else
:
reason
=
str
(
report
.
longrepr
)
if
report
.
when
==
"teardown"
:
msg
=
f
'failed on teardown with "
{
reason
}
"'
else
:
msg
=
f
'failed on setup with "
{
reason
}
"'
self
.
_add_simple
(
"error"
,
bin_xml_escape
(
msg
),
str
(
report
.
longrepr
))
def
append_skipped
(
self
,
report
:
TestReport
)
->
None
:
if
hasattr
(
report
,
"wasxfail"
):
xfailreason
=
report
.
wasxfail
if
xfailreason
.
startswith
(
"reason: "
):
xfailreason
=
xfailreason
[
8
:]
xfailreason
=
bin_xml_escape
(
xfailreason
)
skipped
=
ET
.
Element
(
"skipped"
,
type
=
"pytest.xfail"
,
message
=
xfailreason
)
self
.
append
(
skipped
)
else
:
assert
isinstance
(
report
.
longrepr
,
tuple
)
filename
,
lineno
,
skipreason
=
report
.
longrepr
if
skipreason
.
startswith
(
"Skipped: "
):
skipreason
=
skipreason
[
9
:]
details
=
f
"
{
filename
}
:
{
lineno
}
:
{
skipreason
}
"
skipped
=
ET
.
Element
(
"skipped"
,
type
=
"pytest.skip"
,
message
=
bin_xml_escape
(
skipreason
)
)
skipped
.
text
=
bin_xml_escape
(
details
)
self
.
append
(
skipped
)
self
.
write_captured_output
(
report
)
def
finalize
(
self
)
->
None
:
data
=
self
.
to_xml
()
self
.
__dict__
.
clear
()
# Type ignored because mypy doesn't like overriding a method.
# Also the return value doesn't match...
self
.
to_xml
=
lambda
:
data
# type: ignore[method-assign]
def
_warn_incompatibility_with_xunit2
(
request
:
FixtureRequest
,
fixture_name
:
str
)
->
None
:
"""Emit a PytestWarning about the given fixture being incompatible with newer xunit revisions."""
from
_pytest.warning_types
import
PytestWarning
xml
=
request
.
config
.
stash
.
get
(
xml_key
,
None
)
if
xml
is
not
None
and
xml
.
family
not
in
(
"xunit1"
,
"legacy"
):
request
.
node
.
warn
(
PytestWarning
(
f
"
{
fixture_name
}
is incompatible with junit_family '
{
xml
.
family
}
' (use 'legacy' or 'xunit1')"
)
)
[docs]
@pytest
.
fixture
def
record_property
(
request
:
FixtureRequest
)
->
Callable
[[
str
,
object
],
None
]:
"""Add extra properties to the calling test.
User properties become part of the test report and are available to the
configured reporters, like JUnit XML.
The fixture is callable with ``name, value``. The value is automatically
XML-encoded.
Example::
def test_function(record_property):
record_property("example_key", 1)
"""
_warn_incompatibility_with_xunit2
(
request
,
"record_property"
)
def
append_property
(
name
:
str
,
value
:
object
)
->
None
:
request
.
node
.
user_properties
.
append
((
name
,
value
))
return
append_property
@pytest
.
fixture
def
record_xml_attribute
(
request
:
FixtureRequest
)
->
Callable
[[
str
,
object
],
None
]:
"""Add extra xml attributes to the tag for the calling test.
The fixture is callable with ``name, value``. The value is
automatically XML-encoded.
"""
from
_pytest.warning_types
import
PytestExperimentalApiWarning
request
.
node
.
warn
(
PytestExperimentalApiWarning
(
"record_xml_attribute is an experimental feature"
)
)
_warn_incompatibility_with_xunit2
(
request
,
"record_xml_attribute"
)
# Declare noop
def
add_attr_noop
(
name
:
str
,
value
:
object
)
->
None
:
pass
attr_func
=
add_attr_noop
xml
=
request
.
config
.
stash
.
get
(
xml_key
,
None
)
if
xml
is
not
None
:
node_reporter
=
xml
.
node_reporter
(
request
.
node
.
nodeid
)
attr_func
=
node_reporter
.
add_attribute
return
attr_func
def
_check_record_param_type
(
param
:
str
,
v
:
str
)
->
None
:
"""Used by record_testsuite_property to check that the given parameter name is of the proper
type."""
__tracebackhide__
=
True
if
not
isinstance
(
v
,
str
):
msg
=
"
{param}
parameter needs to be a string, but
{g}
given"
# type: ignore[unreachable]
raise
TypeError
(
msg
.
format
(
param
=
param
,
g
=
type
(
v
)
.
__name__
))
[docs]
@pytest
.
fixture
(
scope
=
"session"
)
def
record_testsuite_property
(
request
:
FixtureRequest
)
->
Callable
[[
str
,
object
],
None
]:
"""Record a new ``<property>`` tag as child of the root ``<testsuite>``.
This is suitable to writing global information regarding the entire test
suite, and is compatible with ``xunit2`` JUnit family.
This is a ``session``-scoped fixture which is called with ``(name, value)``. Example:
.. code-block:: python
def test_foo(record_testsuite_property):
record_testsuite_property("ARCH", "PPC")
record_testsuite_property("STORAGE_TYPE", "CEPH")
:param name:
The property name.
:param value:
The property value. Will be converted to a string.
.. warning::
Currently this fixture **does not work** with the
`pytest-xdist <https://github.com/pytest-dev/pytest-xdist>`__ plugin. See
:issue:`7767` for details.
"""
__tracebackhide__
=
True
def
record_func
(
name
:
str
,
value
:
object
)
->
None
:
"""No-op function in case --junit-xml was not passed in the command-line."""
__tracebackhide__
=
True
_check_record_param_type
(
"name"
,
name
)
xml
=
request
.
config
.
stash
.
get
(
xml_key
,
None
)
if
xml
is
not
None
:
record_func
=
xml
.
add_global_property
return
record_func
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
group
=
parser
.
getgroup
(
"terminal reporting"
)
group
.
addoption
(
"--junitxml"
,
"--junit-xml"
,
action
=
"store"
,
dest
=
"xmlpath"
,
metavar
=
"path"
,
type
=
functools
.
partial
(
filename_arg
,
optname
=
"--junitxml"
),
default
=
None
,
help
=
"Create junit-xml style report file at given path"
,
)
group
.
addoption
(
"--junitprefix"
,
"--junit-prefix"
,
action
=
"store"
,
metavar
=
"str"
,
default
=
None
,
help
=
"Prepend prefix to classnames in junit-xml output"
,
)
parser
.
addini
(
"junit_suite_name"
,
"Test suite name for JUnit report"
,
default
=
"pytest"
)
parser
.
addini
(
"junit_logging"
,
"Write captured log messages to JUnit report: "
"one of no|log|system-out|system-err|out-err|all"
,
default
=
"no"
,
)
parser
.
addini
(
"junit_log_passing_tests"
,
"Capture log information for passing tests to JUnit report: "
,
type
=
"bool"
,
default
=
True
,
)
parser
.
addini
(
"junit_duration_report"
,
"Duration time to report: one of total|call"
,
default
=
"total"
,
)
# choices=['total', 'call'])
parser
.
addini
(
"junit_family"
,
"Emit XML for schema: one of legacy|xunit1|xunit2"
,
default
=
"xunit2"
,
)
def
pytest_configure
(
config
:
Config
)
->
None
:
xmlpath
=
config
.
option
.
xmlpath
# Prevent opening xmllog on worker nodes (xdist).
if
xmlpath
and
not
hasattr
(
config
,
"workerinput"
):
junit_family
=
config
.
getini
(
"junit_family"
)
config
.
stash
[
xml_key
]
=
LogXML
(
xmlpath
,
config
.
option
.
junitprefix
,
config
.
getini
(
"junit_suite_name"
),
config
.
getini
(
"junit_logging"
),
config
.
getini
(
"junit_duration_report"
),
junit_family
,
config
.
getini
(
"junit_log_passing_tests"
),
)
config
.
pluginmanager
.
register
(
config
.
stash
[
xml_key
])
def
pytest_unconfigure
(
config
:
Config
)
->
None
:
xml
=
config
.
stash
.
get
(
xml_key
,
None
)
if
xml
:
del
config
.
stash
[
xml_key
]
config
.
pluginmanager
.
unregister
(
xml
)
def
mangle_test_address
(
address
:
str
)
->
list
[
str
]:
path
,
possible_open_bracket
,
params
=
address
.
partition
(
"["
)
names
=
path
.
split
(
"::"
)
# Convert file path to dotted path.
names
[
0
]
=
names
[
0
]
.
replace
(
nodes
.
SEP
,
"."
)
names
[
0
]
=
re
.
sub
(
r
"\.py$"
,
""
,
names
[
0
])
# Put any params back.
names
[
-
1
]
+=
possible_open_bracket
+
params
return
names
class
LogXML
:
def
__init__
(
self
,
logfile
,
prefix
:
str
|
None
,
suite_name
:
str
=
"pytest"
,
logging
:
str
=
"no"
,
report_duration
:
str
=
"total"
,
family
=
"xunit1"
,
log_passing_tests
:
bool
=
True
,
)
->
None
:
logfile
=
os
.
path
.
expanduser
(
os
.
path
.
expandvars
(
logfile
))
self
.
logfile
=
os
.
path
.
normpath
(
os
.
path
.
abspath
(
logfile
))
self
.
prefix
=
prefix
self
.
suite_name
=
suite_name
self
.
logging
=
logging
self
.
log_passing_tests
=
log_passing_tests
self
.
report_duration
=
report_duration
self
.
family
=
family
self
.
stats
:
dict
[
str
,
int
]
=
dict
.
fromkeys
(
[
"error"
,
"passed"
,
"failure"
,
"skipped"
],
0
)
self
.
node_reporters
:
dict
[
tuple
[
str
|
TestReport
,
object
],
_NodeReporter
]
=
{}
self
.
node_reporters_ordered
:
list
[
_NodeReporter
]
=
[]
self
.
global_properties
:
list
[
tuple
[
str
,
str
]]
=
[]
# List of reports that failed on call but teardown is pending.
self
.
open_reports
:
list
[
TestReport
]
=
[]
self
.
cnt_double_fail_tests
=
0
# Replaces convenience family with real family.
if
self
.
family
==
"legacy"
:
self
.
family
=
"xunit1"
def
finalize
(
self
,
report
:
TestReport
)
->
None
:
nodeid
=
getattr
(
report
,
"nodeid"
,
report
)
# Local hack to handle xdist report order.
workernode
=
getattr
(
report
,
"node"
,
None
)
reporter
=
self
.
node_reporters
.
pop
((
nodeid
,
workernode
))
for
propname
,
propvalue
in
report
.
user_properties
:
reporter
.
add_property
(
propname
,
str
(
propvalue
))
if
reporter
is
not
None
:
reporter
.
finalize
()
def
node_reporter
(
self
,
report
:
TestReport
|
str
)
->
_NodeReporter
:
nodeid
:
str
|
TestReport
=
getattr
(
report
,
"nodeid"
,
report
)
# Local hack to handle xdist report order.
workernode
=
getattr
(
report
,
"node"
,
None
)
key
=
nodeid
,
workernode
if
key
in
self
.
node_reporters
:
# TODO: breaks for --dist=each
return
self
.
node_reporters
[
key
]
reporter
=
_NodeReporter
(
nodeid
,
self
)
self
.
node_reporters
[
key
]
=
reporter
self
.
node_reporters_ordered
.
append
(
reporter
)
return
reporter
def
add_stats
(
self
,
key
:
str
)
->
None
:
if
key
in
self
.
stats
:
self
.
stats
[
key
]
+=
1
def
_opentestcase
(
self
,
report
:
TestReport
)
->
_NodeReporter
:
reporter
=
self
.
node_reporter
(
report
)
reporter
.
record_testreport
(
report
)
return
reporter
def
pytest_runtest_logreport
(
self
,
report
:
TestReport
)
->
None
:
"""Handle a setup/call/teardown report, generating the appropriate
XML tags as necessary.
Note: due to plugins like xdist, this hook may be called in interlaced
order with reports from other nodes. For example:
Usual call order:
-> setup node1
-> call node1
-> teardown node1
-> setup node2
-> call node2
-> teardown node2
Possible call order in xdist:
-> setup node1
-> call node1
-> setup node2
-> call node2
-> teardown node2
-> teardown node1
"""
close_report
=
None
if
report
.
passed
:
if
report
.
when
==
"call"
:
# ignore setup/teardown
reporter
=
self
.
_opentestcase
(
report
)
reporter
.
append_pass
(
report
)
elif
report
.
failed
:
if
report
.
when
==
"teardown"
:
# The following vars are needed when xdist plugin is used.
report_wid
=
getattr
(
report
,
"worker_id"
,
None
)
report_ii
=
getattr
(
report
,
"item_index"
,
None
)
close_report
=
next
(
(
rep
for
rep
in
self
.
open_reports
if
(
rep
.
nodeid
==
report
.
nodeid
and
getattr
(
rep
,
"item_index"
,
None
)
==
report_ii
and
getattr
(
rep
,
"worker_id"
,
None
)
==
report_wid
)
),
None
,
)
if
close_report
:
# We need to open new testcase in case we have failure in
# call and error in teardown in order to follow junit
# schema.
self
.
finalize
(
close_report
)
self
.
cnt_double_fail_tests
+=
1
reporter
=
self
.
_opentestcase
(
report
)
if
report
.
when
==
"call"
:
reporter
.
append_failure
(
report
)
self
.
open_reports
.
append
(
report
)
if
not
self
.
log_passing_tests
:
reporter
.
write_captured_output
(
report
)
else
:
reporter
.
append_error
(
report
)
elif
report
.
skipped
:
reporter
=
self
.
_opentestcase
(
report
)
reporter
.
append_skipped
(
report
)
self
.
update_testcase_duration
(
report
)
if
report
.
when
==
"teardown"
:
reporter
=
self
.
_opentestcase
(
report
)
reporter
.
write_captured_output
(
report
)
self
.
finalize
(
report
)
report_wid
=
getattr
(
report
,
"worker_id"
,
None
)
report_ii
=
getattr
(
report
,
"item_index"
,
None
)
close_report
=
next
(
(
rep
for
rep
in
self
.
open_reports
if
(
rep
.
nodeid
==
report
.
nodeid
and
getattr
(
rep
,
"item_index"
,
None
)
==
report_ii
and
getattr
(
rep
,
"worker_id"
,
None
)
==
report_wid
)
),
None
,
)
if
close_report
:
self
.
open_reports
.
remove
(
close_report
)
def
update_testcase_duration
(
self
,
report
:
TestReport
)
->
None
:
"""Accumulate total duration for nodeid from given report and update
the Junit.testcase with the new total if already created."""
if
self
.
report_duration
in
{
"total"
,
report
.
when
}:
reporter
=
self
.
node_reporter
(
report
)
reporter
.
duration
+=
getattr
(
report
,
"duration"
,
0.0
)
def
pytest_collectreport
(
self
,
report
:
TestReport
)
->
None
:
if
not
report
.
passed
:
reporter
=
self
.
_opentestcase
(
report
)
if
report
.
failed
:
reporter
.
append_collect_error
(
report
)
else
:
reporter
.
append_collect_skipped
(
report
)
def
pytest_internalerror
(
self
,
excrepr
:
ExceptionRepr
)
->
None
:
reporter
=
self
.
node_reporter
(
"internal"
)
reporter
.
attrs
.
update
(
classname
=
"pytest"
,
name
=
"internal"
)
reporter
.
_add_simple
(
"error"
,
"internal error"
,
str
(
excrepr
))
def
pytest_sessionstart
(
self
)
->
None
:
self
.
suite_start_time
=
timing
.
time
()
def
pytest_sessionfinish
(
self
)
->
None
:
dirname
=
os
.
path
.
dirname
(
os
.
path
.
abspath
(
self
.
logfile
))
# exist_ok avoids filesystem race conditions between checking path existence and requesting creation
os
.
makedirs
(
dirname
,
exist_ok
=
True
)
with
open
(
self
.
logfile
,
"w"
,
encoding
=
"utf-8"
)
as
logfile
:
suite_stop_time
=
timing
.
time
()
suite_time_delta
=
suite_stop_time
-
self
.
suite_start_time
numtests
=
(
self
.
stats
[
"passed"
]
+
self
.
stats
[
"failure"
]
+
self
.
stats
[
"skipped"
]
+
self
.
stats
[
"error"
]
-
self
.
cnt_double_fail_tests
)
logfile
.
write
(
'<?xml version="1.0" encoding="utf-8"?>'
)
suite_node
=
ET
.
Element
(
"testsuite"
,
name
=
self
.
suite_name
,
errors
=
str
(
self
.
stats
[
"error"
]),
failures
=
str
(
self
.
stats
[
"failure"
]),
skipped
=
str
(
self
.
stats
[
"skipped"
]),
tests
=
str
(
numtests
),
time
=
f
"
{
suite_time_delta
:
.3f
}
"
,
timestamp
=
datetime
.
fromtimestamp
(
self
.
suite_start_time
,
timezone
.
utc
)
.
astimezone
()
.
isoformat
(),
hostname
=
platform
.
node
(),
)
global_properties
=
self
.
_get_global_properties_node
()
if
global_properties
is
not
None
:
suite_node
.
append
(
global_properties
)
for
node_reporter
in
self
.
node_reporters_ordered
:
suite_node
.
append
(
node_reporter
.
to_xml
())
testsuites
=
ET
.
Element
(
"testsuites"
)
testsuites
.
append
(
suite_node
)
logfile
.
write
(
ET
.
tostring
(
testsuites
,
encoding
=
"unicode"
))
def
pytest_terminal_summary
(
self
,
terminalreporter
:
TerminalReporter
)
->
None
:
terminalreporter
.
write_sep
(
"-"
,
f
"generated xml file:
{
self
.
logfile
}
"
)
def
add_global_property
(
self
,
name
:
str
,
value
:
object
)
->
None
:
__tracebackhide__
=
True
_check_record_param_type
(
"name"
,
name
)
self
.
global_properties
.
append
((
name
,
bin_xml_escape
(
value
)))
def
_get_global_properties_node
(
self
)
->
ET
.
Element
|
None
:
"""Return a Junit node containing custom properties, if any."""
if
self
.
global_properties
:
properties
=
ET
.
Element
(
"properties"
)
for
name
,
value
in
self
.
global_properties
:
properties
.
append
(
ET
.
Element
(
"property"
,
name
=
name
,
value
=
value
))
return
properties
return
None

```


---


# _pytest.doctest - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/doctest.html


# Source code for _pytest.doctest

```

# mypy: allow-untyped-defs
"""Discover and run doctests in modules and test files."""
from
__future__
import
annotations
import
bdb
from
contextlib
import
contextmanager
import
functools
import
inspect
import
os
from
pathlib
import
Path
import
platform
import
sys
import
traceback
import
types
from
typing
import
Any
from
typing
import
Callable
from
typing
import
Generator
from
typing
import
Iterable
from
typing
import
Pattern
from
typing
import
Sequence
from
typing
import
TYPE_CHECKING
import
warnings
from
_pytest
import
outcomes
from
_pytest._code.code
import
ExceptionInfo
from
_pytest._code.code
import
ReprFileLocation
from
_pytest._code.code
import
TerminalRepr
from
_pytest._io
import
TerminalWriter
from
_pytest.compat
import
safe_getattr
from
_pytest.config
import
Config
from
_pytest.config.argparsing
import
Parser
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
TopRequest
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
Item
from
_pytest.outcomes
import
OutcomeException
from
_pytest.outcomes
import
skip
from
_pytest.pathlib
import
fnmatch_ex
from
_pytest.python
import
Module
from
_pytest.python_api
import
approx
from
_pytest.warning_types
import
PytestWarning
if
TYPE_CHECKING
:
import
doctest
from
typing_extensions
import
Self
DOCTEST_REPORT_CHOICE_NONE
=
"none"
DOCTEST_REPORT_CHOICE_CDIFF
=
"cdiff"
DOCTEST_REPORT_CHOICE_NDIFF
=
"ndiff"
DOCTEST_REPORT_CHOICE_UDIFF
=
"udiff"
DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE
=
"only_first_failure"
DOCTEST_REPORT_CHOICES
=
(
DOCTEST_REPORT_CHOICE_NONE
,
DOCTEST_REPORT_CHOICE_CDIFF
,
DOCTEST_REPORT_CHOICE_NDIFF
,
DOCTEST_REPORT_CHOICE_UDIFF
,
DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE
,
)
# Lazy definition of runner class
RUNNER_CLASS
=
None
# Lazy definition of output checker class
CHECKER_CLASS
:
type
[
doctest
.
OutputChecker
]
|
None
=
None
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
parser
.
addini
(
"doctest_optionflags"
,
"Option flags for doctests"
,
type
=
"args"
,
default
=
[
"ELLIPSIS"
],
)
parser
.
addini
(
"doctest_encoding"
,
"Encoding used for doctest files"
,
default
=
"utf-8"
)
group
=
parser
.
getgroup
(
"collect"
)
group
.
addoption
(
"--doctest-modules"
,
action
=
"store_true"
,
default
=
False
,
help
=
"Run doctests in all .py modules"
,
dest
=
"doctestmodules"
,
)
group
.
addoption
(
"--doctest-report"
,
type
=
str
.
lower
,
default
=
"udiff"
,
help
=
"Choose another output format for diffs on doctest failure"
,
choices
=
DOCTEST_REPORT_CHOICES
,
dest
=
"doctestreport"
,
)
group
.
addoption
(
"--doctest-glob"
,
action
=
"append"
,
default
=
[],
metavar
=
"pat"
,
help
=
"Doctests file matching pattern, default: test*.txt"
,
dest
=
"doctestglob"
,
)
group
.
addoption
(
"--doctest-ignore-import-errors"
,
action
=
"store_true"
,
default
=
False
,
help
=
"Ignore doctest collection errors"
,
dest
=
"doctest_ignore_import_errors"
,
)
group
.
addoption
(
"--doctest-continue-on-failure"
,
action
=
"store_true"
,
default
=
False
,
help
=
"For a given doctest, continue to run after the first failure"
,
dest
=
"doctest_continue_on_failure"
,
)
def
pytest_unconfigure
()
->
None
:
global
RUNNER_CLASS
RUNNER_CLASS
=
None
def
pytest_collect_file
(
file_path
:
Path
,
parent
:
Collector
,
)
->
DoctestModule
|
DoctestTextfile
|
None
:
config
=
parent
.
config
if
file_path
.
suffix
==
".py"
:
if
config
.
option
.
doctestmodules
and
not
any
(
(
_is_setup_py
(
file_path
),
_is_main_py
(
file_path
))
):
return
DoctestModule
.
from_parent
(
parent
,
path
=
file_path
)
elif
_is_doctest
(
config
,
file_path
,
parent
):
return
DoctestTextfile
.
from_parent
(
parent
,
path
=
file_path
)
return
None
def
_is_setup_py
(
path
:
Path
)
->
bool
:
if
path
.
name
!=
"setup.py"
:
return
False
contents
=
path
.
read_bytes
()
return
b
"setuptools"
in
contents
or
b
"distutils"
in
contents
def
_is_doctest
(
config
:
Config
,
path
:
Path
,
parent
:
Collector
)
->
bool
:
if
path
.
suffix
in
(
".txt"
,
".rst"
)
and
parent
.
session
.
isinitpath
(
path
):
return
True
globs
=
config
.
getoption
(
"doctestglob"
)
or
[
"test*.txt"
]
return
any
(
fnmatch_ex
(
glob
,
path
)
for
glob
in
globs
)
def
_is_main_py
(
path
:
Path
)
->
bool
:
return
path
.
name
==
"__main__.py"
class
ReprFailDoctest
(
TerminalRepr
):
def
__init__
(
self
,
reprlocation_lines
:
Sequence
[
tuple
[
ReprFileLocation
,
Sequence
[
str
]]]
)
->
None
:
self
.
reprlocation_lines
=
reprlocation_lines
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
for
reprlocation
,
lines
in
self
.
reprlocation_lines
:
for
line
in
lines
:
tw
.
line
(
line
)
reprlocation
.
toterminal
(
tw
)
class
MultipleDoctestFailures
(
Exception
):
def
__init__
(
self
,
failures
:
Sequence
[
doctest
.
DocTestFailure
])
->
None
:
super
()
.
__init__
()
self
.
failures
=
failures
def
_init_runner_class
()
->
type
[
doctest
.
DocTestRunner
]:
import
doctest
class
PytestDoctestRunner
(
doctest
.
DebugRunner
):
"""Runner to collect failures.
Note that the out variable in this case is a list instead of a
stdout-like object.
"""
def
__init__
(
self
,
checker
:
doctest
.
OutputChecker
|
None
=
None
,
verbose
:
bool
|
None
=
None
,
optionflags
:
int
=
0
,
continue_on_failure
:
bool
=
True
,
)
->
None
:
super
()
.
__init__
(
checker
=
checker
,
verbose
=
verbose
,
optionflags
=
optionflags
)
self
.
continue_on_failure
=
continue_on_failure
def
report_failure
(
self
,
out
,
test
:
doctest
.
DocTest
,
example
:
doctest
.
Example
,
got
:
str
,
)
->
None
:
failure
=
doctest
.
DocTestFailure
(
test
,
example
,
got
)
if
self
.
continue_on_failure
:
out
.
append
(
failure
)
else
:
raise
failure
def
report_unexpected_exception
(
self
,
out
,
test
:
doctest
.
DocTest
,
example
:
doctest
.
Example
,
exc_info
:
tuple
[
type
[
BaseException
],
BaseException
,
types
.
TracebackType
],
)
->
None
:
if
isinstance
(
exc_info
[
1
],
OutcomeException
):
raise
exc_info
[
1
]
if
isinstance
(
exc_info
[
1
],
bdb
.
BdbQuit
):
outcomes
.
exit
(
"Quitting debugger"
)
failure
=
doctest
.
UnexpectedException
(
test
,
example
,
exc_info
)
if
self
.
continue_on_failure
:
out
.
append
(
failure
)
else
:
raise
failure
return
PytestDoctestRunner
def
_get_runner
(
checker
:
doctest
.
OutputChecker
|
None
=
None
,
verbose
:
bool
|
None
=
None
,
optionflags
:
int
=
0
,
continue_on_failure
:
bool
=
True
,
)
->
doctest
.
DocTestRunner
:
# We need this in order to do a lazy import on doctest
global
RUNNER_CLASS
if
RUNNER_CLASS
is
None
:
RUNNER_CLASS
=
_init_runner_class
()
# Type ignored because the continue_on_failure argument is only defined on
# PytestDoctestRunner, which is lazily defined so can't be used as a type.
return
RUNNER_CLASS
(
# type: ignore
checker
=
checker
,
verbose
=
verbose
,
optionflags
=
optionflags
,
continue_on_failure
=
continue_on_failure
,
)
class
DoctestItem
(
Item
):
def
__init__
(
self
,
name
:
str
,
parent
:
DoctestTextfile
|
DoctestModule
,
runner
:
doctest
.
DocTestRunner
,
dtest
:
doctest
.
DocTest
,
)
->
None
:
super
()
.
__init__
(
name
,
parent
)
self
.
runner
=
runner
self
.
dtest
=
dtest
# Stuff needed for fixture support.
self
.
obj
=
None
fm
=
self
.
session
.
_fixturemanager
fixtureinfo
=
fm
.
getfixtureinfo
(
node
=
self
,
func
=
None
,
cls
=
None
)
self
.
_fixtureinfo
=
fixtureinfo
self
.
fixturenames
=
fixtureinfo
.
names_closure
self
.
_initrequest
()
@classmethod
def
from_parent
(
# type: ignore[override]
cls
,
parent
:
DoctestTextfile
|
DoctestModule
,
*
,
name
:
str
,
runner
:
doctest
.
DocTestRunner
,
dtest
:
doctest
.
DocTest
,
)
->
Self
:
# incompatible signature due to imposed limits on subclass
"""The public named constructor."""
return
super
()
.
from_parent
(
name
=
name
,
parent
=
parent
,
runner
=
runner
,
dtest
=
dtest
)
def
_initrequest
(
self
)
->
None
:
self
.
funcargs
:
dict
[
str
,
object
]
=
{}
self
.
_request
=
TopRequest
(
self
,
_ispytest
=
True
)
# type: ignore[arg-type]
def
setup
(
self
)
->
None
:
self
.
_request
.
_fillfixtures
()
globs
=
dict
(
getfixture
=
self
.
_request
.
getfixturevalue
)
for
name
,
value
in
self
.
_request
.
getfixturevalue
(
"doctest_namespace"
)
.
items
():
globs
[
name
]
=
value
self
.
dtest
.
globs
.
update
(
globs
)
def
runtest
(
self
)
->
None
:
_check_all_skipped
(
self
.
dtest
)
self
.
_disable_output_capturing_for_darwin
()
failures
:
list
[
doctest
.
DocTestFailure
]
=
[]
# Type ignored because we change the type of `out` from what
# doctest expects.
self
.
runner
.
run
(
self
.
dtest
,
out
=
failures
)
# type: ignore[arg-type]
if
failures
:
raise
MultipleDoctestFailures
(
failures
)
def
_disable_output_capturing_for_darwin
(
self
)
->
None
:
"""Disable output capturing. Otherwise, stdout is lost to doctest (#985)."""
if
platform
.
system
()
!=
"Darwin"
:
return
capman
=
self
.
config
.
pluginmanager
.
getplugin
(
"capturemanager"
)
if
capman
:
capman
.
suspend_global_capture
(
in_
=
True
)
out
,
err
=
capman
.
read_global_capture
()
sys
.
stdout
.
write
(
out
)
sys
.
stderr
.
write
(
err
)
# TODO: Type ignored -- breaks Liskov Substitution.
def
repr_failure
(
# type: ignore[override]
self
,
excinfo
:
ExceptionInfo
[
BaseException
],
)
->
str
|
TerminalRepr
:
import
doctest
failures
:
(
Sequence
[
doctest
.
DocTestFailure
|
doctest
.
UnexpectedException
]
|
None
)
=
None
if
isinstance
(
excinfo
.
value
,
(
doctest
.
DocTestFailure
,
doctest
.
UnexpectedException
)
):
failures
=
[
excinfo
.
value
]
elif
isinstance
(
excinfo
.
value
,
MultipleDoctestFailures
):
failures
=
excinfo
.
value
.
failures
if
failures
is
None
:
return
super
()
.
repr_failure
(
excinfo
)
reprlocation_lines
=
[]
for
failure
in
failures
:
example
=
failure
.
example
test
=
failure
.
test
filename
=
test
.
filename
if
test
.
lineno
is
None
:
lineno
=
None
else
:
lineno
=
test
.
lineno
+
example
.
lineno
+
1
message
=
type
(
failure
)
.
__name__
# TODO: ReprFileLocation doesn't expect a None lineno.
reprlocation
=
ReprFileLocation
(
filename
,
lineno
,
message
)
# type: ignore[arg-type]
checker
=
_get_checker
()
report_choice
=
_get_report_choice
(
self
.
config
.
getoption
(
"doctestreport"
))
if
lineno
is
not
None
:
assert
failure
.
test
.
docstring
is
not
None
lines
=
failure
.
test
.
docstring
.
splitlines
(
False
)
# add line numbers to the left of the error message
assert
test
.
lineno
is
not
None
lines
=
[
"
%03d
%s
"
%
(
i
+
test
.
lineno
+
1
,
x
)
for
(
i
,
x
)
in
enumerate
(
lines
)
]
# trim docstring error lines to 10
lines
=
lines
[
max
(
example
.
lineno
-
9
,
0
)
:
example
.
lineno
+
1
]
else
:
lines
=
[
"EXAMPLE LOCATION UNKNOWN, not showing all tests of that example"
]
indent
=
">>>"
for
line
in
example
.
source
.
splitlines
():
lines
.
append
(
f
"???
{
indent
}
{
line
}
"
)
indent
=
"..."
if
isinstance
(
failure
,
doctest
.
DocTestFailure
):
lines
+=
checker
.
output_difference
(
example
,
failure
.
got
,
report_choice
)
.
split
(
"
\n
"
)
else
:
inner_excinfo
=
ExceptionInfo
.
from_exc_info
(
failure
.
exc_info
)
lines
+=
[
f
"UNEXPECTED EXCEPTION:
{
inner_excinfo
.
value
!r}
"
]
lines
+=
[
x
.
strip
(
"
\n
"
)
for
x
in
traceback
.
format_exception
(
*
failure
.
exc_info
)
]
reprlocation_lines
.
append
((
reprlocation
,
lines
))
return
ReprFailDoctest
(
reprlocation_lines
)
def
reportinfo
(
self
)
->
tuple
[
os
.
PathLike
[
str
]
|
str
,
int
|
None
,
str
]:
return
self
.
path
,
self
.
dtest
.
lineno
,
f
"[doctest]
{
self
.
name
}
"
def
_get_flag_lookup
()
->
dict
[
str
,
int
]:
import
doctest
return
dict
(
DONT_ACCEPT_TRUE_FOR_1
=
doctest
.
DONT_ACCEPT_TRUE_FOR_1
,
DONT_ACCEPT_BLANKLINE
=
doctest
.
DONT_ACCEPT_BLANKLINE
,
NORMALIZE_WHITESPACE
=
doctest
.
NORMALIZE_WHITESPACE
,
ELLIPSIS
=
doctest
.
ELLIPSIS
,
IGNORE_EXCEPTION_DETAIL
=
doctest
.
IGNORE_EXCEPTION_DETAIL
,
COMPARISON_FLAGS
=
doctest
.
COMPARISON_FLAGS
,
ALLOW_UNICODE
=
_get_allow_unicode_flag
(),
ALLOW_BYTES
=
_get_allow_bytes_flag
(),
NUMBER
=
_get_number_flag
(),
)
def
get_optionflags
(
config
:
Config
)
->
int
:
optionflags_str
=
config
.
getini
(
"doctest_optionflags"
)
flag_lookup_table
=
_get_flag_lookup
()
flag_acc
=
0
for
flag
in
optionflags_str
:
flag_acc
|=
flag_lookup_table
[
flag
]
return
flag_acc
def
_get_continue_on_failure
(
config
:
Config
)
->
bool
:
continue_on_failure
:
bool
=
config
.
getvalue
(
"doctest_continue_on_failure"
)
if
continue_on_failure
:
# We need to turn off this if we use pdb since we should stop at
# the first failure.
if
config
.
getvalue
(
"usepdb"
):
continue_on_failure
=
False
return
continue_on_failure
class
DoctestTextfile
(
Module
):
obj
=
None
def
collect
(
self
)
->
Iterable
[
DoctestItem
]:
import
doctest
# Inspired by doctest.testfile; ideally we would use it directly,
# but it doesn't support passing a custom checker.
encoding
=
self
.
config
.
getini
(
"doctest_encoding"
)
text
=
self
.
path
.
read_text
(
encoding
)
filename
=
str
(
self
.
path
)
name
=
self
.
path
.
name
globs
=
{
"__name__"
:
"__main__"
}
optionflags
=
get_optionflags
(
self
.
config
)
runner
=
_get_runner
(
verbose
=
False
,
optionflags
=
optionflags
,
checker
=
_get_checker
(),
continue_on_failure
=
_get_continue_on_failure
(
self
.
config
),
)
parser
=
doctest
.
DocTestParser
()
test
=
parser
.
get_doctest
(
text
,
globs
,
name
,
filename
,
0
)
if
test
.
examples
:
yield
DoctestItem
.
from_parent
(
self
,
name
=
test
.
name
,
runner
=
runner
,
dtest
=
test
)
def
_check_all_skipped
(
test
:
doctest
.
DocTest
)
->
None
:
"""Raise pytest.skip() if all examples in the given DocTest have the SKIP
option set."""
import
doctest
all_skipped
=
all
(
x
.
options
.
get
(
doctest
.
SKIP
,
False
)
for
x
in
test
.
examples
)
if
all_skipped
:
skip
(
"all tests skipped by +SKIP option"
)
def
_is_mocked
(
obj
:
object
)
->
bool
:
"""Return if an object is possibly a mock object by checking the
existence of a highly improbable attribute."""
return
(
safe_getattr
(
obj
,
"pytest_mock_example_attribute_that_shouldnt_exist"
,
None
)
is
not
None
)
@contextmanager
def
_patch_unwrap_mock_aware
()
->
Generator
[
None
]:
"""Context manager which replaces ``inspect.unwrap`` with a version
that's aware of mock objects and doesn't recurse into them."""
real_unwrap
=
inspect
.
unwrap
def
_mock_aware_unwrap
(
func
:
Callable
[
...
,
Any
],
*
,
stop
:
Callable
[[
Any
],
Any
]
|
None
=
None
)
->
Any
:
try
:
if
stop
is
None
or
stop
is
_is_mocked
:
return
real_unwrap
(
func
,
stop
=
_is_mocked
)
_stop
=
stop
return
real_unwrap
(
func
,
stop
=
lambda
obj
:
_is_mocked
(
obj
)
or
_stop
(
func
))
except
Exception
as
e
:
warnings
.
warn
(
f
"Got
{
e
!r}
when unwrapping
{
func
!r}
.  This is usually caused "
"by a violation of Python's object protocol; see e.g. "
"https://github.com/pytest-dev/pytest/issues/5080"
,
PytestWarning
,
)
raise
inspect
.
unwrap
=
_mock_aware_unwrap
try
:
yield
finally
:
inspect
.
unwrap
=
real_unwrap
class
DoctestModule
(
Module
):
def
collect
(
self
)
->
Iterable
[
DoctestItem
]:
import
doctest
class
MockAwareDocTestFinder
(
doctest
.
DocTestFinder
):
py_ver_info_minor
=
sys
.
version_info
[:
2
]
is_find_lineno_broken
=
(
py_ver_info_minor
<
(
3
,
11
)
or
(
py_ver_info_minor
==
(
3
,
11
)
and
sys
.
version_info
.
micro
<
9
)
or
(
py_ver_info_minor
==
(
3
,
12
)
and
sys
.
version_info
.
micro
<
3
)
)
if
is_find_lineno_broken
:
def
_find_lineno
(
self
,
obj
,
source_lines
):
"""On older Pythons, doctest code does not take into account
`@property`. https://github.com/python/cpython/issues/61648
Moreover, wrapped Doctests need to be unwrapped so the correct
line number is returned. #8796
"""
if
isinstance
(
obj
,
property
):
obj
=
getattr
(
obj
,
"fget"
,
obj
)
if
hasattr
(
obj
,
"__wrapped__"
):
# Get the main obj in case of it being wrapped
obj
=
inspect
.
unwrap
(
obj
)
# Type ignored because this is a private function.
return
super
()
.
_find_lineno
(
# type:ignore[misc]
obj
,
source_lines
,
)
if
sys
.
version_info
<
(
3
,
10
):
def
_find
(
self
,
tests
,
obj
,
name
,
module
,
source_lines
,
globs
,
seen
)
->
None
:
"""Override _find to work around issue in stdlib.
https://github.com/pytest-dev/pytest/issues/3456
https://github.com/python/cpython/issues/69718
"""
if
_is_mocked
(
obj
):
return
# pragma: no cover
with
_patch_unwrap_mock_aware
():
# Type ignored because this is a private function.
super
()
.
_find
(
# type:ignore[misc]
tests
,
obj
,
name
,
module
,
source_lines
,
globs
,
seen
)
if
sys
.
version_info
<
(
3
,
13
):
def
_from_module
(
self
,
module
,
object
):
"""`cached_property` objects are never considered a part
of the 'current module'. As such they are skipped by doctest.
Here we override `_from_module` to check the underlying
function instead. https://github.com/python/cpython/issues/107995
"""
if
isinstance
(
object
,
functools
.
cached_property
):
object
=
object
.
func
# Type ignored because this is a private function.
return
super
()
.
_from_module
(
module
,
object
)
# type: ignore[misc]
try
:
module
=
self
.
obj
except
Collector
.
CollectError
:
if
self
.
config
.
getvalue
(
"doctest_ignore_import_errors"
):
skip
(
f
"unable to import module
{
self
.
path
!r}
"
)
else
:
raise
# While doctests currently don't support fixtures directly, we still
# need to pick up autouse fixtures.
self
.
session
.
_fixturemanager
.
parsefactories
(
self
)
# Uses internal doctest module parsing mechanism.
finder
=
MockAwareDocTestFinder
()
optionflags
=
get_optionflags
(
self
.
config
)
runner
=
_get_runner
(
verbose
=
False
,
optionflags
=
optionflags
,
checker
=
_get_checker
(),
continue_on_failure
=
_get_continue_on_failure
(
self
.
config
),
)
for
test
in
finder
.
find
(
module
,
module
.
__name__
):
if
test
.
examples
:
# skip empty doctests
yield
DoctestItem
.
from_parent
(
self
,
name
=
test
.
name
,
runner
=
runner
,
dtest
=
test
)
def
_init_checker_class
()
->
type
[
doctest
.
OutputChecker
]:
import
doctest
import
re
class
LiteralsOutputChecker
(
doctest
.
OutputChecker
):
# Based on doctest_nose_plugin.py from the nltk project
# (https://github.com/nltk/nltk) and on the "numtest" doctest extension
# by Sebastien Boisgerault (https://github.com/boisgera/numtest).
_unicode_literal_re
=
re
.
compile
(
r
"(\W|^)[uU]([rR]?[\'
\"
])"
,
re
.
UNICODE
)
_bytes_literal_re
=
re
.
compile
(
r
"(\W|^)[bB]([rR]?[\'
\"
])"
,
re
.
UNICODE
)
_number_re
=
re
.
compile
(
r
"""
(?P<number>
(?P<mantissa>
(?P<integer1> [+-]?\d*)\.(?P<fraction>\d+)
|
(?P<integer2> [+-]?\d+)\.
)
(?:
[Ee]
(?P<exponent1> [+-]?\d+)
)?
|
(?P<integer3> [+-]?\d+)
(?:
[Ee]
(?P<exponent2> [+-]?\d+)
)
)
"""
,
re
.
VERBOSE
,
)
def
check_output
(
self
,
want
:
str
,
got
:
str
,
optionflags
:
int
)
->
bool
:
if
super
()
.
check_output
(
want
,
got
,
optionflags
):
return
True
allow_unicode
=
optionflags
&
_get_allow_unicode_flag
()
allow_bytes
=
optionflags
&
_get_allow_bytes_flag
()
allow_number
=
optionflags
&
_get_number_flag
()
if
not
allow_unicode
and
not
allow_bytes
and
not
allow_number
:
return
False
def
remove_prefixes
(
regex
:
Pattern
[
str
],
txt
:
str
)
->
str
:
return
re
.
sub
(
regex
,
r
"\1\2"
,
txt
)
if
allow_unicode
:
want
=
remove_prefixes
(
self
.
_unicode_literal_re
,
want
)
got
=
remove_prefixes
(
self
.
_unicode_literal_re
,
got
)
if
allow_bytes
:
want
=
remove_prefixes
(
self
.
_bytes_literal_re
,
want
)
got
=
remove_prefixes
(
self
.
_bytes_literal_re
,
got
)
if
allow_number
:
got
=
self
.
_remove_unwanted_precision
(
want
,
got
)
return
super
()
.
check_output
(
want
,
got
,
optionflags
)
def
_remove_unwanted_precision
(
self
,
want
:
str
,
got
:
str
)
->
str
:
wants
=
list
(
self
.
_number_re
.
finditer
(
want
))
gots
=
list
(
self
.
_number_re
.
finditer
(
got
))
if
len
(
wants
)
!=
len
(
gots
):
return
got
offset
=
0
for
w
,
g
in
zip
(
wants
,
gots
):
fraction
:
str
|
None
=
w
.
group
(
"fraction"
)
exponent
:
str
|
None
=
w
.
group
(
"exponent1"
)
if
exponent
is
None
:
exponent
=
w
.
group
(
"exponent2"
)
precision
=
0
if
fraction
is
None
else
len
(
fraction
)
if
exponent
is
not
None
:
precision
-=
int
(
exponent
)
if
float
(
w
.
group
())
==
approx
(
float
(
g
.
group
()),
abs
=
10
**-
precision
):
# They're close enough. Replace the text we actually
# got with the text we want, so that it will match when we
# check the string literally.
got
=
(
got
[:
g
.
start
()
+
offset
]
+
w
.
group
()
+
got
[
g
.
end
()
+
offset
:]
)
offset
+=
w
.
end
()
-
w
.
start
()
-
(
g
.
end
()
-
g
.
start
())
return
got
return
LiteralsOutputChecker
def
_get_checker
()
->
doctest
.
OutputChecker
:
"""Return a doctest.OutputChecker subclass that supports some
additional options:
* ALLOW_UNICODE and ALLOW_BYTES options to ignore u'' and b''
prefixes (respectively) in string literals. Useful when the same
doctest should run in Python 2 and Python 3.
* NUMBER to ignore floating-point differences smaller than the
precision of the literal number in the doctest.
An inner class is used to avoid importing "doctest" at the module
level.
"""
global
CHECKER_CLASS
if
CHECKER_CLASS
is
None
:
CHECKER_CLASS
=
_init_checker_class
()
return
CHECKER_CLASS
()
def
_get_allow_unicode_flag
()
->
int
:
"""Register and return the ALLOW_UNICODE flag."""
import
doctest
return
doctest
.
register_optionflag
(
"ALLOW_UNICODE"
)
def
_get_allow_bytes_flag
()
->
int
:
"""Register and return the ALLOW_BYTES flag."""
import
doctest
return
doctest
.
register_optionflag
(
"ALLOW_BYTES"
)
def
_get_number_flag
()
->
int
:
"""Register and return the NUMBER flag."""
import
doctest
return
doctest
.
register_optionflag
(
"NUMBER"
)
def
_get_report_choice
(
key
:
str
)
->
int
:
"""Return the actual `doctest` module flag value.
We want to do it as late as possible to avoid importing `doctest` and all
its dependencies when parsing options, as it adds overhead and breaks tests.
"""
import
doctest
return
{
DOCTEST_REPORT_CHOICE_UDIFF
:
doctest
.
REPORT_UDIFF
,
DOCTEST_REPORT_CHOICE_CDIFF
:
doctest
.
REPORT_CDIFF
,
DOCTEST_REPORT_CHOICE_NDIFF
:
doctest
.
REPORT_NDIFF
,
DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE
:
doctest
.
REPORT_ONLY_FIRST_FAILURE
,
DOCTEST_REPORT_CHOICE_NONE
:
0
,
}[
key
]
[docs]
@fixture
(
scope
=
"session"
)
def
doctest_namespace
()
->
dict
[
str
,
Any
]:
"""Fixture that returns a :py:class:`dict` that will be injected into the
namespace of doctests.
Usually this fixture is used in conjunction with another ``autouse`` fixture:
.. code-block:: python
@pytest.fixture(autouse=True)
def add_np(doctest_namespace):
doctest_namespace["np"] = numpy
For more details: :ref:`doctest_namespace`.
"""
return
dict
()

```


---


# _pytest.fixtures - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/fixtures.html


# Source code for _pytest.fixtures

```

# mypy: allow-untyped-defs
from
__future__
import
annotations
import
abc
from
collections
import
defaultdict
from
collections
import
deque
import
dataclasses
import
functools
import
inspect
import
os
from
pathlib
import
Path
import
sys
import
types
from
typing
import
AbstractSet
from
typing
import
Any
from
typing
import
Callable
from
typing
import
cast
from
typing
import
Dict
from
typing
import
Final
from
typing
import
final
from
typing
import
Generator
from
typing
import
Generic
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Mapping
from
typing
import
MutableMapping
from
typing
import
NoReturn
from
typing
import
Optional
from
typing
import
OrderedDict
from
typing
import
overload
from
typing
import
Sequence
from
typing
import
Tuple
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
from
typing
import
Union
import
warnings
import
_pytest
from
_pytest
import
nodes
from
_pytest._code
import
getfslineno
from
_pytest._code
import
Source
from
_pytest._code.code
import
FormattedExcinfo
from
_pytest._code.code
import
TerminalRepr
from
_pytest._io
import
TerminalWriter
from
_pytest.compat
import
_PytestWrapper
from
_pytest.compat
import
assert_never
from
_pytest.compat
import
get_real_func
from
_pytest.compat
import
get_real_method
from
_pytest.compat
import
getfuncargnames
from
_pytest.compat
import
getimfunc
from
_pytest.compat
import
getlocation
from
_pytest.compat
import
is_generator
from
_pytest.compat
import
NOTSET
from
_pytest.compat
import
NotSetType
from
_pytest.compat
import
safe_getattr
from
_pytest.compat
import
safe_isclass
from
_pytest.config
import
_PluggyPlugin
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.deprecated
import
MARKED_FIXTURE
from
_pytest.deprecated
import
YIELD_FIXTURE
from
_pytest.main
import
Session
from
_pytest.mark
import
Mark
from
_pytest.mark
import
ParameterSet
from
_pytest.mark.structures
import
MarkDecorator
from
_pytest.outcomes
import
fail
from
_pytest.outcomes
import
skip
from
_pytest.outcomes
import
TEST_OUTCOME
from
_pytest.pathlib
import
absolutepath
from
_pytest.pathlib
import
bestrelpath
from
_pytest.scope
import
_ScopeName
from
_pytest.scope
import
HIGH_SCOPES
from
_pytest.scope
import
Scope
if
sys
.
version_info
<
(
3
,
11
):
from
exceptiongroup
import
BaseExceptionGroup
if
TYPE_CHECKING
:
from
_pytest.python
import
CallSpec2
from
_pytest.python
import
Function
from
_pytest.python
import
Metafunc
# The value of the fixture -- return/yield of the fixture function (type variable).
FixtureValue
=
TypeVar
(
"FixtureValue"
)
# The type of the fixture function (type variable).
FixtureFunction
=
TypeVar
(
"FixtureFunction"
,
bound
=
Callable
[
...
,
object
])
# The type of a fixture function (type alias generic in fixture value).
_FixtureFunc
=
Union
[
Callable
[
...
,
FixtureValue
],
Callable
[
...
,
Generator
[
FixtureValue
,
None
,
None
]]
]
# The type of FixtureDef.cached_result (type alias generic in fixture value).
_FixtureCachedResult
=
Union
[
Tuple
[
# The result.
FixtureValue
,
# Cache key.
object
,
None
,
],
Tuple
[
None
,
# Cache key.
object
,
# The exception and the original traceback.
Tuple
[
BaseException
,
Optional
[
types
.
TracebackType
]],
],
]
@dataclasses
.
dataclass
(
frozen
=
True
)
class
PseudoFixtureDef
(
Generic
[
FixtureValue
]):
cached_result
:
_FixtureCachedResult
[
FixtureValue
]
_scope
:
Scope
def
pytest_sessionstart
(
session
:
Session
)
->
None
:
session
.
_fixturemanager
=
FixtureManager
(
session
)
def
get_scope_package
(
node
:
nodes
.
Item
,
fixturedef
:
FixtureDef
[
object
],
)
->
nodes
.
Node
|
None
:
from
_pytest.python
import
Package
for
parent
in
node
.
iter_parents
():
if
isinstance
(
parent
,
Package
)
and
parent
.
nodeid
==
fixturedef
.
baseid
:
return
parent
return
node
.
session
def
get_scope_node
(
node
:
nodes
.
Node
,
scope
:
Scope
)
->
nodes
.
Node
|
None
:
import
_pytest.python
if
scope
is
Scope
.
Function
:
# Type ignored because this is actually safe, see:
# https://github.com/python/mypy/issues/4717
return
node
.
getparent
(
nodes
.
Item
)
# type: ignore[type-abstract]
elif
scope
is
Scope
.
Class
:
return
node
.
getparent
(
_pytest
.
python
.
Class
)
elif
scope
is
Scope
.
Module
:
return
node
.
getparent
(
_pytest
.
python
.
Module
)
elif
scope
is
Scope
.
Package
:
return
node
.
getparent
(
_pytest
.
python
.
Package
)
elif
scope
is
Scope
.
Session
:
return
node
.
getparent
(
_pytest
.
main
.
Session
)
else
:
assert_never
(
scope
)
def
getfixturemarker
(
obj
:
object
)
->
FixtureFunctionMarker
|
None
:
"""Return fixturemarker or None if it doesn't exist or raised
exceptions."""
return
cast
(
Optional
[
FixtureFunctionMarker
],
safe_getattr
(
obj
,
"_pytestfixturefunction"
,
None
),
)
# Algorithm for sorting on a per-parametrized resource setup basis.
# It is called for Session scope first and performs sorting
# down to the lower scopes such as to minimize number of "high scope"
# setups and teardowns.
@dataclasses
.
dataclass
(
frozen
=
True
)
class
FixtureArgKey
:
argname
:
str
param_index
:
int
scoped_item_path
:
Path
|
None
item_cls
:
type
|
None
_V
=
TypeVar
(
"_V"
)
OrderedSet
=
Dict
[
_V
,
None
]
def
get_parametrized_fixture_argkeys
(
item
:
nodes
.
Item
,
scope
:
Scope
)
->
Iterator
[
FixtureArgKey
]:
"""Return list of keys for all parametrized arguments which match
the specified scope."""
assert
scope
is
not
Scope
.
Function
try
:
callspec
:
CallSpec2
=
item
.
callspec
# type: ignore[attr-defined]
except
AttributeError
:
return
item_cls
=
None
if
scope
is
Scope
.
Session
:
scoped_item_path
=
None
elif
scope
is
Scope
.
Package
:
# Package key = module's directory.
scoped_item_path
=
item
.
path
.
parent
elif
scope
is
Scope
.
Module
:
scoped_item_path
=
item
.
path
elif
scope
is
Scope
.
Class
:
scoped_item_path
=
item
.
path
item_cls
=
item
.
cls
# type: ignore[attr-defined]
else
:
assert_never
(
scope
)
for
argname
in
callspec
.
indices
:
if
callspec
.
_arg2scope
[
argname
]
!=
scope
:
continue
param_index
=
callspec
.
indices
[
argname
]
yield
FixtureArgKey
(
argname
,
param_index
,
scoped_item_path
,
item_cls
)
def
reorder_items
(
items
:
Sequence
[
nodes
.
Item
])
->
list
[
nodes
.
Item
]:
argkeys_by_item
:
dict
[
Scope
,
dict
[
nodes
.
Item
,
OrderedSet
[
FixtureArgKey
]]]
=
{}
items_by_argkey
:
dict
[
Scope
,
dict
[
FixtureArgKey
,
OrderedDict
[
nodes
.
Item
,
None
]]
]
=
{}
for
scope
in
HIGH_SCOPES
:
scoped_argkeys_by_item
=
argkeys_by_item
[
scope
]
=
{}
scoped_items_by_argkey
=
items_by_argkey
[
scope
]
=
defaultdict
(
OrderedDict
)
for
item
in
items
:
argkeys
=
dict
.
fromkeys
(
get_parametrized_fixture_argkeys
(
item
,
scope
))
if
argkeys
:
scoped_argkeys_by_item
[
item
]
=
argkeys
for
argkey
in
argkeys
:
scoped_items_by_argkey
[
argkey
][
item
]
=
None
items_set
=
dict
.
fromkeys
(
items
)
return
list
(
reorder_items_atscope
(
items_set
,
argkeys_by_item
,
items_by_argkey
,
Scope
.
Session
)
)
def
reorder_items_atscope
(
items
:
OrderedSet
[
nodes
.
Item
],
argkeys_by_item
:
Mapping
[
Scope
,
Mapping
[
nodes
.
Item
,
OrderedSet
[
FixtureArgKey
]]],
items_by_argkey
:
Mapping
[
Scope
,
Mapping
[
FixtureArgKey
,
OrderedDict
[
nodes
.
Item
,
None
]]
],
scope
:
Scope
,
)
->
OrderedSet
[
nodes
.
Item
]:
if
scope
is
Scope
.
Function
or
len
(
items
)
<
3
:
return
items
scoped_items_by_argkey
=
items_by_argkey
[
scope
]
scoped_argkeys_by_item
=
argkeys_by_item
[
scope
]
ignore
:
set
[
FixtureArgKey
]
=
set
()
items_deque
=
deque
(
items
)
items_done
:
OrderedSet
[
nodes
.
Item
]
=
{}
while
items_deque
:
no_argkey_items
:
OrderedSet
[
nodes
.
Item
]
=
{}
slicing_argkey
=
None
while
items_deque
:
item
=
items_deque
.
popleft
()
if
item
in
items_done
or
item
in
no_argkey_items
:
continue
argkeys
=
dict
.
fromkeys
(
k
for
k
in
scoped_argkeys_by_item
.
get
(
item
,
())
if
k
not
in
ignore
)
if
not
argkeys
:
no_argkey_items
[
item
]
=
None
else
:
slicing_argkey
,
_
=
argkeys
.
popitem
()
# We don't have to remove relevant items from later in the
# deque because they'll just be ignored.
matching_items
=
[
i
for
i
in
scoped_items_by_argkey
[
slicing_argkey
]
if
i
in
items
]
for
i
in
reversed
(
matching_items
):
items_deque
.
appendleft
(
i
)
# Fix items_by_argkey order.
for
other_scope
in
HIGH_SCOPES
:
other_scoped_items_by_argkey
=
items_by_argkey
[
other_scope
]
for
argkey
in
argkeys_by_item
[
other_scope
]
.
get
(
i
,
()):
other_scoped_items_by_argkey
[
argkey
][
i
]
=
None
other_scoped_items_by_argkey
[
argkey
]
.
move_to_end
(
i
,
last
=
False
)
break
if
no_argkey_items
:
reordered_no_argkey_items
=
reorder_items_atscope
(
no_argkey_items
,
argkeys_by_item
,
items_by_argkey
,
scope
.
next_lower
()
)
items_done
.
update
(
reordered_no_argkey_items
)
if
slicing_argkey
is
not
None
:
ignore
.
add
(
slicing_argkey
)
return
items_done
@dataclasses
.
dataclass
(
frozen
=
True
)
class
FuncFixtureInfo
:
"""Fixture-related information for a fixture-requesting item (e.g. test
function).
This is used to examine the fixtures which an item requests statically
(known during collection). This includes autouse fixtures, fixtures
requested by the `usefixtures` marker, fixtures requested in the function
parameters, and the transitive closure of these.
An item may also request fixtures dynamically (using `request.getfixturevalue`);
these are not reflected here.
"""
__slots__
=
(
"argnames"
,
"initialnames"
,
"names_closure"
,
"name2fixturedefs"
)
# Fixture names that the item requests directly by function parameters.
argnames
:
tuple
[
str
,
...
]
# Fixture names that the item immediately requires. These include
# argnames + fixture names specified via usefixtures and via autouse=True in
# fixture definitions.
initialnames
:
tuple
[
str
,
...
]
# The transitive closure of the fixture names that the item requires.
# Note: can't include dynamic dependencies (`request.getfixturevalue` calls).
names_closure
:
list
[
str
]
# A map from a fixture name in the transitive closure to the FixtureDefs
# matching the name which are applicable to this function.
# There may be multiple overriding fixtures with the same name. The
# sequence is ordered from furthest to closes to the function.
name2fixturedefs
:
dict
[
str
,
Sequence
[
FixtureDef
[
Any
]]]
def
prune_dependency_tree
(
self
)
->
None
:
"""Recompute names_closure from initialnames and name2fixturedefs.
Can only reduce names_closure, which means that the new closure will
always be a subset of the old one. The order is preserved.
This method is needed because direct parametrization may shadow some
of the fixtures that were included in the originally built dependency
tree. In this way the dependency tree can get pruned, and the closure
of argnames may get reduced.
"""
closure
:
set
[
str
]
=
set
()
working_set
=
set
(
self
.
initialnames
)
while
working_set
:
argname
=
working_set
.
pop
()
# Argname may be something not included in the original names_closure,
# in which case we ignore it. This currently happens with pseudo
# FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.
# So they introduce the new dependency 'request' which might have
# been missing in the original tree (closure).
if
argname
not
in
closure
and
argname
in
self
.
names_closure
:
closure
.
add
(
argname
)
if
argname
in
self
.
name2fixturedefs
:
working_set
.
update
(
self
.
name2fixturedefs
[
argname
][
-
1
]
.
argnames
)
self
.
names_closure
[:]
=
sorted
(
closure
,
key
=
self
.
names_closure
.
index
)
[docs]
class
FixtureRequest
(
abc
.
ABC
):
"""The type of the ``request`` fixture.
A request object gives access to the requesting test context and has a
``param`` attribute in case the fixture is parametrized.
"""
def
__init__
(
self
,
pyfuncitem
:
Function
,
fixturename
:
str
|
None
,
arg2fixturedefs
:
dict
[
str
,
Sequence
[
FixtureDef
[
Any
]]],
fixture_defs
:
dict
[
str
,
FixtureDef
[
Any
]],
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
#: Fixture for which this request is being performed.
self
.
fixturename
:
Final
=
fixturename
self
.
_pyfuncitem
:
Final
=
pyfuncitem
# The FixtureDefs for each fixture name requested by this item.
# Starts from the statically-known fixturedefs resolved during
# collection. Dynamically requested fixtures (using
# `request.getfixturevalue("foo")`) are added dynamically.
self
.
_arg2fixturedefs
:
Final
=
arg2fixturedefs
# The evaluated argnames so far, mapping to the FixtureDef they resolved
# to.
self
.
_fixture_defs
:
Final
=
fixture_defs
# Notes on the type of `param`:
# -`request.param` is only defined in parametrized fixtures, and will raise
#   AttributeError otherwise. Python typing has no notion of "undefined", so
#   this cannot be reflected in the type.
# - Technically `param` is only (possibly) defined on SubRequest, not
#   FixtureRequest, but the typing of that is still in flux so this cheats.
# - In the future we might consider using a generic for the param type, but
#   for now just using Any.
self
.
param
:
Any
@property
def
_fixturemanager
(
self
)
->
FixtureManager
:
return
self
.
_pyfuncitem
.
session
.
_fixturemanager
@property
@abc
.
abstractmethod
def
_scope
(
self
)
->
Scope
:
raise
NotImplementedError
()
@property
def
scope
(
self
)
->
_ScopeName
:
"""Scope string, one of "function", "class", "module", "package", "session"."""
return
self
.
_scope
.
value
@abc
.
abstractmethod
def
_check_scope
(
self
,
requested_fixturedef
:
FixtureDef
[
object
]
|
PseudoFixtureDef
[
object
],
requested_scope
:
Scope
,
)
->
None
:
raise
NotImplementedError
()
@property
def
fixturenames
(
self
)
->
list
[
str
]:
"""Names of all active fixtures in this request."""
result
=
list
(
self
.
_pyfuncitem
.
fixturenames
)
result
.
extend
(
set
(
self
.
_fixture_defs
)
.
difference
(
result
))
return
result
@property
@abc
.
abstractmethod
def
node
(
self
):
"""Underlying collection node (depends on current request scope)."""
raise
NotImplementedError
()
@property
def
config
(
self
)
->
Config
:
"""The pytest config object associated with this request."""
return
self
.
_pyfuncitem
.
config
@property
def
function
(
self
):
"""Test function object if the request has a per-function scope."""
if
self
.
scope
!=
"function"
:
raise
AttributeError
(
f
"function not available in
{
self
.
scope
}
-scoped context"
)
return
self
.
_pyfuncitem
.
obj
@property
def
cls
(
self
):
"""Class (can be None) where the test function was collected."""
if
self
.
scope
not
in
(
"class"
,
"function"
):
raise
AttributeError
(
f
"cls not available in
{
self
.
scope
}
-scoped context"
)
clscol
=
self
.
_pyfuncitem
.
getparent
(
_pytest
.
python
.
Class
)
if
clscol
:
return
clscol
.
obj
@property
def
instance
(
self
):
"""Instance (can be None) on which test function was collected."""
if
self
.
scope
!=
"function"
:
return
None
return
getattr
(
self
.
_pyfuncitem
,
"instance"
,
None
)
@property
def
module
(
self
):
"""Python module object where the test function was collected."""
if
self
.
scope
not
in
(
"function"
,
"class"
,
"module"
):
raise
AttributeError
(
f
"module not available in
{
self
.
scope
}
-scoped context"
)
mod
=
self
.
_pyfuncitem
.
getparent
(
_pytest
.
python
.
Module
)
assert
mod
is
not
None
return
mod
.
obj
@property
def
path
(
self
)
->
Path
:
"""Path where the test function was collected."""
if
self
.
scope
not
in
(
"function"
,
"class"
,
"module"
,
"package"
):
raise
AttributeError
(
f
"path not available in
{
self
.
scope
}
-scoped context"
)
return
self
.
_pyfuncitem
.
path
@property
def
keywords
(
self
)
->
MutableMapping
[
str
,
Any
]:
"""Keywords/markers dictionary for the underlying node."""
node
:
nodes
.
Node
=
self
.
node
return
node
.
keywords
@property
def
session
(
self
)
->
Session
:
"""Pytest session object."""
return
self
.
_pyfuncitem
.
session
[docs]
@abc
.
abstractmethod
def
addfinalizer
(
self
,
finalizer
:
Callable
[[],
object
])
->
None
:
"""Add finalizer/teardown function to be called without arguments after
the last test within the requesting test context finished execution."""
raise
NotImplementedError
()
[docs]
def
applymarker
(
self
,
marker
:
str
|
MarkDecorator
)
->
None
:
"""Apply a marker to a single test function invocation.
This method is useful if you don't want to have a keyword/marker
on all function invocations.
:param marker:
An object created by a call to ``pytest.mark.NAME(...)``.
"""
self
.
node
.
add_marker
(
marker
)
[docs]
def
raiseerror
(
self
,
msg
:
str
|
None
)
->
NoReturn
:
"""Raise a FixtureLookupError exception.
:param msg:
An optional custom error message.
"""
raise
FixtureLookupError
(
None
,
self
,
msg
)
[docs]
def
getfixturevalue
(
self
,
argname
:
str
)
->
Any
:
"""Dynamically run a named fixture function.
Declaring fixtures via function argument is recommended where possible.
But if you can only decide whether to use another fixture at test
setup time, you may use this function to retrieve it inside a fixture
or test function body.
This method can be used during the test setup phase or the test run
phase, but during the test teardown phase a fixture's value may not
be available.
:param argname:
The fixture name.
:raises pytest.FixtureLookupError:
If the given fixture could not be found.
"""
# Note that in addition to the use case described in the docstring,
# getfixturevalue() is also called by pytest itself during item and fixture
# setup to evaluate the fixtures that are requested statically
# (using function parameters, autouse, etc).
fixturedef
=
self
.
_get_active_fixturedef
(
argname
)
assert
fixturedef
.
cached_result
is
not
None
,
(
f
'The fixture value for "
{
argname
}
" is not available.  '
"This can happen when the fixture has already been torn down."
)
return
fixturedef
.
cached_result
[
0
]
def
_iter_chain
(
self
)
->
Iterator
[
SubRequest
]:
"""Yield all SubRequests in the chain, from self up.
Note: does *not* yield the TopRequest.
"""
current
=
self
while
isinstance
(
current
,
SubRequest
):
yield
current
current
=
current
.
_parent_request
def
_get_active_fixturedef
(
self
,
argname
:
str
)
->
FixtureDef
[
object
]
|
PseudoFixtureDef
[
object
]:
if
argname
==
"request"
:
cached_result
=
(
self
,
[
0
],
None
)
return
PseudoFixtureDef
(
cached_result
,
Scope
.
Function
)
# If we already finished computing a fixture by this name in this item,
# return it.
fixturedef
=
self
.
_fixture_defs
.
get
(
argname
)
if
fixturedef
is
not
None
:
self
.
_check_scope
(
fixturedef
,
fixturedef
.
_scope
)
return
fixturedef
# Find the appropriate fixturedef.
fixturedefs
=
self
.
_arg2fixturedefs
.
get
(
argname
,
None
)
if
fixturedefs
is
None
:
# We arrive here because of a dynamic call to
# getfixturevalue(argname) which was naturally
# not known at parsing/collection time.
fixturedefs
=
self
.
_fixturemanager
.
getfixturedefs
(
argname
,
self
.
_pyfuncitem
)
if
fixturedefs
is
not
None
:
self
.
_arg2fixturedefs
[
argname
]
=
fixturedefs
# No fixtures defined with this name.
if
fixturedefs
is
None
:
raise
FixtureLookupError
(
argname
,
self
)
# The are no fixtures with this name applicable for the function.
if
not
fixturedefs
:
raise
FixtureLookupError
(
argname
,
self
)
# A fixture may override another fixture with the same name, e.g. a
# fixture in a module can override a fixture in a conftest, a fixture in
# a class can override a fixture in the module, and so on.
# An overriding fixture can request its own name (possibly indirectly);
# in this case it gets the value of the fixture it overrides, one level
# up.
# Check how many `argname`s deep we are, and take the next one.
# `fixturedefs` is sorted from furthest to closest, so use negative
# indexing to go in reverse.
index
=
-
1
for
request
in
self
.
_iter_chain
():
if
request
.
fixturename
==
argname
:
index
-=
1
# If already consumed all of the available levels, fail.
if
-
index
>
len
(
fixturedefs
):
raise
FixtureLookupError
(
argname
,
self
)
fixturedef
=
fixturedefs
[
index
]
# Prepare a SubRequest object for calling the fixture.
try
:
callspec
=
self
.
_pyfuncitem
.
callspec
except
AttributeError
:
callspec
=
None
if
callspec
is
not
None
and
argname
in
callspec
.
params
:
param
=
callspec
.
params
[
argname
]
param_index
=
callspec
.
indices
[
argname
]
# The parametrize invocation scope overrides the fixture's scope.
scope
=
callspec
.
_arg2scope
[
argname
]
else
:
param
=
NOTSET
param_index
=
0
scope
=
fixturedef
.
_scope
self
.
_check_fixturedef_without_param
(
fixturedef
)
self
.
_check_scope
(
fixturedef
,
scope
)
subrequest
=
SubRequest
(
self
,
scope
,
param
,
param_index
,
fixturedef
,
_ispytest
=
True
)
# Make sure the fixture value is cached, running it if it isn't
fixturedef
.
execute
(
request
=
subrequest
)
self
.
_fixture_defs
[
argname
]
=
fixturedef
return
fixturedef
def
_check_fixturedef_without_param
(
self
,
fixturedef
:
FixtureDef
[
object
])
->
None
:
"""Check that this request is allowed to execute this fixturedef without
a param."""
funcitem
=
self
.
_pyfuncitem
has_params
=
fixturedef
.
params
is
not
None
fixtures_not_supported
=
getattr
(
funcitem
,
"nofuncargs"
,
False
)
if
has_params
and
fixtures_not_supported
:
msg
=
(
f
"
{
funcitem
.
name
}
does not support fixtures, maybe unittest.TestCase subclass?
\n
"
f
"Node id:
{
funcitem
.
nodeid
}
\n
"
f
"Function type:
{
type
(
funcitem
)
.
__name__
}
"
)
fail
(
msg
,
pytrace
=
False
)
if
has_params
:
frame
=
inspect
.
stack
()[
3
]
frameinfo
=
inspect
.
getframeinfo
(
frame
[
0
])
source_path
=
absolutepath
(
frameinfo
.
filename
)
source_lineno
=
frameinfo
.
lineno
try
:
source_path_str
=
str
(
source_path
.
relative_to
(
funcitem
.
config
.
rootpath
))
except
ValueError
:
source_path_str
=
str
(
source_path
)
location
=
getlocation
(
fixturedef
.
func
,
funcitem
.
config
.
rootpath
)
msg
=
(
"The requested fixture has no parameter defined for test:
\n
"
f
"
{
funcitem
.
nodeid
}
\n\n
"
f
"Requested fixture '
{
fixturedef
.
argname
}
' defined in:
\n
"
f
"
{
location
}
\n\n
"
f
"Requested here:
\n
"
f
"
{
source_path_str
}
:
{
source_lineno
}
"
)
fail
(
msg
,
pytrace
=
False
)
def
_get_fixturestack
(
self
)
->
list
[
FixtureDef
[
Any
]]:
values
=
[
request
.
_fixturedef
for
request
in
self
.
_iter_chain
()]
values
.
reverse
()
return
values
@final
class
TopRequest
(
FixtureRequest
):
"""The type of the ``request`` fixture in a test function."""
def
__init__
(
self
,
pyfuncitem
:
Function
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
super
()
.
__init__
(
fixturename
=
None
,
pyfuncitem
=
pyfuncitem
,
arg2fixturedefs
=
pyfuncitem
.
_fixtureinfo
.
name2fixturedefs
.
copy
(),
fixture_defs
=
{},
_ispytest
=
_ispytest
,
)
@property
def
_scope
(
self
)
->
Scope
:
return
Scope
.
Function
def
_check_scope
(
self
,
requested_fixturedef
:
FixtureDef
[
object
]
|
PseudoFixtureDef
[
object
],
requested_scope
:
Scope
,
)
->
None
:
# TopRequest always has function scope so always valid.
pass
@property
def
node
(
self
):
return
self
.
_pyfuncitem
def
__repr__
(
self
)
->
str
:
return
f
"<FixtureRequest for
{
self
.
node
!r}
>"
def
_fillfixtures
(
self
)
->
None
:
item
=
self
.
_pyfuncitem
for
argname
in
item
.
fixturenames
:
if
argname
not
in
item
.
funcargs
:
item
.
funcargs
[
argname
]
=
self
.
getfixturevalue
(
argname
)
def
addfinalizer
(
self
,
finalizer
:
Callable
[[],
object
])
->
None
:
self
.
node
.
addfinalizer
(
finalizer
)
@final
class
SubRequest
(
FixtureRequest
):
"""The type of the ``request`` fixture in a fixture function requested
(transitively) by a test function."""
def
__init__
(
self
,
request
:
FixtureRequest
,
scope
:
Scope
,
param
:
Any
,
param_index
:
int
,
fixturedef
:
FixtureDef
[
object
],
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
super
()
.
__init__
(
pyfuncitem
=
request
.
_pyfuncitem
,
fixturename
=
fixturedef
.
argname
,
fixture_defs
=
request
.
_fixture_defs
,
arg2fixturedefs
=
request
.
_arg2fixturedefs
,
_ispytest
=
_ispytest
,
)
self
.
_parent_request
:
Final
[
FixtureRequest
]
=
request
self
.
_scope_field
:
Final
=
scope
self
.
_fixturedef
:
Final
[
FixtureDef
[
object
]]
=
fixturedef
if
param
is
not
NOTSET
:
self
.
param
=
param
self
.
param_index
:
Final
=
param_index
def
__repr__
(
self
)
->
str
:
return
f
"<SubRequest
{
self
.
fixturename
!r}
for
{
self
.
_pyfuncitem
!r}
>"
@property
def
_scope
(
self
)
->
Scope
:
return
self
.
_scope_field
@property
def
node
(
self
):
scope
=
self
.
_scope
if
scope
is
Scope
.
Function
:
# This might also be a non-function Item despite its attribute name.
node
:
nodes
.
Node
|
None
=
self
.
_pyfuncitem
elif
scope
is
Scope
.
Package
:
node
=
get_scope_package
(
self
.
_pyfuncitem
,
self
.
_fixturedef
)
else
:
node
=
get_scope_node
(
self
.
_pyfuncitem
,
scope
)
if
node
is
None
and
scope
is
Scope
.
Class
:
# Fallback to function item itself.
node
=
self
.
_pyfuncitem
assert
node
,
f
'Could not obtain a node for scope "
{
scope
}
" for function
{
self
.
_pyfuncitem
!r}
'
return
node
def
_check_scope
(
self
,
requested_fixturedef
:
FixtureDef
[
object
]
|
PseudoFixtureDef
[
object
],
requested_scope
:
Scope
,
)
->
None
:
if
isinstance
(
requested_fixturedef
,
PseudoFixtureDef
):
return
if
self
.
_scope
>
requested_scope
:
# Try to report something helpful.
argname
=
requested_fixturedef
.
argname
fixture_stack
=
"
\n
"
.
join
(
self
.
_format_fixturedef_line
(
fixturedef
)
for
fixturedef
in
self
.
_get_fixturestack
()
)
requested_fixture
=
self
.
_format_fixturedef_line
(
requested_fixturedef
)
fail
(
f
"ScopeMismatch: You tried to access the
{
requested_scope
.
value
}
scoped "
f
"fixture
{
argname
}
with a
{
self
.
_scope
.
value
}
scoped request object. "
f
"Requesting fixture stack:
\n
{
fixture_stack
}
\n
"
f
"Requested fixture:
\n
{
requested_fixture
}
"
,
pytrace
=
False
,
)
def
_format_fixturedef_line
(
self
,
fixturedef
:
FixtureDef
[
object
])
->
str
:
factory
=
fixturedef
.
func
path
,
lineno
=
getfslineno
(
factory
)
if
isinstance
(
path
,
Path
):
path
=
bestrelpath
(
self
.
_pyfuncitem
.
session
.
path
,
path
)
signature
=
inspect
.
signature
(
factory
)
return
f
"
{
path
}
:
{
lineno
+
1
}
:  def
{
factory
.
__name__
}{
signature
}
"
def
addfinalizer
(
self
,
finalizer
:
Callable
[[],
object
])
->
None
:
self
.
_fixturedef
.
addfinalizer
(
finalizer
)
[docs]
@final
class
FixtureLookupError
(
LookupError
):
"""Could not return a requested fixture (missing or invalid)."""
def
__init__
(
self
,
argname
:
str
|
None
,
request
:
FixtureRequest
,
msg
:
str
|
None
=
None
)
->
None
:
self
.
argname
=
argname
self
.
request
=
request
self
.
fixturestack
=
request
.
_get_fixturestack
()
self
.
msg
=
msg
def
formatrepr
(
self
)
->
FixtureLookupErrorRepr
:
tblines
:
list
[
str
]
=
[]
addline
=
tblines
.
append
stack
=
[
self
.
request
.
_pyfuncitem
.
obj
]
stack
.
extend
(
map
(
lambda
x
:
x
.
func
,
self
.
fixturestack
))
msg
=
self
.
msg
if
msg
is
not
None
:
# The last fixture raise an error, let's present
# it at the requesting side.
stack
=
stack
[:
-
1
]
for
function
in
stack
:
fspath
,
lineno
=
getfslineno
(
function
)
try
:
lines
,
_
=
inspect
.
getsourcelines
(
get_real_func
(
function
))
except
(
OSError
,
IndexError
,
TypeError
):
error_msg
=
"file
%s
, line
%s
: source code not available"
addline
(
error_msg
%
(
fspath
,
lineno
+
1
))
else
:
addline
(
f
"file
{
fspath
}
, line
{
lineno
+
1
}
"
)
for
i
,
line
in
enumerate
(
lines
):
line
=
line
.
rstrip
()
addline
(
"  "
+
line
)
if
line
.
lstrip
()
.
startswith
(
"def"
):
break
if
msg
is
None
:
fm
=
self
.
request
.
_fixturemanager
available
=
set
()
parent
=
self
.
request
.
_pyfuncitem
.
parent
assert
parent
is
not
None
for
name
,
fixturedefs
in
fm
.
_arg2fixturedefs
.
items
():
faclist
=
list
(
fm
.
_matchfactories
(
fixturedefs
,
parent
))
if
faclist
:
available
.
add
(
name
)
if
self
.
argname
in
available
:
msg
=
(
f
" recursive dependency involving fixture '
{
self
.
argname
}
' detected"
)
else
:
msg
=
f
"fixture '
{
self
.
argname
}
' not found"
msg
+=
"
\n
available fixtures:
{}
"
.
format
(
", "
.
join
(
sorted
(
available
)))
msg
+=
"
\n
use 'pytest --fixtures [testpath]' for help on them."
return
FixtureLookupErrorRepr
(
fspath
,
lineno
,
tblines
,
msg
,
self
.
argname
)
class
FixtureLookupErrorRepr
(
TerminalRepr
):
def
__init__
(
self
,
filename
:
str
|
os
.
PathLike
[
str
],
firstlineno
:
int
,
tblines
:
Sequence
[
str
],
errorstring
:
str
,
argname
:
str
|
None
,
)
->
None
:
self
.
tblines
=
tblines
self
.
errorstring
=
errorstring
self
.
filename
=
filename
self
.
firstlineno
=
firstlineno
self
.
argname
=
argname
def
toterminal
(
self
,
tw
:
TerminalWriter
)
->
None
:
# tw.line("FixtureLookupError: %s" %(self.argname), red=True)
for
tbline
in
self
.
tblines
:
tw
.
line
(
tbline
.
rstrip
())
lines
=
self
.
errorstring
.
split
(
"
\n
"
)
if
lines
:
tw
.
line
(
f
"
{
FormattedExcinfo
.
fail_marker
}
{
lines
[
0
]
.
strip
()
}
"
,
red
=
True
,
)
for
line
in
lines
[
1
:]:
tw
.
line
(
f
"
{
FormattedExcinfo
.
flow_marker
}
{
line
.
strip
()
}
"
,
red
=
True
,
)
tw
.
line
()
tw
.
line
(
"
%s
:
%d
"
%
(
os
.
fspath
(
self
.
filename
),
self
.
firstlineno
+
1
))
def
call_fixture_func
(
fixturefunc
:
_FixtureFunc
[
FixtureValue
],
request
:
FixtureRequest
,
kwargs
)
->
FixtureValue
:
if
is_generator
(
fixturefunc
):
fixturefunc
=
cast
(
Callable
[
...
,
Generator
[
FixtureValue
,
None
,
None
]],
fixturefunc
)
generator
=
fixturefunc
(
**
kwargs
)
try
:
fixture_result
=
next
(
generator
)
except
StopIteration
:
raise
ValueError
(
f
"
{
request
.
fixturename
}
did not yield a value"
)
from
None
finalizer
=
functools
.
partial
(
_teardown_yield_fixture
,
fixturefunc
,
generator
)
request
.
addfinalizer
(
finalizer
)
else
:
fixturefunc
=
cast
(
Callable
[
...
,
FixtureValue
],
fixturefunc
)
fixture_result
=
fixturefunc
(
**
kwargs
)
return
fixture_result
def
_teardown_yield_fixture
(
fixturefunc
,
it
)
->
None
:
"""Execute the teardown of a fixture function by advancing the iterator
after the yield and ensure the iteration ends (if not it means there is
more than one yield in the function)."""
try
:
next
(
it
)
except
StopIteration
:
pass
else
:
fs
,
lineno
=
getfslineno
(
fixturefunc
)
fail
(
f
"fixture function has more than one 'yield':
\n\n
"
f
"
{
Source
(
fixturefunc
)
.
indent
()
}
\n
"
f
"
{
fs
}
:
{
lineno
+
1
}
"
,
pytrace
=
False
,
)
def
_eval_scope_callable
(
scope_callable
:
Callable
[[
str
,
Config
],
_ScopeName
],
fixture_name
:
str
,
config
:
Config
,
)
->
_ScopeName
:
try
:
# Type ignored because there is no typing mechanism to specify
# keyword arguments, currently.
result
=
scope_callable
(
fixture_name
=
fixture_name
,
config
=
config
)
# type: ignore[call-arg]
except
Exception
as
e
:
raise
TypeError
(
f
"Error evaluating
{
scope_callable
}
while defining fixture '
{
fixture_name
}
'.
\n
"
"Expected a function with the signature (*, fixture_name, config)"
)
from
e
if
not
isinstance
(
result
,
str
):
fail
(
f
"Expected
{
scope_callable
}
to return a 'str' while defining fixture '
{
fixture_name
}
', but it returned:
\n
"
f
"
{
result
!r}
"
,
pytrace
=
False
,
)
return
result
[docs]
@final
class
FixtureDef
(
Generic
[
FixtureValue
]):
"""A container for a fixture definition.
Note: At this time, only explicitly documented fields and methods are
considered public stable API.
"""
def
__init__
(
self
,
config
:
Config
,
baseid
:
str
|
None
,
argname
:
str
,
func
:
_FixtureFunc
[
FixtureValue
],
scope
:
Scope
|
_ScopeName
|
Callable
[[
str
,
Config
],
_ScopeName
]
|
None
,
params
:
Sequence
[
object
]
|
None
,
ids
:
tuple
[
object
|
None
,
...
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
# The "base" node ID for the fixture.
#
# This is a node ID prefix. A fixture is only available to a node (e.g.
# a `Function` item) if the fixture's baseid is a nodeid of a parent of
# node.
#
# For a fixture found in a Collector's object (e.g. a `Module`s module,
# a `Class`'s class), the baseid is the Collector's nodeid.
#
# For a fixture found in a conftest plugin, the baseid is the conftest's
# directory path relative to the rootdir.
#
# For other plugins, the baseid is the empty string (always matches).
self
.
baseid
:
Final
=
baseid
or
""
# Whether the fixture was found from a node or a conftest in the
# collection tree. Will be false for fixtures defined in non-conftest
# plugins.
self
.
has_location
:
Final
=
baseid
is
not
None
# The fixture factory function.
self
.
func
:
Final
=
func
# The name by which the fixture may be requested.
self
.
argname
:
Final
=
argname
if
scope
is
None
:
scope
=
Scope
.
Function
elif
callable
(
scope
):
scope
=
_eval_scope_callable
(
scope
,
argname
,
config
)
if
isinstance
(
scope
,
str
):
scope
=
Scope
.
from_user
(
scope
,
descr
=
f
"Fixture '
{
func
.
__name__
}
'"
,
where
=
baseid
)
self
.
_scope
:
Final
=
scope
# If the fixture is directly parametrized, the parameter values.
self
.
params
:
Final
=
params
# If the fixture is directly parametrized, a tuple of explicit IDs to
# assign to the parameter values, or a callable to generate an ID given
# a parameter value.
self
.
ids
:
Final
=
ids
# The names requested by the fixtures.
self
.
argnames
:
Final
=
getfuncargnames
(
func
,
name
=
argname
)
# If the fixture was executed, the current value of the fixture.
# Can change if the fixture is executed with different parameters.
self
.
cached_result
:
_FixtureCachedResult
[
FixtureValue
]
|
None
=
None
self
.
_finalizers
:
Final
[
list
[
Callable
[[],
object
]]]
=
[]
@property
def
scope
(
self
)
->
_ScopeName
:
"""Scope string, one of "function", "class", "module", "package", "session"."""
return
self
.
_scope
.
value
def
addfinalizer
(
self
,
finalizer
:
Callable
[[],
object
])
->
None
:
self
.
_finalizers
.
append
(
finalizer
)
def
finish
(
self
,
request
:
SubRequest
)
->
None
:
exceptions
:
list
[
BaseException
]
=
[]
while
self
.
_finalizers
:
fin
=
self
.
_finalizers
.
pop
()
try
:
fin
()
except
BaseException
as
e
:
exceptions
.
append
(
e
)
node
=
request
.
node
node
.
ihook
.
pytest_fixture_post_finalizer
(
fixturedef
=
self
,
request
=
request
)
# Even if finalization fails, we invalidate the cached fixture
# value and remove all finalizers because they may be bound methods
# which will keep instances alive.
self
.
cached_result
=
None
self
.
_finalizers
.
clear
()
if
len
(
exceptions
)
==
1
:
raise
exceptions
[
0
]
elif
len
(
exceptions
)
>
1
:
msg
=
f
'errors while tearing down fixture "
{
self
.
argname
}
" of
{
node
}
'
raise
BaseExceptionGroup
(
msg
,
exceptions
[::
-
1
])
[docs]
def
execute
(
self
,
request
:
SubRequest
)
->
FixtureValue
:
"""Return the value of this fixture, executing it if not cached."""
# Ensure that the dependent fixtures requested by this fixture are loaded.
# This needs to be done before checking if we have a cached value, since
# if a dependent fixture has their cache invalidated, e.g. due to
# parametrization, they finalize themselves and fixtures depending on it
# (which will likely include this fixture) setting `self.cached_result = None`.
# See #4871
requested_fixtures_that_should_finalize_us
=
[]
for
argname
in
self
.
argnames
:
fixturedef
=
request
.
_get_active_fixturedef
(
argname
)
# Saves requested fixtures in a list so we later can add our finalizer
# to them, ensuring that if a requested fixture gets torn down we get torn
# down first. This is generally handled by SetupState, but still currently
# needed when this fixture is not parametrized but depends on a parametrized
# fixture.
if
not
isinstance
(
fixturedef
,
PseudoFixtureDef
):
requested_fixtures_that_should_finalize_us
.
append
(
fixturedef
)
# Check for (and return) cached value/exception.
if
self
.
cached_result
is
not
None
:
request_cache_key
=
self
.
cache_key
(
request
)
cache_key
=
self
.
cached_result
[
1
]
try
:
# Attempt to make a normal == check: this might fail for objects
# which do not implement the standard comparison (like numpy arrays -- #6497).
cache_hit
=
bool
(
request_cache_key
==
cache_key
)
except
(
ValueError
,
RuntimeError
):
# If the comparison raises, use 'is' as fallback.
cache_hit
=
request_cache_key
is
cache_key
if
cache_hit
:
if
self
.
cached_result
[
2
]
is
not
None
:
exc
,
exc_tb
=
self
.
cached_result
[
2
]
raise
exc
.
with_traceback
(
exc_tb
)
else
:
result
=
self
.
cached_result
[
0
]
return
result
# We have a previous but differently parametrized fixture instance
# so we need to tear it down before creating a new one.
self
.
finish
(
request
)
assert
self
.
cached_result
is
None
# Add finalizer to requested fixtures we saved previously.
# We make sure to do this after checking for cached value to avoid
# adding our finalizer multiple times. (#12135)
finalizer
=
functools
.
partial
(
self
.
finish
,
request
=
request
)
for
parent_fixture
in
requested_fixtures_that_should_finalize_us
:
parent_fixture
.
addfinalizer
(
finalizer
)
ihook
=
request
.
node
.
ihook
try
:
# Setup the fixture, run the code in it, and cache the value
# in self.cached_result
result
=
ihook
.
pytest_fixture_setup
(
fixturedef
=
self
,
request
=
request
)
finally
:
# schedule our finalizer, even if the setup failed
request
.
node
.
addfinalizer
(
finalizer
)
return
result
def
cache_key
(
self
,
request
:
SubRequest
)
->
object
:
return
getattr
(
request
,
"param"
,
None
)
def
__repr__
(
self
)
->
str
:
return
f
"<FixtureDef argname=
{
self
.
argname
!r}
scope=
{
self
.
scope
!r}
baseid=
{
self
.
baseid
!r}
>"
def
resolve_fixture_function
(
fixturedef
:
FixtureDef
[
FixtureValue
],
request
:
FixtureRequest
)
->
_FixtureFunc
[
FixtureValue
]:
"""Get the actual callable that can be called to obtain the fixture
value."""
fixturefunc
=
fixturedef
.
func
# The fixture function needs to be bound to the actual
# request.instance so that code working with "fixturedef" behaves
# as expected.
instance
=
request
.
instance
if
instance
is
not
None
:
# Handle the case where fixture is defined not in a test class, but some other class
# (for example a plugin class with a fixture), see #2270.
if
hasattr
(
fixturefunc
,
"__self__"
)
and
not
isinstance
(
instance
,
fixturefunc
.
__self__
.
__class__
,
):
return
fixturefunc
fixturefunc
=
getimfunc
(
fixturedef
.
func
)
if
fixturefunc
!=
fixturedef
.
func
:
fixturefunc
=
fixturefunc
.
__get__
(
instance
)
return
fixturefunc
def
pytest_fixture_setup
(
fixturedef
:
FixtureDef
[
FixtureValue
],
request
:
SubRequest
)
->
FixtureValue
:
"""Execution of fixture setup."""
kwargs
=
{}
for
argname
in
fixturedef
.
argnames
:
kwargs
[
argname
]
=
request
.
getfixturevalue
(
argname
)
fixturefunc
=
resolve_fixture_function
(
fixturedef
,
request
)
my_cache_key
=
fixturedef
.
cache_key
(
request
)
try
:
result
=
call_fixture_func
(
fixturefunc
,
request
,
kwargs
)
except
TEST_OUTCOME
as
e
:
if
isinstance
(
e
,
skip
.
Exception
):
# The test requested a fixture which caused a skip.
# Don't show the fixture as the skip location, as then the user
# wouldn't know which test skipped.
e
.
_use_item_location
=
True
fixturedef
.
cached_result
=
(
None
,
my_cache_key
,
(
e
,
e
.
__traceback__
))
raise
fixturedef
.
cached_result
=
(
result
,
my_cache_key
,
None
)
return
result
def
wrap_function_to_error_out_if_called_directly
(
function
:
FixtureFunction
,
fixture_marker
:
FixtureFunctionMarker
,
)
->
FixtureFunction
:
"""Wrap the given fixture function so we can raise an error about it being called directly,
instead of used as an argument in a test function."""
name
=
fixture_marker
.
name
or
function
.
__name__
message
=
(
f
'Fixture "
{
name
}
" called directly. Fixtures are not meant to be called directly,
\n
'
"but are created automatically when test functions request them as parameters.
\n
"
"See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and
\n
"
"https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code."
)
@functools
.
wraps
(
function
)
def
result
(
*
args
,
**
kwargs
):
fail
(
message
,
pytrace
=
False
)
# Keep reference to the original function in our own custom attribute so we don't unwrap
# further than this point and lose useful wrappings like @mock.patch (#3774).
result
.
__pytest_wrapped__
=
_PytestWrapper
(
function
)
# type: ignore[attr-defined]
return
cast
(
FixtureFunction
,
result
)
@final
@dataclasses
.
dataclass
(
frozen
=
True
)
class
FixtureFunctionMarker
:
scope
:
_ScopeName
|
Callable
[[
str
,
Config
],
_ScopeName
]
params
:
tuple
[
object
,
...
]
|
None
autouse
:
bool
=
False
ids
:
tuple
[
object
|
None
,
...
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
None
name
:
str
|
None
=
None
_ispytest
:
dataclasses
.
InitVar
[
bool
]
=
False
def
__post_init__
(
self
,
_ispytest
:
bool
)
->
None
:
check_ispytest
(
_ispytest
)
def
__call__
(
self
,
function
:
FixtureFunction
)
->
FixtureFunction
:
if
inspect
.
isclass
(
function
):
raise
ValueError
(
"class fixtures not supported (maybe in the future)"
)
if
getattr
(
function
,
"_pytestfixturefunction"
,
False
):
raise
ValueError
(
f
"@pytest.fixture is being applied more than once to the same function
{
function
.
__name__
!r}
"
)
if
hasattr
(
function
,
"pytestmark"
):
warnings
.
warn
(
MARKED_FIXTURE
,
stacklevel
=
2
)
function
=
wrap_function_to_error_out_if_called_directly
(
function
,
self
)
name
=
self
.
name
or
function
.
__name__
if
name
==
"request"
:
location
=
getlocation
(
function
)
fail
(
f
"'request' is a reserved word for fixtures, use another name:
\n
{
location
}
"
,
pytrace
=
False
,
)
# Type ignored because https://github.com/python/mypy/issues/2087.
function
.
_pytestfixturefunction
=
self
# type: ignore[attr-defined]
return
function
@overload
def
fixture
(
fixture_function
:
FixtureFunction
,
*
,
scope
:
_ScopeName
|
Callable
[[
str
,
Config
],
_ScopeName
]
=
...
,
params
:
Iterable
[
object
]
|
None
=
...
,
autouse
:
bool
=
...
,
ids
:
Sequence
[
object
|
None
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
...
,
name
:
str
|
None
=
...
,
)
->
FixtureFunction
:
...
@overload
def
fixture
(
fixture_function
:
None
=
...
,
*
,
scope
:
_ScopeName
|
Callable
[[
str
,
Config
],
_ScopeName
]
=
...
,
params
:
Iterable
[
object
]
|
None
=
...
,
autouse
:
bool
=
...
,
ids
:
Sequence
[
object
|
None
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
...
,
name
:
str
|
None
=
None
,
)
->
FixtureFunctionMarker
:
...
[docs]
def
fixture
(
fixture_function
:
FixtureFunction
|
None
=
None
,
*
,
scope
:
_ScopeName
|
Callable
[[
str
,
Config
],
_ScopeName
]
=
"function"
,
params
:
Iterable
[
object
]
|
None
=
None
,
autouse
:
bool
=
False
,
ids
:
Sequence
[
object
|
None
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
None
,
name
:
str
|
None
=
None
,
)
->
FixtureFunctionMarker
|
FixtureFunction
:
"""Decorator to mark a fixture factory function.
This decorator can be used, with or without parameters, to define a
fixture function.
The name of the fixture function can later be referenced to cause its
invocation ahead of running tests: test modules or classes can use the
``pytest.mark.usefixtures(fixturename)`` marker.
Test functions can directly use fixture names as input arguments in which
case the fixture instance returned from the fixture function will be
injected.
Fixtures can provide their values to test functions using ``return`` or
``yield`` statements. When using ``yield`` the code block after the
``yield`` statement is executed as teardown code regardless of the test
outcome, and must yield exactly once.
:param scope:
The scope for which this fixture is shared; one of ``"function"``
(default), ``"class"``, ``"module"``, ``"package"`` or ``"session"``.
This parameter may also be a callable which receives ``(fixture_name, config)``
as parameters, and must return a ``str`` with one of the values mentioned above.
See :ref:`dynamic scope` in the docs for more information.
:param params:
An optional list of parameters which will cause multiple invocations
of the fixture function and all of the tests using it. The current
parameter is available in ``request.param``.
:param autouse:
If True, the fixture func is activated for all tests that can see it.
If False (the default), an explicit reference is needed to activate
the fixture.
:param ids:
Sequence of ids each corresponding to the params so that they are
part of the test id. If no ids are provided they will be generated
automatically from the params.
:param name:
The name of the fixture. This defaults to the name of the decorated
function. If a fixture is used in the same module in which it is
defined, the function name of the fixture will be shadowed by the
function arg that requests the fixture; one way to resolve this is to
name the decorated function ``fixture_<fixturename>`` and then use
``@pytest.fixture(name='<fixturename>')``.
"""
fixture_marker
=
FixtureFunctionMarker
(
scope
=
scope
,
params
=
tuple
(
params
)
if
params
is
not
None
else
None
,
autouse
=
autouse
,
ids
=
None
if
ids
is
None
else
ids
if
callable
(
ids
)
else
tuple
(
ids
),
name
=
name
,
_ispytest
=
True
,
)
# Direct decoration.
if
fixture_function
:
return
fixture_marker
(
fixture_function
)
return
fixture_marker
def
yield_fixture
(
fixture_function
=
None
,
*
args
,
scope
=
"function"
,
params
=
None
,
autouse
=
False
,
ids
=
None
,
name
=
None
,
):
"""(Return a) decorator to mark a yield-fixture factory function.
.. deprecated:: 3.0
Use :py:func:`pytest.fixture` directly instead.
"""
warnings
.
warn
(
YIELD_FIXTURE
,
stacklevel
=
2
)
return
fixture
(
fixture_function
,
*
args
,
scope
=
scope
,
params
=
params
,
autouse
=
autouse
,
ids
=
ids
,
name
=
name
,
)
[docs]
@fixture
(
scope
=
"session"
)
def
pytestconfig
(
request
:
FixtureRequest
)
->
Config
:
"""Session-scoped fixture that returns the session's :class:`pytest.Config`
object.
Example::
def test_foo(pytestconfig):
if pytestconfig.get_verbosity() > 0:
...
"""
return
request
.
config
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
parser
.
addini
(
"usefixtures"
,
type
=
"args"
,
default
=
[],
help
=
"List of default fixtures to be used with this project"
,
)
group
=
parser
.
getgroup
(
"general"
)
group
.
addoption
(
"--fixtures"
,
"--funcargs"
,
action
=
"store_true"
,
dest
=
"showfixtures"
,
default
=
False
,
help
=
"Show available fixtures, sorted by plugin appearance "
"(fixtures with leading '_' are only shown with '-v')"
,
)
group
.
addoption
(
"--fixtures-per-test"
,
action
=
"store_true"
,
dest
=
"show_fixtures_per_test"
,
default
=
False
,
help
=
"Show fixtures per test"
,
)
def
pytest_cmdline_main
(
config
:
Config
)
->
int
|
ExitCode
|
None
:
if
config
.
option
.
showfixtures
:
showfixtures
(
config
)
return
0
if
config
.
option
.
show_fixtures_per_test
:
show_fixtures_per_test
(
config
)
return
0
return
None
def
_get_direct_parametrize_args
(
node
:
nodes
.
Node
)
->
set
[
str
]:
"""Return all direct parametrization arguments of a node, so we don't
mistake them for fixtures.
Check https://github.com/pytest-dev/pytest/issues/5036.
These things are done later as well when dealing with parametrization
so this could be improved.
"""
parametrize_argnames
:
set
[
str
]
=
set
()
for
marker
in
node
.
iter_markers
(
name
=
"parametrize"
):
if
not
marker
.
kwargs
.
get
(
"indirect"
,
False
):
p_argnames
,
_
=
ParameterSet
.
_parse_parametrize_args
(
*
marker
.
args
,
**
marker
.
kwargs
)
parametrize_argnames
.
update
(
p_argnames
)
return
parametrize_argnames
def
deduplicate_names
(
*
seqs
:
Iterable
[
str
])
->
tuple
[
str
,
...
]:
"""De-duplicate the sequence of names while keeping the original order."""
# Ideally we would use a set, but it does not preserve insertion order.
return
tuple
(
dict
.
fromkeys
(
name
for
seq
in
seqs
for
name
in
seq
))
class
FixtureManager
:
"""pytest fixture definitions and information is stored and managed
from this class.
During collection fm.parsefactories() is called multiple times to parse
fixture function definitions into FixtureDef objects and internal
data structures.
During collection of test functions, metafunc-mechanics instantiate
a FuncFixtureInfo object which is cached per node/func-name.
This FuncFixtureInfo object is later retrieved by Function nodes
which themselves offer a fixturenames attribute.
The FuncFixtureInfo object holds information about fixtures and FixtureDefs
relevant for a particular function. An initial list of fixtures is
assembled like this:
- ini-defined usefixtures
- autouse-marked fixtures along the collection chain up from the function
- usefixtures markers at module/class/function level
- test function funcargs
Subsequently the funcfixtureinfo.fixturenames attribute is computed
as the closure of the fixtures needed to setup the initial fixtures,
i.e. fixtures needed by fixture functions themselves are appended
to the fixturenames list.
Upon the test-setup phases all fixturenames are instantiated, retrieved
by a lookup of their FuncFixtureInfo.
"""
def
__init__
(
self
,
session
:
Session
)
->
None
:
self
.
session
=
session
self
.
config
:
Config
=
session
.
config
# Maps a fixture name (argname) to all of the FixtureDefs in the test
# suite/plugins defined with this name. Populated by parsefactories().
# TODO: The order of the FixtureDefs list of each arg is significant,
#       explain.
self
.
_arg2fixturedefs
:
Final
[
dict
[
str
,
list
[
FixtureDef
[
Any
]]]]
=
{}
self
.
_holderobjseen
:
Final
[
set
[
object
]]
=
set
()
# A mapping from a nodeid to a list of autouse fixtures it defines.
self
.
_nodeid_autousenames
:
Final
[
dict
[
str
,
list
[
str
]]]
=
{
""
:
self
.
config
.
getini
(
"usefixtures"
),
}
session
.
config
.
pluginmanager
.
register
(
self
,
"funcmanage"
)
def
getfixtureinfo
(
self
,
node
:
nodes
.
Item
,
func
:
Callable
[
...
,
object
]
|
None
,
cls
:
type
|
None
,
)
->
FuncFixtureInfo
:
"""Calculate the :class:`FuncFixtureInfo` for an item.
If ``func`` is None, or if the item sets an attribute
``nofuncargs = True``, then ``func`` is not examined at all.
:param node:
The item requesting the fixtures.
:param func:
The item's function.
:param cls:
If the function is a method, the method's class.
"""
if
func
is
not
None
and
not
getattr
(
node
,
"nofuncargs"
,
False
):
argnames
=
getfuncargnames
(
func
,
name
=
node
.
name
,
cls
=
cls
)
else
:
argnames
=
()
usefixturesnames
=
self
.
_getusefixturesnames
(
node
)
autousenames
=
self
.
_getautousenames
(
node
)
initialnames
=
deduplicate_names
(
autousenames
,
usefixturesnames
,
argnames
)
direct_parametrize_args
=
_get_direct_parametrize_args
(
node
)
names_closure
,
arg2fixturedefs
=
self
.
getfixtureclosure
(
parentnode
=
node
,
initialnames
=
initialnames
,
ignore_args
=
direct_parametrize_args
,
)
return
FuncFixtureInfo
(
argnames
,
initialnames
,
names_closure
,
arg2fixturedefs
)
def
pytest_plugin_registered
(
self
,
plugin
:
_PluggyPlugin
,
plugin_name
:
str
)
->
None
:
# Fixtures defined in conftest plugins are only visible to within the
# conftest's directory. This is unlike fixtures in non-conftest plugins
# which have global visibility. So for conftests, construct the base
# nodeid from the plugin name (which is the conftest path).
if
plugin_name
and
plugin_name
.
endswith
(
"conftest.py"
):
# Note: we explicitly do *not* use `plugin.__file__` here -- The
# difference is that plugin_name has the correct capitalization on
# case-insensitive systems (Windows) and other normalization issues
# (issue #11816).
conftestpath
=
absolutepath
(
plugin_name
)
try
:
nodeid
=
str
(
conftestpath
.
parent
.
relative_to
(
self
.
config
.
rootpath
))
except
ValueError
:
nodeid
=
""
if
nodeid
==
"."
:
nodeid
=
""
if
os
.
sep
!=
nodes
.
SEP
:
nodeid
=
nodeid
.
replace
(
os
.
sep
,
nodes
.
SEP
)
else
:
nodeid
=
None
self
.
parsefactories
(
plugin
,
nodeid
)
def
_getautousenames
(
self
,
node
:
nodes
.
Node
)
->
Iterator
[
str
]:
"""Return the names of autouse fixtures applicable to node."""
for
parentnode
in
node
.
listchain
():
basenames
=
self
.
_nodeid_autousenames
.
get
(
parentnode
.
nodeid
)
if
basenames
:
yield from
basenames
def
_getusefixturesnames
(
self
,
node
:
nodes
.
Item
)
->
Iterator
[
str
]:
"""Return the names of usefixtures fixtures applicable to node."""
for
mark
in
node
.
iter_markers
(
name
=
"usefixtures"
):
yield from
mark
.
args
def
getfixtureclosure
(
self
,
parentnode
:
nodes
.
Node
,
initialnames
:
tuple
[
str
,
...
],
ignore_args
:
AbstractSet
[
str
],
)
->
tuple
[
list
[
str
],
dict
[
str
,
Sequence
[
FixtureDef
[
Any
]]]]:
# Collect the closure of all fixtures, starting with the given
# fixturenames as the initial set.  As we have to visit all
# factory definitions anyway, we also return an arg2fixturedefs
# mapping so that the caller can reuse it and does not have
# to re-discover fixturedefs again for each fixturename
# (discovering matching fixtures for a given name/node is expensive).
fixturenames_closure
=
list
(
initialnames
)
arg2fixturedefs
:
dict
[
str
,
Sequence
[
FixtureDef
[
Any
]]]
=
{}
lastlen
=
-
1
while
lastlen
!=
len
(
fixturenames_closure
):
lastlen
=
len
(
fixturenames_closure
)
for
argname
in
fixturenames_closure
:
if
argname
in
ignore_args
:
continue
if
argname
in
arg2fixturedefs
:
continue
fixturedefs
=
self
.
getfixturedefs
(
argname
,
parentnode
)
if
fixturedefs
:
arg2fixturedefs
[
argname
]
=
fixturedefs
for
arg
in
fixturedefs
[
-
1
]
.
argnames
:
if
arg
not
in
fixturenames_closure
:
fixturenames_closure
.
append
(
arg
)
def
sort_by_scope
(
arg_name
:
str
)
->
Scope
:
try
:
fixturedefs
=
arg2fixturedefs
[
arg_name
]
except
KeyError
:
return
Scope
.
Function
else
:
return
fixturedefs
[
-
1
]
.
_scope
fixturenames_closure
.
sort
(
key
=
sort_by_scope
,
reverse
=
True
)
return
fixturenames_closure
,
arg2fixturedefs
def
pytest_generate_tests
(
self
,
metafunc
:
Metafunc
)
->
None
:
"""Generate new tests based on parametrized fixtures used by the given metafunc"""
def
get_parametrize_mark_argnames
(
mark
:
Mark
)
->
Sequence
[
str
]:
args
,
_
=
ParameterSet
.
_parse_parametrize_args
(
*
mark
.
args
,
**
mark
.
kwargs
)
return
args
for
argname
in
metafunc
.
fixturenames
:
# Get the FixtureDefs for the argname.
fixture_defs
=
metafunc
.
_arg2fixturedefs
.
get
(
argname
)
if
not
fixture_defs
:
# Will raise FixtureLookupError at setup time if not parametrized somewhere
# else (e.g @pytest.mark.parametrize)
continue
# If the test itself parametrizes using this argname, give it
# precedence.
if
any
(
argname
in
get_parametrize_mark_argnames
(
mark
)
for
mark
in
metafunc
.
definition
.
iter_markers
(
"parametrize"
)
):
continue
# In the common case we only look at the fixture def with the
# closest scope (last in the list). But if the fixture overrides
# another fixture, while requesting the super fixture, keep going
# in case the super fixture is parametrized (#1953).
for
fixturedef
in
reversed
(
fixture_defs
):
# Fixture is parametrized, apply it and stop.
if
fixturedef
.
params
is
not
None
:
metafunc
.
parametrize
(
argname
,
fixturedef
.
params
,
indirect
=
True
,
scope
=
fixturedef
.
scope
,
ids
=
fixturedef
.
ids
,
)
break
# Not requesting the overridden super fixture, stop.
if
argname
not
in
fixturedef
.
argnames
:
break
# Try next super fixture, if any.
def
pytest_collection_modifyitems
(
self
,
items
:
list
[
nodes
.
Item
])
->
None
:
# Separate parametrized setups.
items
[:]
=
reorder_items
(
items
)
def
_register_fixture
(
self
,
*
,
name
:
str
,
func
:
_FixtureFunc
[
object
],
nodeid
:
str
|
None
,
scope
:
Scope
|
_ScopeName
|
Callable
[[
str
,
Config
],
_ScopeName
]
=
"function"
,
params
:
Sequence
[
object
]
|
None
=
None
,
ids
:
tuple
[
object
|
None
,
...
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
None
,
autouse
:
bool
=
False
,
)
->
None
:
"""Register a fixture
:param name:
The fixture's name.
:param func:
The fixture's implementation function.
:param nodeid:
The visibility of the fixture. The fixture will be available to the
node with this nodeid and its children in the collection tree.
None means that the fixture is visible to the entire collection tree,
e.g. a fixture defined for general use in a plugin.
:param scope:
The fixture's scope.
:param params:
The fixture's parametrization params.
:param ids:
The fixture's IDs.
:param autouse:
Whether this is an autouse fixture.
"""
fixture_def
=
FixtureDef
(
config
=
self
.
config
,
baseid
=
nodeid
,
argname
=
name
,
func
=
func
,
scope
=
scope
,
params
=
params
,
ids
=
ids
,
_ispytest
=
True
,
)
faclist
=
self
.
_arg2fixturedefs
.
setdefault
(
name
,
[])
if
fixture_def
.
has_location
:
faclist
.
append
(
fixture_def
)
else
:
# fixturedefs with no location are at the front
# so this inserts the current fixturedef after the
# existing fixturedefs from external plugins but
# before the fixturedefs provided in conftests.
i
=
len
([
f
for
f
in
faclist
if
not
f
.
has_location
])
faclist
.
insert
(
i
,
fixture_def
)
if
autouse
:
self
.
_nodeid_autousenames
.
setdefault
(
nodeid
or
""
,
[])
.
append
(
name
)
@overload
def
parsefactories
(
self
,
node_or_obj
:
nodes
.
Node
,
)
->
None
:
raise
NotImplementedError
()
@overload
def
parsefactories
(
self
,
node_or_obj
:
object
,
nodeid
:
str
|
None
,
)
->
None
:
raise
NotImplementedError
()
def
parsefactories
(
self
,
node_or_obj
:
nodes
.
Node
|
object
,
nodeid
:
str
|
NotSetType
|
None
=
NOTSET
,
)
->
None
:
"""Collect fixtures from a collection node or object.
Found fixtures are parsed into `FixtureDef`s and saved.
If `node_or_object` is a collection node (with an underlying Python
object), the node's object is traversed and the node's nodeid is used to
determine the fixtures' visibility. `nodeid` must not be specified in
this case.
If `node_or_object` is an object (e.g. a plugin), the object is
traversed and the given `nodeid` is used to determine the fixtures'
visibility. `nodeid` must be specified in this case; None and "" mean
total visibility.
"""
if
nodeid
is
not
NOTSET
:
holderobj
=
node_or_obj
else
:
assert
isinstance
(
node_or_obj
,
nodes
.
Node
)
holderobj
=
cast
(
object
,
node_or_obj
.
obj
)
# type: ignore[attr-defined]
assert
isinstance
(
node_or_obj
.
nodeid
,
str
)
nodeid
=
node_or_obj
.
nodeid
if
holderobj
in
self
.
_holderobjseen
:
return
# Avoid accessing `@property` (and other descriptors) when iterating fixtures.
if
not
safe_isclass
(
holderobj
)
and
not
isinstance
(
holderobj
,
types
.
ModuleType
):
holderobj_tp
:
object
=
type
(
holderobj
)
else
:
holderobj_tp
=
holderobj
self
.
_holderobjseen
.
add
(
holderobj
)
for
name
in
dir
(
holderobj
):
# The attribute can be an arbitrary descriptor, so the attribute
# access below can raise. safe_getattr() ignores such exceptions.
obj_ub
=
safe_getattr
(
holderobj_tp
,
name
,
None
)
marker
=
getfixturemarker
(
obj_ub
)
if
not
isinstance
(
marker
,
FixtureFunctionMarker
):
# Magic globals  with __getattr__ might have got us a wrong
# fixture attribute.
continue
# OK we know it is a fixture -- now safe to look up on the _instance_.
obj
=
getattr
(
holderobj
,
name
)
if
marker
.
name
:
name
=
marker
.
name
# During fixture definition we wrap the original fixture function
# to issue a warning if called directly, so here we unwrap it in
# order to not emit the warning when pytest itself calls the
# fixture function.
func
=
get_real_method
(
obj
,
holderobj
)
self
.
_register_fixture
(
name
=
name
,
nodeid
=
nodeid
,
func
=
func
,
scope
=
marker
.
scope
,
params
=
marker
.
params
,
ids
=
marker
.
ids
,
autouse
=
marker
.
autouse
,
)
def
getfixturedefs
(
self
,
argname
:
str
,
node
:
nodes
.
Node
)
->
Sequence
[
FixtureDef
[
Any
]]
|
None
:
"""Get FixtureDefs for a fixture name which are applicable
to a given node.
Returns None if there are no fixtures at all defined with the given
name. (This is different from the case in which there are fixtures
with the given name, but none applicable to the node. In this case,
an empty result is returned).
:param argname: Name of the fixture to search for.
:param node: The requesting Node.
"""
try
:
fixturedefs
=
self
.
_arg2fixturedefs
[
argname
]
except
KeyError
:
return
None
return
tuple
(
self
.
_matchfactories
(
fixturedefs
,
node
))
def
_matchfactories
(
self
,
fixturedefs
:
Iterable
[
FixtureDef
[
Any
]],
node
:
nodes
.
Node
)
->
Iterator
[
FixtureDef
[
Any
]]:
parentnodeids
=
{
n
.
nodeid
for
n
in
node
.
iter_parents
()}
for
fixturedef
in
fixturedefs
:
if
fixturedef
.
baseid
in
parentnodeids
:
yield
fixturedef
def
show_fixtures_per_test
(
config
:
Config
)
->
int
|
ExitCode
:
from
_pytest.main
import
wrap_session
return
wrap_session
(
config
,
_show_fixtures_per_test
)
_PYTEST_DIR
=
Path
(
_pytest
.
__file__
)
.
parent
def
_pretty_fixture_path
(
invocation_dir
:
Path
,
func
)
->
str
:
loc
=
Path
(
getlocation
(
func
,
invocation_dir
))
prefix
=
Path
(
"..."
,
"_pytest"
)
try
:
return
str
(
prefix
/
loc
.
relative_to
(
_PYTEST_DIR
))
except
ValueError
:
return
bestrelpath
(
invocation_dir
,
loc
)
def
_show_fixtures_per_test
(
config
:
Config
,
session
:
Session
)
->
None
:
import
_pytest.config
session
.
perform_collect
()
invocation_dir
=
config
.
invocation_params
.
dir
tw
=
_pytest
.
config
.
create_terminal_writer
(
config
)
verbose
=
config
.
get_verbosity
()
def
get_best_relpath
(
func
)
->
str
:
loc
=
getlocation
(
func
,
invocation_dir
)
return
bestrelpath
(
invocation_dir
,
Path
(
loc
))
def
write_fixture
(
fixture_def
:
FixtureDef
[
object
])
->
None
:
argname
=
fixture_def
.
argname
if
verbose
<=
0
and
argname
.
startswith
(
"_"
):
return
prettypath
=
_pretty_fixture_path
(
invocation_dir
,
fixture_def
.
func
)
tw
.
write
(
f
"
{
argname
}
"
,
green
=
True
)
tw
.
write
(
f
" --
{
prettypath
}
"
,
yellow
=
True
)
tw
.
write
(
"
\n
"
)
fixture_doc
=
inspect
.
getdoc
(
fixture_def
.
func
)
if
fixture_doc
:
write_docstring
(
tw
,
fixture_doc
.
split
(
"
\n\n
"
,
maxsplit
=
1
)[
0
]
if
verbose
<=
0
else
fixture_doc
,
)
else
:
tw
.
line
(
"    no docstring available"
,
red
=
True
)
def
write_item
(
item
:
nodes
.
Item
)
->
None
:
# Not all items have _fixtureinfo attribute.
info
:
FuncFixtureInfo
|
None
=
getattr
(
item
,
"_fixtureinfo"
,
None
)
if
info
is
None
or
not
info
.
name2fixturedefs
:
# This test item does not use any fixtures.
return
tw
.
line
()
tw
.
sep
(
"-"
,
f
"fixtures used by
{
item
.
name
}
"
)
# TODO: Fix this type ignore.
tw
.
sep
(
"-"
,
f
"(
{
get_best_relpath
(
item
.
function
)
}
)"
)
# type: ignore[attr-defined]
# dict key not used in loop but needed for sorting.
for
_
,
fixturedefs
in
sorted
(
info
.
name2fixturedefs
.
items
()):
assert
fixturedefs
is
not
None
if
not
fixturedefs
:
continue
# Last item is expected to be the one used by the test item.
write_fixture
(
fixturedefs
[
-
1
])
for
session_item
in
session
.
items
:
write_item
(
session_item
)
def
showfixtures
(
config
:
Config
)
->
int
|
ExitCode
:
from
_pytest.main
import
wrap_session
return
wrap_session
(
config
,
_showfixtures_main
)
def
_showfixtures_main
(
config
:
Config
,
session
:
Session
)
->
None
:
import
_pytest.config
session
.
perform_collect
()
invocation_dir
=
config
.
invocation_params
.
dir
tw
=
_pytest
.
config
.
create_terminal_writer
(
config
)
verbose
=
config
.
get_verbosity
()
fm
=
session
.
_fixturemanager
available
=
[]
seen
:
set
[
tuple
[
str
,
str
]]
=
set
()
for
argname
,
fixturedefs
in
fm
.
_arg2fixturedefs
.
items
():
assert
fixturedefs
is
not
None
if
not
fixturedefs
:
continue
for
fixturedef
in
fixturedefs
:
loc
=
getlocation
(
fixturedef
.
func
,
invocation_dir
)
if
(
fixturedef
.
argname
,
loc
)
in
seen
:
continue
seen
.
add
((
fixturedef
.
argname
,
loc
))
available
.
append
(
(
len
(
fixturedef
.
baseid
),
fixturedef
.
func
.
__module__
,
_pretty_fixture_path
(
invocation_dir
,
fixturedef
.
func
),
fixturedef
.
argname
,
fixturedef
,
)
)
available
.
sort
()
currentmodule
=
None
for
baseid
,
module
,
prettypath
,
argname
,
fixturedef
in
available
:
if
currentmodule
!=
module
:
if
not
module
.
startswith
(
"_pytest."
):
tw
.
line
()
tw
.
sep
(
"-"
,
f
"fixtures defined from
{
module
}
"
)
currentmodule
=
module
if
verbose
<=
0
and
argname
.
startswith
(
"_"
):
continue
tw
.
write
(
f
"
{
argname
}
"
,
green
=
True
)
if
fixturedef
.
scope
!=
"function"
:
tw
.
write
(
f
" [
{
fixturedef
.
scope
}
scope]"
,
cyan
=
True
)
tw
.
write
(
f
" --
{
prettypath
}
"
,
yellow
=
True
)
tw
.
write
(
"
\n
"
)
doc
=
inspect
.
getdoc
(
fixturedef
.
func
)
if
doc
:
write_docstring
(
tw
,
doc
.
split
(
"
\n\n
"
,
maxsplit
=
1
)[
0
]
if
verbose
<=
0
else
doc
)
else
:
tw
.
line
(
"    no docstring available"
,
red
=
True
)
tw
.
line
()
def
write_docstring
(
tw
:
TerminalWriter
,
doc
:
str
,
indent
:
str
=
"    "
)
->
None
:
for
line
in
doc
.
split
(
"
\n
"
):
tw
.
line
(
indent
+
line
)

```


---


# _pytest.config.exceptions - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/config/exceptions.html


# Source code for _pytest.config.exceptions

```

from
__future__
import
annotations
from
typing
import
final
[docs]
@final
class
UsageError
(
Exception
):
"""Error in pytest usage or invocation."""
class
PrintHelp
(
Exception
):
"""Raised when pytest should print its help to skip the rest of the
argument parsing and validation."""

```


---


# _pytest.logging - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/logging.html


# Source code for _pytest.logging

```

# mypy: allow-untyped-defs
"""Access and control log capturing."""
from
__future__
import
annotations
from
contextlib
import
contextmanager
from
contextlib
import
nullcontext
from
datetime
import
datetime
from
datetime
import
timedelta
from
datetime
import
timezone
import
io
from
io
import
StringIO
import
logging
from
logging
import
LogRecord
import
os
from
pathlib
import
Path
import
re
from
types
import
TracebackType
from
typing
import
AbstractSet
from
typing
import
Dict
from
typing
import
final
from
typing
import
Generator
from
typing
import
Generic
from
typing
import
List
from
typing
import
Literal
from
typing
import
Mapping
from
typing
import
TYPE_CHECKING
from
typing
import
TypeVar
from
_pytest
import
nodes
from
_pytest._io
import
TerminalWriter
from
_pytest.capture
import
CaptureManager
from
_pytest.config
import
_strtobool
from
_pytest.config
import
Config
from
_pytest.config
import
create_terminal_writer
from
_pytest.config
import
hookimpl
from
_pytest.config
import
UsageError
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.main
import
Session
from
_pytest.stash
import
StashKey
from
_pytest.terminal
import
TerminalReporter
if
TYPE_CHECKING
:
logging_StreamHandler
=
logging
.
StreamHandler
[
StringIO
]
else
:
logging_StreamHandler
=
logging
.
StreamHandler
DEFAULT_LOG_FORMAT
=
"
%(levelname)-8s
%(name)s
:
%(filename)s
:
%(lineno)d
%(message)s
"
DEFAULT_LOG_DATE_FORMAT
=
"%H:%M:%S"
_ANSI_ESCAPE_SEQ
=
re
.
compile
(
r
"\x1b\[[\d;]+m"
)
caplog_handler_key
=
StashKey
[
"LogCaptureHandler"
]()
caplog_records_key
=
StashKey
[
Dict
[
str
,
List
[
logging
.
LogRecord
]]]()
def
_remove_ansi_escape_sequences
(
text
:
str
)
->
str
:
return
_ANSI_ESCAPE_SEQ
.
sub
(
""
,
text
)
class
DatetimeFormatter
(
logging
.
Formatter
):
"""A logging formatter which formats record with
:func:`datetime.datetime.strftime` formatter instead of
:func:`time.strftime` in case of microseconds in format string.
"""
def
formatTime
(
self
,
record
:
LogRecord
,
datefmt
:
str
|
None
=
None
)
->
str
:
if
datefmt
and
"
%f
"
in
datefmt
:
ct
=
self
.
converter
(
record
.
created
)
tz
=
timezone
(
timedelta
(
seconds
=
ct
.
tm_gmtoff
),
ct
.
tm_zone
)
# Construct `datetime.datetime` object from `struct_time`
# and msecs information from `record`
# Using int() instead of round() to avoid it exceeding 1_000_000 and causing a ValueError (#11861).
dt
=
datetime
(
*
ct
[
0
:
6
],
microsecond
=
int
(
record
.
msecs
*
1000
),
tzinfo
=
tz
)
return
dt
.
strftime
(
datefmt
)
# Use `logging.Formatter` for non-microsecond formats
return
super
()
.
formatTime
(
record
,
datefmt
)
class
ColoredLevelFormatter
(
DatetimeFormatter
):
"""A logging formatter which colorizes the %(levelname)..s part of the
log format passed to __init__."""
LOGLEVEL_COLOROPTS
:
Mapping
[
int
,
AbstractSet
[
str
]]
=
{
logging
.
CRITICAL
:
{
"red"
},
logging
.
ERROR
:
{
"red"
,
"bold"
},
logging
.
WARNING
:
{
"yellow"
},
logging
.
WARN
:
{
"yellow"
},
logging
.
INFO
:
{
"green"
},
logging
.
DEBUG
:
{
"purple"
},
logging
.
NOTSET
:
set
(),
}
LEVELNAME_FMT_REGEX
=
re
.
compile
(
r
"%\(levelname\)([+-.]?\d*(?:\.\d+)?s)"
)
def
__init__
(
self
,
terminalwriter
:
TerminalWriter
,
*
args
,
**
kwargs
)
->
None
:
super
()
.
__init__
(
*
args
,
**
kwargs
)
self
.
_terminalwriter
=
terminalwriter
self
.
_original_fmt
=
self
.
_style
.
_fmt
self
.
_level_to_fmt_mapping
:
dict
[
int
,
str
]
=
{}
for
level
,
color_opts
in
self
.
LOGLEVEL_COLOROPTS
.
items
():
self
.
add_color_level
(
level
,
*
color_opts
)
def
add_color_level
(
self
,
level
:
int
,
*
color_opts
:
str
)
->
None
:
"""Add or update color opts for a log level.
:param level:
Log level to apply a style to, e.g. ``logging.INFO``.
:param color_opts:
ANSI escape sequence color options. Capitalized colors indicates
background color, i.e. ``'green', 'Yellow', 'bold'`` will give bold
green text on yellow background.
.. warning::
This is an experimental API.
"""
assert
self
.
_fmt
is
not
None
levelname_fmt_match
=
self
.
LEVELNAME_FMT_REGEX
.
search
(
self
.
_fmt
)
if
not
levelname_fmt_match
:
return
levelname_fmt
=
levelname_fmt_match
.
group
()
formatted_levelname
=
levelname_fmt
%
{
"levelname"
:
logging
.
getLevelName
(
level
)}
# add ANSI escape sequences around the formatted levelname
color_kwargs
=
{
name
:
True
for
name
in
color_opts
}
colorized_formatted_levelname
=
self
.
_terminalwriter
.
markup
(
formatted_levelname
,
**
color_kwargs
)
self
.
_level_to_fmt_mapping
[
level
]
=
self
.
LEVELNAME_FMT_REGEX
.
sub
(
colorized_formatted_levelname
,
self
.
_fmt
)
def
format
(
self
,
record
:
logging
.
LogRecord
)
->
str
:
fmt
=
self
.
_level_to_fmt_mapping
.
get
(
record
.
levelno
,
self
.
_original_fmt
)
self
.
_style
.
_fmt
=
fmt
return
super
()
.
format
(
record
)
class
PercentStyleMultiline
(
logging
.
PercentStyle
):
"""A logging style with special support for multiline messages.
If the message of a record consists of multiple lines, this style
formats the message as if each line were logged separately.
"""
def
__init__
(
self
,
fmt
:
str
,
auto_indent
:
int
|
str
|
bool
|
None
)
->
None
:
super
()
.
__init__
(
fmt
)
self
.
_auto_indent
=
self
.
_get_auto_indent
(
auto_indent
)
@staticmethod
def
_get_auto_indent
(
auto_indent_option
:
int
|
str
|
bool
|
None
)
->
int
:
"""Determine the current auto indentation setting.
Specify auto indent behavior (on/off/fixed) by passing in
extra={"auto_indent": [value]} to the call to logging.log() or
using a --log-auto-indent [value] command line or the
log_auto_indent [value] config option.
Default behavior is auto-indent off.
Using the string "True" or "on" or the boolean True as the value
turns auto indent on, using the string "False" or "off" or the
boolean False or the int 0 turns it off, and specifying a
positive integer fixes the indentation position to the value
specified.
Any other values for the option are invalid, and will silently be
converted to the default.
:param None|bool|int|str auto_indent_option:
User specified option for indentation from command line, config
or extra kwarg. Accepts int, bool or str. str option accepts the
same range of values as boolean config options, as well as
positive integers represented in str form.
:returns:
Indentation value, which can be
-1 (automatically determine indentation) or
0 (auto-indent turned off) or
>0 (explicitly set indentation position).
"""
if
auto_indent_option
is
None
:
return
0
elif
isinstance
(
auto_indent_option
,
bool
):
if
auto_indent_option
:
return
-
1
else
:
return
0
elif
isinstance
(
auto_indent_option
,
int
):
return
int
(
auto_indent_option
)
elif
isinstance
(
auto_indent_option
,
str
):
try
:
return
int
(
auto_indent_option
)
except
ValueError
:
pass
try
:
if
_strtobool
(
auto_indent_option
):
return
-
1
except
ValueError
:
return
0
return
0
def
format
(
self
,
record
:
logging
.
LogRecord
)
->
str
:
if
"
\n
"
in
record
.
message
:
if
hasattr
(
record
,
"auto_indent"
):
# Passed in from the "extra={}" kwarg on the call to logging.log().
auto_indent
=
self
.
_get_auto_indent
(
record
.
auto_indent
)
else
:
auto_indent
=
self
.
_auto_indent
if
auto_indent
:
lines
=
record
.
message
.
splitlines
()
formatted
=
self
.
_fmt
%
{
**
record
.
__dict__
,
"message"
:
lines
[
0
]}
if
auto_indent
<
0
:
indentation
=
_remove_ansi_escape_sequences
(
formatted
)
.
find
(
lines
[
0
]
)
else
:
# Optimizes logging by allowing a fixed indentation.
indentation
=
auto_indent
lines
[
0
]
=
formatted
return
(
"
\n
"
+
" "
*
indentation
)
.
join
(
lines
)
return
self
.
_fmt
%
record
.
__dict__
def
get_option_ini
(
config
:
Config
,
*
names
:
str
):
for
name
in
names
:
ret
=
config
.
getoption
(
name
)
# 'default' arg won't work as expected
if
ret
is
None
:
ret
=
config
.
getini
(
name
)
if
ret
:
return
ret
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
"""Add options to control log capturing."""
group
=
parser
.
getgroup
(
"logging"
)
def
add_option_ini
(
option
,
dest
,
default
=
None
,
type
=
None
,
**
kwargs
):
parser
.
addini
(
dest
,
default
=
default
,
type
=
type
,
help
=
"Default value for "
+
option
)
group
.
addoption
(
option
,
dest
=
dest
,
**
kwargs
)
add_option_ini
(
"--log-level"
,
dest
=
"log_level"
,
default
=
None
,
metavar
=
"LEVEL"
,
help
=
(
"Level of messages to catch/display."
" Not set by default, so it depends on the root/parent log handler's"
' effective level, where it is "WARNING" by default.'
),
)
add_option_ini
(
"--log-format"
,
dest
=
"log_format"
,
default
=
DEFAULT_LOG_FORMAT
,
help
=
"Log format used by the logging module"
,
)
add_option_ini
(
"--log-date-format"
,
dest
=
"log_date_format"
,
default
=
DEFAULT_LOG_DATE_FORMAT
,
help
=
"Log date format used by the logging module"
,
)
parser
.
addini
(
"log_cli"
,
default
=
False
,
type
=
"bool"
,
help
=
'Enable log display during test run (also known as "live logging")'
,
)
add_option_ini
(
"--log-cli-level"
,
dest
=
"log_cli_level"
,
default
=
None
,
help
=
"CLI logging level"
)
add_option_ini
(
"--log-cli-format"
,
dest
=
"log_cli_format"
,
default
=
None
,
help
=
"Log format used by the logging module"
,
)
add_option_ini
(
"--log-cli-date-format"
,
dest
=
"log_cli_date_format"
,
default
=
None
,
help
=
"Log date format used by the logging module"
,
)
add_option_ini
(
"--log-file"
,
dest
=
"log_file"
,
default
=
None
,
help
=
"Path to a file when logging will be written to"
,
)
add_option_ini
(
"--log-file-mode"
,
dest
=
"log_file_mode"
,
default
=
"w"
,
choices
=
[
"w"
,
"a"
],
help
=
"Log file open mode"
,
)
add_option_ini
(
"--log-file-level"
,
dest
=
"log_file_level"
,
default
=
None
,
help
=
"Log file logging level"
,
)
add_option_ini
(
"--log-file-format"
,
dest
=
"log_file_format"
,
default
=
None
,
help
=
"Log format used by the logging module"
,
)
add_option_ini
(
"--log-file-date-format"
,
dest
=
"log_file_date_format"
,
default
=
None
,
help
=
"Log date format used by the logging module"
,
)
add_option_ini
(
"--log-auto-indent"
,
dest
=
"log_auto_indent"
,
default
=
None
,
help
=
"Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer."
,
)
group
.
addoption
(
"--log-disable"
,
action
=
"append"
,
default
=
[],
dest
=
"logger_disable"
,
help
=
"Disable a logger by name. Can be passed multiple times."
,
)
_HandlerType
=
TypeVar
(
"_HandlerType"
,
bound
=
logging
.
Handler
)
# Not using @contextmanager for performance reasons.
class
catching_logs
(
Generic
[
_HandlerType
]):
"""Context manager that prepares the whole logging machinery properly."""
__slots__
=
(
"handler"
,
"level"
,
"orig_level"
)
def
__init__
(
self
,
handler
:
_HandlerType
,
level
:
int
|
None
=
None
)
->
None
:
self
.
handler
=
handler
self
.
level
=
level
def
__enter__
(
self
)
->
_HandlerType
:
root_logger
=
logging
.
getLogger
()
if
self
.
level
is
not
None
:
self
.
handler
.
setLevel
(
self
.
level
)
root_logger
.
addHandler
(
self
.
handler
)
if
self
.
level
is
not
None
:
self
.
orig_level
=
root_logger
.
level
root_logger
.
setLevel
(
min
(
self
.
orig_level
,
self
.
level
))
return
self
.
handler
def
__exit__
(
self
,
exc_type
:
type
[
BaseException
]
|
None
,
exc_val
:
BaseException
|
None
,
exc_tb
:
TracebackType
|
None
,
)
->
None
:
root_logger
=
logging
.
getLogger
()
if
self
.
level
is
not
None
:
root_logger
.
setLevel
(
self
.
orig_level
)
root_logger
.
removeHandler
(
self
.
handler
)
class
LogCaptureHandler
(
logging_StreamHandler
):
"""A logging handler that stores log records and the log text."""
def
__init__
(
self
)
->
None
:
"""Create a new log handler."""
super
()
.
__init__
(
StringIO
())
self
.
records
:
list
[
logging
.
LogRecord
]
=
[]
def
emit
(
self
,
record
:
logging
.
LogRecord
)
->
None
:
"""Keep the log records in a list in addition to the log text."""
self
.
records
.
append
(
record
)
super
()
.
emit
(
record
)
def
reset
(
self
)
->
None
:
self
.
records
=
[]
self
.
stream
=
StringIO
()
def
clear
(
self
)
->
None
:
self
.
records
.
clear
()
self
.
stream
=
StringIO
()
def
handleError
(
self
,
record
:
logging
.
LogRecord
)
->
None
:
if
logging
.
raiseExceptions
:
# Fail the test if the log message is bad (emit failed).
# The default behavior of logging is to print "Logging error"
# to stderr with the call stack and some extra details.
# pytest wants to make such mistakes visible during testing.
raise
# noqa: PLE0704
[docs]
@final
class
LogCaptureFixture
:
"""Provides access and control of log capturing."""
def
__init__
(
self
,
item
:
nodes
.
Node
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_item
=
item
self
.
_initial_handler_level
:
int
|
None
=
None
# Dict of log name -> log level.
self
.
_initial_logger_levels
:
dict
[
str
|
None
,
int
]
=
{}
self
.
_initial_disabled_logging_level
:
int
|
None
=
None
def
_finalize
(
self
)
->
None
:
"""Finalize the fixture.
This restores the log levels and the disabled logging levels changed by :meth:`set_level`.
"""
# Restore log levels.
if
self
.
_initial_handler_level
is
not
None
:
self
.
handler
.
setLevel
(
self
.
_initial_handler_level
)
for
logger_name
,
level
in
self
.
_initial_logger_levels
.
items
():
logger
=
logging
.
getLogger
(
logger_name
)
logger
.
setLevel
(
level
)
# Disable logging at the original disabled logging level.
if
self
.
_initial_disabled_logging_level
is
not
None
:
logging
.
disable
(
self
.
_initial_disabled_logging_level
)
self
.
_initial_disabled_logging_level
=
None
@property
def
handler
(
self
)
->
LogCaptureHandler
:
"""Get the logging handler used by the fixture."""
return
self
.
_item
.
stash
[
caplog_handler_key
]
[docs]
def
get_records
(
self
,
when
:
Literal
[
"setup"
,
"call"
,
"teardown"
]
)
->
list
[
logging
.
LogRecord
]:
"""Get the logging records for one of the possible test phases.
:param when:
Which test phase to obtain the records from.
Valid values are: "setup", "call" and "teardown".
:returns: The list of captured records at the given stage.
.. versionadded:: 3.4
"""
return
self
.
_item
.
stash
[
caplog_records_key
]
.
get
(
when
,
[])
@property
def
text
(
self
)
->
str
:
"""The formatted log text."""
return
_remove_ansi_escape_sequences
(
self
.
handler
.
stream
.
getvalue
())
@property
def
records
(
self
)
->
list
[
logging
.
LogRecord
]:
"""The list of log records."""
return
self
.
handler
.
records
@property
def
record_tuples
(
self
)
->
list
[
tuple
[
str
,
int
,
str
]]:
"""A list of a stripped down version of log records intended
for use in assertion comparison.
The format of the tuple is:
(logger_name, log_level, message)
"""
return
[(
r
.
name
,
r
.
levelno
,
r
.
getMessage
())
for
r
in
self
.
records
]
@property
def
messages
(
self
)
->
list
[
str
]:
"""A list of format-interpolated log messages.
Unlike 'records', which contains the format string and parameters for
interpolation, log messages in this list are all interpolated.
Unlike 'text', which contains the output from the handler, log
messages in this list are unadorned with levels, timestamps, etc,
making exact comparisons more reliable.
Note that traceback or stack info (from :func:`logging.exception` or
the `exc_info` or `stack_info` arguments to the logging functions) is
not included, as this is added by the formatter in the handler.
.. versionadded:: 3.7
"""
return
[
r
.
getMessage
()
for
r
in
self
.
records
]
[docs]
def
clear
(
self
)
->
None
:
"""Reset the list of log records and the captured log text."""
self
.
handler
.
clear
()
def
_force_enable_logging
(
self
,
level
:
int
|
str
,
logger_obj
:
logging
.
Logger
)
->
int
:
"""Enable the desired logging level if the global level was disabled via ``logging.disabled``.
Only enables logging levels greater than or equal to the requested ``level``.
Does nothing if the desired ``level`` wasn't disabled.
:param level:
The logger level caplog should capture.
All logging is enabled if a non-standard logging level string is supplied.
Valid level strings are in :data:`logging._nameToLevel`.
:param logger_obj: The logger object to check.
:return: The original disabled logging level.
"""
original_disable_level
:
int
=
logger_obj
.
manager
.
disable
if
isinstance
(
level
,
str
):
# Try to translate the level string to an int for `logging.disable()`
level
=
logging
.
getLevelName
(
level
)
if
not
isinstance
(
level
,
int
):
# The level provided was not valid, so just un-disable all logging.
logging
.
disable
(
logging
.
NOTSET
)
elif
not
logger_obj
.
isEnabledFor
(
level
):
# Each level is `10` away from other levels.
# https://docs.python.org/3/library/logging.html#logging-levels
disable_level
=
max
(
level
-
10
,
logging
.
NOTSET
)
logging
.
disable
(
disable_level
)
return
original_disable_level
[docs]
def
set_level
(
self
,
level
:
int
|
str
,
logger
:
str
|
None
=
None
)
->
None
:
"""Set the threshold level of a logger for the duration of a test.
Logging messages which are less severe than this level will not be captured.
.. versionchanged:: 3.4
The levels of the loggers changed by this function will be
restored to their initial values at the end of the test.
Will enable the requested logging level if it was disabled via :func:`logging.disable`.
:param level: The level.
:param logger: The logger to update. If not given, the root logger.
"""
logger_obj
=
logging
.
getLogger
(
logger
)
# Save the original log-level to restore it during teardown.
self
.
_initial_logger_levels
.
setdefault
(
logger
,
logger_obj
.
level
)
logger_obj
.
setLevel
(
level
)
if
self
.
_initial_handler_level
is
None
:
self
.
_initial_handler_level
=
self
.
handler
.
level
self
.
handler
.
setLevel
(
level
)
initial_disabled_logging_level
=
self
.
_force_enable_logging
(
level
,
logger_obj
)
if
self
.
_initial_disabled_logging_level
is
None
:
self
.
_initial_disabled_logging_level
=
initial_disabled_logging_level
[docs]
@contextmanager
def
at_level
(
self
,
level
:
int
|
str
,
logger
:
str
|
None
=
None
)
->
Generator
[
None
]:
"""Context manager that sets the level for capturing of logs. After
the end of the 'with' statement the level is restored to its original
value.
Will enable the requested logging level if it was disabled via :func:`logging.disable`.
:param level: The level.
:param logger: The logger to update. If not given, the root logger.
"""
logger_obj
=
logging
.
getLogger
(
logger
)
orig_level
=
logger_obj
.
level
logger_obj
.
setLevel
(
level
)
handler_orig_level
=
self
.
handler
.
level
self
.
handler
.
setLevel
(
level
)
original_disable_level
=
self
.
_force_enable_logging
(
level
,
logger_obj
)
try
:
yield
finally
:
logger_obj
.
setLevel
(
orig_level
)
self
.
handler
.
setLevel
(
handler_orig_level
)
logging
.
disable
(
original_disable_level
)
[docs]
@contextmanager
def
filtering
(
self
,
filter_
:
logging
.
Filter
)
->
Generator
[
None
]:
"""Context manager that temporarily adds the given filter to the caplog's
:meth:`handler` for the 'with' statement block, and removes that filter at the
end of the block.
:param filter_: A custom :class:`logging.Filter` object.
.. versionadded:: 7.5
"""
self
.
handler
.
addFilter
(
filter_
)
try
:
yield
finally
:
self
.
handler
.
removeFilter
(
filter_
)
[docs]
@fixture
def
caplog
(
request
:
FixtureRequest
)
->
Generator
[
LogCaptureFixture
]:
"""Access and control log capturing.
Captured logs are available through the following properties/methods::
* caplog.messages        -> list of format-interpolated log messages
* caplog.text            -> string containing formatted log output
* caplog.records         -> list of logging.LogRecord instances
* caplog.record_tuples   -> list of (logger_name, level, message) tuples
* caplog.clear()         -> clear captured records and formatted log output string
"""
result
=
LogCaptureFixture
(
request
.
node
,
_ispytest
=
True
)
yield
result
result
.
_finalize
()
def
get_log_level_for_setting
(
config
:
Config
,
*
setting_names
:
str
)
->
int
|
None
:
for
setting_name
in
setting_names
:
log_level
=
config
.
getoption
(
setting_name
)
if
log_level
is
None
:
log_level
=
config
.
getini
(
setting_name
)
if
log_level
:
break
else
:
return
None
if
isinstance
(
log_level
,
str
):
log_level
=
log_level
.
upper
()
try
:
return
int
(
getattr
(
logging
,
log_level
,
log_level
))
except
ValueError
as
e
:
# Python logging does not recognise this as a logging level
raise
UsageError
(
f
"'
{
log_level
}
' is not recognized as a logging level name for "
f
"'
{
setting_name
}
'. Please consider passing the "
"logging level num instead."
)
from
e
# run after terminalreporter/capturemanager are configured
@hookimpl
(
trylast
=
True
)
def
pytest_configure
(
config
:
Config
)
->
None
:
config
.
pluginmanager
.
register
(
LoggingPlugin
(
config
),
"logging-plugin"
)
class
LoggingPlugin
:
"""Attaches to the logging module and captures log messages for each test."""
def
__init__
(
self
,
config
:
Config
)
->
None
:
"""Create a new plugin to capture log messages.
The formatter can be safely shared across all handlers so
create a single one for the entire test session here.
"""
self
.
_config
=
config
# Report logging.
self
.
formatter
=
self
.
_create_formatter
(
get_option_ini
(
config
,
"log_format"
),
get_option_ini
(
config
,
"log_date_format"
),
get_option_ini
(
config
,
"log_auto_indent"
),
)
self
.
log_level
=
get_log_level_for_setting
(
config
,
"log_level"
)
self
.
caplog_handler
=
LogCaptureHandler
()
self
.
caplog_handler
.
setFormatter
(
self
.
formatter
)
self
.
report_handler
=
LogCaptureHandler
()
self
.
report_handler
.
setFormatter
(
self
.
formatter
)
# File logging.
self
.
log_file_level
=
get_log_level_for_setting
(
config
,
"log_file_level"
,
"log_level"
)
log_file
=
get_option_ini
(
config
,
"log_file"
)
or
os
.
devnull
if
log_file
!=
os
.
devnull
:
directory
=
os
.
path
.
dirname
(
os
.
path
.
abspath
(
log_file
))
if
not
os
.
path
.
isdir
(
directory
):
os
.
makedirs
(
directory
)
self
.
log_file_mode
=
get_option_ini
(
config
,
"log_file_mode"
)
or
"w"
self
.
log_file_handler
=
_FileHandler
(
log_file
,
mode
=
self
.
log_file_mode
,
encoding
=
"UTF-8"
)
log_file_format
=
get_option_ini
(
config
,
"log_file_format"
,
"log_format"
)
log_file_date_format
=
get_option_ini
(
config
,
"log_file_date_format"
,
"log_date_format"
)
log_file_formatter
=
DatetimeFormatter
(
log_file_format
,
datefmt
=
log_file_date_format
)
self
.
log_file_handler
.
setFormatter
(
log_file_formatter
)
# CLI/live logging.
self
.
log_cli_level
=
get_log_level_for_setting
(
config
,
"log_cli_level"
,
"log_level"
)
if
self
.
_log_cli_enabled
():
terminal_reporter
=
config
.
pluginmanager
.
get_plugin
(
"terminalreporter"
)
# Guaranteed by `_log_cli_enabled()`.
assert
terminal_reporter
is
not
None
capture_manager
=
config
.
pluginmanager
.
get_plugin
(
"capturemanager"
)
# if capturemanager plugin is disabled, live logging still works.
self
.
log_cli_handler
:
(
_LiveLoggingStreamHandler
|
_LiveLoggingNullHandler
)
=
_LiveLoggingStreamHandler
(
terminal_reporter
,
capture_manager
)
else
:
self
.
log_cli_handler
=
_LiveLoggingNullHandler
()
log_cli_formatter
=
self
.
_create_formatter
(
get_option_ini
(
config
,
"log_cli_format"
,
"log_format"
),
get_option_ini
(
config
,
"log_cli_date_format"
,
"log_date_format"
),
get_option_ini
(
config
,
"log_auto_indent"
),
)
self
.
log_cli_handler
.
setFormatter
(
log_cli_formatter
)
self
.
_disable_loggers
(
loggers_to_disable
=
config
.
option
.
logger_disable
)
def
_disable_loggers
(
self
,
loggers_to_disable
:
list
[
str
])
->
None
:
if
not
loggers_to_disable
:
return
for
name
in
loggers_to_disable
:
logger
=
logging
.
getLogger
(
name
)
logger
.
disabled
=
True
def
_create_formatter
(
self
,
log_format
,
log_date_format
,
auto_indent
):
# Color option doesn't exist if terminal plugin is disabled.
color
=
getattr
(
self
.
_config
.
option
,
"color"
,
"no"
)
if
color
!=
"no"
and
ColoredLevelFormatter
.
LEVELNAME_FMT_REGEX
.
search
(
log_format
):
formatter
:
logging
.
Formatter
=
ColoredLevelFormatter
(
create_terminal_writer
(
self
.
_config
),
log_format
,
log_date_format
)
else
:
formatter
=
DatetimeFormatter
(
log_format
,
log_date_format
)
formatter
.
_style
=
PercentStyleMultiline
(
formatter
.
_style
.
_fmt
,
auto_indent
=
auto_indent
)
return
formatter
def
set_log_path
(
self
,
fname
:
str
)
->
None
:
"""Set the filename parameter for Logging.FileHandler().
Creates parent directory if it does not exist.
.. warning::
This is an experimental API.
"""
fpath
=
Path
(
fname
)
if
not
fpath
.
is_absolute
():
fpath
=
self
.
_config
.
rootpath
/
fpath
if
not
fpath
.
parent
.
exists
():
fpath
.
parent
.
mkdir
(
exist_ok
=
True
,
parents
=
True
)
# https://github.com/python/mypy/issues/11193
stream
:
io
.
TextIOWrapper
=
fpath
.
open
(
mode
=
self
.
log_file_mode
,
encoding
=
"UTF-8"
)
# type: ignore[assignment]
old_stream
=
self
.
log_file_handler
.
setStream
(
stream
)
if
old_stream
:
old_stream
.
close
()
def
_log_cli_enabled
(
self
)
->
bool
:
"""Return whether live logging is enabled."""
enabled
=
self
.
_config
.
getoption
(
"--log-cli-level"
)
is
not
None
or
self
.
_config
.
getini
(
"log_cli"
)
if
not
enabled
:
return
False
terminal_reporter
=
self
.
_config
.
pluginmanager
.
get_plugin
(
"terminalreporter"
)
if
terminal_reporter
is
None
:
# terminal reporter is disabled e.g. by pytest-xdist.
return
False
return
True
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_sessionstart
(
self
)
->
Generator
[
None
]:
self
.
log_cli_handler
.
set_when
(
"sessionstart"
)
with
catching_logs
(
self
.
log_cli_handler
,
level
=
self
.
log_cli_level
):
with
catching_logs
(
self
.
log_file_handler
,
level
=
self
.
log_file_level
):
return
(
yield
)
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_collection
(
self
)
->
Generator
[
None
]:
self
.
log_cli_handler
.
set_when
(
"collection"
)
with
catching_logs
(
self
.
log_cli_handler
,
level
=
self
.
log_cli_level
):
with
catching_logs
(
self
.
log_file_handler
,
level
=
self
.
log_file_level
):
return
(
yield
)
@hookimpl
(
wrapper
=
True
)
def
pytest_runtestloop
(
self
,
session
:
Session
)
->
Generator
[
None
,
object
,
object
]:
if
session
.
config
.
option
.
collectonly
:
return
(
yield
)
if
self
.
_log_cli_enabled
()
and
self
.
_config
.
get_verbosity
()
<
1
:
# The verbose flag is needed to avoid messy test progress output.
self
.
_config
.
option
.
verbose
=
1
with
catching_logs
(
self
.
log_cli_handler
,
level
=
self
.
log_cli_level
):
with
catching_logs
(
self
.
log_file_handler
,
level
=
self
.
log_file_level
):
return
(
yield
)
# Run all the tests.
@hookimpl
def
pytest_runtest_logstart
(
self
)
->
None
:
self
.
log_cli_handler
.
reset
()
self
.
log_cli_handler
.
set_when
(
"start"
)
@hookimpl
def
pytest_runtest_logreport
(
self
)
->
None
:
self
.
log_cli_handler
.
set_when
(
"logreport"
)
def
_runtest_for
(
self
,
item
:
nodes
.
Item
,
when
:
str
)
->
Generator
[
None
]:
"""Implement the internals of the pytest_runtest_xxx() hooks."""
with
catching_logs
(
self
.
caplog_handler
,
level
=
self
.
log_level
,
)
as
caplog_handler
,
catching_logs
(
self
.
report_handler
,
level
=
self
.
log_level
,
)
as
report_handler
:
caplog_handler
.
reset
()
report_handler
.
reset
()
item
.
stash
[
caplog_records_key
][
when
]
=
caplog_handler
.
records
item
.
stash
[
caplog_handler_key
]
=
caplog_handler
try
:
yield
finally
:
log
=
report_handler
.
stream
.
getvalue
()
.
strip
()
item
.
add_report_section
(
when
,
"log"
,
log
)
@hookimpl
(
wrapper
=
True
)
def
pytest_runtest_setup
(
self
,
item
:
nodes
.
Item
)
->
Generator
[
None
]:
self
.
log_cli_handler
.
set_when
(
"setup"
)
empty
:
dict
[
str
,
list
[
logging
.
LogRecord
]]
=
{}
item
.
stash
[
caplog_records_key
]
=
empty
yield from
self
.
_runtest_for
(
item
,
"setup"
)
@hookimpl
(
wrapper
=
True
)
def
pytest_runtest_call
(
self
,
item
:
nodes
.
Item
)
->
Generator
[
None
]:
self
.
log_cli_handler
.
set_when
(
"call"
)
yield from
self
.
_runtest_for
(
item
,
"call"
)
@hookimpl
(
wrapper
=
True
)
def
pytest_runtest_teardown
(
self
,
item
:
nodes
.
Item
)
->
Generator
[
None
]:
self
.
log_cli_handler
.
set_when
(
"teardown"
)
try
:
yield from
self
.
_runtest_for
(
item
,
"teardown"
)
finally
:
del
item
.
stash
[
caplog_records_key
]
del
item
.
stash
[
caplog_handler_key
]
@hookimpl
def
pytest_runtest_logfinish
(
self
)
->
None
:
self
.
log_cli_handler
.
set_when
(
"finish"
)
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_sessionfinish
(
self
)
->
Generator
[
None
]:
self
.
log_cli_handler
.
set_when
(
"sessionfinish"
)
with
catching_logs
(
self
.
log_cli_handler
,
level
=
self
.
log_cli_level
):
with
catching_logs
(
self
.
log_file_handler
,
level
=
self
.
log_file_level
):
return
(
yield
)
@hookimpl
def
pytest_unconfigure
(
self
)
->
None
:
# Close the FileHandler explicitly.
# (logging.shutdown might have lost the weakref?!)
self
.
log_file_handler
.
close
()
class
_FileHandler
(
logging
.
FileHandler
):
"""A logging FileHandler with pytest tweaks."""
def
handleError
(
self
,
record
:
logging
.
LogRecord
)
->
None
:
# Handled by LogCaptureHandler.
pass
class
_LiveLoggingStreamHandler
(
logging_StreamHandler
):
"""A logging StreamHandler used by the live logging feature: it will
write a newline before the first log message in each test.
During live logging we must also explicitly disable stdout/stderr
capturing otherwise it will get captured and won't appear in the
terminal.
"""
# Officially stream needs to be a IO[str], but TerminalReporter
# isn't. So force it.
stream
:
TerminalReporter
=
None
# type: ignore
def
__init__
(
self
,
terminal_reporter
:
TerminalReporter
,
capture_manager
:
CaptureManager
|
None
,
)
->
None
:
super
()
.
__init__
(
stream
=
terminal_reporter
)
# type: ignore[arg-type]
self
.
capture_manager
=
capture_manager
self
.
reset
()
self
.
set_when
(
None
)
self
.
_test_outcome_written
=
False
def
reset
(
self
)
->
None
:
"""Reset the handler; should be called before the start of each test."""
self
.
_first_record_emitted
=
False
def
set_when
(
self
,
when
:
str
|
None
)
->
None
:
"""Prepare for the given test phase (setup/call/teardown)."""
self
.
_when
=
when
self
.
_section_name_shown
=
False
if
when
==
"start"
:
self
.
_test_outcome_written
=
False
def
emit
(
self
,
record
:
logging
.
LogRecord
)
->
None
:
ctx_manager
=
(
self
.
capture_manager
.
global_and_fixture_disabled
()
if
self
.
capture_manager
else
nullcontext
()
)
with
ctx_manager
:
if
not
self
.
_first_record_emitted
:
self
.
stream
.
write
(
"
\n
"
)
self
.
_first_record_emitted
=
True
elif
self
.
_when
in
(
"teardown"
,
"finish"
):
if
not
self
.
_test_outcome_written
:
self
.
_test_outcome_written
=
True
self
.
stream
.
write
(
"
\n
"
)
if
not
self
.
_section_name_shown
and
self
.
_when
:
self
.
stream
.
section
(
"live log "
+
self
.
_when
,
sep
=
"-"
,
bold
=
True
)
self
.
_section_name_shown
=
True
super
()
.
emit
(
record
)
def
handleError
(
self
,
record
:
logging
.
LogRecord
)
->
None
:
# Handled by LogCaptureHandler.
pass
class
_LiveLoggingNullHandler
(
logging
.
NullHandler
):
"""A logging handler used when live logging is disabled."""
def
reset
(
self
)
->
None
:
pass
def
set_when
(
self
,
when
:
str
)
->
None
:
pass
def
handleError
(
self
,
record
:
logging
.
LogRecord
)
->
None
:
# Handled by LogCaptureHandler.
pass

```


---


# _pytest.outcomes - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/outcomes.html


# Source code for _pytest.outcomes

```

"""Exception classes and constants handling test outcomes as well as
functions creating them."""
from
__future__
import
annotations
import
sys
from
typing
import
Any
from
typing
import
Callable
from
typing
import
cast
from
typing
import
NoReturn
from
typing
import
Protocol
from
typing
import
Type
from
typing
import
TypeVar
from
.warning_types
import
PytestDeprecationWarning
class
OutcomeException
(
BaseException
):
"""OutcomeException and its subclass instances indicate and contain info
about test and collection outcomes."""
def
__init__
(
self
,
msg
:
str
|
None
=
None
,
pytrace
:
bool
=
True
)
->
None
:
if
msg
is
not
None
and
not
isinstance
(
msg
,
str
):
error_msg
=
(
# type: ignore[unreachable]
"
{}
expected string as 'msg' parameter, got '
{}
' instead.
\n
"
"Perhaps you meant to use a mark?"
)
raise
TypeError
(
error_msg
.
format
(
type
(
self
)
.
__name__
,
type
(
msg
)
.
__name__
))
super
()
.
__init__
(
msg
)
self
.
msg
=
msg
self
.
pytrace
=
pytrace
def
__repr__
(
self
)
->
str
:
if
self
.
msg
is
not
None
:
return
self
.
msg
return
f
"<
{
self
.
__class__
.
__name__
}
instance>"
__str__
=
__repr__
TEST_OUTCOME
=
(
OutcomeException
,
Exception
)
class
Skipped
(
OutcomeException
):
# XXX hackish: on 3k we fake to live in the builtins
# in order to have Skipped exception printing shorter/nicer
__module__
=
"builtins"
def
__init__
(
self
,
msg
:
str
|
None
=
None
,
pytrace
:
bool
=
True
,
allow_module_level
:
bool
=
False
,
*
,
_use_item_location
:
bool
=
False
,
)
->
None
:
super
()
.
__init__
(
msg
=
msg
,
pytrace
=
pytrace
)
self
.
allow_module_level
=
allow_module_level
# If true, the skip location is reported as the item's location,
# instead of the place that raises the exception/calls skip().
self
.
_use_item_location
=
_use_item_location
class
Failed
(
OutcomeException
):
"""Raised from an explicit call to pytest.fail()."""
__module__
=
"builtins"
class
Exit
(
Exception
):
"""Raised for immediate program exits (no tracebacks/summaries)."""
def
__init__
(
self
,
msg
:
str
=
"unknown reason"
,
returncode
:
int
|
None
=
None
)
->
None
:
self
.
msg
=
msg
self
.
returncode
=
returncode
super
()
.
__init__
(
msg
)
# Elaborate hack to work around https://github.com/python/mypy/issues/2087.
# Ideally would just be `exit.Exception = Exit` etc.
_F
=
TypeVar
(
"_F"
,
bound
=
Callable
[
...
,
object
])
_ET
=
TypeVar
(
"_ET"
,
bound
=
Type
[
BaseException
])
class
_WithException
(
Protocol
[
_F
,
_ET
]):
Exception
:
_ET
__call__
:
_F
def
_with_exception
(
exception_type
:
_ET
)
->
Callable
[[
_F
],
_WithException
[
_F
,
_ET
]]:
def
decorate
(
func
:
_F
)
->
_WithException
[
_F
,
_ET
]:
func_with_exception
=
cast
(
_WithException
[
_F
,
_ET
],
func
)
func_with_exception
.
Exception
=
exception_type
return
func_with_exception
return
decorate
# Exposed helper methods.
[docs]
@_with_exception
(
Exit
)
def
exit
(
reason
:
str
=
""
,
returncode
:
int
|
None
=
None
,
)
->
NoReturn
:
"""Exit testing process.
:param reason:
The message to show as the reason for exiting pytest.  reason has a default value
only because `msg` is deprecated.
:param returncode:
Return code to be used when exiting pytest. None means the same as ``0`` (no error), same as :func:`sys.exit`.
:raises pytest.exit.Exception:
The exception that is raised.
"""
__tracebackhide__
=
True
raise
Exit
(
reason
,
returncode
)
[docs]
@_with_exception
(
Skipped
)
def
skip
(
reason
:
str
=
""
,
*
,
allow_module_level
:
bool
=
False
,
)
->
NoReturn
:
"""Skip an executing test with the given message.
This function should be called only during testing (setup, call or teardown) or
during collection by using the ``allow_module_level`` flag.  This function can
be called in doctests as well.
:param reason:
The message to show the user as reason for the skip.
:param allow_module_level:
Allows this function to be called at module level.
Raising the skip exception at module level will stop
the execution of the module and prevent the collection of all tests in the module,
even those defined before the `skip` call.
Defaults to False.
:raises pytest.skip.Exception:
The exception that is raised.
.. note::
It is better to use the :ref:`pytest.mark.skipif ref` marker when
possible to declare a test to be skipped under certain conditions
like mismatching platforms or dependencies.
Similarly, use the ``# doctest: +SKIP`` directive (see :py:data:`doctest.SKIP`)
to skip a doctest statically.
"""
__tracebackhide__
=
True
raise
Skipped
(
msg
=
reason
,
allow_module_level
=
allow_module_level
)
[docs]
@_with_exception
(
Failed
)
def
fail
(
reason
:
str
=
""
,
pytrace
:
bool
=
True
)
->
NoReturn
:
"""Explicitly fail an executing test with the given message.
:param reason:
The message to show the user as reason for the failure.
:param pytrace:
If False, msg represents the full failure information and no
python traceback will be reported.
:raises pytest.fail.Exception:
The exception that is raised.
"""
__tracebackhide__
=
True
raise
Failed
(
msg
=
reason
,
pytrace
=
pytrace
)
class
XFailed
(
Failed
):
"""Raised from an explicit call to pytest.xfail()."""
[docs]
@_with_exception
(
XFailed
)
def
xfail
(
reason
:
str
=
""
)
->
NoReturn
:
"""Imperatively xfail an executing test or setup function with the given reason.
This function should be called only during testing (setup, call or teardown).
No other code is executed after using ``xfail()`` (it is implemented
internally by raising an exception).
:param reason:
The message to show the user as reason for the xfail.
.. note::
It is better to use the :ref:`pytest.mark.xfail ref` marker when
possible to declare a test to be xfailed under certain conditions
like known bugs or missing features.
:raises pytest.xfail.Exception:
The exception that is raised.
"""
__tracebackhide__
=
True
raise
XFailed
(
reason
)
[docs]
def
importorskip
(
modname
:
str
,
minversion
:
str
|
None
=
None
,
reason
:
str
|
None
=
None
,
*
,
exc_type
:
type
[
ImportError
]
|
None
=
None
,
)
->
Any
:
"""Import and return the requested module ``modname``, or skip the
current test if the module cannot be imported.
:param modname:
The name of the module to import.
:param minversion:
If given, the imported module's ``__version__`` attribute must be at
least this minimal version, otherwise the test is still skipped.
:param reason:
If given, this reason is shown as the message when the module cannot
be imported.
:param exc_type:
The exception that should be captured in order to skip modules.
Must be :py:class:`ImportError` or a subclass.
If the module can be imported but raises :class:`ImportError`, pytest will
issue a warning to the user, as often users expect the module not to be
found (which would raise :class:`ModuleNotFoundError` instead).
This warning can be suppressed by passing ``exc_type=ImportError`` explicitly.
See :ref:`import-or-skip-import-error` for details.
:returns:
The imported module. This should be assigned to its canonical name.
:raises pytest.skip.Exception:
If the module cannot be imported.
Example::
docutils = pytest.importorskip("docutils")
.. versionadded:: 8.2
The ``exc_type`` parameter.
"""
import
warnings
__tracebackhide__
=
True
compile
(
modname
,
""
,
"eval"
)
# to catch syntaxerrors
# Until pytest 9.1, we will warn the user if we catch ImportError (instead of ModuleNotFoundError),
# as this might be hiding an installation/environment problem, which is not usually what is intended
# when using importorskip() (#11523).
# In 9.1, to keep the function signature compatible, we just change the code below to:
# 1. Use `exc_type = ModuleNotFoundError` if `exc_type` is not given.
# 2. Remove `warn_on_import` and the warning handling.
if
exc_type
is
None
:
exc_type
=
ImportError
warn_on_import_error
=
True
else
:
warn_on_import_error
=
False
skipped
:
Skipped
|
None
=
None
warning
:
Warning
|
None
=
None
with
warnings
.
catch_warnings
():
# Make sure to ignore ImportWarnings that might happen because
# of existing directories with the same name we're trying to
# import but without a __init__.py file.
warnings
.
simplefilter
(
"ignore"
)
try
:
__import__
(
modname
)
except
exc_type
as
exc
:
# Do not raise or issue warnings inside the catch_warnings() block.
if
reason
is
None
:
reason
=
f
"could not import
{
modname
!r}
:
{
exc
}
"
skipped
=
Skipped
(
reason
,
allow_module_level
=
True
)
if
warn_on_import_error
and
not
isinstance
(
exc
,
ModuleNotFoundError
):
lines
=
[
""
,
f
"Module '
{
modname
}
' was found, but when imported by pytest it raised:"
,
f
"
{
exc
!r}
"
,
"In pytest 9.1 this warning will become an error by default."
,
"You can fix the underlying problem, or alternatively overwrite this behavior and silence this "
"warning by passing exc_type=ImportError explicitly."
,
"See https://docs.pytest.org/en/stable/deprecations.html#pytest-importorskip-default-behavior-regarding-importerror"
,
]
warning
=
PytestDeprecationWarning
(
"
\n
"
.
join
(
lines
))
if
warning
:
warnings
.
warn
(
warning
,
stacklevel
=
2
)
if
skipped
:
raise
skipped
mod
=
sys
.
modules
[
modname
]
if
minversion
is
None
:
return
mod
verattr
=
getattr
(
mod
,
"__version__"
,
None
)
if
minversion
is
not
None
:
# Imported lazily to improve start-up time.
from
packaging.version
import
Version
if
verattr
is
None
or
Version
(
verattr
)
<
Version
(
minversion
):
raise
Skipped
(
f
"module
{
modname
!r}
has __version__
{
verattr
!r}
, required is:
{
minversion
!r}
"
,
allow_module_level
=
True
,
)
return
mod

```


---


# _pytest.pytester - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/pytester.html


# Source code for _pytest.pytester

```

# mypy: allow-untyped-defs
"""(Disabled by default) support for testing pytest and pytest plugins.
PYTEST_DONT_REWRITE
"""
from
__future__
import
annotations
import
collections.abc
import
contextlib
from
fnmatch
import
fnmatch
import
gc
import
importlib
from
io
import
StringIO
import
locale
import
os
from
pathlib
import
Path
import
platform
import
re
import
shutil
import
subprocess
import
sys
import
traceback
from
typing
import
Any
from
typing
import
Callable
from
typing
import
Final
from
typing
import
final
from
typing
import
Generator
from
typing
import
IO
from
typing
import
Iterable
from
typing
import
Literal
from
typing
import
overload
from
typing
import
Sequence
from
typing
import
TextIO
from
typing
import
TYPE_CHECKING
from
weakref
import
WeakKeyDictionary
from
iniconfig
import
IniConfig
from
iniconfig
import
SectionWrapper
from
_pytest
import
timing
from
_pytest._code
import
Source
from
_pytest.capture
import
_get_multicapture
from
_pytest.compat
import
NOTSET
from
_pytest.compat
import
NotSetType
from
_pytest.config
import
_PluggyPlugin
from
_pytest.config
import
Config
from
_pytest.config
import
ExitCode
from
_pytest.config
import
hookimpl
from
_pytest.config
import
main
from
_pytest.config
import
PytestPluginManager
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
fixture
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.main
import
Session
from
_pytest.monkeypatch
import
MonkeyPatch
from
_pytest.nodes
import
Collector
from
_pytest.nodes
import
Item
from
_pytest.outcomes
import
fail
from
_pytest.outcomes
import
importorskip
from
_pytest.outcomes
import
skip
from
_pytest.pathlib
import
bestrelpath
from
_pytest.pathlib
import
make_numbered_dir
from
_pytest.reports
import
CollectReport
from
_pytest.reports
import
TestReport
from
_pytest.tmpdir
import
TempPathFactory
from
_pytest.warning_types
import
PytestWarning
if
TYPE_CHECKING
:
import
pexpect
pytest_plugins
=
[
"pytester_assertions"
]
IGNORE_PAM
=
[
# filenames added when obtaining details about the current user
"/var/lib/sss/mc/passwd"
]
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
parser
.
addoption
(
"--lsof"
,
action
=
"store_true"
,
dest
=
"lsof"
,
default
=
False
,
help
=
"Run FD checks if lsof is available"
,
)
parser
.
addoption
(
"--runpytest"
,
default
=
"inprocess"
,
dest
=
"runpytest"
,
choices
=
(
"inprocess"
,
"subprocess"
),
help
=
(
"Run pytest sub runs in tests using an 'inprocess' "
"or 'subprocess' (python -m main) method"
),
)
parser
.
addini
(
"pytester_example_dir"
,
help
=
"Directory to take the pytester example files from"
)
def
pytest_configure
(
config
:
Config
)
->
None
:
if
config
.
getvalue
(
"lsof"
):
checker
=
LsofFdLeakChecker
()
if
checker
.
matching_platform
():
config
.
pluginmanager
.
register
(
checker
)
config
.
addinivalue_line
(
"markers"
,
"pytester_example_path(*path_segments): join the given path "
"segments to `pytester_example_dir` for this test."
,
)
class
LsofFdLeakChecker
:
def
get_open_files
(
self
)
->
list
[
tuple
[
str
,
str
]]:
if
sys
.
version_info
>=
(
3
,
11
):
# New in Python 3.11, ignores utf-8 mode
encoding
=
locale
.
getencoding
()
else
:
encoding
=
locale
.
getpreferredencoding
(
False
)
out
=
subprocess
.
run
(
(
"lsof"
,
"-Ffn0"
,
"-p"
,
str
(
os
.
getpid
())),
stdout
=
subprocess
.
PIPE
,
stderr
=
subprocess
.
DEVNULL
,
check
=
True
,
text
=
True
,
encoding
=
encoding
,
)
.
stdout
def
isopen
(
line
:
str
)
->
bool
:
return
line
.
startswith
(
"f"
)
and
(
"deleted"
not
in
line
and
"mem"
not
in
line
and
"txt"
not
in
line
and
"cwd"
not
in
line
)
open_files
=
[]
for
line
in
out
.
split
(
"
\n
"
):
if
isopen
(
line
):
fields
=
line
.
split
(
"
\0
"
)
fd
=
fields
[
0
][
1
:]
filename
=
fields
[
1
][
1
:]
if
filename
in
IGNORE_PAM
:
continue
if
filename
.
startswith
(
"/"
):
open_files
.
append
((
fd
,
filename
))
return
open_files
def
matching_platform
(
self
)
->
bool
:
try
:
subprocess
.
run
((
"lsof"
,
"-v"
),
check
=
True
)
except
(
OSError
,
subprocess
.
CalledProcessError
):
return
False
else
:
return
True
@hookimpl
(
wrapper
=
True
,
tryfirst
=
True
)
def
pytest_runtest_protocol
(
self
,
item
:
Item
)
->
Generator
[
None
,
object
,
object
]:
lines1
=
self
.
get_open_files
()
try
:
return
(
yield
)
finally
:
if
hasattr
(
sys
,
"pypy_version_info"
):
gc
.
collect
()
lines2
=
self
.
get_open_files
()
new_fds
=
{
t
[
0
]
for
t
in
lines2
}
-
{
t
[
0
]
for
t
in
lines1
}
leaked_files
=
[
t
for
t
in
lines2
if
t
[
0
]
in
new_fds
]
if
leaked_files
:
error
=
[
f
"*****
{
len
(
leaked_files
)
}
FD leakage detected"
,
*
(
str
(
f
)
for
f
in
leaked_files
),
"*** Before:"
,
*
(
str
(
f
)
for
f
in
lines1
),
"*** After:"
,
*
(
str
(
f
)
for
f
in
lines2
),
f
"*****
{
len
(
leaked_files
)
}
FD leakage detected"
,
"*** function
{}
:
{}
:
{}
"
.
format
(
*
item
.
location
),
"See issue #2366"
,
]
item
.
warn
(
PytestWarning
(
"
\n
"
.
join
(
error
)))
# used at least by pytest-xdist plugin
@fixture
def
_pytest
(
request
:
FixtureRequest
)
->
PytestArg
:
"""Return a helper which offers a gethookrecorder(hook) method which
returns a HookRecorder instance which helps to make assertions about called
hooks."""
return
PytestArg
(
request
)
class
PytestArg
:
def
__init__
(
self
,
request
:
FixtureRequest
)
->
None
:
self
.
_request
=
request
def
gethookrecorder
(
self
,
hook
)
->
HookRecorder
:
hookrecorder
=
HookRecorder
(
hook
.
_pm
)
self
.
_request
.
addfinalizer
(
hookrecorder
.
finish_recording
)
return
hookrecorder
def
get_public_names
(
values
:
Iterable
[
str
])
->
list
[
str
]:
"""Only return names from iterator values without a leading underscore."""
return
[
x
for
x
in
values
if
x
[
0
]
!=
"_"
]
[docs]
@final
class
RecordedHookCall
:
"""A recorded call to a hook.
The arguments to the hook call are set as attributes.
For example:
.. code-block:: python
calls = hook_recorder.getcalls("pytest_runtest_setup")
# Suppose pytest_runtest_setup was called once with `item=an_item`.
assert calls[0].item is an_item
"""
def
__init__
(
self
,
name
:
str
,
kwargs
)
->
None
:
self
.
__dict__
.
update
(
kwargs
)
self
.
_name
=
name
def
__repr__
(
self
)
->
str
:
d
=
self
.
__dict__
.
copy
()
del
d
[
"_name"
]
return
f
"<RecordedHookCall
{
self
.
_name
!r}
(**
{
d
!r}
)>"
if
TYPE_CHECKING
:
# The class has undetermined attributes, this tells mypy about it.
def
__getattr__
(
self
,
key
:
str
):
...
[docs]
@final
class
HookRecorder
:
"""Record all hooks called in a plugin manager.
Hook recorders are created by :class:`Pytester`.
This wraps all the hook calls in the plugin manager, recording each call
before propagating the normal calls.
"""
def
__init__
(
self
,
pluginmanager
:
PytestPluginManager
,
*
,
_ispytest
:
bool
=
False
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_pluginmanager
=
pluginmanager
self
.
calls
:
list
[
RecordedHookCall
]
=
[]
self
.
ret
:
int
|
ExitCode
|
None
=
None
def
before
(
hook_name
:
str
,
hook_impls
,
kwargs
)
->
None
:
self
.
calls
.
append
(
RecordedHookCall
(
hook_name
,
kwargs
))
def
after
(
outcome
,
hook_name
:
str
,
hook_impls
,
kwargs
)
->
None
:
pass
self
.
_undo_wrapping
=
pluginmanager
.
add_hookcall_monitoring
(
before
,
after
)
def
finish_recording
(
self
)
->
None
:
self
.
_undo_wrapping
()
[docs]
def
getcalls
(
self
,
names
:
str
|
Iterable
[
str
])
->
list
[
RecordedHookCall
]:
"""Get all recorded calls to hooks with the given names (or name)."""
if
isinstance
(
names
,
str
):
names
=
names
.
split
()
return
[
call
for
call
in
self
.
calls
if
call
.
_name
in
names
]
def
assert_contains
(
self
,
entries
:
Sequence
[
tuple
[
str
,
str
]])
->
None
:
__tracebackhide__
=
True
i
=
0
entries
=
list
(
entries
)
# Since Python 3.13, f_locals is not a dict, but eval requires a dict.
backlocals
=
dict
(
sys
.
_getframe
(
1
)
.
f_locals
)
while
entries
:
name
,
check
=
entries
.
pop
(
0
)
for
ind
,
call
in
enumerate
(
self
.
calls
[
i
:]):
if
call
.
_name
==
name
:
print
(
"NAMEMATCH"
,
name
,
call
)
if
eval
(
check
,
backlocals
,
call
.
__dict__
):
print
(
"CHECKERMATCH"
,
repr
(
check
),
"->"
,
call
)
else
:
print
(
"NOCHECKERMATCH"
,
repr
(
check
),
"-"
,
call
)
continue
i
+=
ind
+
1
break
print
(
"NONAMEMATCH"
,
name
,
"with"
,
call
)
else
:
fail
(
f
"could not find
{
name
!r}
check
{
check
!r}
"
)
def
popcall
(
self
,
name
:
str
)
->
RecordedHookCall
:
__tracebackhide__
=
True
for
i
,
call
in
enumerate
(
self
.
calls
):
if
call
.
_name
==
name
:
del
self
.
calls
[
i
]
return
call
lines
=
[
f
"could not find call
{
name
!r}
, in:"
]
lines
.
extend
([
f
"
{
x
}
"
for
x
in
self
.
calls
])
fail
(
"
\n
"
.
join
(
lines
))
def
getcall
(
self
,
name
:
str
)
->
RecordedHookCall
:
values
=
self
.
getcalls
(
name
)
assert
len
(
values
)
==
1
,
(
name
,
values
)
return
values
[
0
]
# functionality for test reports
@overload
def
getreports
(
self
,
names
:
Literal
[
"pytest_collectreport"
],
)
->
Sequence
[
CollectReport
]:
...
@overload
def
getreports
(
self
,
names
:
Literal
[
"pytest_runtest_logreport"
],
)
->
Sequence
[
TestReport
]:
...
@overload
def
getreports
(
self
,
names
:
str
|
Iterable
[
str
]
=
(
"pytest_collectreport"
,
"pytest_runtest_logreport"
,
),
)
->
Sequence
[
CollectReport
|
TestReport
]:
...
def
getreports
(
self
,
names
:
str
|
Iterable
[
str
]
=
(
"pytest_collectreport"
,
"pytest_runtest_logreport"
,
),
)
->
Sequence
[
CollectReport
|
TestReport
]:
return
[
x
.
report
for
x
in
self
.
getcalls
(
names
)]
[docs]
def
matchreport
(
self
,
inamepart
:
str
=
""
,
names
:
str
|
Iterable
[
str
]
=
(
"pytest_runtest_logreport"
,
"pytest_collectreport"
,
),
when
:
str
|
None
=
None
,
)
->
CollectReport
|
TestReport
:
"""Return a testreport whose dotted import path matches."""
values
=
[]
for
rep
in
self
.
getreports
(
names
=
names
):
if
not
when
and
rep
.
when
!=
"call"
and
rep
.
passed
:
# setup/teardown passing reports - let's ignore those
continue
if
when
and
rep
.
when
!=
when
:
continue
if
not
inamepart
or
inamepart
in
rep
.
nodeid
.
split
(
"::"
):
values
.
append
(
rep
)
if
not
values
:
raise
ValueError
(
f
"could not find test report matching
{
inamepart
!r}
: "
"no test reports at all!"
)
if
len
(
values
)
>
1
:
raise
ValueError
(
f
"found 2 or more testreports matching
{
inamepart
!r}
:
{
values
}
"
)
return
values
[
0
]
@overload
def
getfailures
(
self
,
names
:
Literal
[
"pytest_collectreport"
],
)
->
Sequence
[
CollectReport
]:
...
@overload
def
getfailures
(
self
,
names
:
Literal
[
"pytest_runtest_logreport"
],
)
->
Sequence
[
TestReport
]:
...
@overload
def
getfailures
(
self
,
names
:
str
|
Iterable
[
str
]
=
(
"pytest_collectreport"
,
"pytest_runtest_logreport"
,
),
)
->
Sequence
[
CollectReport
|
TestReport
]:
...
def
getfailures
(
self
,
names
:
str
|
Iterable
[
str
]
=
(
"pytest_collectreport"
,
"pytest_runtest_logreport"
,
),
)
->
Sequence
[
CollectReport
|
TestReport
]:
return
[
rep
for
rep
in
self
.
getreports
(
names
)
if
rep
.
failed
]
def
getfailedcollections
(
self
)
->
Sequence
[
CollectReport
]:
return
self
.
getfailures
(
"pytest_collectreport"
)
def
listoutcomes
(
self
,
)
->
tuple
[
Sequence
[
TestReport
],
Sequence
[
CollectReport
|
TestReport
],
Sequence
[
CollectReport
|
TestReport
],
]:
passed
=
[]
skipped
=
[]
failed
=
[]
for
rep
in
self
.
getreports
(
(
"pytest_collectreport"
,
"pytest_runtest_logreport"
)
):
if
rep
.
passed
:
if
rep
.
when
==
"call"
:
assert
isinstance
(
rep
,
TestReport
)
passed
.
append
(
rep
)
elif
rep
.
skipped
:
skipped
.
append
(
rep
)
else
:
assert
rep
.
failed
,
f
"Unexpected outcome:
{
rep
!r}
"
failed
.
append
(
rep
)
return
passed
,
skipped
,
failed
def
countoutcomes
(
self
)
->
list
[
int
]:
return
[
len
(
x
)
for
x
in
self
.
listoutcomes
()]
def
assertoutcome
(
self
,
passed
:
int
=
0
,
skipped
:
int
=
0
,
failed
:
int
=
0
)
->
None
:
__tracebackhide__
=
True
from
_pytest.pytester_assertions
import
assertoutcome
outcomes
=
self
.
listoutcomes
()
assertoutcome
(
outcomes
,
passed
=
passed
,
skipped
=
skipped
,
failed
=
failed
,
)
def
clear
(
self
)
->
None
:
self
.
calls
[:]
=
[]
@fixture
def
linecomp
()
->
LineComp
:
"""A :class: `LineComp` instance for checking that an input linearly
contains a sequence of strings."""
return
LineComp
()
@fixture
(
name
=
"LineMatcher"
)
def
LineMatcher_fixture
(
request
:
FixtureRequest
)
->
type
[
LineMatcher
]:
"""A reference to the :class: `LineMatcher`.
This is instantiable with a list of lines (without their trailing newlines).
This is useful for testing large texts, such as the output of commands.
"""
return
LineMatcher
@fixture
def
pytester
(
request
:
FixtureRequest
,
tmp_path_factory
:
TempPathFactory
,
monkeypatch
:
MonkeyPatch
)
->
Pytester
:
"""
Facilities to write tests/configuration files, execute pytest in isolation, and match
against expected output, perfect for black-box testing of pytest plugins.
It attempts to isolate the test run from external factors as much as possible, modifying
the current working directory to ``path`` and environment variables during initialization.
It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`
fixture but provides methods which aid in testing pytest itself.
"""
return
Pytester
(
request
,
tmp_path_factory
,
monkeypatch
,
_ispytest
=
True
)
@fixture
def
_sys_snapshot
()
->
Generator
[
None
]:
snappaths
=
SysPathsSnapshot
()
snapmods
=
SysModulesSnapshot
()
yield
snapmods
.
restore
()
snappaths
.
restore
()
@fixture
def
_config_for_test
()
->
Generator
[
Config
]:
from
_pytest.config
import
get_config
config
=
get_config
()
yield
config
config
.
_ensure_unconfigure
()
# cleanup, e.g. capman closing tmpfiles.
# Regex to match the session duration string in the summary: "74.34s".
rex_session_duration
=
re
.
compile
(
r
"\d+\.\d\ds"
)
# Regex to match all the counts and phrases in the summary line: "34 passed, 111 skipped".
rex_outcome
=
re
.
compile
(
r
"(\d+) (\w+)"
)
[docs]
@final
class
RunResult
:
"""The result of running a command from :class:`~pytest.Pytester`."""
def
__init__
(
self
,
ret
:
int
|
ExitCode
,
outlines
:
list
[
str
],
errlines
:
list
[
str
],
duration
:
float
,
)
->
None
:
try
:
self
.
ret
:
int
|
ExitCode
=
ExitCode
(
ret
)
"""The return value."""
except
ValueError
:
self
.
ret
=
ret
self
.
outlines
=
outlines
"""List of lines captured from stdout."""
self
.
errlines
=
errlines
"""List of lines captured from stderr."""
self
.
stdout
=
LineMatcher
(
outlines
)
""":class:`~pytest.LineMatcher` of stdout.
Use e.g. :func:`str(stdout) <pytest.LineMatcher.__str__()>` to reconstruct stdout, or the commonly used
:func:`stdout.fnmatch_lines() <pytest.LineMatcher.fnmatch_lines()>` method.
"""
self
.
stderr
=
LineMatcher
(
errlines
)
""":class:`~pytest.LineMatcher` of stderr."""
self
.
duration
=
duration
"""Duration in seconds."""
def
__repr__
(
self
)
->
str
:
return
(
"<RunResult ret=
%s
len(stdout.lines)=
%d
len(stderr.lines)=
%d
duration=
%.2f
s>"
%
(
self
.
ret
,
len
(
self
.
stdout
.
lines
),
len
(
self
.
stderr
.
lines
),
self
.
duration
)
)
[docs]
def
parseoutcomes
(
self
)
->
dict
[
str
,
int
]:
"""Return a dictionary of outcome noun -> count from parsing the terminal
output that the test process produced.
The returned nouns will always be in plural form::
======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====
Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
"""
return
self
.
parse_summary_nouns
(
self
.
outlines
)
[docs]
@classmethod
def
parse_summary_nouns
(
cls
,
lines
)
->
dict
[
str
,
int
]:
"""Extract the nouns from a pytest terminal summary line.
It always returns the plural noun for consistency::
======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====
Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
"""
for
line
in
reversed
(
lines
):
if
rex_session_duration
.
search
(
line
):
outcomes
=
rex_outcome
.
findall
(
line
)
ret
=
{
noun
:
int
(
count
)
for
(
count
,
noun
)
in
outcomes
}
break
else
:
raise
ValueError
(
"Pytest terminal summary report not found"
)
to_plural
=
{
"warning"
:
"warnings"
,
"error"
:
"errors"
,
}
return
{
to_plural
.
get
(
k
,
k
):
v
for
k
,
v
in
ret
.
items
()}
[docs]
def
assert_outcomes
(
self
,
passed
:
int
=
0
,
skipped
:
int
=
0
,
failed
:
int
=
0
,
errors
:
int
=
0
,
xpassed
:
int
=
0
,
xfailed
:
int
=
0
,
warnings
:
int
|
None
=
None
,
deselected
:
int
|
None
=
None
,
)
->
None
:
"""
Assert that the specified outcomes appear with the respective
numbers (0 means it didn't occur) in the text output from a test run.
``warnings`` and ``deselected`` are only checked if not None.
"""
__tracebackhide__
=
True
from
_pytest.pytester_assertions
import
assert_outcomes
outcomes
=
self
.
parseoutcomes
()
assert_outcomes
(
outcomes
,
passed
=
passed
,
skipped
=
skipped
,
failed
=
failed
,
errors
=
errors
,
xpassed
=
xpassed
,
xfailed
=
xfailed
,
warnings
=
warnings
,
deselected
=
deselected
,
)
class
SysModulesSnapshot
:
def
__init__
(
self
,
preserve
:
Callable
[[
str
],
bool
]
|
None
=
None
)
->
None
:
self
.
__preserve
=
preserve
self
.
__saved
=
dict
(
sys
.
modules
)
def
restore
(
self
)
->
None
:
if
self
.
__preserve
:
self
.
__saved
.
update
(
(
k
,
m
)
for
k
,
m
in
sys
.
modules
.
items
()
if
self
.
__preserve
(
k
)
)
sys
.
modules
.
clear
()
sys
.
modules
.
update
(
self
.
__saved
)
class
SysPathsSnapshot
:
def
__init__
(
self
)
->
None
:
self
.
__saved
=
list
(
sys
.
path
),
list
(
sys
.
meta_path
)
def
restore
(
self
)
->
None
:
sys
.
path
[:],
sys
.
meta_path
[:]
=
self
.
__saved
[docs]
@final
class
Pytester
:
"""
Facilities to write tests/configuration files, execute pytest in isolation, and match
against expected output, perfect for black-box testing of pytest plugins.
It attempts to isolate the test run from external factors as much as possible, modifying
the current working directory to :attr:`path` and environment variables during initialization.
"""
__test__
=
False
CLOSE_STDIN
:
Final
=
NOTSET
[docs]
class
TimeoutExpired
(
Exception
):
pass
def
__init__
(
self
,
request
:
FixtureRequest
,
tmp_path_factory
:
TempPathFactory
,
monkeypatch
:
MonkeyPatch
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
self
.
_request
=
request
self
.
_mod_collections
:
WeakKeyDictionary
[
Collector
,
list
[
Item
|
Collector
]]
=
(
WeakKeyDictionary
()
)
if
request
.
function
:
name
:
str
=
request
.
function
.
__name__
else
:
name
=
request
.
node
.
name
self
.
_name
=
name
self
.
_path
:
Path
=
tmp_path_factory
.
mktemp
(
name
,
numbered
=
True
)
#: A list of plugins to use with :py:meth:`parseconfig` and
#: :py:meth:`runpytest`.  Initially this is an empty list but plugins can
#: be added to the list.  The type of items to add to the list depends on
#: the method using them so refer to them for details.
self
.
plugins
:
list
[
str
|
_PluggyPlugin
]
=
[]
self
.
_sys_path_snapshot
=
SysPathsSnapshot
()
self
.
_sys_modules_snapshot
=
self
.
__take_sys_modules_snapshot
()
self
.
_request
.
addfinalizer
(
self
.
_finalize
)
self
.
_method
=
self
.
_request
.
config
.
getoption
(
"--runpytest"
)
self
.
_test_tmproot
=
tmp_path_factory
.
mktemp
(
f
"tmp-
{
name
}
"
,
numbered
=
True
)
self
.
_monkeypatch
=
mp
=
monkeypatch
self
.
chdir
()
mp
.
setenv
(
"PYTEST_DEBUG_TEMPROOT"
,
str
(
self
.
_test_tmproot
))
# Ensure no unexpected caching via tox.
mp
.
delenv
(
"TOX_ENV_DIR"
,
raising
=
False
)
# Discard outer pytest options.
mp
.
delenv
(
"PYTEST_ADDOPTS"
,
raising
=
False
)
# Ensure no user config is used.
tmphome
=
str
(
self
.
path
)
mp
.
setenv
(
"HOME"
,
tmphome
)
mp
.
setenv
(
"USERPROFILE"
,
tmphome
)
# Do not use colors for inner runs by default.
mp
.
setenv
(
"PY_COLORS"
,
"0"
)
@property
def
path
(
self
)
->
Path
:
"""Temporary directory path used to create files/run tests from, etc."""
return
self
.
_path
def
__repr__
(
self
)
->
str
:
return
f
"<Pytester
{
self
.
path
!r}
>"
def
_finalize
(
self
)
->
None
:
"""
Clean up global state artifacts.
Some methods modify the global interpreter state and this tries to
clean this up. It does not remove the temporary directory however so
it can be looked at after the test run has finished.
"""
self
.
_sys_modules_snapshot
.
restore
()
self
.
_sys_path_snapshot
.
restore
()
def
__take_sys_modules_snapshot
(
self
)
->
SysModulesSnapshot
:
# Some zope modules used by twisted-related tests keep internal state
# and can't be deleted; we had some trouble in the past with
# `zope.interface` for example.
#
# Preserve readline due to https://bugs.python.org/issue41033.
# pexpect issues a SIGWINCH.
def
preserve_module
(
name
):
return
name
.
startswith
((
"zope"
,
"readline"
))
return
SysModulesSnapshot
(
preserve
=
preserve_module
)
[docs]
def
make_hook_recorder
(
self
,
pluginmanager
:
PytestPluginManager
)
->
HookRecorder
:
"""Create a new :class:`HookRecorder` for a :class:`PytestPluginManager`."""
pluginmanager
.
reprec
=
reprec
=
HookRecorder
(
pluginmanager
,
_ispytest
=
True
)
# type: ignore[attr-defined]
self
.
_request
.
addfinalizer
(
reprec
.
finish_recording
)
return
reprec
[docs]
def
chdir
(
self
)
->
None
:
"""Cd into the temporary directory.
This is done automatically upon instantiation.
"""
self
.
_monkeypatch
.
chdir
(
self
.
path
)
def
_makefile
(
self
,
ext
:
str
,
lines
:
Sequence
[
Any
|
bytes
],
files
:
dict
[
str
,
str
],
encoding
:
str
=
"utf-8"
,
)
->
Path
:
items
=
list
(
files
.
items
())
if
ext
is
None
:
raise
TypeError
(
"ext must not be None"
)
if
ext
and
not
ext
.
startswith
(
"."
):
raise
ValueError
(
f
"pytester.makefile expects a file extension, try .
{
ext
}
instead of
{
ext
}
"
)
def
to_text
(
s
:
Any
|
bytes
)
->
str
:
return
s
.
decode
(
encoding
)
if
isinstance
(
s
,
bytes
)
else
str
(
s
)
if
lines
:
source
=
"
\n
"
.
join
(
to_text
(
x
)
for
x
in
lines
)
basename
=
self
.
_name
items
.
insert
(
0
,
(
basename
,
source
))
ret
=
None
for
basename
,
value
in
items
:
p
=
self
.
path
.
joinpath
(
basename
)
.
with_suffix
(
ext
)
p
.
parent
.
mkdir
(
parents
=
True
,
exist_ok
=
True
)
source_
=
Source
(
value
)
source
=
"
\n
"
.
join
(
to_text
(
line
)
for
line
in
source_
.
lines
)
p
.
write_text
(
source
.
strip
(),
encoding
=
encoding
)
if
ret
is
None
:
ret
=
p
assert
ret
is
not
None
return
ret
[docs]
def
makefile
(
self
,
ext
:
str
,
*
args
:
str
,
**
kwargs
:
str
)
->
Path
:
r
"""Create new text file(s) in the test directory.
:param ext:
The extension the file(s) should use, including the dot, e.g. `.py`.
:param args:
All args are treated as strings and joined using newlines.
The result is written as contents to the file.  The name of the
file is based on the test function requesting this fixture.
:param kwargs:
Each keyword is the name of a file, while the value of it will
be written as contents of the file.
:returns:
The first created file.
Examples:
.. code-block:: python
pytester.makefile(".txt", "line1", "line2")
pytester.makefile(".ini", pytest="[pytest]\naddopts=-rs\n")
To create binary files, use :meth:`pathlib.Path.write_bytes` directly:
.. code-block:: python
filename = pytester.path.joinpath("foo.bin")
filename.write_bytes(b"...")
"""
return
self
.
_makefile
(
ext
,
args
,
kwargs
)
[docs]
def
makeconftest
(
self
,
source
:
str
)
->
Path
:
"""Write a conftest.py file.
:param source: The contents.
:returns: The conftest.py file.
"""
return
self
.
makepyfile
(
conftest
=
source
)
[docs]
def
makeini
(
self
,
source
:
str
)
->
Path
:
"""Write a tox.ini file.
:param source: The contents.
:returns: The tox.ini file.
"""
return
self
.
makefile
(
".ini"
,
tox
=
source
)
[docs]
def
getinicfg
(
self
,
source
:
str
)
->
SectionWrapper
:
"""Return the pytest section from the tox.ini config file."""
p
=
self
.
makeini
(
source
)
return
IniConfig
(
str
(
p
))[
"pytest"
]
[docs]
def
makepyprojecttoml
(
self
,
source
:
str
)
->
Path
:
"""Write a pyproject.toml file.
:param source: The contents.
:returns: The pyproject.ini file.
.. versionadded:: 6.0
"""
return
self
.
makefile
(
".toml"
,
pyproject
=
source
)
[docs]
def
makepyfile
(
self
,
*
args
,
**
kwargs
)
->
Path
:
r
"""Shortcut for .makefile() with a .py extension.
Defaults to the test name with a '.py' extension, e.g test_foobar.py, overwriting
existing files.
Examples:
.. code-block:: python
def test_something(pytester):
# Initial file is created test_something.py.
pytester.makepyfile("foobar")
# To create multiple files, pass kwargs accordingly.
pytester.makepyfile(custom="foobar")
# At this point, both 'test_something.py' & 'custom.py' exist in the test directory.
"""
return
self
.
_makefile
(
".py"
,
args
,
kwargs
)
[docs]
def
maketxtfile
(
self
,
*
args
,
**
kwargs
)
->
Path
:
r
"""Shortcut for .makefile() with a .txt extension.
Defaults to the test name with a '.txt' extension, e.g test_foobar.txt, overwriting
existing files.
Examples:
.. code-block:: python
def test_something(pytester):
# Initial file is created test_something.txt.
pytester.maketxtfile("foobar")
# To create multiple files, pass kwargs accordingly.
pytester.maketxtfile(custom="foobar")
# At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.
"""
return
self
.
_makefile
(
".txt"
,
args
,
kwargs
)
[docs]
def
syspathinsert
(
self
,
path
:
str
|
os
.
PathLike
[
str
]
|
None
=
None
)
->
None
:
"""Prepend a directory to sys.path, defaults to :attr:`path`.
This is undone automatically when this object dies at the end of each
test.
:param path:
The path.
"""
if
path
is
None
:
path
=
self
.
path
self
.
_monkeypatch
.
syspath_prepend
(
str
(
path
))
[docs]
def
mkdir
(
self
,
name
:
str
|
os
.
PathLike
[
str
])
->
Path
:
"""Create a new (sub)directory.
:param name:
The name of the directory, relative to the pytester path.
:returns:
The created directory.
:rtype: pathlib.Path
"""
p
=
self
.
path
/
name
p
.
mkdir
()
return
p
[docs]
def
mkpydir
(
self
,
name
:
str
|
os
.
PathLike
[
str
])
->
Path
:
"""Create a new python package.
This creates a (sub)directory with an empty ``__init__.py`` file so it
gets recognised as a Python package.
"""
p
=
self
.
path
/
name
p
.
mkdir
()
p
.
joinpath
(
"__init__.py"
)
.
touch
()
return
p
[docs]
def
copy_example
(
self
,
name
:
str
|
None
=
None
)
->
Path
:
"""Copy file from project's directory into the testdir.
:param name:
The name of the file to copy.
:return:
Path to the copied directory (inside ``self.path``).
:rtype: pathlib.Path
"""
example_dir_
=
self
.
_request
.
config
.
getini
(
"pytester_example_dir"
)
if
example_dir_
is
None
:
raise
ValueError
(
"pytester_example_dir is unset, can't copy examples"
)
example_dir
:
Path
=
self
.
_request
.
config
.
rootpath
/
example_dir_
for
extra_element
in
self
.
_request
.
node
.
iter_markers
(
"pytester_example_path"
):
assert
extra_element
.
args
example_dir
=
example_dir
.
joinpath
(
*
extra_element
.
args
)
if
name
is
None
:
func_name
=
self
.
_name
maybe_dir
=
example_dir
/
func_name
maybe_file
=
example_dir
/
(
func_name
+
".py"
)
if
maybe_dir
.
is_dir
():
example_path
=
maybe_dir
elif
maybe_file
.
is_file
():
example_path
=
maybe_file
else
:
raise
LookupError
(
f
"
{
func_name
}
can't be found as module or package in
{
example_dir
}
"
)
else
:
example_path
=
example_dir
.
joinpath
(
name
)
if
example_path
.
is_dir
()
and
not
example_path
.
joinpath
(
"__init__.py"
)
.
is_file
():
shutil
.
copytree
(
example_path
,
self
.
path
,
symlinks
=
True
,
dirs_exist_ok
=
True
)
return
self
.
path
elif
example_path
.
is_file
():
result
=
self
.
path
.
joinpath
(
example_path
.
name
)
shutil
.
copy
(
example_path
,
result
)
return
result
else
:
raise
LookupError
(
f
'example "
{
example_path
}
" is not found as a file or directory'
)
[docs]
def
getnode
(
self
,
config
:
Config
,
arg
:
str
|
os
.
PathLike
[
str
])
->
Collector
|
Item
:
"""Get the collection node of a file.
:param config:
A pytest config.
See :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.
:param arg:
Path to the file.
:returns:
The node.
"""
session
=
Session
.
from_config
(
config
)
assert
"::"
not
in
str
(
arg
)
p
=
Path
(
os
.
path
.
abspath
(
arg
))
config
.
hook
.
pytest_sessionstart
(
session
=
session
)
res
=
session
.
perform_collect
([
str
(
p
)],
genitems
=
False
)[
0
]
config
.
hook
.
pytest_sessionfinish
(
session
=
session
,
exitstatus
=
ExitCode
.
OK
)
return
res
[docs]
def
getpathnode
(
self
,
path
:
str
|
os
.
PathLike
[
str
])
->
Collector
|
Item
:
"""Return the collection node of a file.
This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to
create the (configured) pytest Config instance.
:param path:
Path to the file.
:returns:
The node.
"""
path
=
Path
(
path
)
config
=
self
.
parseconfigure
(
path
)
session
=
Session
.
from_config
(
config
)
x
=
bestrelpath
(
session
.
path
,
path
)
config
.
hook
.
pytest_sessionstart
(
session
=
session
)
res
=
session
.
perform_collect
([
x
],
genitems
=
False
)[
0
]
config
.
hook
.
pytest_sessionfinish
(
session
=
session
,
exitstatus
=
ExitCode
.
OK
)
return
res
[docs]
def
genitems
(
self
,
colitems
:
Sequence
[
Item
|
Collector
])
->
list
[
Item
]:
"""Generate all test items from a collection node.
This recurses into the collection node and returns a list of all the
test items contained within.
:param colitems:
The collection nodes.
:returns:
The collected items.
"""
session
=
colitems
[
0
]
.
session
result
:
list
[
Item
]
=
[]
for
colitem
in
colitems
:
result
.
extend
(
session
.
genitems
(
colitem
))
return
result
[docs]
def
runitem
(
self
,
source
:
str
)
->
Any
:
"""Run the "test_func" Item.
The calling test instance (class containing the test method) must
provide a ``.getrunner()`` method which should return a runner which
can run the test protocol for a single item, e.g.
``_pytest.runner.runtestprotocol``.
"""
# used from runner functional tests
item
=
self
.
getitem
(
source
)
# the test class where we are called from wants to provide the runner
testclassinstance
=
self
.
_request
.
instance
runner
=
testclassinstance
.
getrunner
()
return
runner
(
item
)
[docs]
def
inline_runsource
(
self
,
source
:
str
,
*
cmdlineargs
)
->
HookRecorder
:
"""Run a test module in process using ``pytest.main()``.
This run writes "source" into a temporary file and runs
``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance
for the result.
:param source: The source code of the test module.
:param cmdlineargs: Any extra command line arguments to use.
"""
p
=
self
.
makepyfile
(
source
)
values
=
[
*
list
(
cmdlineargs
),
p
]
return
self
.
inline_run
(
*
values
)
[docs]
def
inline_genitems
(
self
,
*
args
)
->
tuple
[
list
[
Item
],
HookRecorder
]:
"""Run ``pytest.main(['--collect-only'])`` in-process.
Runs the :py:func:`pytest.main` function to run all of pytest inside
the test process itself like :py:meth:`inline_run`, but returns a
tuple of the collected items and a :py:class:`HookRecorder` instance.
"""
rec
=
self
.
inline_run
(
"--collect-only"
,
*
args
)
items
=
[
x
.
item
for
x
in
rec
.
getcalls
(
"pytest_itemcollected"
)]
return
items
,
rec
[docs]
def
inline_run
(
self
,
*
args
:
str
|
os
.
PathLike
[
str
],
plugins
=
(),
no_reraise_ctrlc
:
bool
=
False
,
)
->
HookRecorder
:
"""Run ``pytest.main()`` in-process, returning a HookRecorder.
Runs the :py:func:`pytest.main` function to run all of pytest inside
the test process itself.  This means it can return a
:py:class:`HookRecorder` instance which gives more detailed results
from that run than can be done by matching stdout/stderr from
:py:meth:`runpytest`.
:param args:
Command line arguments to pass to :py:func:`pytest.main`.
:param plugins:
Extra plugin instances the ``pytest.main()`` instance should use.
:param no_reraise_ctrlc:
Typically we reraise keyboard interrupts from the child run. If
True, the KeyboardInterrupt exception is captured.
"""
# (maybe a cpython bug?) the importlib cache sometimes isn't updated
# properly between file creation and inline_run (especially if imports
# are interspersed with file creation)
importlib
.
invalidate_caches
()
plugins
=
list
(
plugins
)
finalizers
=
[]
try
:
# Any sys.module or sys.path changes done while running pytest
# inline should be reverted after the test run completes to avoid
# clashing with later inline tests run within the same pytest test,
# e.g. just because they use matching test module names.
finalizers
.
append
(
self
.
__take_sys_modules_snapshot
()
.
restore
)
finalizers
.
append
(
SysPathsSnapshot
()
.
restore
)
# Important note:
# - our tests should not leave any other references/registrations
#   laying around other than possibly loaded test modules
#   referenced from sys.modules, as nothing will clean those up
#   automatically
rec
=
[]
class
Collect
:
def
pytest_configure
(
x
,
config
:
Config
)
->
None
:
rec
.
append
(
self
.
make_hook_recorder
(
config
.
pluginmanager
))
plugins
.
append
(
Collect
())
ret
=
main
([
str
(
x
)
for
x
in
args
],
plugins
=
plugins
)
if
len
(
rec
)
==
1
:
reprec
=
rec
.
pop
()
else
:
class
reprec
:
# type: ignore
pass
reprec
.
ret
=
ret
# Typically we reraise keyboard interrupts from the child run
# because it's our user requesting interruption of the testing.
if
ret
==
ExitCode
.
INTERRUPTED
and
not
no_reraise_ctrlc
:
calls
=
reprec
.
getcalls
(
"pytest_keyboard_interrupt"
)
if
calls
and
calls
[
-
1
]
.
excinfo
.
type
==
KeyboardInterrupt
:
raise
KeyboardInterrupt
()
return
reprec
finally
:
for
finalizer
in
finalizers
:
finalizer
()
[docs]
def
runpytest_inprocess
(
self
,
*
args
:
str
|
os
.
PathLike
[
str
],
**
kwargs
:
Any
)
->
RunResult
:
"""Return result of running pytest in-process, providing a similar
interface to what self.runpytest() provides."""
syspathinsert
=
kwargs
.
pop
(
"syspathinsert"
,
False
)
if
syspathinsert
:
self
.
syspathinsert
()
now
=
timing
.
time
()
capture
=
_get_multicapture
(
"sys"
)
capture
.
start_capturing
()
try
:
try
:
reprec
=
self
.
inline_run
(
*
args
,
**
kwargs
)
except
SystemExit
as
e
:
ret
=
e
.
args
[
0
]
try
:
ret
=
ExitCode
(
e
.
args
[
0
])
except
ValueError
:
pass
class
reprec
:
# type: ignore
ret
=
ret
except
Exception
:
traceback
.
print_exc
()
class
reprec
:
# type: ignore
ret
=
ExitCode
(
3
)
finally
:
out
,
err
=
capture
.
readouterr
()
capture
.
stop_capturing
()
sys
.
stdout
.
write
(
out
)
sys
.
stderr
.
write
(
err
)
assert
reprec
.
ret
is
not
None
res
=
RunResult
(
reprec
.
ret
,
out
.
splitlines
(),
err
.
splitlines
(),
timing
.
time
()
-
now
)
res
.
reprec
=
reprec
# type: ignore
return
res
[docs]
def
runpytest
(
self
,
*
args
:
str
|
os
.
PathLike
[
str
],
**
kwargs
:
Any
)
->
RunResult
:
"""Run pytest inline or in a subprocess, depending on the command line
option "--runpytest" and return a :py:class:`~pytest.RunResult`."""
new_args
=
self
.
_ensure_basetemp
(
args
)
if
self
.
_method
==
"inprocess"
:
return
self
.
runpytest_inprocess
(
*
new_args
,
**
kwargs
)
elif
self
.
_method
==
"subprocess"
:
return
self
.
runpytest_subprocess
(
*
new_args
,
**
kwargs
)
raise
RuntimeError
(
f
"Unrecognized runpytest option:
{
self
.
_method
}
"
)
def
_ensure_basetemp
(
self
,
args
:
Sequence
[
str
|
os
.
PathLike
[
str
]]
)
->
list
[
str
|
os
.
PathLike
[
str
]]:
new_args
=
list
(
args
)
for
x
in
new_args
:
if
str
(
x
)
.
startswith
(
"--basetemp"
):
break
else
:
new_args
.
append
(
"--basetemp=
{}
"
.
format
(
self
.
path
.
parent
.
joinpath
(
"basetemp"
))
)
return
new_args
[docs]
def
parseconfig
(
self
,
*
args
:
str
|
os
.
PathLike
[
str
])
->
Config
:
"""Return a new pytest :class:`pytest.Config` instance from given
commandline args.
This invokes the pytest bootstrapping code in _pytest.config to create a
new :py:class:`pytest.PytestPluginManager` and call the
:hook:`pytest_cmdline_parse` hook to create a new :class:`pytest.Config`
instance.
If :attr:`plugins` has been populated they should be plugin modules
to be registered with the plugin manager.
"""
import
_pytest.config
new_args
=
self
.
_ensure_basetemp
(
args
)
new_args
=
[
str
(
x
)
for
x
in
new_args
]
config
=
_pytest
.
config
.
_prepareconfig
(
new_args
,
self
.
plugins
)
# type: ignore[arg-type]
# we don't know what the test will do with this half-setup config
# object and thus we make sure it gets unconfigured properly in any
# case (otherwise capturing could still be active, for example)
self
.
_request
.
addfinalizer
(
config
.
_ensure_unconfigure
)
return
config
[docs]
def
parseconfigure
(
self
,
*
args
:
str
|
os
.
PathLike
[
str
])
->
Config
:
"""Return a new pytest configured Config instance.
Returns a new :py:class:`pytest.Config` instance like
:py:meth:`parseconfig`, but also calls the :hook:`pytest_configure`
hook.
"""
config
=
self
.
parseconfig
(
*
args
)
config
.
_do_configure
()
return
config
[docs]
def
getitem
(
self
,
source
:
str
|
os
.
PathLike
[
str
],
funcname
:
str
=
"test_func"
)
->
Item
:
"""Return the test item for a test function.
Writes the source to a python file and runs pytest's collection on
the resulting module, returning the test item for the requested
function name.
:param source:
The module source.
:param funcname:
The name of the test function for which to return a test item.
:returns:
The test item.
"""
items
=
self
.
getitems
(
source
)
for
item
in
items
:
if
item
.
name
==
funcname
:
return
item
assert
0
,
f
"
{
funcname
!r}
item not found in module:
\n
{
source
}
\n
items:
{
items
}
"
[docs]
def
getitems
(
self
,
source
:
str
|
os
.
PathLike
[
str
])
->
list
[
Item
]:
"""Return all test items collected from the module.
Writes the source to a Python file and runs pytest's collection on
the resulting module, returning all test items contained within.
"""
modcol
=
self
.
getmodulecol
(
source
)
return
self
.
genitems
([
modcol
])
[docs]
def
getmodulecol
(
self
,
source
:
str
|
os
.
PathLike
[
str
],
configargs
=
(),
*
,
withinit
:
bool
=
False
,
):
"""Return the module collection node for ``source``.
Writes ``source`` to a file using :py:meth:`makepyfile` and then
runs the pytest collection on it, returning the collection node for the
test module.
:param source:
The source code of the module to collect.
:param configargs:
Any extra arguments to pass to :py:meth:`parseconfigure`.
:param withinit:
Whether to also write an ``__init__.py`` file to the same
directory to ensure it is a package.
"""
if
isinstance
(
source
,
os
.
PathLike
):
path
=
self
.
path
.
joinpath
(
source
)
assert
not
withinit
,
"not supported for paths"
else
:
kw
=
{
self
.
_name
:
str
(
source
)}
path
=
self
.
makepyfile
(
**
kw
)
if
withinit
:
self
.
makepyfile
(
__init__
=
"#"
)
self
.
config
=
config
=
self
.
parseconfigure
(
path
,
*
configargs
)
return
self
.
getnode
(
config
,
path
)
[docs]
def
collect_by_name
(
self
,
modcol
:
Collector
,
name
:
str
)
->
Item
|
Collector
|
None
:
"""Return the collection node for name from the module collection.
Searches a module collection node for a collection node matching the
given name.
:param modcol: A module collection node; see :py:meth:`getmodulecol`.
:param name: The name of the node to return.
"""
if
modcol
not
in
self
.
_mod_collections
:
self
.
_mod_collections
[
modcol
]
=
list
(
modcol
.
collect
())
for
colitem
in
self
.
_mod_collections
[
modcol
]:
if
colitem
.
name
==
name
:
return
colitem
return
None
[docs]
def
popen
(
self
,
cmdargs
:
Sequence
[
str
|
os
.
PathLike
[
str
]],
stdout
:
int
|
TextIO
=
subprocess
.
PIPE
,
stderr
:
int
|
TextIO
=
subprocess
.
PIPE
,
stdin
:
NotSetType
|
bytes
|
IO
[
Any
]
|
int
=
CLOSE_STDIN
,
**
kw
,
):
"""Invoke :py:class:`subprocess.Popen`.
Calls :py:class:`subprocess.Popen` making sure the current working
directory is in ``PYTHONPATH``.
You probably want to use :py:meth:`run` instead.
"""
env
=
os
.
environ
.
copy
()
env
[
"PYTHONPATH"
]
=
os
.
pathsep
.
join
(
filter
(
None
,
[
os
.
getcwd
(),
env
.
get
(
"PYTHONPATH"
,
""
)])
)
kw
[
"env"
]
=
env
if
stdin
is
self
.
CLOSE_STDIN
:
kw
[
"stdin"
]
=
subprocess
.
PIPE
elif
isinstance
(
stdin
,
bytes
):
kw
[
"stdin"
]
=
subprocess
.
PIPE
else
:
kw
[
"stdin"
]
=
stdin
popen
=
subprocess
.
Popen
(
cmdargs
,
stdout
=
stdout
,
stderr
=
stderr
,
**
kw
)
if
stdin
is
self
.
CLOSE_STDIN
:
assert
popen
.
stdin
is
not
None
popen
.
stdin
.
close
()
elif
isinstance
(
stdin
,
bytes
):
assert
popen
.
stdin
is
not
None
popen
.
stdin
.
write
(
stdin
)
return
popen
[docs]
def
run
(
self
,
*
cmdargs
:
str
|
os
.
PathLike
[
str
],
timeout
:
float
|
None
=
None
,
stdin
:
NotSetType
|
bytes
|
IO
[
Any
]
|
int
=
CLOSE_STDIN
,
)
->
RunResult
:
"""Run a command with arguments.
Run a process using :py:class:`subprocess.Popen` saving the stdout and
stderr.
:param cmdargs:
The sequence of arguments to pass to :py:class:`subprocess.Popen`,
with path-like objects being converted to :py:class:`str`
automatically.
:param timeout:
The period in seconds after which to timeout and raise
:py:class:`Pytester.TimeoutExpired`.
:param stdin:
Optional standard input.
- If it is ``CLOSE_STDIN`` (Default), then this method calls
:py:class:`subprocess.Popen` with ``stdin=subprocess.PIPE``, and
the standard input is closed immediately after the new command is
started.
- If it is of type :py:class:`bytes`, these bytes are sent to the
standard input of the command.
- Otherwise, it is passed through to :py:class:`subprocess.Popen`.
For further information in this case, consult the document of the
``stdin`` parameter in :py:class:`subprocess.Popen`.
:type stdin: _pytest.compat.NotSetType | bytes | IO[Any] | int
:returns:
The result.
"""
__tracebackhide__
=
True
cmdargs
=
tuple
(
os
.
fspath
(
arg
)
for
arg
in
cmdargs
)
p1
=
self
.
path
.
joinpath
(
"stdout"
)
p2
=
self
.
path
.
joinpath
(
"stderr"
)
print
(
"running:"
,
*
cmdargs
)
print
(
"     in:"
,
Path
.
cwd
())
with
p1
.
open
(
"w"
,
encoding
=
"utf8"
)
as
f1
,
p2
.
open
(
"w"
,
encoding
=
"utf8"
)
as
f2
:
now
=
timing
.
time
()
popen
=
self
.
popen
(
cmdargs
,
stdin
=
stdin
,
stdout
=
f1
,
stderr
=
f2
,
close_fds
=
(
sys
.
platform
!=
"win32"
),
)
if
popen
.
stdin
is
not
None
:
popen
.
stdin
.
close
()
def
handle_timeout
()
->
None
:
__tracebackhide__
=
True
timeout_message
=
f
"
{
timeout
}
second timeout expired running:
{
cmdargs
}
"
popen
.
kill
()
popen
.
wait
()
raise
self
.
TimeoutExpired
(
timeout_message
)
if
timeout
is
None
:
ret
=
popen
.
wait
()
else
:
try
:
ret
=
popen
.
wait
(
timeout
)
except
subprocess
.
TimeoutExpired
:
handle_timeout
()
with
p1
.
open
(
encoding
=
"utf8"
)
as
f1
,
p2
.
open
(
encoding
=
"utf8"
)
as
f2
:
out
=
f1
.
read
()
.
splitlines
()
err
=
f2
.
read
()
.
splitlines
()
self
.
_dump_lines
(
out
,
sys
.
stdout
)
self
.
_dump_lines
(
err
,
sys
.
stderr
)
with
contextlib
.
suppress
(
ValueError
):
ret
=
ExitCode
(
ret
)
return
RunResult
(
ret
,
out
,
err
,
timing
.
time
()
-
now
)
def
_dump_lines
(
self
,
lines
,
fp
):
try
:
for
line
in
lines
:
print
(
line
,
file
=
fp
)
except
UnicodeEncodeError
:
print
(
f
"couldn't print to
{
fp
}
because of encoding"
)
def
_getpytestargs
(
self
)
->
tuple
[
str
,
...
]:
return
sys
.
executable
,
"-mpytest"
[docs]
def
runpython
(
self
,
script
:
os
.
PathLike
[
str
])
->
RunResult
:
"""Run a python script using sys.executable as interpreter."""
return
self
.
run
(
sys
.
executable
,
script
)
[docs]
def
runpython_c
(
self
,
command
:
str
)
->
RunResult
:
"""Run ``python -c "command"``."""
return
self
.
run
(
sys
.
executable
,
"-c"
,
command
)
[docs]
def
runpytest_subprocess
(
self
,
*
args
:
str
|
os
.
PathLike
[
str
],
timeout
:
float
|
None
=
None
)
->
RunResult
:
"""Run pytest as a subprocess with given arguments.
Any plugins added to the :py:attr:`plugins` list will be added using the
``-p`` command line option.  Additionally ``--basetemp`` is used to put
any temporary files and directories in a numbered directory prefixed
with "runpytest-" to not conflict with the normal numbered pytest
location for temporary files and directories.
:param args:
The sequence of arguments to pass to the pytest subprocess.
:param timeout:
The period in seconds after which to timeout and raise
:py:class:`Pytester.TimeoutExpired`.
:returns:
The result.
"""
__tracebackhide__
=
True
p
=
make_numbered_dir
(
root
=
self
.
path
,
prefix
=
"runpytest-"
,
mode
=
0o700
)
args
=
(
f
"--basetemp=
{
p
}
"
,
*
args
)
plugins
=
[
x
for
x
in
self
.
plugins
if
isinstance
(
x
,
str
)]
if
plugins
:
args
=
(
"-p"
,
plugins
[
0
],
*
args
)
args
=
self
.
_getpytestargs
()
+
args
return
self
.
run
(
*
args
,
timeout
=
timeout
)
[docs]
def
spawn_pytest
(
self
,
string
:
str
,
expect_timeout
:
float
=
10.0
)
->
pexpect
.
spawn
:
"""Run pytest using pexpect.
This makes sure to use the right pytest and sets up the temporary
directory locations.
The pexpect child is returned.
"""
basetemp
=
self
.
path
/
"temp-pexpect"
basetemp
.
mkdir
(
mode
=
0o700
)
invoke
=
" "
.
join
(
map
(
str
,
self
.
_getpytestargs
()))
cmd
=
f
"
{
invoke
}
--basetemp=
{
basetemp
}
{
string
}
"
return
self
.
spawn
(
cmd
,
expect_timeout
=
expect_timeout
)
[docs]
def
spawn
(
self
,
cmd
:
str
,
expect_timeout
:
float
=
10.0
)
->
pexpect
.
spawn
:
"""Run a command using pexpect.
The pexpect child is returned.
"""
pexpect
=
importorskip
(
"pexpect"
,
"3.0"
)
if
hasattr
(
sys
,
"pypy_version_info"
)
and
"64"
in
platform
.
machine
():
skip
(
"pypy-64 bit not supported"
)
if
not
hasattr
(
pexpect
,
"spawn"
):
skip
(
"pexpect.spawn not available"
)
logfile
=
self
.
path
.
joinpath
(
"spawn.out"
)
.
open
(
"wb"
)
child
=
pexpect
.
spawn
(
cmd
,
logfile
=
logfile
,
timeout
=
expect_timeout
)
self
.
_request
.
addfinalizer
(
logfile
.
close
)
return
child
class
LineComp
:
def
__init__
(
self
)
->
None
:
self
.
stringio
=
StringIO
()
""":class:`python:io.StringIO()` instance used for input."""
def
assert_contains_lines
(
self
,
lines2
:
Sequence
[
str
])
->
None
:
"""Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.
Lines are matched using :func:`LineMatcher.fnmatch_lines <pytest.LineMatcher.fnmatch_lines>`.
"""
__tracebackhide__
=
True
val
=
self
.
stringio
.
getvalue
()
self
.
stringio
.
truncate
(
0
)
self
.
stringio
.
seek
(
0
)
lines1
=
val
.
split
(
"
\n
"
)
LineMatcher
(
lines1
)
.
fnmatch_lines
(
lines2
)
[docs]
class
LineMatcher
:
"""Flexible matching of text.
This is a convenience class to test large texts like the output of
commands.
The constructor takes a list of lines without their trailing newlines, i.e.
``text.splitlines()``.
"""
def
__init__
(
self
,
lines
:
list
[
str
])
->
None
:
self
.
lines
=
lines
self
.
_log_output
:
list
[
str
]
=
[]
[docs]
def
__str__
(
self
)
->
str
:
"""Return the entire original text.
.. versionadded:: 6.2
You can use :meth:`str` in older versions.
"""
return
"
\n
"
.
join
(
self
.
lines
)
def
_getlines
(
self
,
lines2
:
str
|
Sequence
[
str
]
|
Source
)
->
Sequence
[
str
]:
if
isinstance
(
lines2
,
str
):
lines2
=
Source
(
lines2
)
if
isinstance
(
lines2
,
Source
):
lines2
=
lines2
.
strip
()
.
lines
return
lines2
[docs]
def
fnmatch_lines_random
(
self
,
lines2
:
Sequence
[
str
])
->
None
:
"""Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`)."""
__tracebackhide__
=
True
self
.
_match_lines_random
(
lines2
,
fnmatch
)
[docs]
def
re_match_lines_random
(
self
,
lines2
:
Sequence
[
str
])
->
None
:
"""Check lines exist in the output in any order (using :func:`python:re.match`)."""
__tracebackhide__
=
True
self
.
_match_lines_random
(
lines2
,
lambda
name
,
pat
:
bool
(
re
.
match
(
pat
,
name
)))
def
_match_lines_random
(
self
,
lines2
:
Sequence
[
str
],
match_func
:
Callable
[[
str
,
str
],
bool
]
)
->
None
:
__tracebackhide__
=
True
lines2
=
self
.
_getlines
(
lines2
)
for
line
in
lines2
:
for
x
in
self
.
lines
:
if
line
==
x
or
match_func
(
x
,
line
):
self
.
_log
(
"matched: "
,
repr
(
line
))
break
else
:
msg
=
f
"line
{
line
!r}
not found in output"
self
.
_log
(
msg
)
self
.
_fail
(
msg
)
[docs]
def
get_lines_after
(
self
,
fnline
:
str
)
->
Sequence
[
str
]:
"""Return all lines following the given line in the text.
The given line can contain glob wildcards.
"""
for
i
,
line
in
enumerate
(
self
.
lines
):
if
fnline
==
line
or
fnmatch
(
line
,
fnline
):
return
self
.
lines
[
i
+
1
:]
raise
ValueError
(
f
"line
{
fnline
!r}
not found in output"
)
def
_log
(
self
,
*
args
)
->
None
:
self
.
_log_output
.
append
(
" "
.
join
(
str
(
x
)
for
x
in
args
))
@property
def
_log_text
(
self
)
->
str
:
return
"
\n
"
.
join
(
self
.
_log_output
)
[docs]
def
fnmatch_lines
(
self
,
lines2
:
Sequence
[
str
],
*
,
consecutive
:
bool
=
False
)
->
None
:
"""Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).
The argument is a list of lines which have to match and can use glob
wildcards.  If they do not match a pytest.fail() is called.  The
matches and non-matches are also shown as part of the error message.
:param lines2: String patterns to match.
:param consecutive: Match lines consecutively?
"""
__tracebackhide__
=
True
self
.
_match_lines
(
lines2
,
fnmatch
,
"fnmatch"
,
consecutive
=
consecutive
)
[docs]
def
re_match_lines
(
self
,
lines2
:
Sequence
[
str
],
*
,
consecutive
:
bool
=
False
)
->
None
:
"""Check lines exist in the output (using :func:`python:re.match`).
The argument is a list of lines which have to match using ``re.match``.
If they do not match a pytest.fail() is called.
The matches and non-matches are also shown as part of the error message.
:param lines2: string patterns to match.
:param consecutive: match lines consecutively?
"""
__tracebackhide__
=
True
self
.
_match_lines
(
lines2
,
lambda
name
,
pat
:
bool
(
re
.
match
(
pat
,
name
)),
"re.match"
,
consecutive
=
consecutive
,
)
def
_match_lines
(
self
,
lines2
:
Sequence
[
str
],
match_func
:
Callable
[[
str
,
str
],
bool
],
match_nickname
:
str
,
*
,
consecutive
:
bool
=
False
,
)
->
None
:
"""Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.
:param Sequence[str] lines2:
List of string patterns to match. The actual format depends on
``match_func``.
:param match_func:
A callable ``match_func(line, pattern)`` where line is the
captured line from stdout/stderr and pattern is the matching
pattern.
:param str match_nickname:
The nickname for the match function that will be logged to stdout
when a match occurs.
:param consecutive:
Match lines consecutively?
"""
if
not
isinstance
(
lines2
,
collections
.
abc
.
Sequence
):
raise
TypeError
(
f
"invalid type for lines2:
{
type
(
lines2
)
.
__name__
}
"
)
lines2
=
self
.
_getlines
(
lines2
)
lines1
=
self
.
lines
[:]
extralines
=
[]
__tracebackhide__
=
True
wnick
=
len
(
match_nickname
)
+
1
started
=
False
for
line
in
lines2
:
nomatchprinted
=
False
while
lines1
:
nextline
=
lines1
.
pop
(
0
)
if
line
==
nextline
:
self
.
_log
(
"exact match:"
,
repr
(
line
))
started
=
True
break
elif
match_func
(
nextline
,
line
):
self
.
_log
(
f
"
{
match_nickname
}
:"
,
repr
(
line
))
self
.
_log
(
"{:>
{width}
}"
.
format
(
"with:"
,
width
=
wnick
),
repr
(
nextline
)
)
started
=
True
break
else
:
if
consecutive
and
started
:
msg
=
f
"no consecutive match:
{
line
!r}
"
self
.
_log
(
msg
)
self
.
_log
(
"{:>
{width}
}"
.
format
(
"with:"
,
width
=
wnick
),
repr
(
nextline
)
)
self
.
_fail
(
msg
)
if
not
nomatchprinted
:
self
.
_log
(
"{:>
{width}
}"
.
format
(
"nomatch:"
,
width
=
wnick
),
repr
(
line
)
)
nomatchprinted
=
True
self
.
_log
(
"{:>
{width}
}"
.
format
(
"and:"
,
width
=
wnick
),
repr
(
nextline
))
extralines
.
append
(
nextline
)
else
:
msg
=
f
"remains unmatched:
{
line
!r}
"
self
.
_log
(
msg
)
self
.
_fail
(
msg
)
self
.
_log_output
=
[]
[docs]
def
no_fnmatch_line
(
self
,
pat
:
str
)
->
None
:
"""Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.
:param str pat: The pattern to match lines.
"""
__tracebackhide__
=
True
self
.
_no_match_line
(
pat
,
fnmatch
,
"fnmatch"
)
[docs]
def
no_re_match_line
(
self
,
pat
:
str
)
->
None
:
"""Ensure captured lines do not match the given pattern, using ``re.match``.
:param str pat: The regular expression to match lines.
"""
__tracebackhide__
=
True
self
.
_no_match_line
(
pat
,
lambda
name
,
pat
:
bool
(
re
.
match
(
pat
,
name
)),
"re.match"
)
def
_no_match_line
(
self
,
pat
:
str
,
match_func
:
Callable
[[
str
,
str
],
bool
],
match_nickname
:
str
)
->
None
:
"""Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``.
:param str pat: The pattern to match lines.
"""
__tracebackhide__
=
True
nomatch_printed
=
False
wnick
=
len
(
match_nickname
)
+
1
for
line
in
self
.
lines
:
if
match_func
(
line
,
pat
):
msg
=
f
"
{
match_nickname
}
:
{
pat
!r}
"
self
.
_log
(
msg
)
self
.
_log
(
"{:>
{width}
}"
.
format
(
"with:"
,
width
=
wnick
),
repr
(
line
))
self
.
_fail
(
msg
)
else
:
if
not
nomatch_printed
:
self
.
_log
(
"{:>
{width}
}"
.
format
(
"nomatch:"
,
width
=
wnick
),
repr
(
pat
))
nomatch_printed
=
True
self
.
_log
(
"{:>
{width}
}"
.
format
(
"and:"
,
width
=
wnick
),
repr
(
line
))
self
.
_log_output
=
[]
def
_fail
(
self
,
msg
:
str
)
->
None
:
__tracebackhide__
=
True
log_text
=
self
.
_log_text
self
.
_log_output
=
[]
fail
(
log_text
)
[docs]
def
str
(
self
)
->
str
:
"""Return the entire original text."""
return
str
(
self
)

```


---


# _pytest.config - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/config.html


# Source code for _pytest.config

```

# mypy: allow-untyped-defs
"""Command line options, ini-file and conftest.py processing."""
from
__future__
import
annotations
import
argparse
import
collections.abc
import
copy
import
dataclasses
import
enum
from
functools
import
lru_cache
import
glob
import
importlib.metadata
import
inspect
import
os
import
pathlib
import
re
import
shlex
import
sys
from
textwrap
import
dedent
import
types
from
types
import
FunctionType
from
typing
import
Any
from
typing
import
Callable
from
typing
import
cast
from
typing
import
Final
from
typing
import
final
from
typing
import
Generator
from
typing
import
IO
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Sequence
from
typing
import
TextIO
from
typing
import
Type
from
typing
import
TYPE_CHECKING
import
warnings
import
pluggy
from
pluggy
import
HookimplMarker
from
pluggy
import
HookimplOpts
from
pluggy
import
HookspecMarker
from
pluggy
import
HookspecOpts
from
pluggy
import
PluginManager
from
.compat
import
PathAwareHookProxy
from
.exceptions
import
PrintHelp
as
PrintHelp
from
.exceptions
import
UsageError
as
UsageError
from
.findpaths
import
determine_setup
from
_pytest
import
__version__
import
_pytest._code
from
_pytest._code
import
ExceptionInfo
from
_pytest._code
import
filter_traceback
from
_pytest._code.code
import
TracebackStyle
from
_pytest._io
import
TerminalWriter
from
_pytest.config.argparsing
import
Argument
from
_pytest.config.argparsing
import
Parser
import
_pytest.deprecated
import
_pytest.hookspec
from
_pytest.outcomes
import
fail
from
_pytest.outcomes
import
Skipped
from
_pytest.pathlib
import
absolutepath
from
_pytest.pathlib
import
bestrelpath
from
_pytest.pathlib
import
import_path
from
_pytest.pathlib
import
ImportMode
from
_pytest.pathlib
import
resolve_package_path
from
_pytest.pathlib
import
safe_exists
from
_pytest.stash
import
Stash
from
_pytest.warning_types
import
PytestConfigWarning
from
_pytest.warning_types
import
warn_explicit_for
if
TYPE_CHECKING
:
from
_pytest.cacheprovider
import
Cache
from
_pytest.terminal
import
TerminalReporter
_PluggyPlugin
=
object
"""A type to represent plugin objects.
Plugins can be any namespace, so we can't narrow it down much, but we use an
alias to make the intent clear.
Ideally this type would be provided by pluggy itself.
"""
hookimpl
=
HookimplMarker
(
"pytest"
)
hookspec
=
HookspecMarker
(
"pytest"
)
[docs]
@final
class
ExitCode
(
enum
.
IntEnum
):
"""Encodes the valid exit codes by pytest.
Currently users and plugins may supply other exit codes as well.
.. versionadded:: 5.0
"""
#: Tests passed.
OK
=
0
#: Tests failed.
TESTS_FAILED
=
1
#: pytest was interrupted.
INTERRUPTED
=
2
#: An internal error got in the way.
INTERNAL_ERROR
=
3
#: pytest was misused.
USAGE_ERROR
=
4
#: pytest couldn't find tests.
NO_TESTS_COLLECTED
=
5
class
ConftestImportFailure
(
Exception
):
def
__init__
(
self
,
path
:
pathlib
.
Path
,
*
,
cause
:
Exception
,
)
->
None
:
self
.
path
=
path
self
.
cause
=
cause
def
__str__
(
self
)
->
str
:
return
f
"
{
type
(
self
.
cause
)
.
__name__
}
:
{
self
.
cause
}
(from
{
self
.
path
}
)"
def
filter_traceback_for_conftest_import_failure
(
entry
:
_pytest
.
_code
.
TracebackEntry
,
)
->
bool
:
"""Filter tracebacks entries which point to pytest internals or importlib.
Make a special case for importlib because we use it to import test modules and conftest files
in _pytest.pathlib.import_path.
"""
return
filter_traceback
(
entry
)
and
"importlib"
not
in
str
(
entry
.
path
)
.
split
(
os
.
sep
)
[docs]
def
main
(
args
:
list
[
str
]
|
os
.
PathLike
[
str
]
|
None
=
None
,
plugins
:
Sequence
[
str
|
_PluggyPlugin
]
|
None
=
None
,
)
->
int
|
ExitCode
:
"""Perform an in-process test run.
:param args:
List of command line arguments. If `None` or not given, defaults to reading
arguments directly from the process command line (:data:`sys.argv`).
:param plugins: List of plugin objects to be auto-registered during initialization.
:returns: An exit code.
"""
old_pytest_version
=
os
.
environ
.
get
(
"PYTEST_VERSION"
)
try
:
os
.
environ
[
"PYTEST_VERSION"
]
=
__version__
try
:
config
=
_prepareconfig
(
args
,
plugins
)
except
ConftestImportFailure
as
e
:
exc_info
=
ExceptionInfo
.
from_exception
(
e
.
cause
)
tw
=
TerminalWriter
(
sys
.
stderr
)
tw
.
line
(
f
"ImportError while loading conftest '
{
e
.
path
}
'."
,
red
=
True
)
exc_info
.
traceback
=
exc_info
.
traceback
.
filter
(
filter_traceback_for_conftest_import_failure
)
exc_repr
=
(
exc_info
.
getrepr
(
style
=
"short"
,
chain
=
False
)
if
exc_info
.
traceback
else
exc_info
.
exconly
()
)
formatted_tb
=
str
(
exc_repr
)
for
line
in
formatted_tb
.
splitlines
():
tw
.
line
(
line
.
rstrip
(),
red
=
True
)
return
ExitCode
.
USAGE_ERROR
else
:
try
:
ret
:
ExitCode
|
int
=
config
.
hook
.
pytest_cmdline_main
(
config
=
config
)
try
:
return
ExitCode
(
ret
)
except
ValueError
:
return
ret
finally
:
config
.
_ensure_unconfigure
()
except
UsageError
as
e
:
tw
=
TerminalWriter
(
sys
.
stderr
)
for
msg
in
e
.
args
:
tw
.
line
(
f
"ERROR:
{
msg
}
\n
"
,
red
=
True
)
return
ExitCode
.
USAGE_ERROR
finally
:
if
old_pytest_version
is
None
:
os
.
environ
.
pop
(
"PYTEST_VERSION"
,
None
)
else
:
os
.
environ
[
"PYTEST_VERSION"
]
=
old_pytest_version
def
console_main
()
->
int
:
"""The CLI entry point of pytest.
This function is not meant for programmable use; use `main()` instead.
"""
# https://docs.python.org/3/library/signal.html#note-on-sigpipe
try
:
code
=
main
()
sys
.
stdout
.
flush
()
return
code
except
BrokenPipeError
:
# Python flushes standard streams on exit; redirect remaining output
# to devnull to avoid another BrokenPipeError at shutdown
devnull
=
os
.
open
(
os
.
devnull
,
os
.
O_WRONLY
)
os
.
dup2
(
devnull
,
sys
.
stdout
.
fileno
())
return
1
# Python exits with error code 1 on EPIPE
class
cmdline
:
# compatibility namespace
main
=
staticmethod
(
main
)
def
filename_arg
(
path
:
str
,
optname
:
str
)
->
str
:
"""Argparse type validator for filename arguments.
:path: Path of filename.
:optname: Name of the option.
"""
if
os
.
path
.
isdir
(
path
):
raise
UsageError
(
f
"
{
optname
}
must be a filename, given:
{
path
}
"
)
return
path
def
directory_arg
(
path
:
str
,
optname
:
str
)
->
str
:
"""Argparse type validator for directory arguments.
:path: Path of directory.
:optname: Name of the option.
"""
if
not
os
.
path
.
isdir
(
path
):
raise
UsageError
(
f
"
{
optname
}
must be a directory, given:
{
path
}
"
)
return
path
# Plugins that cannot be disabled via "-p no:X" currently.
essential_plugins
=
(
"mark"
,
"main"
,
"runner"
,
"fixtures"
,
"helpconfig"
,
# Provides -p.
)
default_plugins
=
(
*
essential_plugins
,
"python"
,
"terminal"
,
"debugging"
,
"unittest"
,
"capture"
,
"skipping"
,
"legacypath"
,
"tmpdir"
,
"monkeypatch"
,
"recwarn"
,
"pastebin"
,
"assertion"
,
"junitxml"
,
"doctest"
,
"cacheprovider"
,
"freeze_support"
,
"setuponly"
,
"setupplan"
,
"stepwise"
,
"warnings"
,
"logging"
,
"reports"
,
"python_path"
,
"unraisableexception"
,
"threadexception"
,
"faulthandler"
,
)
builtin_plugins
=
set
(
default_plugins
)
builtin_plugins
.
add
(
"pytester"
)
builtin_plugins
.
add
(
"pytester_assertions"
)
def
get_config
(
args
:
list
[
str
]
|
None
=
None
,
plugins
:
Sequence
[
str
|
_PluggyPlugin
]
|
None
=
None
,
)
->
Config
:
# subsequent calls to main will create a fresh instance
pluginmanager
=
PytestPluginManager
()
config
=
Config
(
pluginmanager
,
invocation_params
=
Config
.
InvocationParams
(
args
=
args
or
(),
plugins
=
plugins
,
dir
=
pathlib
.
Path
.
cwd
(),
),
)
if
args
is
not
None
:
# Handle any "-p no:plugin" args.
pluginmanager
.
consider_preparse
(
args
,
exclude_only
=
True
)
for
spec
in
default_plugins
:
pluginmanager
.
import_plugin
(
spec
)
return
config
def
get_plugin_manager
()
->
PytestPluginManager
:
"""Obtain a new instance of the
:py:class:`pytest.PytestPluginManager`, with default plugins
already loaded.
This function can be used by integration with other tools, like hooking
into pytest to run tests into an IDE.
"""
return
get_config
()
.
pluginmanager
def
_prepareconfig
(
args
:
list
[
str
]
|
os
.
PathLike
[
str
]
|
None
=
None
,
plugins
:
Sequence
[
str
|
_PluggyPlugin
]
|
None
=
None
,
)
->
Config
:
if
args
is
None
:
args
=
sys
.
argv
[
1
:]
elif
isinstance
(
args
,
os
.
PathLike
):
args
=
[
os
.
fspath
(
args
)]
elif
not
isinstance
(
args
,
list
):
msg
=
(
# type:ignore[unreachable]
"`args` parameter expected to be a list of strings, got:
{!r}
(type:
{}
)"
)
raise
TypeError
(
msg
.
format
(
args
,
type
(
args
)))
config
=
get_config
(
args
,
plugins
)
pluginmanager
=
config
.
pluginmanager
try
:
if
plugins
:
for
plugin
in
plugins
:
if
isinstance
(
plugin
,
str
):
pluginmanager
.
consider_pluginarg
(
plugin
)
else
:
pluginmanager
.
register
(
plugin
)
config
=
pluginmanager
.
hook
.
pytest_cmdline_parse
(
pluginmanager
=
pluginmanager
,
args
=
args
)
return
config
except
BaseException
:
config
.
_ensure_unconfigure
()
raise
def
_get_directory
(
path
:
pathlib
.
Path
)
->
pathlib
.
Path
:
"""Get the directory of a path - itself if already a directory."""
if
path
.
is_file
():
return
path
.
parent
else
:
return
path
def
_get_legacy_hook_marks
(
method
:
Any
,
hook_type
:
str
,
opt_names
:
tuple
[
str
,
...
],
)
->
dict
[
str
,
bool
]:
if
TYPE_CHECKING
:
# abuse typeguard from importlib to avoid massive method type union that's lacking an alias
assert
inspect
.
isroutine
(
method
)
known_marks
:
set
[
str
]
=
{
m
.
name
for
m
in
getattr
(
method
,
"pytestmark"
,
[])}
must_warn
:
list
[
str
]
=
[]
opts
:
dict
[
str
,
bool
]
=
{}
for
opt_name
in
opt_names
:
opt_attr
=
getattr
(
method
,
opt_name
,
AttributeError
)
if
opt_attr
is
not
AttributeError
:
must_warn
.
append
(
f
"
{
opt_name
}
=
{
opt_attr
}
"
)
opts
[
opt_name
]
=
True
elif
opt_name
in
known_marks
:
must_warn
.
append
(
f
"
{
opt_name
}
=True"
)
opts
[
opt_name
]
=
True
else
:
opts
[
opt_name
]
=
False
if
must_warn
:
hook_opts
=
", "
.
join
(
must_warn
)
message
=
_pytest
.
deprecated
.
HOOK_LEGACY_MARKING
.
format
(
type
=
hook_type
,
fullname
=
method
.
__qualname__
,
hook_opts
=
hook_opts
,
)
warn_explicit_for
(
cast
(
FunctionType
,
method
),
message
)
return
opts
[docs]
@final
class
PytestPluginManager
(
PluginManager
):
"""A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with
additional pytest-specific functionality:
* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and
``pytest_plugins`` global variables found in plugins being loaded.
* ``conftest.py`` loading during start-up.
"""
def
__init__
(
self
)
->
None
:
import
_pytest.assertion
super
()
.
__init__
(
"pytest"
)
# -- State related to local conftest plugins.
# All loaded conftest modules.
self
.
_conftest_plugins
:
set
[
types
.
ModuleType
]
=
set
()
# All conftest modules applicable for a directory.
# This includes the directory's own conftest modules as well
# as those of its parent directories.
self
.
_dirpath2confmods
:
dict
[
pathlib
.
Path
,
list
[
types
.
ModuleType
]]
=
{}
# Cutoff directory above which conftests are no longer discovered.
self
.
_confcutdir
:
pathlib
.
Path
|
None
=
None
# If set, conftest loading is skipped.
self
.
_noconftest
=
False
# _getconftestmodules()'s call to _get_directory() causes a stat
# storm when it's called potentially thousands of times in a test
# session (#9478), often with the same path, so cache it.
self
.
_get_directory
=
lru_cache
(
256
)(
_get_directory
)
# plugins that were explicitly skipped with pytest.skip
# list of (module name, skip reason)
# previously we would issue a warning when a plugin was skipped, but
# since we refactored warnings as first citizens of Config, they are
# just stored here to be used later.
self
.
skipped_plugins
:
list
[
tuple
[
str
,
str
]]
=
[]
self
.
add_hookspecs
(
_pytest
.
hookspec
)
self
.
register
(
self
)
if
os
.
environ
.
get
(
"PYTEST_DEBUG"
):
err
:
IO
[
str
]
=
sys
.
stderr
encoding
:
str
=
getattr
(
err
,
"encoding"
,
"utf8"
)
try
:
err
=
open
(
os
.
dup
(
err
.
fileno
()),
mode
=
err
.
mode
,
buffering
=
1
,
encoding
=
encoding
,
)
except
Exception
:
pass
self
.
trace
.
root
.
setwriter
(
err
.
write
)
self
.
enable_tracing
()
# Config._consider_importhook will set a real object if required.
self
.
rewrite_hook
=
_pytest
.
assertion
.
DummyRewriteHook
()
# Used to know when we are importing conftests after the pytest_configure stage.
self
.
_configured
=
False
def
parse_hookimpl_opts
(
self
,
plugin
:
_PluggyPlugin
,
name
:
str
)
->
HookimplOpts
|
None
:
""":meta private:"""
# pytest hooks are always prefixed with "pytest_",
# so we avoid accessing possibly non-readable attributes
# (see issue #1073).
if
not
name
.
startswith
(
"pytest_"
):
return
None
# Ignore names which cannot be hooks.
if
name
==
"pytest_plugins"
:
return
None
opts
=
super
()
.
parse_hookimpl_opts
(
plugin
,
name
)
if
opts
is
not
None
:
return
opts
method
=
getattr
(
plugin
,
name
)
# Consider only actual functions for hooks (#3775).
if
not
inspect
.
isroutine
(
method
):
return
None
# Collect unmarked hooks as long as they have the `pytest_' prefix.
return
_get_legacy_hook_marks
(
# type: ignore[return-value]
method
,
"impl"
,
(
"tryfirst"
,
"trylast"
,
"optionalhook"
,
"hookwrapper"
)
)
def
parse_hookspec_opts
(
self
,
module_or_class
,
name
:
str
)
->
HookspecOpts
|
None
:
""":meta private:"""
opts
=
super
()
.
parse_hookspec_opts
(
module_or_class
,
name
)
if
opts
is
None
:
method
=
getattr
(
module_or_class
,
name
)
if
name
.
startswith
(
"pytest_"
):
opts
=
_get_legacy_hook_marks
(
# type: ignore[assignment]
method
,
"spec"
,
(
"firstresult"
,
"historic"
),
)
return
opts
[docs]
def
register
(
self
,
plugin
:
_PluggyPlugin
,
name
:
str
|
None
=
None
)
->
str
|
None
:
if
name
in
_pytest
.
deprecated
.
DEPRECATED_EXTERNAL_PLUGINS
:
warnings
.
warn
(
PytestConfigWarning
(
"
{}
plugin has been merged into the core, "
"please remove it from your requirements."
.
format
(
name
.
replace
(
"_"
,
"-"
)
)
)
)
return
None
plugin_name
=
super
()
.
register
(
plugin
,
name
)
if
plugin_name
is
not
None
:
self
.
hook
.
pytest_plugin_registered
.
call_historic
(
kwargs
=
dict
(
plugin
=
plugin
,
plugin_name
=
plugin_name
,
manager
=
self
,
)
)
if
isinstance
(
plugin
,
types
.
ModuleType
):
self
.
consider_module
(
plugin
)
return
plugin_name
[docs]
def
getplugin
(
self
,
name
:
str
):
# Support deprecated naming because plugins (xdist e.g.) use it.
plugin
:
_PluggyPlugin
|
None
=
self
.
get_plugin
(
name
)
return
plugin
[docs]
def
hasplugin
(
self
,
name
:
str
)
->
bool
:
"""Return whether a plugin with the given name is registered."""
return
bool
(
self
.
get_plugin
(
name
))
def
pytest_configure
(
self
,
config
:
Config
)
->
None
:
""":meta private:"""
# XXX now that the pluginmanager exposes hookimpl(tryfirst...)
# we should remove tryfirst/trylast as markers.
config
.
addinivalue_line
(
"markers"
,
"tryfirst: mark a hook implementation function such that the "
"plugin machinery will try to call it first/as early as possible. "
"DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead."
,
)
config
.
addinivalue_line
(
"markers"
,
"trylast: mark a hook implementation function such that the "
"plugin machinery will try to call it last/as late as possible. "
"DEPRECATED, use @pytest.hookimpl(trylast=True) instead."
,
)
self
.
_configured
=
True
#
# Internal API for local conftest plugin handling.
#
def
_set_initial_conftests
(
self
,
args
:
Sequence
[
str
|
pathlib
.
Path
],
pyargs
:
bool
,
noconftest
:
bool
,
rootpath
:
pathlib
.
Path
,
confcutdir
:
pathlib
.
Path
|
None
,
invocation_dir
:
pathlib
.
Path
,
importmode
:
ImportMode
|
str
,
*
,
consider_namespace_packages
:
bool
,
)
->
None
:
"""Load initial conftest files given a preparsed "namespace".
As conftest files may add their own command line options which have
arguments ('--my-opt somepath') we might get some false positives.
All builtin and 3rd party plugins will have been loaded, however, so
common options will not confuse our logic here.
"""
self
.
_confcutdir
=
(
absolutepath
(
invocation_dir
/
confcutdir
)
if
confcutdir
else
None
)
self
.
_noconftest
=
noconftest
self
.
_using_pyargs
=
pyargs
foundanchor
=
False
for
initial_path
in
args
:
path
=
str
(
initial_path
)
# remove node-id syntax
i
=
path
.
find
(
"::"
)
if
i
!=
-
1
:
path
=
path
[:
i
]
anchor
=
absolutepath
(
invocation_dir
/
path
)
# Ensure we do not break if what appears to be an anchor
# is in fact a very long option (#10169, #11394).
if
safe_exists
(
anchor
):
self
.
_try_load_conftest
(
anchor
,
importmode
,
rootpath
,
consider_namespace_packages
=
consider_namespace_packages
,
)
foundanchor
=
True
if
not
foundanchor
:
self
.
_try_load_conftest
(
invocation_dir
,
importmode
,
rootpath
,
consider_namespace_packages
=
consider_namespace_packages
,
)
def
_is_in_confcutdir
(
self
,
path
:
pathlib
.
Path
)
->
bool
:
"""Whether to consider the given path to load conftests from."""
if
self
.
_confcutdir
is
None
:
return
True
# The semantics here are literally:
#   Do not load a conftest if it is found upwards from confcut dir.
# But this is *not* the same as:
#   Load only conftests from confcutdir or below.
# At first glance they might seem the same thing, however we do support use cases where
# we want to load conftests that are not found in confcutdir or below, but are found
# in completely different directory hierarchies like packages installed
# in out-of-source trees.
# (see #9767 for a regression where the logic was inverted).
return
path
not
in
self
.
_confcutdir
.
parents
def
_try_load_conftest
(
self
,
anchor
:
pathlib
.
Path
,
importmode
:
str
|
ImportMode
,
rootpath
:
pathlib
.
Path
,
*
,
consider_namespace_packages
:
bool
,
)
->
None
:
self
.
_loadconftestmodules
(
anchor
,
importmode
,
rootpath
,
consider_namespace_packages
=
consider_namespace_packages
,
)
# let's also consider test* subdirs
if
anchor
.
is_dir
():
for
x
in
anchor
.
glob
(
"test*"
):
if
x
.
is_dir
():
self
.
_loadconftestmodules
(
x
,
importmode
,
rootpath
,
consider_namespace_packages
=
consider_namespace_packages
,
)
def
_loadconftestmodules
(
self
,
path
:
pathlib
.
Path
,
importmode
:
str
|
ImportMode
,
rootpath
:
pathlib
.
Path
,
*
,
consider_namespace_packages
:
bool
,
)
->
None
:
if
self
.
_noconftest
:
return
directory
=
self
.
_get_directory
(
path
)
# Optimization: avoid repeated searches in the same directory.
# Assumes always called with same importmode and rootpath.
if
directory
in
self
.
_dirpath2confmods
:
return
clist
=
[]
for
parent
in
reversed
((
directory
,
*
directory
.
parents
)):
if
self
.
_is_in_confcutdir
(
parent
):
conftestpath
=
parent
/
"conftest.py"
if
conftestpath
.
is_file
():
mod
=
self
.
_importconftest
(
conftestpath
,
importmode
,
rootpath
,
consider_namespace_packages
=
consider_namespace_packages
,
)
clist
.
append
(
mod
)
self
.
_dirpath2confmods
[
directory
]
=
clist
def
_getconftestmodules
(
self
,
path
:
pathlib
.
Path
)
->
Sequence
[
types
.
ModuleType
]:
directory
=
self
.
_get_directory
(
path
)
return
self
.
_dirpath2confmods
.
get
(
directory
,
())
def
_rget_with_confmod
(
self
,
name
:
str
,
path
:
pathlib
.
Path
,
)
->
tuple
[
types
.
ModuleType
,
Any
]:
modules
=
self
.
_getconftestmodules
(
path
)
for
mod
in
reversed
(
modules
):
try
:
return
mod
,
getattr
(
mod
,
name
)
except
AttributeError
:
continue
raise
KeyError
(
name
)
def
_importconftest
(
self
,
conftestpath
:
pathlib
.
Path
,
importmode
:
str
|
ImportMode
,
rootpath
:
pathlib
.
Path
,
*
,
consider_namespace_packages
:
bool
,
)
->
types
.
ModuleType
:
conftestpath_plugin_name
=
str
(
conftestpath
)
existing
=
self
.
get_plugin
(
conftestpath_plugin_name
)
if
existing
is
not
None
:
return
cast
(
types
.
ModuleType
,
existing
)
# conftest.py files there are not in a Python package all have module
# name "conftest", and thus conflict with each other. Clear the existing
# before loading the new one, otherwise the existing one will be
# returned from the module cache.
pkgpath
=
resolve_package_path
(
conftestpath
)
if
pkgpath
is
None
:
try
:
del
sys
.
modules
[
conftestpath
.
stem
]
except
KeyError
:
pass
try
:
mod
=
import_path
(
conftestpath
,
mode
=
importmode
,
root
=
rootpath
,
consider_namespace_packages
=
consider_namespace_packages
,
)
except
Exception
as
e
:
assert
e
.
__traceback__
is
not
None
raise
ConftestImportFailure
(
conftestpath
,
cause
=
e
)
from
e
self
.
_check_non_top_pytest_plugins
(
mod
,
conftestpath
)
self
.
_conftest_plugins
.
add
(
mod
)
dirpath
=
conftestpath
.
parent
if
dirpath
in
self
.
_dirpath2confmods
:
for
path
,
mods
in
self
.
_dirpath2confmods
.
items
():
if
dirpath
in
path
.
parents
or
path
==
dirpath
:
if
mod
in
mods
:
raise
AssertionError
(
f
"While trying to load conftest path
{
conftestpath
!s}
, "
f
"found that the module
{
mod
}
is already loaded with path
{
mod
.
__file__
}
. "
"This is not supposed to happen. Please report this issue to pytest."
)
mods
.
append
(
mod
)
self
.
trace
(
f
"loading conftestmodule
{
mod
!r}
"
)
self
.
consider_conftest
(
mod
,
registration_name
=
conftestpath_plugin_name
)
return
mod
def
_check_non_top_pytest_plugins
(
self
,
mod
:
types
.
ModuleType
,
conftestpath
:
pathlib
.
Path
,
)
->
None
:
if
(
hasattr
(
mod
,
"pytest_plugins"
)
and
self
.
_configured
and
not
self
.
_using_pyargs
):
msg
=
(
"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:
\n
"
"It affects the entire test suite instead of just below the conftest as expected.
\n
"
"
{}
\n
"
"Please move it to a top level conftest file at the rootdir:
\n
"
"
{}
\n
"
"For more information, visit:
\n
"
"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files"
)
fail
(
msg
.
format
(
conftestpath
,
self
.
_confcutdir
),
pytrace
=
False
)
#
# API for bootstrapping plugin loading
#
#
def
consider_preparse
(
self
,
args
:
Sequence
[
str
],
*
,
exclude_only
:
bool
=
False
)
->
None
:
""":meta private:"""
i
=
0
n
=
len
(
args
)
while
i
<
n
:
opt
=
args
[
i
]
i
+=
1
if
isinstance
(
opt
,
str
):
if
opt
==
"-p"
:
try
:
parg
=
args
[
i
]
except
IndexError
:
return
i
+=
1
elif
opt
.
startswith
(
"-p"
):
parg
=
opt
[
2
:]
else
:
continue
parg
=
parg
.
strip
()
if
exclude_only
and
not
parg
.
startswith
(
"no:"
):
continue
self
.
consider_pluginarg
(
parg
)
def
consider_pluginarg
(
self
,
arg
:
str
)
->
None
:
""":meta private:"""
if
arg
.
startswith
(
"no:"
):
name
=
arg
[
3
:]
if
name
in
essential_plugins
:
raise
UsageError
(
f
"plugin
{
name
}
cannot be disabled"
)
# PR #4304: remove stepwise if cacheprovider is blocked.
if
name
==
"cacheprovider"
:
self
.
set_blocked
(
"stepwise"
)
self
.
set_blocked
(
"pytest_stepwise"
)
self
.
set_blocked
(
name
)
if
not
name
.
startswith
(
"pytest_"
):
self
.
set_blocked
(
"pytest_"
+
name
)
else
:
name
=
arg
# Unblock the plugin.
self
.
unblock
(
name
)
if
not
name
.
startswith
(
"pytest_"
):
self
.
unblock
(
"pytest_"
+
name
)
self
.
import_plugin
(
arg
,
consider_entry_points
=
True
)
def
consider_conftest
(
self
,
conftestmodule
:
types
.
ModuleType
,
registration_name
:
str
)
->
None
:
""":meta private:"""
self
.
register
(
conftestmodule
,
name
=
registration_name
)
def
consider_env
(
self
)
->
None
:
""":meta private:"""
self
.
_import_plugin_specs
(
os
.
environ
.
get
(
"PYTEST_PLUGINS"
))
def
consider_module
(
self
,
mod
:
types
.
ModuleType
)
->
None
:
""":meta private:"""
self
.
_import_plugin_specs
(
getattr
(
mod
,
"pytest_plugins"
,
[]))
def
_import_plugin_specs
(
self
,
spec
:
None
|
types
.
ModuleType
|
str
|
Sequence
[
str
]
)
->
None
:
plugins
=
_get_plugin_specs_as_list
(
spec
)
for
import_spec
in
plugins
:
self
.
import_plugin
(
import_spec
)
[docs]
def
import_plugin
(
self
,
modname
:
str
,
consider_entry_points
:
bool
=
False
)
->
None
:
"""Import a plugin with ``modname``.
If ``consider_entry_points`` is True, entry point names are also
considered to find a plugin.
"""
# Most often modname refers to builtin modules, e.g. "pytester",
# "terminal" or "capture".  Those plugins are registered under their
# basename for historic purposes but must be imported with the
# _pytest prefix.
assert
isinstance
(
modname
,
str
),
f
"module name as text required, got
{
modname
!r}
"
if
self
.
is_blocked
(
modname
)
or
self
.
get_plugin
(
modname
)
is
not
None
:
return
importspec
=
"_pytest."
+
modname
if
modname
in
builtin_plugins
else
modname
self
.
rewrite_hook
.
mark_rewrite
(
importspec
)
if
consider_entry_points
:
loaded
=
self
.
load_setuptools_entrypoints
(
"pytest11"
,
name
=
modname
)
if
loaded
:
return
try
:
__import__
(
importspec
)
except
ImportError
as
e
:
raise
ImportError
(
f
'Error importing plugin "
{
modname
}
":
{
e
.
args
[
0
]
}
'
)
.
with_traceback
(
e
.
__traceback__
)
from
e
except
Skipped
as
e
:
self
.
skipped_plugins
.
append
((
modname
,
e
.
msg
or
""
))
else
:
mod
=
sys
.
modules
[
importspec
]
self
.
register
(
mod
,
modname
)
def
_get_plugin_specs_as_list
(
specs
:
None
|
types
.
ModuleType
|
str
|
Sequence
[
str
],
)
->
list
[
str
]:
"""Parse a plugins specification into a list of plugin names."""
# None means empty.
if
specs
is
None
:
return
[]
# Workaround for #3899 - a submodule which happens to be called "pytest_plugins".
if
isinstance
(
specs
,
types
.
ModuleType
):
return
[]
# Comma-separated list.
if
isinstance
(
specs
,
str
):
return
specs
.
split
(
","
)
if
specs
else
[]
# Direct specification.
if
isinstance
(
specs
,
collections
.
abc
.
Sequence
):
return
list
(
specs
)
raise
UsageError
(
f
"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got:
{
specs
!r}
"
)
class
Notset
:
def
__repr__
(
self
):
return
"<NOTSET>"
notset
=
Notset
()
def
_iter_rewritable_modules
(
package_files
:
Iterable
[
str
])
->
Iterator
[
str
]:
"""Given an iterable of file names in a source distribution, return the "names" that should
be marked for assertion rewrite.
For example the package "pytest_mock/__init__.py" should be added as "pytest_mock" in
the assertion rewrite mechanism.
This function has to deal with dist-info based distributions and egg based distributions
(which are still very much in use for "editable" installs).
Here are the file names as seen in a dist-info based distribution:
pytest_mock/__init__.py
pytest_mock/_version.py
pytest_mock/plugin.py
pytest_mock.egg-info/PKG-INFO
Here are the file names as seen in an egg based distribution:
src/pytest_mock/__init__.py
src/pytest_mock/_version.py
src/pytest_mock/plugin.py
src/pytest_mock.egg-info/PKG-INFO
LICENSE
setup.py
We have to take in account those two distribution flavors in order to determine which
names should be considered for assertion rewriting.
More information:
https://github.com/pytest-dev/pytest-mock/issues/167
"""
package_files
=
list
(
package_files
)
seen_some
=
False
for
fn
in
package_files
:
is_simple_module
=
"/"
not
in
fn
and
fn
.
endswith
(
".py"
)
is_package
=
fn
.
count
(
"/"
)
==
1
and
fn
.
endswith
(
"__init__.py"
)
if
is_simple_module
:
module_name
,
_
=
os
.
path
.
splitext
(
fn
)
# we ignore "setup.py" at the root of the distribution
# as well as editable installation finder modules made by setuptools
if
module_name
!=
"setup"
and
not
module_name
.
startswith
(
"__editable__"
):
seen_some
=
True
yield
module_name
elif
is_package
:
package_name
=
os
.
path
.
dirname
(
fn
)
seen_some
=
True
yield
package_name
if
not
seen_some
:
# At this point we did not find any packages or modules suitable for assertion
# rewriting, so we try again by stripping the first path component (to account for
# "src" based source trees for example).
# This approach lets us have the common case continue to be fast, as egg-distributions
# are rarer.
new_package_files
=
[]
for
fn
in
package_files
:
parts
=
fn
.
split
(
"/"
)
new_fn
=
"/"
.
join
(
parts
[
1
:])
if
new_fn
:
new_package_files
.
append
(
new_fn
)
if
new_package_files
:
yield from
_iter_rewritable_modules
(
new_package_files
)
[docs]
@final
class
Config
:
"""Access to configuration values, pluginmanager and plugin hooks.
:param PytestPluginManager pluginmanager:
A pytest PluginManager.
:param InvocationParams invocation_params:
Object containing parameters regarding the :func:`pytest.main`
invocation.
"""
[docs]
@final
@dataclasses
.
dataclass
(
frozen
=
True
)
class
InvocationParams
:
"""Holds parameters passed during :func:`pytest.main`.
The object attributes are read-only.
.. versionadded:: 5.1
.. note::
Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``
ini option are handled by pytest, not being included in the ``args`` attribute.
Plugins accessing ``InvocationParams`` must be aware of that.
"""
args
:
tuple
[
str
,
...
]
"""The command-line arguments as passed to :func:`pytest.main`."""
plugins
:
Sequence
[
str
|
_PluggyPlugin
]
|
None
"""Extra plugins, might be `None`."""
dir
:
pathlib
.
Path
"""The directory from which :func:`pytest.main` was invoked. :type: pathlib.Path"""
def
__init__
(
self
,
*
,
args
:
Iterable
[
str
],
plugins
:
Sequence
[
str
|
_PluggyPlugin
]
|
None
,
dir
:
pathlib
.
Path
,
)
->
None
:
object
.
__setattr__
(
self
,
"args"
,
tuple
(
args
))
object
.
__setattr__
(
self
,
"plugins"
,
plugins
)
object
.
__setattr__
(
self
,
"dir"
,
dir
)
[docs]
class
ArgsSource
(
enum
.
Enum
):
"""Indicates the source of the test arguments.
.. versionadded:: 7.2
"""
#: Command line arguments.
ARGS
=
enum
.
auto
()
#: Invocation directory.
INVOCATION_DIR
=
enum
.
auto
()
INCOVATION_DIR
=
INVOCATION_DIR
# backwards compatibility alias
#: 'testpaths' configuration value.
TESTPATHS
=
enum
.
auto
()
# Set by cacheprovider plugin.
cache
:
Cache
def
__init__
(
self
,
pluginmanager
:
PytestPluginManager
,
*
,
invocation_params
:
InvocationParams
|
None
=
None
,
)
->
None
:
from
.argparsing
import
FILE_OR_DIR
from
.argparsing
import
Parser
if
invocation_params
is
None
:
invocation_params
=
self
.
InvocationParams
(
args
=
(),
plugins
=
None
,
dir
=
pathlib
.
Path
.
cwd
()
)
self
.
option
=
argparse
.
Namespace
()
"""Access to command line option as attributes.
:type: argparse.Namespace
"""
self
.
invocation_params
=
invocation_params
"""The parameters with which pytest was invoked.
:type: InvocationParams
"""
_a
=
FILE_OR_DIR
self
.
_parser
=
Parser
(
usage
=
f
"%(prog)s [options] [
{
_a
}
] [
{
_a
}
] [...]"
,
processopt
=
self
.
_processopt
,
_ispytest
=
True
,
)
self
.
pluginmanager
=
pluginmanager
"""The plugin manager handles plugin registration and hook invocation.
:type: PytestPluginManager
"""
self
.
stash
=
Stash
()
"""A place where plugins can store information on the config for their
own use.
:type: Stash
"""
# Deprecated alias. Was never public. Can be removed in a few releases.
self
.
_store
=
self
.
stash
self
.
trace
=
self
.
pluginmanager
.
trace
.
root
.
get
(
"config"
)
self
.
hook
:
pluggy
.
HookRelay
=
PathAwareHookProxy
(
self
.
pluginmanager
.
hook
)
# type: ignore[assignment]
self
.
_inicache
:
dict
[
str
,
Any
]
=
{}
self
.
_override_ini
:
Sequence
[
str
]
=
()
self
.
_opt2dest
:
dict
[
str
,
str
]
=
{}
self
.
_cleanup
:
list
[
Callable
[[],
None
]]
=
[]
self
.
pluginmanager
.
register
(
self
,
"pytestconfig"
)
self
.
_configured
=
False
self
.
hook
.
pytest_addoption
.
call_historic
(
kwargs
=
dict
(
parser
=
self
.
_parser
,
pluginmanager
=
self
.
pluginmanager
)
)
self
.
args_source
=
Config
.
ArgsSource
.
ARGS
self
.
args
:
list
[
str
]
=
[]
@property
def
rootpath
(
self
)
->
pathlib
.
Path
:
"""The path to the :ref:`rootdir <rootdir>`.
:type: pathlib.Path
.. versionadded:: 6.1
"""
return
self
.
_rootpath
@property
def
inipath
(
self
)
->
pathlib
.
Path
|
None
:
"""The path to the :ref:`configfile <configfiles>`.
.. versionadded:: 6.1
"""
return
self
.
_inipath
[docs]
def
add_cleanup
(
self
,
func
:
Callable
[[],
None
])
->
None
:
"""Add a function to be called when the config object gets out of
use (usually coinciding with pytest_unconfigure)."""
self
.
_cleanup
.
append
(
func
)
def
_do_configure
(
self
)
->
None
:
assert
not
self
.
_configured
self
.
_configured
=
True
with
warnings
.
catch_warnings
():
warnings
.
simplefilter
(
"default"
)
self
.
hook
.
pytest_configure
.
call_historic
(
kwargs
=
dict
(
config
=
self
))
def
_ensure_unconfigure
(
self
)
->
None
:
if
self
.
_configured
:
self
.
_configured
=
False
self
.
hook
.
pytest_unconfigure
(
config
=
self
)
self
.
hook
.
pytest_configure
.
_call_history
=
[]
while
self
.
_cleanup
:
fin
=
self
.
_cleanup
.
pop
()
fin
()
def
get_terminal_writer
(
self
)
->
TerminalWriter
:
terminalreporter
:
TerminalReporter
|
None
=
self
.
pluginmanager
.
get_plugin
(
"terminalreporter"
)
assert
terminalreporter
is
not
None
return
terminalreporter
.
_tw
def
pytest_cmdline_parse
(
self
,
pluginmanager
:
PytestPluginManager
,
args
:
list
[
str
]
)
->
Config
:
try
:
self
.
parse
(
args
)
except
UsageError
:
# Handle --version and --help here in a minimal fashion.
# This gets done via helpconfig normally, but its
# pytest_cmdline_main is not called in case of errors.
if
getattr
(
self
.
option
,
"version"
,
False
)
or
"--version"
in
args
:
from
_pytest.helpconfig
import
showversion
showversion
(
self
)
elif
(
getattr
(
self
.
option
,
"help"
,
False
)
or
"--help"
in
args
or
"-h"
in
args
):
self
.
_parser
.
_getparser
()
.
print_help
()
sys
.
stdout
.
write
(
"
\n
NOTE: displaying only minimal help due to UsageError.
\n\n
"
)
raise
return
self
def
notify_exception
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
],
option
:
argparse
.
Namespace
|
None
=
None
,
)
->
None
:
if
option
and
getattr
(
option
,
"fulltrace"
,
False
):
style
:
TracebackStyle
=
"long"
else
:
style
=
"native"
excrepr
=
excinfo
.
getrepr
(
funcargs
=
True
,
showlocals
=
getattr
(
option
,
"showlocals"
,
False
),
style
=
style
)
res
=
self
.
hook
.
pytest_internalerror
(
excrepr
=
excrepr
,
excinfo
=
excinfo
)
if
not
any
(
res
):
for
line
in
str
(
excrepr
)
.
split
(
"
\n
"
):
sys
.
stderr
.
write
(
f
"INTERNALERROR>
{
line
}
\n
"
)
sys
.
stderr
.
flush
()
def
cwd_relative_nodeid
(
self
,
nodeid
:
str
)
->
str
:
# nodeid's are relative to the rootpath, compute relative to cwd.
if
self
.
invocation_params
.
dir
!=
self
.
rootpath
:
base_path_part
,
*
nodeid_part
=
nodeid
.
split
(
"::"
)
# Only process path part
fullpath
=
self
.
rootpath
/
base_path_part
relative_path
=
bestrelpath
(
self
.
invocation_params
.
dir
,
fullpath
)
nodeid
=
"::"
.
join
([
relative_path
,
*
nodeid_part
])
return
nodeid
[docs]
@classmethod
def
fromdictargs
(
cls
,
option_dict
,
args
)
->
Config
:
"""Constructor usable for subprocesses."""
config
=
get_config
(
args
)
config
.
option
.
__dict__
.
update
(
option_dict
)
config
.
parse
(
args
,
addopts
=
False
)
for
x
in
config
.
option
.
plugins
:
config
.
pluginmanager
.
consider_pluginarg
(
x
)
return
config
def
_processopt
(
self
,
opt
:
Argument
)
->
None
:
for
name
in
opt
.
_short_opts
+
opt
.
_long_opts
:
self
.
_opt2dest
[
name
]
=
opt
.
dest
if
hasattr
(
opt
,
"default"
):
if
not
hasattr
(
self
.
option
,
opt
.
dest
):
setattr
(
self
.
option
,
opt
.
dest
,
opt
.
default
)
@hookimpl
(
trylast
=
True
)
def
pytest_load_initial_conftests
(
self
,
early_config
:
Config
)
->
None
:
# We haven't fully parsed the command line arguments yet, so
# early_config.args it not set yet. But we need it for
# discovering the initial conftests. So "pre-run" the logic here.
# It will be done for real in `parse()`.
args
,
args_source
=
early_config
.
_decide_args
(
args
=
early_config
.
known_args_namespace
.
file_or_dir
,
pyargs
=
early_config
.
known_args_namespace
.
pyargs
,
testpaths
=
early_config
.
getini
(
"testpaths"
),
invocation_dir
=
early_config
.
invocation_params
.
dir
,
rootpath
=
early_config
.
rootpath
,
warn
=
False
,
)
self
.
pluginmanager
.
_set_initial_conftests
(
args
=
args
,
pyargs
=
early_config
.
known_args_namespace
.
pyargs
,
noconftest
=
early_config
.
known_args_namespace
.
noconftest
,
rootpath
=
early_config
.
rootpath
,
confcutdir
=
early_config
.
known_args_namespace
.
confcutdir
,
invocation_dir
=
early_config
.
invocation_params
.
dir
,
importmode
=
early_config
.
known_args_namespace
.
importmode
,
consider_namespace_packages
=
early_config
.
getini
(
"consider_namespace_packages"
),
)
def
_initini
(
self
,
args
:
Sequence
[
str
])
->
None
:
ns
,
unknown_args
=
self
.
_parser
.
parse_known_and_unknown_args
(
args
,
namespace
=
copy
.
copy
(
self
.
option
)
)
rootpath
,
inipath
,
inicfg
=
determine_setup
(
inifile
=
ns
.
inifilename
,
args
=
ns
.
file_or_dir
+
unknown_args
,
rootdir_cmd_arg
=
ns
.
rootdir
or
None
,
invocation_dir
=
self
.
invocation_params
.
dir
,
)
self
.
_rootpath
=
rootpath
self
.
_inipath
=
inipath
self
.
inicfg
=
inicfg
self
.
_parser
.
extra_info
[
"rootdir"
]
=
str
(
self
.
rootpath
)
self
.
_parser
.
extra_info
[
"inifile"
]
=
str
(
self
.
inipath
)
self
.
_parser
.
addini
(
"addopts"
,
"Extra command line options"
,
"args"
)
self
.
_parser
.
addini
(
"minversion"
,
"Minimally required pytest version"
)
self
.
_parser
.
addini
(
"required_plugins"
,
"Plugins that must be present for pytest to run"
,
type
=
"args"
,
default
=
[],
)
self
.
_override_ini
=
ns
.
override_ini
or
()
def
_consider_importhook
(
self
,
args
:
Sequence
[
str
])
->
None
:
"""Install the PEP 302 import hook if using assertion rewriting.
Needs to parse the --assert=<mode> option from the commandline
and find all the installed plugins to mark them for rewriting
by the importhook.
"""
ns
,
unknown_args
=
self
.
_parser
.
parse_known_and_unknown_args
(
args
)
mode
=
getattr
(
ns
,
"assertmode"
,
"plain"
)
if
mode
==
"rewrite"
:
import
_pytest.assertion
try
:
hook
=
_pytest
.
assertion
.
install_importhook
(
self
)
except
SystemError
:
mode
=
"plain"
else
:
self
.
_mark_plugins_for_rewrite
(
hook
)
self
.
_warn_about_missing_assertion
(
mode
)
def
_mark_plugins_for_rewrite
(
self
,
hook
)
->
None
:
"""Given an importhook, mark for rewrite any top-level
modules or packages in the distribution package for
all pytest plugins."""
self
.
pluginmanager
.
rewrite_hook
=
hook
if
os
.
environ
.
get
(
"PYTEST_DISABLE_PLUGIN_AUTOLOAD"
):
# We don't autoload from distribution package entry points,
# no need to continue.
return
package_files
=
(
str
(
file
)
for
dist
in
importlib
.
metadata
.
distributions
()
if
any
(
ep
.
group
==
"pytest11"
for
ep
in
dist
.
entry_points
)
for
file
in
dist
.
files
or
[]
)
for
name
in
_iter_rewritable_modules
(
package_files
):
hook
.
mark_rewrite
(
name
)
def
_validate_args
(
self
,
args
:
list
[
str
],
via
:
str
)
->
list
[
str
]:
"""Validate known args."""
self
.
_parser
.
_config_source_hint
=
via
# type: ignore
try
:
self
.
_parser
.
parse_known_and_unknown_args
(
args
,
namespace
=
copy
.
copy
(
self
.
option
)
)
finally
:
del
self
.
_parser
.
_config_source_hint
# type: ignore
return
args
def
_decide_args
(
self
,
*
,
args
:
list
[
str
],
pyargs
:
bool
,
testpaths
:
list
[
str
],
invocation_dir
:
pathlib
.
Path
,
rootpath
:
pathlib
.
Path
,
warn
:
bool
,
)
->
tuple
[
list
[
str
],
ArgsSource
]:
"""Decide the args (initial paths/nodeids) to use given the relevant inputs.
:param warn: Whether can issue warnings.
:returns: The args and the args source. Guaranteed to be non-empty.
"""
if
args
:
source
=
Config
.
ArgsSource
.
ARGS
result
=
args
else
:
if
invocation_dir
==
rootpath
:
source
=
Config
.
ArgsSource
.
TESTPATHS
if
pyargs
:
result
=
testpaths
else
:
result
=
[]
for
path
in
testpaths
:
result
.
extend
(
sorted
(
glob
.
iglob
(
path
,
recursive
=
True
)))
if
testpaths
and
not
result
:
if
warn
:
warning_text
=
(
"No files were found in testpaths; "
"consider removing or adjusting your testpaths configuration. "
"Searching recursively from the current directory instead."
)
self
.
issue_config_time_warning
(
PytestConfigWarning
(
warning_text
),
stacklevel
=
3
)
else
:
result
=
[]
if
not
result
:
source
=
Config
.
ArgsSource
.
INVOCATION_DIR
result
=
[
str
(
invocation_dir
)]
return
result
,
source
def
_preparse
(
self
,
args
:
list
[
str
],
addopts
:
bool
=
True
)
->
None
:
if
addopts
:
env_addopts
=
os
.
environ
.
get
(
"PYTEST_ADDOPTS"
,
""
)
if
len
(
env_addopts
):
args
[:]
=
(
self
.
_validate_args
(
shlex
.
split
(
env_addopts
),
"via PYTEST_ADDOPTS"
)
+
args
)
self
.
_initini
(
args
)
if
addopts
:
args
[:]
=
(
self
.
_validate_args
(
self
.
getini
(
"addopts"
),
"via addopts config"
)
+
args
)
self
.
known_args_namespace
=
self
.
_parser
.
parse_known_args
(
args
,
namespace
=
copy
.
copy
(
self
.
option
)
)
self
.
_checkversion
()
self
.
_consider_importhook
(
args
)
self
.
pluginmanager
.
consider_preparse
(
args
,
exclude_only
=
False
)
if
not
os
.
environ
.
get
(
"PYTEST_DISABLE_PLUGIN_AUTOLOAD"
):
# Don't autoload from distribution package entry point. Only
# explicitly specified plugins are going to be loaded.
self
.
pluginmanager
.
load_setuptools_entrypoints
(
"pytest11"
)
self
.
pluginmanager
.
consider_env
()
self
.
known_args_namespace
=
self
.
_parser
.
parse_known_args
(
args
,
namespace
=
copy
.
copy
(
self
.
known_args_namespace
)
)
self
.
_validate_plugins
()
self
.
_warn_about_skipped_plugins
()
if
self
.
known_args_namespace
.
confcutdir
is
None
:
if
self
.
inipath
is
not
None
:
confcutdir
=
str
(
self
.
inipath
.
parent
)
else
:
confcutdir
=
str
(
self
.
rootpath
)
self
.
known_args_namespace
.
confcutdir
=
confcutdir
try
:
self
.
hook
.
pytest_load_initial_conftests
(
early_config
=
self
,
args
=
args
,
parser
=
self
.
_parser
)
except
ConftestImportFailure
as
e
:
if
self
.
known_args_namespace
.
help
or
self
.
known_args_namespace
.
version
:
# we don't want to prevent --help/--version to work
# so just let is pass and print a warning at the end
self
.
issue_config_time_warning
(
PytestConfigWarning
(
f
"could not load initial conftests:
{
e
.
path
}
"
),
stacklevel
=
2
,
)
else
:
raise
@hookimpl
(
wrapper
=
True
)
def
pytest_collection
(
self
)
->
Generator
[
None
,
object
,
object
]:
# Validate invalid ini keys after collection is done so we take in account
# options added by late-loading conftest files.
try
:
return
(
yield
)
finally
:
self
.
_validate_config_options
()
def
_checkversion
(
self
)
->
None
:
import
pytest
minver
=
self
.
inicfg
.
get
(
"minversion"
,
None
)
if
minver
:
# Imported lazily to improve start-up time.
from
packaging.version
import
Version
if
not
isinstance
(
minver
,
str
):
raise
pytest
.
UsageError
(
f
"
{
self
.
inipath
}
: 'minversion' must be a single value"
)
if
Version
(
minver
)
>
Version
(
pytest
.
__version__
):
raise
pytest
.
UsageError
(
f
"
{
self
.
inipath
}
: 'minversion' requires pytest-
{
minver
}
, actual pytest-
{
pytest
.
__version__
}
'"
)
def
_validate_config_options
(
self
)
->
None
:
for
key
in
sorted
(
self
.
_get_unknown_ini_keys
()):
self
.
_warn_or_fail_if_strict
(
f
"Unknown config option:
{
key
}
\n
"
)
def
_validate_plugins
(
self
)
->
None
:
required_plugins
=
sorted
(
self
.
getini
(
"required_plugins"
))
if
not
required_plugins
:
return
# Imported lazily to improve start-up time.
from
packaging.requirements
import
InvalidRequirement
from
packaging.requirements
import
Requirement
from
packaging.version
import
Version
plugin_info
=
self
.
pluginmanager
.
list_plugin_distinfo
()
plugin_dist_info
=
{
dist
.
project_name
:
dist
.
version
for
_
,
dist
in
plugin_info
}
missing_plugins
=
[]
for
required_plugin
in
required_plugins
:
try
:
req
=
Requirement
(
required_plugin
)
except
InvalidRequirement
:
missing_plugins
.
append
(
required_plugin
)
continue
if
req
.
name
not
in
plugin_dist_info
:
missing_plugins
.
append
(
required_plugin
)
elif
not
req
.
specifier
.
contains
(
Version
(
plugin_dist_info
[
req
.
name
]),
prereleases
=
True
):
missing_plugins
.
append
(
required_plugin
)
if
missing_plugins
:
raise
UsageError
(
"Missing required plugins:
{}
"
.
format
(
", "
.
join
(
missing_plugins
)),
)
def
_warn_or_fail_if_strict
(
self
,
message
:
str
)
->
None
:
if
self
.
known_args_namespace
.
strict_config
:
raise
UsageError
(
message
)
self
.
issue_config_time_warning
(
PytestConfigWarning
(
message
),
stacklevel
=
3
)
def
_get_unknown_ini_keys
(
self
)
->
list
[
str
]:
parser_inicfg
=
self
.
_parser
.
_inidict
return
[
name
for
name
in
self
.
inicfg
if
name
not
in
parser_inicfg
]
def
parse
(
self
,
args
:
list
[
str
],
addopts
:
bool
=
True
)
->
None
:
# Parse given cmdline arguments into this config object.
assert
(
self
.
args
==
[]
),
"can only parse cmdline args at most once per Config object"
self
.
hook
.
pytest_addhooks
.
call_historic
(
kwargs
=
dict
(
pluginmanager
=
self
.
pluginmanager
)
)
self
.
_preparse
(
args
,
addopts
=
addopts
)
self
.
_parser
.
after_preparse
=
True
# type: ignore
try
:
args
=
self
.
_parser
.
parse_setoption
(
args
,
self
.
option
,
namespace
=
self
.
option
)
self
.
args
,
self
.
args_source
=
self
.
_decide_args
(
args
=
args
,
pyargs
=
self
.
known_args_namespace
.
pyargs
,
testpaths
=
self
.
getini
(
"testpaths"
),
invocation_dir
=
self
.
invocation_params
.
dir
,
rootpath
=
self
.
rootpath
,
warn
=
True
,
)
except
PrintHelp
:
pass
[docs]
def
issue_config_time_warning
(
self
,
warning
:
Warning
,
stacklevel
:
int
)
->
None
:
"""Issue and handle a warning during the "configure" stage.
During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``
function because it is not possible to have hook wrappers around ``pytest_configure``.
This function is mainly intended for plugins that need to issue warnings during
``pytest_configure`` (or similar stages).
:param warning: The warning instance.
:param stacklevel: stacklevel forwarded to warnings.warn.
"""
if
self
.
pluginmanager
.
is_blocked
(
"warnings"
):
return
cmdline_filters
=
self
.
known_args_namespace
.
pythonwarnings
or
[]
config_filters
=
self
.
getini
(
"filterwarnings"
)
with
warnings
.
catch_warnings
(
record
=
True
)
as
records
:
warnings
.
simplefilter
(
"always"
,
type
(
warning
))
apply_warning_filters
(
config_filters
,
cmdline_filters
)
warnings
.
warn
(
warning
,
stacklevel
=
stacklevel
)
if
records
:
frame
=
sys
.
_getframe
(
stacklevel
-
1
)
location
=
frame
.
f_code
.
co_filename
,
frame
.
f_lineno
,
frame
.
f_code
.
co_name
self
.
hook
.
pytest_warning_recorded
.
call_historic
(
kwargs
=
dict
(
warning_message
=
records
[
0
],
when
=
"config"
,
nodeid
=
""
,
location
=
location
,
)
)
[docs]
def
addinivalue_line
(
self
,
name
:
str
,
line
:
str
)
->
None
:
"""Add a line to an ini-file option. The option must have been
declared but might not yet be set in which case the line becomes
the first line in its value."""
x
=
self
.
getini
(
name
)
assert
isinstance
(
x
,
list
)
x
.
append
(
line
)
# modifies the cached list inline
[docs]
def
getini
(
self
,
name
:
str
):
"""Return configuration value from an :ref:`ini file <configfiles>`.
If a configuration value is not defined in an
:ref:`ini file <configfiles>`, then the ``default`` value provided while
registering the configuration through
:func:`parser.addini <pytest.Parser.addini>` will be returned.
Please note that you can even provide ``None`` as a valid
default value.
If ``default`` is not provided while registering using
:func:`parser.addini <pytest.Parser.addini>`, then a default value
based on the ``type`` parameter passed to
:func:`parser.addini <pytest.Parser.addini>` will be returned.
The default values based on ``type`` are:
``paths``, ``pathlist``, ``args`` and ``linelist`` : empty list ``[]``
``bool`` : ``False``
``string`` : empty string ``""``
If neither the ``default`` nor the ``type`` parameter is passed
while registering the configuration through
:func:`parser.addini <pytest.Parser.addini>`, then the configuration
is treated as a string and a default empty string '' is returned.
If the specified name hasn't been registered through a prior
:func:`parser.addini <pytest.Parser.addini>` call (usually from a
plugin), a ValueError is raised.
"""
try
:
return
self
.
_inicache
[
name
]
except
KeyError
:
self
.
_inicache
[
name
]
=
val
=
self
.
_getini
(
name
)
return
val
# Meant for easy monkeypatching by legacypath plugin.
# Can be inlined back (with no cover removed) once legacypath is gone.
def
_getini_unknown_type
(
self
,
name
:
str
,
type
:
str
,
value
:
str
|
list
[
str
]):
msg
=
f
"unknown configuration type:
{
type
}
"
raise
ValueError
(
msg
,
value
)
# pragma: no cover
def
_getini
(
self
,
name
:
str
):
try
:
description
,
type
,
default
=
self
.
_parser
.
_inidict
[
name
]
except
KeyError
as
e
:
raise
ValueError
(
f
"unknown configuration value:
{
name
!r}
"
)
from
e
override_value
=
self
.
_get_override_ini_value
(
name
)
if
override_value
is
None
:
try
:
value
=
self
.
inicfg
[
name
]
except
KeyError
:
return
default
else
:
value
=
override_value
# Coerce the values based on types.
#
# Note: some coercions are only required if we are reading from .ini files, because
# the file format doesn't contain type information, but when reading from toml we will
# get either str or list of str values (see _parse_ini_config_from_pyproject_toml).
# For example:
#
#   ini:
#     a_line_list = "tests acceptance"
#   in this case, we need to split the string to obtain a list of strings.
#
#   toml:
#     a_line_list = ["tests", "acceptance"]
#   in this case, we already have a list ready to use.
#
if
type
==
"paths"
:
dp
=
(
self
.
inipath
.
parent
if
self
.
inipath
is
not
None
else
self
.
invocation_params
.
dir
)
input_values
=
shlex
.
split
(
value
)
if
isinstance
(
value
,
str
)
else
value
return
[
dp
/
x
for
x
in
input_values
]
elif
type
==
"args"
:
return
shlex
.
split
(
value
)
if
isinstance
(
value
,
str
)
else
value
elif
type
==
"linelist"
:
if
isinstance
(
value
,
str
):
return
[
t
for
t
in
map
(
lambda
x
:
x
.
strip
(),
value
.
split
(
"
\n
"
))
if
t
]
else
:
return
value
elif
type
==
"bool"
:
return
_strtobool
(
str
(
value
)
.
strip
())
elif
type
==
"string"
:
return
value
elif
type
is
None
:
return
value
else
:
return
self
.
_getini_unknown_type
(
name
,
type
,
value
)
def
_getconftest_pathlist
(
self
,
name
:
str
,
path
:
pathlib
.
Path
)
->
list
[
pathlib
.
Path
]
|
None
:
try
:
mod
,
relroots
=
self
.
pluginmanager
.
_rget_with_confmod
(
name
,
path
)
except
KeyError
:
return
None
assert
mod
.
__file__
is
not
None
modpath
=
pathlib
.
Path
(
mod
.
__file__
)
.
parent
values
:
list
[
pathlib
.
Path
]
=
[]
for
relroot
in
relroots
:
if
isinstance
(
relroot
,
os
.
PathLike
):
relroot
=
pathlib
.
Path
(
relroot
)
else
:
relroot
=
relroot
.
replace
(
"/"
,
os
.
sep
)
relroot
=
absolutepath
(
modpath
/
relroot
)
values
.
append
(
relroot
)
return
values
def
_get_override_ini_value
(
self
,
name
:
str
)
->
str
|
None
:
value
=
None
# override_ini is a list of "ini=value" options.
# Always use the last item if multiple values are set for same ini-name,
# e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.
for
ini_config
in
self
.
_override_ini
:
try
:
key
,
user_ini_value
=
ini_config
.
split
(
"="
,
1
)
except
ValueError
as
e
:
raise
UsageError
(
f
"-o/--override-ini expects option=value style (got:
{
ini_config
!r}
)."
)
from
e
else
:
if
key
==
name
:
value
=
user_ini_value
return
value
[docs]
def
getoption
(
self
,
name
:
str
,
default
=
notset
,
skip
:
bool
=
False
):
"""Return command line option value.
:param name: Name of the option. You may also specify
the literal ``--OPT`` option instead of the "dest" option name.
:param default: Fallback value if no option of that name is **declared** via :hook:`pytest_addoption`.
Note this parameter will be ignored when the option is **declared** even if the option's value is ``None``.
:param skip: If ``True``, raise :func:`pytest.skip` if option is undeclared or has a ``None`` value.
Note that even if ``True``, if a default was specified it will be returned instead of a skip.
"""
name
=
self
.
_opt2dest
.
get
(
name
,
name
)
try
:
val
=
getattr
(
self
.
option
,
name
)
if
val
is
None
and
skip
:
raise
AttributeError
(
name
)
return
val
except
AttributeError
as
e
:
if
default
is
not
notset
:
return
default
if
skip
:
import
pytest
pytest
.
skip
(
f
"no
{
name
!r}
option found"
)
raise
ValueError
(
f
"no option named
{
name
!r}
"
)
from
e
[docs]
def
getvalue
(
self
,
name
:
str
,
path
=
None
):
"""Deprecated, use getoption() instead."""
return
self
.
getoption
(
name
)
[docs]
def
getvalueorskip
(
self
,
name
:
str
,
path
=
None
):
"""Deprecated, use getoption(skip=True) instead."""
return
self
.
getoption
(
name
,
skip
=
True
)
#: Verbosity type for failed assertions (see :confval:`verbosity_assertions`).
VERBOSITY_ASSERTIONS
:
Final
=
"assertions"
#: Verbosity type for test case execution (see :confval:`verbosity_test_cases`).
VERBOSITY_TEST_CASES
:
Final
=
"test_cases"
_VERBOSITY_INI_DEFAULT
:
Final
=
"auto"
[docs]
def
get_verbosity
(
self
,
verbosity_type
:
str
|
None
=
None
)
->
int
:
r
"""Retrieve the verbosity level for a fine-grained verbosity type.
:param verbosity_type: Verbosity type to get level for. If a level is
configured for the given type, that value will be returned. If the
given type is not a known verbosity type, the global verbosity
level will be returned. If the given type is None (default), the
global verbosity level will be returned.
To configure a level for a fine-grained verbosity type, the
configuration file should have a setting for the configuration name
and a numeric value for the verbosity level. A special value of "auto"
can be used to explicitly use the global verbosity level.
Example:
.. code-block:: ini
# content of pytest.ini
[pytest]
verbosity_assertions = 2
.. code-block:: console
pytest -v
.. code-block:: python
print(config.get_verbosity())  # 1
print(config.get_verbosity(Config.VERBOSITY_ASSERTIONS))  # 2
"""
global_level
=
self
.
getoption
(
"verbose"
,
default
=
0
)
assert
isinstance
(
global_level
,
int
)
if
verbosity_type
is
None
:
return
global_level
ini_name
=
Config
.
_verbosity_ini_name
(
verbosity_type
)
if
ini_name
not
in
self
.
_parser
.
_inidict
:
return
global_level
level
=
self
.
getini
(
ini_name
)
if
level
==
Config
.
_VERBOSITY_INI_DEFAULT
:
return
global_level
return
int
(
level
)
@staticmethod
def
_verbosity_ini_name
(
verbosity_type
:
str
)
->
str
:
return
f
"verbosity_
{
verbosity_type
}
"
@staticmethod
def
_add_verbosity_ini
(
parser
:
Parser
,
verbosity_type
:
str
,
help
:
str
)
->
None
:
"""Add a output verbosity configuration option for the given output type.
:param parser: Parser for command line arguments and ini-file values.
:param verbosity_type: Fine-grained verbosity category.
:param help: Description of the output this type controls.
The value should be retrieved via a call to
:py:func:`config.get_verbosity(type) <pytest.Config.get_verbosity>`.
"""
parser
.
addini
(
Config
.
_verbosity_ini_name
(
verbosity_type
),
help
=
help
,
type
=
"string"
,
default
=
Config
.
_VERBOSITY_INI_DEFAULT
,
)
def
_warn_about_missing_assertion
(
self
,
mode
:
str
)
->
None
:
if
not
_assertion_supported
():
if
mode
==
"plain"
:
warning_text
=
(
"ASSERTIONS ARE NOT EXECUTED"
" and FAILING TESTS WILL PASS.  Are you"
" using python -O?"
)
else
:
warning_text
=
(
"assertions not in test modules or"
" plugins will be ignored"
" because assert statements are not executed "
"by the underlying Python interpreter "
"(are you using python -O?)
\n
"
)
self
.
issue_config_time_warning
(
PytestConfigWarning
(
warning_text
),
stacklevel
=
3
,
)
def
_warn_about_skipped_plugins
(
self
)
->
None
:
for
module_name
,
msg
in
self
.
pluginmanager
.
skipped_plugins
:
self
.
issue_config_time_warning
(
PytestConfigWarning
(
f
"skipped plugin
{
module_name
!r}
:
{
msg
}
"
),
stacklevel
=
2
,
)
def
_assertion_supported
()
->
bool
:
try
:
assert
False
except
AssertionError
:
return
True
else
:
return
False
# type: ignore[unreachable]
def
create_terminal_writer
(
config
:
Config
,
file
:
TextIO
|
None
=
None
)
->
TerminalWriter
:
"""Create a TerminalWriter instance configured according to the options
in the config object.
Every code which requires a TerminalWriter object and has access to a
config object should use this function.
"""
tw
=
TerminalWriter
(
file
=
file
)
if
config
.
option
.
color
==
"yes"
:
tw
.
hasmarkup
=
True
elif
config
.
option
.
color
==
"no"
:
tw
.
hasmarkup
=
False
if
config
.
option
.
code_highlight
==
"yes"
:
tw
.
code_highlight
=
True
elif
config
.
option
.
code_highlight
==
"no"
:
tw
.
code_highlight
=
False
return
tw
def
_strtobool
(
val
:
str
)
->
bool
:
"""Convert a string representation of truth to True or False.
True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
'val' is anything else.
.. note:: Copied from distutils.util.
"""
val
=
val
.
lower
()
if
val
in
(
"y"
,
"yes"
,
"t"
,
"true"
,
"on"
,
"1"
):
return
True
elif
val
in
(
"n"
,
"no"
,
"f"
,
"false"
,
"off"
,
"0"
):
return
False
else
:
raise
ValueError
(
f
"invalid truth value
{
val
!r}
"
)
@lru_cache
(
maxsize
=
50
)
def
parse_warning_filter
(
arg
:
str
,
*
,
escape
:
bool
)
->
tuple
[
warnings
.
_ActionKind
,
str
,
type
[
Warning
],
str
,
int
]:
"""Parse a warnings filter string.
This is copied from warnings._setoption with the following changes:
* Does not apply the filter.
* Escaping is optional.
* Raises UsageError so we get nice error messages on failure.
"""
__tracebackhide__
=
True
error_template
=
dedent
(
f
"""
\
while parsing the following warning configuration:
{
arg
}
This error occurred:
{{
error
}}
"""
)
parts
=
arg
.
split
(
":"
)
if
len
(
parts
)
>
5
:
doc_url
=
(
"https://docs.python.org/3/library/warnings.html#describing-warning-filters"
)
error
=
dedent
(
f
"""
\
Too many fields (
{
len
(
parts
)
}
), expected at most 5 separated by colons:
action:message:category:module:line
For more information please consult:
{
doc_url
}
"""
)
raise
UsageError
(
error_template
.
format
(
error
=
error
))
while
len
(
parts
)
<
5
:
parts
.
append
(
""
)
action_
,
message
,
category_
,
module
,
lineno_
=
(
s
.
strip
()
for
s
in
parts
)
try
:
action
:
warnings
.
_ActionKind
=
warnings
.
_getaction
(
action_
)
# type: ignore[attr-defined]
except
warnings
.
_OptionError
as
e
:
raise
UsageError
(
error_template
.
format
(
error
=
str
(
e
)))
from
None
try
:
category
:
type
[
Warning
]
=
_resolve_warning_category
(
category_
)
except
Exception
:
exc_info
=
ExceptionInfo
.
from_current
()
exception_text
=
exc_info
.
getrepr
(
style
=
"native"
)
raise
UsageError
(
error_template
.
format
(
error
=
exception_text
))
from
None
if
message
and
escape
:
message
=
re
.
escape
(
message
)
if
module
and
escape
:
module
=
re
.
escape
(
module
)
+
r
"\Z"
if
lineno_
:
try
:
lineno
=
int
(
lineno_
)
if
lineno
<
0
:
raise
ValueError
(
"number is negative"
)
except
ValueError
as
e
:
raise
UsageError
(
error_template
.
format
(
error
=
f
"invalid lineno
{
lineno_
!r}
:
{
e
}
"
)
)
from
None
else
:
lineno
=
0
return
action
,
message
,
category
,
module
,
lineno
def
_resolve_warning_category
(
category
:
str
)
->
type
[
Warning
]:
"""
Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)
propagate so we can get access to their tracebacks (#9218).
"""
__tracebackhide__
=
True
if
not
category
:
return
Warning
if
"."
not
in
category
:
import
builtins
as
m
klass
=
category
else
:
module
,
_
,
klass
=
category
.
rpartition
(
"."
)
m
=
__import__
(
module
,
None
,
None
,
[
klass
])
cat
=
getattr
(
m
,
klass
)
if
not
issubclass
(
cat
,
Warning
):
raise
UsageError
(
f
"
{
cat
}
is not a Warning subclass"
)
return
cast
(
Type
[
Warning
],
cat
)
def
apply_warning_filters
(
config_filters
:
Iterable
[
str
],
cmdline_filters
:
Iterable
[
str
]
)
->
None
:
"""Applies pytest-configured filters to the warnings module"""
# Filters should have this precedence: cmdline options, config.
# Filters should be applied in the inverse order of precedence.
for
arg
in
config_filters
:
warnings
.
filterwarnings
(
*
parse_warning_filter
(
arg
,
escape
=
False
))
for
arg
in
cmdline_filters
:
warnings
.
filterwarnings
(
*
parse_warning_filter
(
arg
,
escape
=
True
))

```


---


# _pytest.python - pytest documentation

URL: https://docs.pytest.org/en/stable/_modules/_pytest/python.html


# Source code for _pytest.python

```

# mypy: allow-untyped-defs
"""Python test discovery, setup and run of test functions."""
from
__future__
import
annotations
import
abc
from
collections
import
Counter
from
collections
import
defaultdict
import
dataclasses
import
enum
import
fnmatch
from
functools
import
partial
import
inspect
import
itertools
import
os
from
pathlib
import
Path
import
types
from
typing
import
Any
from
typing
import
Callable
from
typing
import
Dict
from
typing
import
final
from
typing
import
Generator
from
typing
import
Iterable
from
typing
import
Iterator
from
typing
import
Literal
from
typing
import
Mapping
from
typing
import
Pattern
from
typing
import
Sequence
from
typing
import
TYPE_CHECKING
import
warnings
import
_pytest
from
_pytest
import
fixtures
from
_pytest
import
nodes
from
_pytest._code
import
filter_traceback
from
_pytest._code
import
getfslineno
from
_pytest._code.code
import
ExceptionInfo
from
_pytest._code.code
import
TerminalRepr
from
_pytest._code.code
import
Traceback
from
_pytest._io.saferepr
import
saferepr
from
_pytest.compat
import
ascii_escaped
from
_pytest.compat
import
get_default_arg_names
from
_pytest.compat
import
get_real_func
from
_pytest.compat
import
getimfunc
from
_pytest.compat
import
is_async_function
from
_pytest.compat
import
is_generator
from
_pytest.compat
import
LEGACY_PATH
from
_pytest.compat
import
NOTSET
from
_pytest.compat
import
safe_getattr
from
_pytest.compat
import
safe_isclass
from
_pytest.config
import
Config
from
_pytest.config
import
hookimpl
from
_pytest.config.argparsing
import
Parser
from
_pytest.deprecated
import
check_ispytest
from
_pytest.fixtures
import
FixtureDef
from
_pytest.fixtures
import
FixtureRequest
from
_pytest.fixtures
import
FuncFixtureInfo
from
_pytest.fixtures
import
get_scope_node
from
_pytest.main
import
Session
from
_pytest.mark
import
MARK_GEN
from
_pytest.mark
import
ParameterSet
from
_pytest.mark.structures
import
get_unpacked_marks
from
_pytest.mark.structures
import
Mark
from
_pytest.mark.structures
import
MarkDecorator
from
_pytest.mark.structures
import
normalize_mark_list
from
_pytest.outcomes
import
fail
from
_pytest.outcomes
import
skip
from
_pytest.pathlib
import
fnmatch_ex
from
_pytest.pathlib
import
import_path
from
_pytest.pathlib
import
ImportPathMismatchError
from
_pytest.pathlib
import
scandir
from
_pytest.scope
import
_ScopeName
from
_pytest.scope
import
Scope
from
_pytest.stash
import
StashKey
from
_pytest.warning_types
import
PytestCollectionWarning
from
_pytest.warning_types
import
PytestReturnNotNoneWarning
from
_pytest.warning_types
import
PytestUnhandledCoroutineWarning
if
TYPE_CHECKING
:
from
typing_extensions
import
Self
def
pytest_addoption
(
parser
:
Parser
)
->
None
:
parser
.
addini
(
"python_files"
,
type
=
"args"
,
# NOTE: default is also used in AssertionRewritingHook.
default
=
[
"test_*.py"
,
"*_test.py"
],
help
=
"Glob-style file patterns for Python test module discovery"
,
)
parser
.
addini
(
"python_classes"
,
type
=
"args"
,
default
=
[
"Test"
],
help
=
"Prefixes or glob names for Python test class discovery"
,
)
parser
.
addini
(
"python_functions"
,
type
=
"args"
,
default
=
[
"test"
],
help
=
"Prefixes or glob names for Python test function and method discovery"
,
)
parser
.
addini
(
"disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
,
type
=
"bool"
,
default
=
False
,
help
=
"Disable string escape non-ASCII characters, might cause unwanted "
"side effects(use at your own risk)"
,
)
def
pytest_generate_tests
(
metafunc
:
Metafunc
)
->
None
:
for
marker
in
metafunc
.
definition
.
iter_markers
(
name
=
"parametrize"
):
metafunc
.
parametrize
(
*
marker
.
args
,
**
marker
.
kwargs
,
_param_mark
=
marker
)
def
pytest_configure
(
config
:
Config
)
->
None
:
config
.
addinivalue_line
(
"markers"
,
"parametrize(argnames, argvalues): call a test function multiple "
"times passing in different arguments in turn. argvalues generally "
"needs to be a list of values if argnames specifies only one name "
"or a list of tuples of values if argnames specifies multiple names. "
"Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
"decorated test function, one with arg1=1 and another with arg1=2."
"see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info "
"and examples."
,
)
config
.
addinivalue_line
(
"markers"
,
"usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
"all of the specified fixtures. see "
"https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures "
,
)
def
async_warn_and_skip
(
nodeid
:
str
)
->
None
:
msg
=
"async def functions are not natively supported and have been skipped.
\n
"
msg
+=
(
"You need to install a suitable plugin for your async framework, for example:
\n
"
)
msg
+=
"  - anyio
\n
"
msg
+=
"  - pytest-asyncio
\n
"
msg
+=
"  - pytest-tornasync
\n
"
msg
+=
"  - pytest-trio
\n
"
msg
+=
"  - pytest-twisted"
warnings
.
warn
(
PytestUnhandledCoroutineWarning
(
msg
.
format
(
nodeid
)))
skip
(
reason
=
"async def function and no async plugin installed (see warnings)"
)
@hookimpl
(
trylast
=
True
)
def
pytest_pyfunc_call
(
pyfuncitem
:
Function
)
->
object
|
None
:
testfunction
=
pyfuncitem
.
obj
if
is_async_function
(
testfunction
):
async_warn_and_skip
(
pyfuncitem
.
nodeid
)
funcargs
=
pyfuncitem
.
funcargs
testargs
=
{
arg
:
funcargs
[
arg
]
for
arg
in
pyfuncitem
.
_fixtureinfo
.
argnames
}
result
=
testfunction
(
**
testargs
)
if
hasattr
(
result
,
"__await__"
)
or
hasattr
(
result
,
"__aiter__"
):
async_warn_and_skip
(
pyfuncitem
.
nodeid
)
elif
result
is
not
None
:
warnings
.
warn
(
PytestReturnNotNoneWarning
(
f
"Expected None, but
{
pyfuncitem
.
nodeid
}
returned
{
result
!r}
, which will be an error in a "
"future version of pytest.  Did you mean to use `assert` instead of `return`?"
)
)
return
True
def
pytest_collect_directory
(
path
:
Path
,
parent
:
nodes
.
Collector
)
->
nodes
.
Collector
|
None
:
pkginit
=
path
/
"__init__.py"
try
:
has_pkginit
=
pkginit
.
is_file
()
except
PermissionError
:
# See https://github.com/pytest-dev/pytest/issues/12120#issuecomment-2106349096.
return
None
if
has_pkginit
:
return
Package
.
from_parent
(
parent
,
path
=
path
)
return
None
def
pytest_collect_file
(
file_path
:
Path
,
parent
:
nodes
.
Collector
)
->
Module
|
None
:
if
file_path
.
suffix
==
".py"
:
if
not
parent
.
session
.
isinitpath
(
file_path
):
if
not
path_matches_patterns
(
file_path
,
parent
.
config
.
getini
(
"python_files"
)
):
return
None
ihook
=
parent
.
session
.
gethookproxy
(
file_path
)
module
:
Module
=
ihook
.
pytest_pycollect_makemodule
(
module_path
=
file_path
,
parent
=
parent
)
return
module
return
None
def
path_matches_patterns
(
path
:
Path
,
patterns
:
Iterable
[
str
])
->
bool
:
"""Return whether path matches any of the patterns in the list of globs given."""
return
any
(
fnmatch_ex
(
pattern
,
path
)
for
pattern
in
patterns
)
def
pytest_pycollect_makemodule
(
module_path
:
Path
,
parent
)
->
Module
:
return
Module
.
from_parent
(
parent
,
path
=
module_path
)
@hookimpl
(
trylast
=
True
)
def
pytest_pycollect_makeitem
(
collector
:
Module
|
Class
,
name
:
str
,
obj
:
object
)
->
None
|
nodes
.
Item
|
nodes
.
Collector
|
list
[
nodes
.
Item
|
nodes
.
Collector
]:
assert
isinstance
(
collector
,
(
Class
,
Module
)),
type
(
collector
)
# Nothing was collected elsewhere, let's do it here.
if
safe_isclass
(
obj
):
if
collector
.
istestclass
(
obj
,
name
):
return
Class
.
from_parent
(
collector
,
name
=
name
,
obj
=
obj
)
elif
collector
.
istestfunction
(
obj
,
name
):
# mock seems to store unbound methods (issue473), normalize it.
obj
=
getattr
(
obj
,
"__func__"
,
obj
)
# We need to try and unwrap the function if it's a functools.partial
# or a functools.wrapped.
# We mustn't if it's been wrapped with mock.patch (python 2 only).
if
not
(
inspect
.
isfunction
(
obj
)
or
inspect
.
isfunction
(
get_real_func
(
obj
))):
filename
,
lineno
=
getfslineno
(
obj
)
warnings
.
warn_explicit
(
message
=
PytestCollectionWarning
(
f
"cannot collect
{
name
!r}
because it is not a function."
),
category
=
None
,
filename
=
str
(
filename
),
lineno
=
lineno
+
1
,
)
elif
getattr
(
obj
,
"__test__"
,
True
):
if
is_generator
(
obj
):
res
=
Function
.
from_parent
(
collector
,
name
=
name
)
reason
=
(
f
"yield tests were removed in pytest 4.0 -
{
name
}
will be ignored"
)
res
.
add_marker
(
MARK_GEN
.
xfail
(
run
=
False
,
reason
=
reason
))
res
.
warn
(
PytestCollectionWarning
(
reason
))
return
res
else
:
return
list
(
collector
.
_genfunctions
(
name
,
obj
))
return
None
class
PyobjMixin
(
nodes
.
Node
):
"""this mix-in inherits from Node to carry over the typing information
as its intended to always mix in before a node
its position in the mro is unaffected"""
_ALLOW_MARKERS
=
True
@property
def
module
(
self
):
"""Python module object this node was collected from (can be None)."""
node
=
self
.
getparent
(
Module
)
return
node
.
obj
if
node
is
not
None
else
None
@property
def
cls
(
self
):
"""Python class object this node was collected from (can be None)."""
node
=
self
.
getparent
(
Class
)
return
node
.
obj
if
node
is
not
None
else
None
@property
def
instance
(
self
):
"""Python instance object the function is bound to.
Returns None if not a test method, e.g. for a standalone test function,
a class or a module.
"""
# Overridden by Function.
return
None
@property
def
obj
(
self
):
"""Underlying Python object."""
obj
=
getattr
(
self
,
"_obj"
,
None
)
if
obj
is
None
:
self
.
_obj
=
obj
=
self
.
_getobj
()
# XXX evil hack
# used to avoid Function marker duplication
if
self
.
_ALLOW_MARKERS
:
self
.
own_markers
.
extend
(
get_unpacked_marks
(
self
.
obj
))
# This assumes that `obj` is called before there is a chance
# to add custom keys to `self.keywords`, so no fear of overriding.
self
.
keywords
.
update
((
mark
.
name
,
mark
)
for
mark
in
self
.
own_markers
)
return
obj
@obj
.
setter
def
obj
(
self
,
value
):
self
.
_obj
=
value
def
_getobj
(
self
):
"""Get the underlying Python object. May be overwritten by subclasses."""
# TODO: Improve the type of `parent` such that assert/ignore aren't needed.
assert
self
.
parent
is
not
None
obj
=
self
.
parent
.
obj
# type: ignore[attr-defined]
return
getattr
(
obj
,
self
.
name
)
def
getmodpath
(
self
,
stopatmodule
:
bool
=
True
,
includemodule
:
bool
=
False
)
->
str
:
"""Return Python path relative to the containing module."""
parts
=
[]
for
node
in
self
.
iter_parents
():
name
=
node
.
name
if
isinstance
(
node
,
Module
):
name
=
os
.
path
.
splitext
(
name
)[
0
]
if
stopatmodule
:
if
includemodule
:
parts
.
append
(
name
)
break
parts
.
append
(
name
)
parts
.
reverse
()
return
"."
.
join
(
parts
)
def
reportinfo
(
self
)
->
tuple
[
os
.
PathLike
[
str
]
|
str
,
int
|
None
,
str
]:
# XXX caching?
path
,
lineno
=
getfslineno
(
self
.
obj
)
modpath
=
self
.
getmodpath
()
return
path
,
lineno
,
modpath
# As an optimization, these builtin attribute names are pre-ignored when
# iterating over an object during collection -- the pytest_pycollect_makeitem
# hook is not called for them.
# fmt: off
class
_EmptyClass
:
pass
# noqa: E701
IGNORED_ATTRIBUTES
=
frozenset
.
union
(
frozenset
(),
# Module.
dir
(
types
.
ModuleType
(
"empty_module"
)),
# Some extra module attributes the above doesn't catch.
{
"__builtins__"
,
"__file__"
,
"__cached__"
},
# Class.
dir
(
_EmptyClass
),
# Instance.
dir
(
_EmptyClass
()),
)
del
_EmptyClass
# fmt: on
class
PyCollector
(
PyobjMixin
,
nodes
.
Collector
,
abc
.
ABC
):
def
funcnamefilter
(
self
,
name
:
str
)
->
bool
:
return
self
.
_matches_prefix_or_glob_option
(
"python_functions"
,
name
)
def
isnosetest
(
self
,
obj
:
object
)
->
bool
:
"""Look for the __test__ attribute, which is applied by the
@nose.tools.istest decorator.
"""
# We explicitly check for "is True" here to not mistakenly treat
# classes with a custom __getattr__ returning something truthy (like a
# function) as test classes.
return
safe_getattr
(
obj
,
"__test__"
,
False
)
is
True
def
classnamefilter
(
self
,
name
:
str
)
->
bool
:
return
self
.
_matches_prefix_or_glob_option
(
"python_classes"
,
name
)
def
istestfunction
(
self
,
obj
:
object
,
name
:
str
)
->
bool
:
if
self
.
funcnamefilter
(
name
)
or
self
.
isnosetest
(
obj
):
if
isinstance
(
obj
,
(
staticmethod
,
classmethod
)):
# staticmethods and classmethods need to be unwrapped.
obj
=
safe_getattr
(
obj
,
"__func__"
,
False
)
return
callable
(
obj
)
and
fixtures
.
getfixturemarker
(
obj
)
is
None
else
:
return
False
def
istestclass
(
self
,
obj
:
object
,
name
:
str
)
->
bool
:
if
not
(
self
.
classnamefilter
(
name
)
or
self
.
isnosetest
(
obj
)):
return
False
if
inspect
.
isabstract
(
obj
):
return
False
return
True
def
_matches_prefix_or_glob_option
(
self
,
option_name
:
str
,
name
:
str
)
->
bool
:
"""Check if the given name matches the prefix or glob-pattern defined
in ini configuration."""
for
option
in
self
.
config
.
getini
(
option_name
):
if
name
.
startswith
(
option
):
return
True
# Check that name looks like a glob-string before calling fnmatch
# because this is called for every name in each collected module,
# and fnmatch is somewhat expensive to call.
elif
(
"*"
in
option
or
"?"
in
option
or
"["
in
option
)
and
fnmatch
.
fnmatch
(
name
,
option
):
return
True
return
False
def
collect
(
self
)
->
Iterable
[
nodes
.
Item
|
nodes
.
Collector
]:
if
not
getattr
(
self
.
obj
,
"__test__"
,
True
):
return
[]
# Avoid random getattrs and peek in the __dict__ instead.
dicts
=
[
getattr
(
self
.
obj
,
"__dict__"
,
{})]
if
isinstance
(
self
.
obj
,
type
):
for
basecls
in
self
.
obj
.
__mro__
:
dicts
.
append
(
basecls
.
__dict__
)
# In each class, nodes should be definition ordered.
# __dict__ is definition ordered.
seen
:
set
[
str
]
=
set
()
dict_values
:
list
[
list
[
nodes
.
Item
|
nodes
.
Collector
]]
=
[]
ihook
=
self
.
ihook
for
dic
in
dicts
:
values
:
list
[
nodes
.
Item
|
nodes
.
Collector
]
=
[]
# Note: seems like the dict can change during iteration -
# be careful not to remove the list() without consideration.
for
name
,
obj
in
list
(
dic
.
items
()):
if
name
in
IGNORED_ATTRIBUTES
:
continue
if
name
in
seen
:
continue
seen
.
add
(
name
)
res
=
ihook
.
pytest_pycollect_makeitem
(
collector
=
self
,
name
=
name
,
obj
=
obj
)
if
res
is
None
:
continue
elif
isinstance
(
res
,
list
):
values
.
extend
(
res
)
else
:
values
.
append
(
res
)
dict_values
.
append
(
values
)
# Between classes in the class hierarchy, reverse-MRO order -- nodes
# inherited from base classes should come before subclasses.
result
=
[]
for
values
in
reversed
(
dict_values
):
result
.
extend
(
values
)
return
result
def
_genfunctions
(
self
,
name
:
str
,
funcobj
)
->
Iterator
[
Function
]:
modulecol
=
self
.
getparent
(
Module
)
assert
modulecol
is
not
None
module
=
modulecol
.
obj
clscol
=
self
.
getparent
(
Class
)
cls
=
clscol
and
clscol
.
obj
or
None
definition
=
FunctionDefinition
.
from_parent
(
self
,
name
=
name
,
callobj
=
funcobj
)
fixtureinfo
=
definition
.
_fixtureinfo
# pytest_generate_tests impls call metafunc.parametrize() which fills
# metafunc._calls, the outcome of the hook.
metafunc
=
Metafunc
(
definition
=
definition
,
fixtureinfo
=
fixtureinfo
,
config
=
self
.
config
,
cls
=
cls
,
module
=
module
,
_ispytest
=
True
,
)
methods
=
[]
if
hasattr
(
module
,
"pytest_generate_tests"
):
methods
.
append
(
module
.
pytest_generate_tests
)
if
cls
is
not
None
and
hasattr
(
cls
,
"pytest_generate_tests"
):
methods
.
append
(
cls
()
.
pytest_generate_tests
)
self
.
ihook
.
pytest_generate_tests
.
call_extra
(
methods
,
dict
(
metafunc
=
metafunc
))
if
not
metafunc
.
_calls
:
yield
Function
.
from_parent
(
self
,
name
=
name
,
fixtureinfo
=
fixtureinfo
)
else
:
# Direct parametrizations taking place in module/class-specific
# `metafunc.parametrize` calls may have shadowed some fixtures, so make sure
# we update what the function really needs a.k.a its fixture closure. Note that
# direct parametrizations using `@pytest.mark.parametrize` have already been considered
# into making the closure using `ignore_args` arg to `getfixtureclosure`.
fixtureinfo
.
prune_dependency_tree
()
for
callspec
in
metafunc
.
_calls
:
subname
=
f
"
{
name
}
[
{
callspec
.
id
}
]"
yield
Function
.
from_parent
(
self
,
name
=
subname
,
callspec
=
callspec
,
fixtureinfo
=
fixtureinfo
,
keywords
=
{
callspec
.
id
:
True
},
originalname
=
name
,
)
def
importtestmodule
(
path
:
Path
,
config
:
Config
,
):
# We assume we are only called once per module.
importmode
=
config
.
getoption
(
"--import-mode"
)
try
:
mod
=
import_path
(
path
,
mode
=
importmode
,
root
=
config
.
rootpath
,
consider_namespace_packages
=
config
.
getini
(
"consider_namespace_packages"
),
)
except
SyntaxError
as
e
:
raise
nodes
.
Collector
.
CollectError
(
ExceptionInfo
.
from_current
()
.
getrepr
(
style
=
"short"
)
)
from
e
except
ImportPathMismatchError
as
e
:
raise
nodes
.
Collector
.
CollectError
(
"import file mismatch:
\n
"
"imported module
{!r}
has this __file__ attribute:
\n
"
"
{}
\n
"
"which is not the same as the test file we want to collect:
\n
"
"
{}
\n
"
"HINT: remove __pycache__ / .pyc files and/or use a "
"unique basename for your test file modules"
.
format
(
*
e
.
args
)
)
from
e
except
ImportError
as
e
:
exc_info
=
ExceptionInfo
.
from_current
()
if
config
.
get_verbosity
()
<
2
:
exc_info
.
traceback
=
exc_info
.
traceback
.
filter
(
filter_traceback
)
exc_repr
=
(
exc_info
.
getrepr
(
style
=
"short"
)
if
exc_info
.
traceback
else
exc_info
.
exconly
()
)
formatted_tb
=
str
(
exc_repr
)
raise
nodes
.
Collector
.
CollectError
(
f
"ImportError while importing test module '
{
path
}
'.
\n
"
"Hint: make sure your test modules/packages have valid Python names.
\n
"
"Traceback:
\n
"
f
"
{
formatted_tb
}
"
)
from
e
except
skip
.
Exception
as
e
:
if
e
.
allow_module_level
:
raise
raise
nodes
.
Collector
.
CollectError
(
"Using pytest.skip outside of a test will skip the entire module. "
"If that's your intention, pass `allow_module_level=True`. "
"If you want to skip a specific test or an entire class, "
"use the @pytest.mark.skip or @pytest.mark.skipif decorators."
)
from
e
config
.
pluginmanager
.
consider_module
(
mod
)
return
mod
[docs]
class
Module
(
nodes
.
File
,
PyCollector
):
"""Collector for test classes and functions in a Python module."""
def
_getobj
(
self
):
return
importtestmodule
(
self
.
path
,
self
.
config
)
[docs]
def
collect
(
self
)
->
Iterable
[
nodes
.
Item
|
nodes
.
Collector
]:
self
.
_register_setup_module_fixture
()
self
.
_register_setup_function_fixture
()
self
.
session
.
_fixturemanager
.
parsefactories
(
self
)
return
super
()
.
collect
()
def
_register_setup_module_fixture
(
self
)
->
None
:
"""Register an autouse, module-scoped fixture for the collected module object
that invokes setUpModule/tearDownModule if either or both are available.
Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
other fixtures (#517).
"""
setup_module
=
_get_first_non_fixture_func
(
self
.
obj
,
(
"setUpModule"
,
"setup_module"
)
)
teardown_module
=
_get_first_non_fixture_func
(
self
.
obj
,
(
"tearDownModule"
,
"teardown_module"
)
)
if
setup_module
is
None
and
teardown_module
is
None
:
return
def
xunit_setup_module_fixture
(
request
)
->
Generator
[
None
]:
module
=
request
.
module
if
setup_module
is
not
None
:
_call_with_optional_argument
(
setup_module
,
module
)
yield
if
teardown_module
is
not
None
:
_call_with_optional_argument
(
teardown_module
,
module
)
self
.
session
.
_fixturemanager
.
_register_fixture
(
# Use a unique name to speed up lookup.
name
=
f
"_xunit_setup_module_fixture_
{
self
.
obj
.
__name__
}
"
,
func
=
xunit_setup_module_fixture
,
nodeid
=
self
.
nodeid
,
scope
=
"module"
,
autouse
=
True
,
)
def
_register_setup_function_fixture
(
self
)
->
None
:
"""Register an autouse, function-scoped fixture for the collected module object
that invokes setup_function/teardown_function if either or both are available.
Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
other fixtures (#517).
"""
setup_function
=
_get_first_non_fixture_func
(
self
.
obj
,
(
"setup_function"
,))
teardown_function
=
_get_first_non_fixture_func
(
self
.
obj
,
(
"teardown_function"
,)
)
if
setup_function
is
None
and
teardown_function
is
None
:
return
def
xunit_setup_function_fixture
(
request
)
->
Generator
[
None
]:
if
request
.
instance
is
not
None
:
# in this case we are bound to an instance, so we need to let
# setup_method handle this
yield
return
function
=
request
.
function
if
setup_function
is
not
None
:
_call_with_optional_argument
(
setup_function
,
function
)
yield
if
teardown_function
is
not
None
:
_call_with_optional_argument
(
teardown_function
,
function
)
self
.
session
.
_fixturemanager
.
_register_fixture
(
# Use a unique name to speed up lookup.
name
=
f
"_xunit_setup_function_fixture_
{
self
.
obj
.
__name__
}
"
,
func
=
xunit_setup_function_fixture
,
nodeid
=
self
.
nodeid
,
scope
=
"function"
,
autouse
=
True
,
)
[docs]
class
Package
(
nodes
.
Directory
):
"""Collector for files and directories in a Python packages -- directories
with an `__init__.py` file.
.. note::
Directories without an `__init__.py` file are instead collected by
:class:`~pytest.Dir` by default. Both are :class:`~pytest.Directory`
collectors.
.. versionchanged:: 8.0
Now inherits from :class:`~pytest.Directory`.
"""
def
__init__
(
self
,
fspath
:
LEGACY_PATH
|
None
,
parent
:
nodes
.
Collector
,
# NOTE: following args are unused:
config
=
None
,
session
=
None
,
nodeid
=
None
,
path
:
Path
|
None
=
None
,
)
->
None
:
# NOTE: Could be just the following, but kept as-is for compat.
# super().__init__(self, fspath, parent=parent)
session
=
parent
.
session
super
()
.
__init__
(
fspath
=
fspath
,
path
=
path
,
parent
=
parent
,
config
=
config
,
session
=
session
,
nodeid
=
nodeid
,
)
def
setup
(
self
)
->
None
:
init_mod
=
importtestmodule
(
self
.
path
/
"__init__.py"
,
self
.
config
)
# Not using fixtures to call setup_module here because autouse fixtures
# from packages are not called automatically (#4085).
setup_module
=
_get_first_non_fixture_func
(
init_mod
,
(
"setUpModule"
,
"setup_module"
)
)
if
setup_module
is
not
None
:
_call_with_optional_argument
(
setup_module
,
init_mod
)
teardown_module
=
_get_first_non_fixture_func
(
init_mod
,
(
"tearDownModule"
,
"teardown_module"
)
)
if
teardown_module
is
not
None
:
func
=
partial
(
_call_with_optional_argument
,
teardown_module
,
init_mod
)
self
.
addfinalizer
(
func
)
[docs]
def
collect
(
self
)
->
Iterable
[
nodes
.
Item
|
nodes
.
Collector
]:
# Always collect __init__.py first.
def
sort_key
(
entry
:
os
.
DirEntry
[
str
])
->
object
:
return
(
entry
.
name
!=
"__init__.py"
,
entry
.
name
)
config
=
self
.
config
col
:
nodes
.
Collector
|
None
cols
:
Sequence
[
nodes
.
Collector
]
ihook
=
self
.
ihook
for
direntry
in
scandir
(
self
.
path
,
sort_key
):
if
direntry
.
is_dir
():
path
=
Path
(
direntry
.
path
)
if
not
self
.
session
.
isinitpath
(
path
,
with_parents
=
True
):
if
ihook
.
pytest_ignore_collect
(
collection_path
=
path
,
config
=
config
):
continue
col
=
ihook
.
pytest_collect_directory
(
path
=
path
,
parent
=
self
)
if
col
is
not
None
:
yield
col
elif
direntry
.
is_file
():
path
=
Path
(
direntry
.
path
)
if
not
self
.
session
.
isinitpath
(
path
):
if
ihook
.
pytest_ignore_collect
(
collection_path
=
path
,
config
=
config
):
continue
cols
=
ihook
.
pytest_collect_file
(
file_path
=
path
,
parent
=
self
)
yield from
cols
def
_call_with_optional_argument
(
func
,
arg
)
->
None
:
"""Call the given function with the given argument if func accepts one argument, otherwise
calls func without arguments."""
arg_count
=
func
.
__code__
.
co_argcount
if
inspect
.
ismethod
(
func
):
arg_count
-=
1
if
arg_count
:
func
(
arg
)
else
:
func
()
def
_get_first_non_fixture_func
(
obj
:
object
,
names
:
Iterable
[
str
])
->
object
|
None
:
"""Return the attribute from the given object to be used as a setup/teardown
xunit-style function, but only if not marked as a fixture to avoid calling it twice.
"""
for
name
in
names
:
meth
:
object
|
None
=
getattr
(
obj
,
name
,
None
)
if
meth
is
not
None
and
fixtures
.
getfixturemarker
(
meth
)
is
None
:
return
meth
return
None
[docs]
class
Class
(
PyCollector
):
"""Collector for test methods (and nested classes) in a Python class."""
[docs]
@classmethod
def
from_parent
(
cls
,
parent
,
*
,
name
,
obj
=
None
,
**
kw
)
->
Self
:
# type: ignore[override]
"""The public constructor."""
return
super
()
.
from_parent
(
name
=
name
,
parent
=
parent
,
**
kw
)
def
newinstance
(
self
):
return
self
.
obj
()
[docs]
def
collect
(
self
)
->
Iterable
[
nodes
.
Item
|
nodes
.
Collector
]:
if
not
safe_getattr
(
self
.
obj
,
"__test__"
,
True
):
return
[]
if
hasinit
(
self
.
obj
):
assert
self
.
parent
is
not
None
self
.
warn
(
PytestCollectionWarning
(
f
"cannot collect test class
{
self
.
obj
.
__name__
!r}
because it has a "
f
"__init__ constructor (from:
{
self
.
parent
.
nodeid
}
)"
)
)
return
[]
elif
hasnew
(
self
.
obj
):
assert
self
.
parent
is
not
None
self
.
warn
(
PytestCollectionWarning
(
f
"cannot collect test class
{
self
.
obj
.
__name__
!r}
because it has a "
f
"__new__ constructor (from:
{
self
.
parent
.
nodeid
}
)"
)
)
return
[]
self
.
_register_setup_class_fixture
()
self
.
_register_setup_method_fixture
()
self
.
session
.
_fixturemanager
.
parsefactories
(
self
.
newinstance
(),
self
.
nodeid
)
return
super
()
.
collect
()
def
_register_setup_class_fixture
(
self
)
->
None
:
"""Register an autouse, class scoped fixture into the collected class object
that invokes setup_class/teardown_class if either or both are available.
Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
other fixtures (#517).
"""
setup_class
=
_get_first_non_fixture_func
(
self
.
obj
,
(
"setup_class"
,))
teardown_class
=
_get_first_non_fixture_func
(
self
.
obj
,
(
"teardown_class"
,))
if
setup_class
is
None
and
teardown_class
is
None
:
return
def
xunit_setup_class_fixture
(
request
)
->
Generator
[
None
]:
cls
=
request
.
cls
if
setup_class
is
not
None
:
func
=
getimfunc
(
setup_class
)
_call_with_optional_argument
(
func
,
cls
)
yield
if
teardown_class
is
not
None
:
func
=
getimfunc
(
teardown_class
)
_call_with_optional_argument
(
func
,
cls
)
self
.
session
.
_fixturemanager
.
_register_fixture
(
# Use a unique name to speed up lookup.
name
=
f
"_xunit_setup_class_fixture_
{
self
.
obj
.
__qualname__
}
"
,
func
=
xunit_setup_class_fixture
,
nodeid
=
self
.
nodeid
,
scope
=
"class"
,
autouse
=
True
,
)
def
_register_setup_method_fixture
(
self
)
->
None
:
"""Register an autouse, function scoped fixture into the collected class object
that invokes setup_method/teardown_method if either or both are available.
Using a fixture to invoke these methods ensures we play nicely and unsurprisingly with
other fixtures (#517).
"""
setup_name
=
"setup_method"
setup_method
=
_get_first_non_fixture_func
(
self
.
obj
,
(
setup_name
,))
teardown_name
=
"teardown_method"
teardown_method
=
_get_first_non_fixture_func
(
self
.
obj
,
(
teardown_name
,))
if
setup_method
is
None
and
teardown_method
is
None
:
return
def
xunit_setup_method_fixture
(
request
)
->
Generator
[
None
]:
instance
=
request
.
instance
method
=
request
.
function
if
setup_method
is
not
None
:
func
=
getattr
(
instance
,
setup_name
)
_call_with_optional_argument
(
func
,
method
)
yield
if
teardown_method
is
not
None
:
func
=
getattr
(
instance
,
teardown_name
)
_call_with_optional_argument
(
func
,
method
)
self
.
session
.
_fixturemanager
.
_register_fixture
(
# Use a unique name to speed up lookup.
name
=
f
"_xunit_setup_method_fixture_
{
self
.
obj
.
__qualname__
}
"
,
func
=
xunit_setup_method_fixture
,
nodeid
=
self
.
nodeid
,
scope
=
"function"
,
autouse
=
True
,
)
def
hasinit
(
obj
:
object
)
->
bool
:
init
:
object
=
getattr
(
obj
,
"__init__"
,
None
)
if
init
:
return
init
!=
object
.
__init__
return
False
def
hasnew
(
obj
:
object
)
->
bool
:
new
:
object
=
getattr
(
obj
,
"__new__"
,
None
)
if
new
:
return
new
!=
object
.
__new__
return
False
@final
@dataclasses
.
dataclass
(
frozen
=
True
)
class
IdMaker
:
"""Make IDs for a parametrization."""
__slots__
=
(
"argnames"
,
"parametersets"
,
"idfn"
,
"ids"
,
"config"
,
"nodeid"
,
"func_name"
,
)
# The argnames of the parametrization.
argnames
:
Sequence
[
str
]
# The ParameterSets of the parametrization.
parametersets
:
Sequence
[
ParameterSet
]
# Optionally, a user-provided callable to make IDs for parameters in a
# ParameterSet.
idfn
:
Callable
[[
Any
],
object
|
None
]
|
None
# Optionally, explicit IDs for ParameterSets by index.
ids
:
Sequence
[
object
|
None
]
|
None
# Optionally, the pytest config.
# Used for controlling ASCII escaping, and for calling the
# :hook:`pytest_make_parametrize_id` hook.
config
:
Config
|
None
# Optionally, the ID of the node being parametrized.
# Used only for clearer error messages.
nodeid
:
str
|
None
# Optionally, the ID of the function being parametrized.
# Used only for clearer error messages.
func_name
:
str
|
None
def
make_unique_parameterset_ids
(
self
)
->
list
[
str
]:
"""Make a unique identifier for each ParameterSet, that may be used to
identify the parametrization in a node ID.
Format is <prm_1_token>-...-<prm_n_token>[counter], where prm_x_token is
- user-provided id, if given
- else an id derived from the value, applicable for certain types
- else <argname><parameterset index>
The counter suffix is appended only in case a string wouldn't be unique
otherwise.
"""
resolved_ids
=
list
(
self
.
_resolve_ids
())
# All IDs must be unique!
if
len
(
resolved_ids
)
!=
len
(
set
(
resolved_ids
)):
# Record the number of occurrences of each ID.
id_counts
=
Counter
(
resolved_ids
)
# Map the ID to its next suffix.
id_suffixes
:
dict
[
str
,
int
]
=
defaultdict
(
int
)
# Suffix non-unique IDs to make them unique.
for
index
,
id
in
enumerate
(
resolved_ids
):
if
id_counts
[
id
]
>
1
:
suffix
=
""
if
id
and
id
[
-
1
]
.
isdigit
():
suffix
=
"_"
new_id
=
f
"
{
id
}{
suffix
}{
id_suffixes
[
id
]
}
"
while
new_id
in
set
(
resolved_ids
):
id_suffixes
[
id
]
+=
1
new_id
=
f
"
{
id
}{
suffix
}{
id_suffixes
[
id
]
}
"
resolved_ids
[
index
]
=
new_id
id_suffixes
[
id
]
+=
1
assert
len
(
resolved_ids
)
==
len
(
set
(
resolved_ids
)
),
f
"Internal error:
{
resolved_ids
=}
"
return
resolved_ids
def
_resolve_ids
(
self
)
->
Iterable
[
str
]:
"""Resolve IDs for all ParameterSets (may contain duplicates)."""
for
idx
,
parameterset
in
enumerate
(
self
.
parametersets
):
if
parameterset
.
id
is
not
None
:
# ID provided directly - pytest.param(..., id="...")
yield
parameterset
.
id
elif
self
.
ids
and
idx
<
len
(
self
.
ids
)
and
self
.
ids
[
idx
]
is
not
None
:
# ID provided in the IDs list - parametrize(..., ids=[...]).
yield
self
.
_idval_from_value_required
(
self
.
ids
[
idx
],
idx
)
else
:
# ID not provided - generate it.
yield
"-"
.
join
(
self
.
_idval
(
val
,
argname
,
idx
)
for
val
,
argname
in
zip
(
parameterset
.
values
,
self
.
argnames
)
)
def
_idval
(
self
,
val
:
object
,
argname
:
str
,
idx
:
int
)
->
str
:
"""Make an ID for a parameter in a ParameterSet."""
idval
=
self
.
_idval_from_function
(
val
,
argname
,
idx
)
if
idval
is
not
None
:
return
idval
idval
=
self
.
_idval_from_hook
(
val
,
argname
)
if
idval
is
not
None
:
return
idval
idval
=
self
.
_idval_from_value
(
val
)
if
idval
is
not
None
:
return
idval
return
self
.
_idval_from_argname
(
argname
,
idx
)
def
_idval_from_function
(
self
,
val
:
object
,
argname
:
str
,
idx
:
int
)
->
str
|
None
:
"""Try to make an ID for a parameter in a ParameterSet using the
user-provided id callable, if given."""
if
self
.
idfn
is
None
:
return
None
try
:
id
=
self
.
idfn
(
val
)
except
Exception
as
e
:
prefix
=
f
"
{
self
.
nodeid
}
: "
if
self
.
nodeid
is
not
None
else
""
msg
=
"error raised while trying to determine id of parameter '
{}
' at position
{}
"
msg
=
prefix
+
msg
.
format
(
argname
,
idx
)
raise
ValueError
(
msg
)
from
e
if
id
is
None
:
return
None
return
self
.
_idval_from_value
(
id
)
def
_idval_from_hook
(
self
,
val
:
object
,
argname
:
str
)
->
str
|
None
:
"""Try to make an ID for a parameter in a ParameterSet by calling the
:hook:`pytest_make_parametrize_id` hook."""
if
self
.
config
:
id
:
str
|
None
=
self
.
config
.
hook
.
pytest_make_parametrize_id
(
config
=
self
.
config
,
val
=
val
,
argname
=
argname
)
return
id
return
None
def
_idval_from_value
(
self
,
val
:
object
)
->
str
|
None
:
"""Try to make an ID for a parameter in a ParameterSet from its value,
if the value type is supported."""
if
isinstance
(
val
,
(
str
,
bytes
)):
return
_ascii_escaped_by_config
(
val
,
self
.
config
)
elif
val
is
None
or
isinstance
(
val
,
(
float
,
int
,
bool
,
complex
)):
return
str
(
val
)
elif
isinstance
(
val
,
Pattern
):
return
ascii_escaped
(
val
.
pattern
)
elif
val
is
NOTSET
:
# Fallback to default. Note that NOTSET is an enum.Enum.
pass
elif
isinstance
(
val
,
enum
.
Enum
):
return
str
(
val
)
elif
isinstance
(
getattr
(
val
,
"__name__"
,
None
),
str
):
# Name of a class, function, module, etc.
name
:
str
=
getattr
(
val
,
"__name__"
)
return
name
return
None
def
_idval_from_value_required
(
self
,
val
:
object
,
idx
:
int
)
->
str
:
"""Like _idval_from_value(), but fails if the type is not supported."""
id
=
self
.
_idval_from_value
(
val
)
if
id
is
not
None
:
return
id
# Fail.
if
self
.
func_name
is
not
None
:
prefix
=
f
"In
{
self
.
func_name
}
: "
elif
self
.
nodeid
is
not
None
:
prefix
=
f
"In
{
self
.
nodeid
}
: "
else
:
prefix
=
""
msg
=
(
f
"
{
prefix
}
ids contains unsupported value
{
saferepr
(
val
)
}
(type:
{
type
(
val
)
!r}
) at index
{
idx
}
. "
"Supported types are: str, bytes, int, float, complex, bool, enum, regex or anything with a __name__."
)
fail
(
msg
,
pytrace
=
False
)
@staticmethod
def
_idval_from_argname
(
argname
:
str
,
idx
:
int
)
->
str
:
"""Make an ID for a parameter in a ParameterSet from the argument name
and the index of the ParameterSet."""
return
str
(
argname
)
+
str
(
idx
)
@final
@dataclasses
.
dataclass
(
frozen
=
True
)
class
CallSpec2
:
"""A planned parameterized invocation of a test function.
Calculated during collection for a given test function's Metafunc.
Once collection is over, each callspec is turned into a single Item
and stored in item.callspec.
"""
# arg name -> arg value which will be passed to a fixture or pseudo-fixture
# of the same name. (indirect or direct parametrization respectively)
params
:
dict
[
str
,
object
]
=
dataclasses
.
field
(
default_factory
=
dict
)
# arg name -> arg index.
indices
:
dict
[
str
,
int
]
=
dataclasses
.
field
(
default_factory
=
dict
)
# Used for sorting parametrized resources.
_arg2scope
:
Mapping
[
str
,
Scope
]
=
dataclasses
.
field
(
default_factory
=
dict
)
# Parts which will be added to the item's name in `[..]` separated by "-".
_idlist
:
Sequence
[
str
]
=
dataclasses
.
field
(
default_factory
=
tuple
)
# Marks which will be applied to the item.
marks
:
list
[
Mark
]
=
dataclasses
.
field
(
default_factory
=
list
)
def
setmulti
(
self
,
*
,
argnames
:
Iterable
[
str
],
valset
:
Iterable
[
object
],
id
:
str
,
marks
:
Iterable
[
Mark
|
MarkDecorator
],
scope
:
Scope
,
param_index
:
int
,
)
->
CallSpec2
:
params
=
self
.
params
.
copy
()
indices
=
self
.
indices
.
copy
()
arg2scope
=
dict
(
self
.
_arg2scope
)
for
arg
,
val
in
zip
(
argnames
,
valset
):
if
arg
in
params
:
raise
ValueError
(
f
"duplicate parametrization of
{
arg
!r}
"
)
params
[
arg
]
=
val
indices
[
arg
]
=
param_index
arg2scope
[
arg
]
=
scope
return
CallSpec2
(
params
=
params
,
indices
=
indices
,
_arg2scope
=
arg2scope
,
_idlist
=
[
*
self
.
_idlist
,
id
],
marks
=
[
*
self
.
marks
,
*
normalize_mark_list
(
marks
)],
)
def
getparam
(
self
,
name
:
str
)
->
object
:
try
:
return
self
.
params
[
name
]
except
KeyError
as
e
:
raise
ValueError
(
name
)
from
e
@property
def
id
(
self
)
->
str
:
return
"-"
.
join
(
self
.
_idlist
)
def
get_direct_param_fixture_func
(
request
:
FixtureRequest
)
->
Any
:
return
request
.
param
# Used for storing pseudo fixturedefs for direct parametrization.
name2pseudofixturedef_key
=
StashKey
[
Dict
[
str
,
FixtureDef
[
Any
]]]()
[docs]
@final
class
Metafunc
:
"""Objects passed to the :hook:`pytest_generate_tests` hook.
They help to inspect a test function and to generate tests according to
test configuration or values specified in the class or module where a
test function is defined.
"""
def
__init__
(
self
,
definition
:
FunctionDefinition
,
fixtureinfo
:
fixtures
.
FuncFixtureInfo
,
config
:
Config
,
cls
=
None
,
module
=
None
,
*
,
_ispytest
:
bool
=
False
,
)
->
None
:
check_ispytest
(
_ispytest
)
#: Access to the underlying :class:`_pytest.python.FunctionDefinition`.
self
.
definition
=
definition
#: Access to the :class:`pytest.Config` object for the test session.
self
.
config
=
config
#: The module object where the test function is defined in.
self
.
module
=
module
#: Underlying Python test function.
self
.
function
=
definition
.
obj
#: Set of fixture names required by the test function.
self
.
fixturenames
=
fixtureinfo
.
names_closure
#: Class object where the test function is defined in or ``None``.
self
.
cls
=
cls
self
.
_arg2fixturedefs
=
fixtureinfo
.
name2fixturedefs
# Result of parametrize().
self
.
_calls
:
list
[
CallSpec2
]
=
[]
[docs]
def
parametrize
(
self
,
argnames
:
str
|
Sequence
[
str
],
argvalues
:
Iterable
[
ParameterSet
|
Sequence
[
object
]
|
object
],
indirect
:
bool
|
Sequence
[
str
]
=
False
,
ids
:
Iterable
[
object
|
None
]
|
Callable
[[
Any
],
object
|
None
]
|
None
=
None
,
scope
:
_ScopeName
|
None
=
None
,
*
,
_param_mark
:
Mark
|
None
=
None
,
)
->
None
:
"""Add new invocations to the underlying test function using the list
of argvalues for the given argnames. Parametrization is performed
during the collection phase. If you need to setup expensive resources
see about setting indirect to do it rather than at test setup time.
Can be called multiple times per test function (but only on different
argument names), in which case each call parametrizes all previous
parametrizations, e.g.
::
unparametrized:         t
parametrize ["x", "y"]: t[x], t[y]
parametrize [1, 2]:     t[x-1], t[x-2], t[y-1], t[y-2]
:param argnames:
A comma-separated string denoting one or more argument names, or
a list/tuple of argument strings.
:param argvalues:
The list of argvalues determines how often a test is invoked with
different argument values.
If only one argname was specified argvalues is a list of values.
If N argnames were specified, argvalues must be a list of
N-tuples, where each tuple-element specifies a value for its
respective argname.
:type argvalues: Iterable[_pytest.mark.structures.ParameterSet | Sequence[object] | object]
:param indirect:
A list of arguments' names (subset of argnames) or a boolean.
If True the list contains all names from the argnames. Each
argvalue corresponding to an argname in this list will
be passed as request.param to its respective argname fixture
function so that it can perform more expensive setups during the
setup phase of a test rather than at collection time.
:param ids:
Sequence of (or generator for) ids for ``argvalues``,
or a callable to return part of the id for each argvalue.
With sequences (and generators like ``itertools.count()``) the
returned ids should be of type ``string``, ``int``, ``float``,
``bool``, or ``None``.
They are mapped to the corresponding index in ``argvalues``.
``None`` means to use the auto-generated id.
If it is a callable it will be called for each entry in
``argvalues``, and the return value is used as part of the
auto-generated id for the whole set (where parts are joined with
dashes ("-")).
This is useful to provide more specific ids for certain items, e.g.
dates.  Returning ``None`` will use an auto-generated id.
If no ids are provided they will be generated automatically from
the argvalues.
:param scope:
If specified it denotes the scope of the parameters.
The scope is used for grouping tests by parameter instances.
It will also override any fixture-function defined scope, allowing
to set a dynamic scope using test context or configuration.
"""
argnames
,
parametersets
=
ParameterSet
.
_for_parametrize
(
argnames
,
argvalues
,
self
.
function
,
self
.
config
,
nodeid
=
self
.
definition
.
nodeid
,
)
del
argvalues
if
"request"
in
argnames
:
fail
(
"'request' is a reserved name and cannot be used in @pytest.mark.parametrize"
,
pytrace
=
False
,
)
if
scope
is
not
None
:
scope_
=
Scope
.
from_user
(
scope
,
descr
=
f
"parametrize() call in
{
self
.
function
.
__name__
}
"
)
else
:
scope_
=
_find_parametrized_scope
(
argnames
,
self
.
_arg2fixturedefs
,
indirect
)
self
.
_validate_if_using_arg_names
(
argnames
,
indirect
)
# Use any already (possibly) generated ids with parametrize Marks.
if
_param_mark
and
_param_mark
.
_param_ids_from
:
generated_ids
=
_param_mark
.
_param_ids_from
.
_param_ids_generated
if
generated_ids
is
not
None
:
ids
=
generated_ids
ids
=
self
.
_resolve_parameter_set_ids
(
argnames
,
ids
,
parametersets
,
nodeid
=
self
.
definition
.
nodeid
)
# Store used (possibly generated) ids with parametrize Marks.
if
_param_mark
and
_param_mark
.
_param_ids_from
and
generated_ids
is
None
:
object
.
__setattr__
(
_param_mark
.
_param_ids_from
,
"_param_ids_generated"
,
ids
)
# Add funcargs as fixturedefs to fixtureinfo.arg2fixturedefs by registering
# artificial "pseudo" FixtureDef's so that later at test execution time we can
# rely on a proper FixtureDef to exist for fixture setup.
node
=
None
# If we have a scope that is higher than function, we need
# to make sure we only ever create an according fixturedef on
# a per-scope basis. We thus store and cache the fixturedef on the
# node related to the scope.
if
scope_
is
not
Scope
.
Function
:
collector
=
self
.
definition
.
parent
assert
collector
is
not
None
node
=
get_scope_node
(
collector
,
scope_
)
if
node
is
None
:
# If used class scope and there is no class, use module-level
# collector (for now).
if
scope_
is
Scope
.
Class
:
assert
isinstance
(
collector
,
Module
)
node
=
collector
# If used package scope and there is no package, use session
# (for now).
elif
scope_
is
Scope
.
Package
:
node
=
collector
.
session
else
:
assert
False
,
f
"Unhandled missing scope:
{
scope
}
"
if
node
is
None
:
name2pseudofixturedef
=
None
else
:
default
:
dict
[
str
,
FixtureDef
[
Any
]]
=
{}
name2pseudofixturedef
=
node
.
stash
.
setdefault
(
name2pseudofixturedef_key
,
default
)
arg_directness
=
self
.
_resolve_args_directness
(
argnames
,
indirect
)
for
argname
in
argnames
:
if
arg_directness
[
argname
]
==
"indirect"
:
continue
if
name2pseudofixturedef
is
not
None
and
argname
in
name2pseudofixturedef
:
fixturedef
=
name2pseudofixturedef
[
argname
]
else
:
fixturedef
=
FixtureDef
(
config
=
self
.
config
,
baseid
=
""
,
argname
=
argname
,
func
=
get_direct_param_fixture_func
,
scope
=
scope_
,
params
=
None
,
ids
=
None
,
_ispytest
=
True
,
)
if
name2pseudofixturedef
is
not
None
:
name2pseudofixturedef
[
argname
]
=
fixturedef
self
.
_arg2fixturedefs
[
argname
]
=
[
fixturedef
]
# Create the new calls: if we are parametrize() multiple times (by applying the decorator
# more than once) then we accumulate those calls generating the cartesian product
# of all calls.
newcalls
=
[]
for
callspec
in
self
.
_calls
or
[
CallSpec2
()]:
for
param_index
,
(
param_id
,
param_set
)
in
enumerate
(
zip
(
ids
,
parametersets
)
):
newcallspec
=
callspec
.
setmulti
(
argnames
=
argnames
,
valset
=
param_set
.
values
,
id
=
param_id
,
marks
=
param_set
.
marks
,
scope
=
scope_
,
param_index
=
param_index
,
)
newcalls
.
append
(
newcallspec
)
self
.
_calls
=
newcalls
def
_resolve_parameter_set_ids
(
self
,
argnames
:
Sequence
[
str
],
ids
:
Iterable
[
object
|
None
]
|
Callable
[[
Any
],
object
|
None
]
|
None
,
parametersets
:
Sequence
[
ParameterSet
],
nodeid
:
str
,
)
->
list
[
str
]:
"""Resolve the actual ids for the given parameter sets.
:param argnames:
Argument names passed to ``parametrize()``.
:param ids:
The `ids` parameter of the ``parametrize()`` call (see docs).
:param parametersets:
The parameter sets, each containing a set of values corresponding
to ``argnames``.
:param nodeid str:
The nodeid of the definition item that generated this
parametrization.
:returns:
List with ids for each parameter set given.
"""
if
ids
is
None
:
idfn
=
None
ids_
=
None
elif
callable
(
ids
):
idfn
=
ids
ids_
=
None
else
:
idfn
=
None
ids_
=
self
.
_validate_ids
(
ids
,
parametersets
,
self
.
function
.
__name__
)
id_maker
=
IdMaker
(
argnames
,
parametersets
,
idfn
,
ids_
,
self
.
config
,
nodeid
=
nodeid
,
func_name
=
self
.
function
.
__name__
,
)
return
id_maker
.
make_unique_parameterset_ids
()
def
_validate_ids
(
self
,
ids
:
Iterable
[
object
|
None
],
parametersets
:
Sequence
[
ParameterSet
],
func_name
:
str
,
)
->
list
[
object
|
None
]:
try
:
num_ids
=
len
(
ids
)
# type: ignore[arg-type]
except
TypeError
:
try
:
iter
(
ids
)
except
TypeError
as
e
:
raise
TypeError
(
"ids must be a callable or an iterable"
)
from
e
num_ids
=
len
(
parametersets
)
# num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849
if
num_ids
!=
len
(
parametersets
)
and
num_ids
!=
0
:
msg
=
"In
{}
:
{}
parameter sets specified, with different number of ids:
{}
"
fail
(
msg
.
format
(
func_name
,
len
(
parametersets
),
num_ids
),
pytrace
=
False
)
return
list
(
itertools
.
islice
(
ids
,
num_ids
))
def
_resolve_args_directness
(
self
,
argnames
:
Sequence
[
str
],
indirect
:
bool
|
Sequence
[
str
],
)
->
dict
[
str
,
Literal
[
"indirect"
,
"direct"
]]:
"""Resolve if each parametrized argument must be considered an indirect
parameter to a fixture of the same name, or a direct parameter to the
parametrized function, based on the ``indirect`` parameter of the
parametrized() call.
:param argnames:
List of argument names passed to ``parametrize()``.
:param indirect:
Same as the ``indirect`` parameter of ``parametrize()``.
:returns
A dict mapping each arg name to either "indirect" or "direct".
"""
arg_directness
:
dict
[
str
,
Literal
[
"indirect"
,
"direct"
]]
if
isinstance
(
indirect
,
bool
):
arg_directness
=
dict
.
fromkeys
(
argnames
,
"indirect"
if
indirect
else
"direct"
)
elif
isinstance
(
indirect
,
Sequence
):
arg_directness
=
dict
.
fromkeys
(
argnames
,
"direct"
)
for
arg
in
indirect
:
if
arg
not
in
argnames
:
fail
(
f
"In
{
self
.
function
.
__name__
}
: indirect fixture '
{
arg
}
' doesn't exist"
,
pytrace
=
False
,
)
arg_directness
[
arg
]
=
"indirect"
else
:
fail
(
f
"In
{
self
.
function
.
__name__
}
: expected Sequence or boolean"
f
" for indirect, got
{
type
(
indirect
)
.
__name__
}
"
,
pytrace
=
False
,
)
return
arg_directness
def
_validate_if_using_arg_names
(
self
,
argnames
:
Sequence
[
str
],
indirect
:
bool
|
Sequence
[
str
],
)
->
None
:
"""Check if all argnames are being used, by default values, or directly/indirectly.
:param List[str] argnames: List of argument names passed to ``parametrize()``.
:param indirect: Same as the ``indirect`` parameter of ``parametrize()``.
:raises ValueError: If validation fails.
"""
default_arg_names
=
set
(
get_default_arg_names
(
self
.
function
))
func_name
=
self
.
function
.
__name__
for
arg
in
argnames
:
if
arg
not
in
self
.
fixturenames
:
if
arg
in
default_arg_names
:
fail
(
f
"In
{
func_name
}
: function already takes an argument '
{
arg
}
' with a default value"
,
pytrace
=
False
,
)
else
:
if
isinstance
(
indirect
,
Sequence
):
name
=
"fixture"
if
arg
in
indirect
else
"argument"
else
:
name
=
"fixture"
if
indirect
else
"argument"
fail
(
f
"In
{
func_name
}
: function uses no
{
name
}
'
{
arg
}
'"
,
pytrace
=
False
,
)
def
_find_parametrized_scope
(
argnames
:
Sequence
[
str
],
arg2fixturedefs
:
Mapping
[
str
,
Sequence
[
fixtures
.
FixtureDef
[
object
]]],
indirect
:
bool
|
Sequence
[
str
],
)
->
Scope
:
"""Find the most appropriate scope for a parametrized call based on its arguments.
When there's at least one direct argument, always use "function" scope.
When a test function is parametrized and all its arguments are indirect
(e.g. fixtures), return the most narrow scope based on the fixtures used.
Related to issue #1832, based on code posted by @Kingdread.
"""
if
isinstance
(
indirect
,
Sequence
):
all_arguments_are_fixtures
=
len
(
indirect
)
==
len
(
argnames
)
else
:
all_arguments_are_fixtures
=
bool
(
indirect
)
if
all_arguments_are_fixtures
:
fixturedefs
=
arg2fixturedefs
or
{}
used_scopes
=
[
fixturedef
[
-
1
]
.
_scope
for
name
,
fixturedef
in
fixturedefs
.
items
()
if
name
in
argnames
]
# Takes the most narrow scope from used fixtures.
return
min
(
used_scopes
,
default
=
Scope
.
Function
)
return
Scope
.
Function
def
_ascii_escaped_by_config
(
val
:
str
|
bytes
,
config
:
Config
|
None
)
->
str
:
if
config
is
None
:
escape_option
=
False
else
:
escape_option
=
config
.
getini
(
"disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
)
# TODO: If escaping is turned off and the user passes bytes,
#       will return a bytes. For now we ignore this but the
#       code *probably* doesn't handle this case.
return
val
if
escape_option
else
ascii_escaped
(
val
)
# type: ignore
[docs]
class
Function
(
PyobjMixin
,
nodes
.
Item
):
"""Item responsible for setting up and executing a Python test function.
:param name:
The full function name, including any decorations like those
added by parametrization (``my_func[my_param]``).
:param parent:
The parent Node.
:param config:
The pytest Config object.
:param callspec:
If given, this function has been parametrized and the callspec contains
meta information about the parametrization.
:param callobj:
If given, the object which will be called when the Function is invoked,
otherwise the callobj will be obtained from ``parent`` using ``originalname``.
:param keywords:
Keywords bound to the function object for "-k" matching.
:param session:
The pytest Session object.
:param fixtureinfo:
Fixture information already resolved at this fixture node..
:param originalname:
The attribute name to use for accessing the underlying function object.
Defaults to ``name``. Set this if name is different from the original name,
for example when it contains decorations like those added by parametrization
(``my_func[my_param]``).
"""
# Disable since functions handle it themselves.
_ALLOW_MARKERS
=
False
def
__init__
(
self
,
name
:
str
,
parent
,
config
:
Config
|
None
=
None
,
callspec
:
CallSpec2
|
None
=
None
,
callobj
=
NOTSET
,
keywords
:
Mapping
[
str
,
Any
]
|
None
=
None
,
session
:
Session
|
None
=
None
,
fixtureinfo
:
FuncFixtureInfo
|
None
=
None
,
originalname
:
str
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
name
,
parent
,
config
=
config
,
session
=
session
)
if
callobj
is
not
NOTSET
:
self
.
_obj
=
callobj
self
.
_instance
=
getattr
(
callobj
,
"__self__"
,
None
)
#: Original function name, without any decorations (for example
#: parametrization adds a ``"[...]"`` suffix to function names), used to access
#: the underlying function object from ``parent`` (in case ``callobj`` is not given
#: explicitly).
#:
#: .. versionadded:: 3.0
self
.
originalname
=
originalname
or
name
# Note: when FunctionDefinition is introduced, we should change ``originalname``
# to a readonly property that returns FunctionDefinition.name.
self
.
own_markers
.
extend
(
get_unpacked_marks
(
self
.
obj
))
if
callspec
:
self
.
callspec
=
callspec
self
.
own_markers
.
extend
(
callspec
.
marks
)
# todo: this is a hell of a hack
# https://github.com/pytest-dev/pytest/issues/4569
# Note: the order of the updates is important here; indicates what
# takes priority (ctor argument over function attributes over markers).
# Take own_markers only; NodeKeywords handles parent traversal on its own.
self
.
keywords
.
update
((
mark
.
name
,
mark
)
for
mark
in
self
.
own_markers
)
self
.
keywords
.
update
(
self
.
obj
.
__dict__
)
if
keywords
:
self
.
keywords
.
update
(
keywords
)
if
fixtureinfo
is
None
:
fm
=
self
.
session
.
_fixturemanager
fixtureinfo
=
fm
.
getfixtureinfo
(
self
,
self
.
obj
,
self
.
cls
)
self
.
_fixtureinfo
:
FuncFixtureInfo
=
fixtureinfo
self
.
fixturenames
=
fixtureinfo
.
names_closure
self
.
_initrequest
()
# todo: determine sound type limitations
[docs]
@classmethod
def
from_parent
(
cls
,
parent
,
**
kw
)
->
Self
:
"""The public constructor."""
return
super
()
.
from_parent
(
parent
=
parent
,
**
kw
)
def
_initrequest
(
self
)
->
None
:
self
.
funcargs
:
dict
[
str
,
object
]
=
{}
self
.
_request
=
fixtures
.
TopRequest
(
self
,
_ispytest
=
True
)
@property
def
function
(
self
):
"""Underlying python 'function' object."""
return
getimfunc
(
self
.
obj
)
@property
def
instance
(
self
):
try
:
return
self
.
_instance
except
AttributeError
:
if
isinstance
(
self
.
parent
,
Class
):
# Each Function gets a fresh class instance.
self
.
_instance
=
self
.
_getinstance
()
else
:
self
.
_instance
=
None
return
self
.
_instance
def
_getinstance
(
self
):
if
isinstance
(
self
.
parent
,
Class
):
# Each Function gets a fresh class instance.
return
self
.
parent
.
newinstance
()
else
:
return
None
def
_getobj
(
self
):
instance
=
self
.
instance
if
instance
is
not
None
:
parent_obj
=
instance
else
:
assert
self
.
parent
is
not
None
parent_obj
=
self
.
parent
.
obj
# type: ignore[attr-defined]
return
getattr
(
parent_obj
,
self
.
originalname
)
@property
def
_pyfuncitem
(
self
):
"""(compatonly) for code expecting pytest-2.2 style request objects."""
return
self
[docs]
def
runtest
(
self
)
->
None
:
"""Execute the underlying test function."""
self
.
ihook
.
pytest_pyfunc_call
(
pyfuncitem
=
self
)
def
setup
(
self
)
->
None
:
self
.
_request
.
_fillfixtures
()
def
_traceback_filter
(
self
,
excinfo
:
ExceptionInfo
[
BaseException
])
->
Traceback
:
if
hasattr
(
self
,
"_obj"
)
and
not
self
.
config
.
getoption
(
"fulltrace"
,
False
):
code
=
_pytest
.
_code
.
Code
.
from_function
(
get_real_func
(
self
.
obj
))
path
,
firstlineno
=
code
.
path
,
code
.
firstlineno
traceback
=
excinfo
.
traceback
ntraceback
=
traceback
.
cut
(
path
=
path
,
firstlineno
=
firstlineno
)
if
ntraceback
==
traceback
:
ntraceback
=
ntraceback
.
cut
(
path
=
path
)
if
ntraceback
==
traceback
:
ntraceback
=
ntraceback
.
filter
(
filter_traceback
)
if
not
ntraceback
:
ntraceback
=
traceback
ntraceback
=
ntraceback
.
filter
(
excinfo
)
# issue364: mark all but first and last frames to
# only show a single-line message for each frame.
if
self
.
config
.
getoption
(
"tbstyle"
,
"auto"
)
==
"auto"
:
if
len
(
ntraceback
)
>
2
:
ntraceback
=
Traceback
(
(
ntraceback
[
0
],
*
(
t
.
with_repr_style
(
"short"
)
for
t
in
ntraceback
[
1
:
-
1
]),
ntraceback
[
-
1
],
)
)
return
ntraceback
return
excinfo
.
traceback
# TODO: Type ignored -- breaks Liskov Substitution.
[docs]
def
repr_failure
(
# type: ignore[override]
self
,
excinfo
:
ExceptionInfo
[
BaseException
],
)
->
str
|
TerminalRepr
:
style
=
self
.
config
.
getoption
(
"tbstyle"
,
"auto"
)
if
style
==
"auto"
:
style
=
"long"
return
self
.
_repr_failure_py
(
excinfo
,
style
=
style
)
[docs]
class
FunctionDefinition
(
Function
):
"""This class is a stop gap solution until we evolve to have actual function
definition nodes and manage to get rid of ``metafunc``."""
[docs]
def
runtest
(
self
)
->
None
:
raise
RuntimeError
(
"function definitions are not supposed to be run as tests"
)
setup
=
runtest

```


---


# Development Guide - pytest documentation

URL: https://docs.pytest.org/en/stable/development_guide.html


# Development Guide¶


---


# History - pytest documentation

URL: https://docs.pytest.org/en/stable/history.html


# History¶

pytest has a long and interesting history. The first commit in this repository is from January 2007, and even that commit alone already tells a lot: The repository originally was from the py library (later split off to pytest), and it originally was a SVN revision, migrated to Mercurial, and finally migrated to git. However, the commit says “create the new development trunk” and is already quite big: 435 files changed, 58640 insertions(+) . This is because pytest originally was born as part of PyPy , to make it easier to write tests for it. Here’s how it evolved from there to its own project: Late 2002 / early 2003, PyPy was born . Like that blog post mentioned, from very early on, there was a big focus on testing. There were various testsupport files on top of unittest.py, and as early as June 2003, Holger Krekel ( @hpk42 ) refactored its test framework to clean things up ( pypy.tool.test , but still on top of unittest.py , with nothing pytest-like yet). In December 2003, there was another iteration at improving their testing situation, by Stefan Schwarzer, called pypy.tool.newtest . However, it didn’t seem to be around for long, as around June/July 2004, efforts started on a thing called utest , offering plain assertions. This seems like the start of something pytest-like, but unfortunately, it’s unclear where the test runner’s code was at the time. The closest thing still around is this file , but that doesn’t seem like a complete test runner at all. What can be seen is that there were various efforts by Laura Creighton and Samuele Pedroni ( @pedronis ) at automatically converting existing tests to the new utest framework. Around the same time, for Europython 2004, @hpk42 started a project originally called “std”, intended to be a “complementary standard library” - already laying out the principles behind what later became pytest: current “batteries included” are very useful, but some of them are written in a pretty much java-like style, especially the unittest-framework […] the best API is one that doesn’t exist […] a testing package should require as few boilerplate code as possible and offer much flexibility it should provide premium quality tracebacks and debugging aid […] first of all … forget about limited “assertXYZ APIs” and use the real thing, e.g.:

```

assert
x
==
y

```


---


# Release announcements - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/index.html


# Release announcements¶


---


# Writing plugins - pytest documentation

URL: https://docs.pytest.org/en/stable/writing_plugins.html


# Writing plugins¶

It is easy to implement local conftest plugins for your own project or pip-installable plugins that can be used throughout many projects, including third party projects. Please refer to How to install and use plugins if you only want to use but not write plugins. A plugin contains one or multiple hook functions. Writing hooks explains the basics and details of how you can write a hook function yourself. pytest implements all aspects of configuration, collection, running and reporting by calling well specified hooks of the following plugins: builtin plugins: loaded from pytest’s internal _pytest directory. external plugins : installed third-party modules discovered through entry points in their packaging metadata conftest.py plugins : modules auto-discovered in test directories In principle, each hook call is a 1:N Python function call where N is the number of registered implementation functions for a given specification. All specifications and implementations follow the pytest_ prefix naming convention, making them easy to distinguish and find.

# Plugin discovery order at tool startup¶

pytest loads plugin modules at tool startup in the following way: by scanning the command line for the -p no:name option and blocking that plugin from being loaded (even builtin plugins can be blocked this way). This happens before normal command-line parsing. by loading all builtin plugins. by scanning the command line for the -p name option and loading the specified plugin. This happens before normal command-line parsing. by loading all plugins registered through installed third-party package entry points , unless the PYTEST_DISABLE_PLUGIN_AUTOLOAD environment variable is set. by loading all plugins specified through the PYTEST_PLUGINS environment variable. by loading all “initial “ conftest.py files: determine the test paths: specified on the command line, otherwise in testpaths if defined and running from the rootdir, otherwise the current dir for each test path, load conftest.py and test*/conftest.py relative to the directory part of the test path, if exist. Before a conftest.py file is loaded, load conftest.py files in all of its parent directories. After a conftest.py file is loaded, recursively load all plugins specified in its pytest_plugins variable if present.

# conftest.py: local per-directory plugins¶

Local conftest.py plugins contain directory-specific hook implementations. Hook Session and test running activities will invoke all hooks defined in conftest.py files closer to the root of the filesystem. Example of implementing the pytest_runtest_setup hook so that is called for tests in the a sub directory but not for other directories:

```

a
/
conftest
.
py
:
def
pytest_runtest_setup
(
item
):
# called for running each test in 'a' directory
print
(
"setting up"
,
item
)
a
/
test_sub
.
py
:
def
test_sub
():
pass
test_flat
.
py
:
def
test_flat
():
pass

```

Here is how you might run it:

```

pytest
test_flat
.
py
--
capture
=
no
# will not show "setting up"
pytest
a
/
test_sub
.
py
--
capture
=
no
# will show "setting up"

```

Note If you have conftest.py files which do not reside in a python package directory (i.e. one containing an __init__.py ) then “import conftest” can be ambiguous because there might be other conftest.py files as well on your PYTHONPATH or sys.path . It is thus good practice for projects to either put conftest.py under a package scope or to never import anything from a conftest.py file. See also: pytest import mechanisms and sys.path/PYTHONPATH . Note Some hooks cannot be implemented in conftest.py files which are not initial due to how pytest discovers plugins during startup. See the documentation of each hook for details.

# Writing your own plugin¶

If you want to write a plugin, there are many real-life examples you can copy from: a custom collection example plugin: A basic example for specifying tests in Yaml files builtin plugins which provide pytest’s own functionality many external plugins providing additional features All of these plugins implement hooks and/or fixtures to extend and add functionality. Note Make sure to check out the excellent cookiecutter-pytest-plugin project, which is a cookiecutter template for authoring plugins. The template provides an excellent starting point with a working plugin, tests running with tox, a comprehensive README file as well as a pre-configured entry-point. Also consider contributing your plugin to pytest-dev once it has some happy users other than yourself.

# Making your plugin installable by others¶

If you want to make your plugin externally available, you may define a so-called entry point for your distribution so that pytest finds your plugin module. Entry points are a feature that is provided by packaging tools . pytest looks up the pytest11 entrypoint to discover its plugins, thus you can make your plugin available by defining it in your pyproject.toml file.

```

# sample ./pyproject.toml file
[build-system]
requires
=
[
"hatchling"
]
build-backend
=
"hatchling.build"
[project]
name
=
"myproject"
classifiers
=
[
"Framework :: Pytest"
,
]
[project.entry-points.pytest11]
myproject
=
"myproject.pluginmodule"

```

If a package is installed this way, pytest will load myproject.pluginmodule as a plugin which can define hooks . Confirm registration with pytest --trace-config Note Make sure to include Framework :: Pytest in your list of PyPI classifiers to make it easy for users to find your plugin.

# Assertion Rewriting¶

One of the main features of pytest is the use of plain assert statements and the detailed introspection of expressions upon assertion failures. This is provided by “assertion rewriting” which modifies the parsed AST before it gets compiled to bytecode. This is done via a PEP 302 import hook which gets installed early on when pytest starts up and will perform this rewriting when modules get imported. However, since we do not want to test different bytecode from what you will run in production, this hook only rewrites test modules themselves (as defined by the python_files configuration option), and any modules which are part of plugins. Any other imported module will not be rewritten and normal assertion behaviour will happen. If you have assertion helpers in other modules where you would need assertion rewriting to be enabled you need to ask pytest explicitly to rewrite this module before it gets imported. Register one or more module names to be rewritten on import. This function will make sure that this module or all modules inside the package will get their assert statements rewritten. Thus you should make sure to call this before the module is actually imported, usually in your __init__.py if you are a plugin using a package. names ( str ) – The module names to register. This is especially important when you write a pytest plugin which is created using a package. The import hook only treats conftest.py files and any modules which are listed in the pytest11 entrypoint as plugins. As an example consider the following package:

```

pytest_foo
/
__init__
.
py
pytest_foo
/
plugin
.
py
pytest_foo
/
helper
.
py

```

With the following typical setup.py extract:

```

setup
(
...
,
entry_points
=
{
"pytest11"
:
[
"foo = pytest_foo.plugin"
]},
...
)

```

In this case only pytest_foo/plugin.py will be rewritten. If the helper module also contains assert statements which need to be rewritten it needs to be marked as such, before it gets imported. This is easiest by marking it for rewriting inside the __init__.py module, which will always be imported first when a module inside a package is imported. This way plugin.py can still import helper.py normally. The contents of pytest_foo/__init__.py will then need to look like this:

```

import
pytest
pytest
.
register_assert_rewrite
(
"pytest_foo.helper"
)

```

# Requiring/Loading plugins in a test module or conftest file¶

You can require plugins in a test module or a conftest.py file using pytest_plugins :

```

pytest_plugins
=
[
"name1"
,
"name2"
]

```

When the test module or conftest plugin is loaded the specified plugins will be loaded as well. Any module can be blessed as a plugin, including internal application modules:

```

pytest_plugins
=
"myapp.testsupport.myplugin"

```

pytest_plugins are processed recursively, so note that in the example above if myapp.testsupport.myplugin also declares pytest_plugins , the contents of the variable will also be loaded as plugins, and so on. Note Requiring plugins using pytest_plugins variable in non-root conftest.py files is deprecated. This is important because conftest.py files implement per-directory hook implementations, but once a plugin is imported, it will affect the entire directory tree. In order to avoid confusion, defining pytest_plugins in any conftest.py file which is not located in the tests root directory is deprecated, and will raise a warning. This mechanism makes it easy to share fixtures within applications or even external applications without the need to create external plugins using the entry point packaging metadata technique. Plugins imported by pytest_plugins will also automatically be marked for assertion rewriting (see pytest.register_assert_rewrite() ). However for this to have any effect the module must not be imported already; if it was already imported at the time the pytest_plugins statement is processed, a warning will result and assertions inside the plugin will not be rewritten. To fix this you can either call pytest.register_assert_rewrite() yourself before the module is imported, or you can arrange the code to delay the importing until after the plugin is registered.

# Accessing another plugin by name¶

If a plugin wants to collaborate with code from another plugin it can obtain a reference through the plugin manager like this:

```

plugin
=
config
.
pluginmanager
.
get_plugin
(
"name_of_plugin"
)

```

If you want to look at the names of existing plugins, use the --trace-config option.

# Registering custom markers¶

If your plugin uses any markers, you should register them so that they appear in pytest’s help text and do not cause spurious warnings . For example, the following plugin would register cool_marker and mark_with for all users:

```

def
pytest_configure
(
config
):
config
.
addinivalue_line
(
"markers"
,
"cool_marker: this one is for cool tests."
)
config
.
addinivalue_line
(
"markers"
,
"mark_with(arg, arg2): this marker takes arguments."
)

```

# Testing plugins¶

pytest comes with a plugin named pytester that helps you write tests for your plugin code. The plugin is disabled by default, so you will have to enable it before you can use it. You can do so by adding the following line to a conftest.py file in your testing directory:

```

# content of conftest.py
pytest_plugins
=
[
"pytester"
]

```

Alternatively you can invoke pytest with the -p pytester command line option. This will allow you to use the pytester fixture for testing your plugin code. Let’s demonstrate what you can do with the plugin with an example. Imagine we developed a plugin that provides a fixture hello which yields a function and we can invoke this function with one optional parameter. It will return a string value of Hello World! if we do not supply a value or Hello {value}! if we do supply a string value.

```

import
pytest
def
pytest_addoption
(
parser
):
group
=
parser
.
getgroup
(
"helloworld"
)
group
.
addoption
(
"--name"
,
action
=
"store"
,
dest
=
"name"
,
default
=
"World"
,
help
=
'Default "name" for hello().'
,
)
@pytest
.
fixture
def
hello
(
request
):
name
=
request
.
config
.
getoption
(
"name"
)
def
_hello
(
name
=
None
):
if
not
name
:
name
=
request
.
config
.
getoption
(
"name"
)
return
f
"Hello
{
name
}
!"
return
_hello

```

Now the pytester fixture provides a convenient API for creating temporary conftest.py files and test files. It also allows us to run the tests and return a result object, with which we can assert the tests’ outcomes.

```

def
test_hello
(
pytester
):
"""Make sure that our plugin works."""
# create a temporary conftest.py file
pytester
.
makeconftest
(
"""
import pytest
@pytest.fixture(params=[
"Brianna",
"Andreas",
"Floris",
])
def name(request):
return request.param
"""
)
# create a temporary pytest test file
pytester
.
makepyfile
(
"""
def test_hello_default(hello):
assert hello() == "Hello World!"
def test_hello_name(hello, name):
assert hello(name) == "Hello {0}!".format(name)
"""
)
# run all tests with pytest
result
=
pytester
.
runpytest
()
# check that all 4 tests passed
result
.
assert_outcomes
(
passed
=
4
)

```

Additionally it is possible to copy examples to the pytester ’s isolated environment before running pytest on it. This way we can abstract the tested logic to separate files, which is especially useful for longer tests and/or longer conftest.py files. Note that for pytester.copy_example to work we need to set pytester_example_dir in our pytest.ini to tell pytest where to look for example files.

```

# content of pytest.ini
[pytest]
pytester_example_dir
=
.

```

```

# content of test_example.py
def
test_plugin
(
pytester
):
pytester
.
copy_example
(
"test_example.py"
)
pytester
.
runpytest
(
"-k"
,
"test_example"
)
def
test_example
():
pass

```

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
configfile: pytest.ini
collected 2 items

test_example.py
..
[100%]
============================
2 passed
in 0.12s =============================

```


---


# How to manage logging - pytest documentation

URL: https://docs.pytest.org/en/stable/logging.html


# How to manage logging¶

pytest captures log messages of level WARNING or above automatically and displays them in their own section for each failed test in the same manner as captured stdout and stderr. Running without options:

```

pytest

```

Shows failed tests like so:

```

----------------------- Captured stdlog call ----------------------
test_reporting.py    26 WARNING  text going to logger
----------------------- Captured stdout call ----------------------
text going to stdout
----------------------- Captured stderr call ----------------------
text going to stderr
==================== 2 failed in 0.02 seconds =====================

```

By default each captured log message shows the module, line number, log level and message. If desired the log and date format can be specified to anything that the logging module supports by passing specific formatting options:

```

pytest
--log-format
=
"%(asctime)s %(levelname)s %(message)s"
\
--log-date-format
=
"%Y-%m-%d %H:%M:%S"

```

Shows failed tests like so:

```

----------------------- Captured stdlog call ----------------------
2010-04-10 14:48:44 WARNING text going to logger
----------------------- Captured stdout call ----------------------
text going to stdout
----------------------- Captured stderr call ----------------------
text going to stderr
==================== 2 failed in 0.02 seconds =====================

```

These options can also be customized through pytest.ini file:

```

[pytest]
log_format
=
%(asctime)s %(levelname)s %(message)s
log_date_format
=
%Y-%m-%d %H:%M:%S

```

Specific loggers can be disabled via --log-disable={logger_name} . This argument can be passed multiple times:

```

pytest
--log-disable
=
main
--log-disable
=
testing

```

Further it is possible to disable reporting of captured content (stdout, stderr and logs) on failed tests completely with:

```

pytest
--show-capture
=
no

```

# caplog fixture¶

Inside tests it is possible to change the log level for the captured log messages. This is supported by the caplog fixture:

```

def
test_foo
(
caplog
):
caplog
.
set_level
(
logging
.
INFO
)

```

By default the level is set on the root logger, however as a convenience it is also possible to set the log level of any logger:

```

def
test_foo
(
caplog
):
caplog
.
set_level
(
logging
.
CRITICAL
,
logger
=
"root.baz"
)

```

The log levels set are restored automatically at the end of the test. It is also possible to use a context manager to temporarily change the log level inside a with block:

```

def
test_bar
(
caplog
):
with
caplog
.
at_level
(
logging
.
INFO
):
pass

```

Again, by default the level of the root logger is affected but the level of any logger can be changed instead with:

```

def
test_bar
(
caplog
):
with
caplog
.
at_level
(
logging
.
CRITICAL
,
logger
=
"root.baz"
):
pass

```

Lastly all the logs sent to the logger during the test run are made available on the fixture in the form of both the logging.LogRecord instances and the final log text. This is useful for when you want to assert on the contents of a message:

```

def
test_baz
(
caplog
):
func_under_test
()
for
record
in
caplog
.
records
:
assert
record
.
levelname
!=
"CRITICAL"
assert
"wally"
not
in
caplog
.
text

```

For all the available attributes of the log records see the logging.LogRecord class. You can also resort to record_tuples if all you want to do is to ensure, that certain messages have been logged under a given logger name with a given severity and message:

```

def
test_foo
(
caplog
):
logging
.
getLogger
()
.
info
(
"boo
%s
"
,
"arg"
)
assert
caplog
.
record_tuples
==
[(
"root"
,
logging
.
INFO
,
"boo arg"
)]

```

You can call caplog.clear() to reset the captured log records in a test:

```

def
test_something_with_clearing_records
(
caplog
):
some_method_that_creates_log_records
()
caplog
.
clear
()
your_test_method
()
assert
[
"Foo"
]
==
[
rec
.
message
for
rec
in
caplog
.
records
]

```

The caplog.records attribute contains records from the current stage only, so inside the setup phase it contains only setup logs, same with the call and teardown phases. To access logs from other stages, use the caplog.get_records(when) method. As an example, if you want to make sure that tests which use a certain fixture never log any warnings, you can inspect the records for the setup and call stages during teardown like so:

```

@pytest
.
fixture
def
window
(
caplog
):
window
=
create_window
()
yield
window
for
when
in
(
"setup"
,
"call"
):
messages
=
[
x
.
message
for
x
in
caplog
.
get_records
(
when
)
if
x
.
levelno
==
logging
.
WARNING
]
if
messages
:
pytest
.
fail
(
f
"warning messages encountered during testing:
{
messages
}
"
)

```

The full API is available at pytest.LogCaptureFixture . Warning The caplog fixture adds a handler to the root logger to capture logs. If the root logger is modified during a test, for example with logging.config.dictConfig , this handler may be removed and cause no logs to be captured. To avoid this, ensure that any root logger configuration only adds to the existing handlers.

# Live Logs¶

By setting the log_cli configuration option to true , pytest will output logging records as they are emitted directly into the console. You can specify the logging level for which log records with equal or higher level are printed to the console by passing --log-cli-level . This setting accepts the logging level names or numeric values as seen in logging’s documentation . Additionally, you can also specify --log-cli-format and --log-cli-date-format which mirror and default to --log-format and --log-date-format if not provided, but are applied only to the console logging handler. All of the CLI log options can also be set in the configuration INI file. The option names are: log_cli_level log_cli_format log_cli_date_format If you need to record the whole test suite logging calls to a file, you can pass --log-file=/path/to/log/file . This log file is opened in write mode by default which means that it will be overwritten at each run tests session. If you’d like the file opened in append mode instead, then you can pass --log-file-mode=a . Note that relative paths for the log-file location, whether passed on the CLI or declared in a config file, are always resolved relative to the current working directory. You can also specify the logging level for the log file by passing --log-file-level . This setting accepts the logging level names or numeric values as seen in logging’s documentation . Additionally, you can also specify --log-file-format and --log-file-date-format which are equal to --log-format and --log-date-format but are applied to the log file logging handler. All of the log file options can also be set in the configuration INI file. The option names are: log_file log_file_mode log_file_level log_file_format log_file_date_format You can call set_log_path() to customize the log_file path dynamically. This functionality is considered experimental . Note that set_log_path() respects the log_file_mode option.

# Customizing Colors¶

Log levels are colored if colored terminal output is enabled. Changing from default colors or putting color on custom log levels is supported through add_color_level() . Example:

```

@pytest
.
hookimpl
(
trylast
=
True
)
def
pytest_configure
(
config
):
logging_plugin
=
config
.
pluginmanager
.
get_plugin
(
"logging-plugin"
)
# Change color on existing log level
logging_plugin
.
log_cli_handler
.
formatter
.
add_color_level
(
logging
.
INFO
,
"cyan"
)
# Add color to a custom log level (a custom log level `SPAM` is already set up)
logging_plugin
.
log_cli_handler
.
formatter
.
add_color_level
(
logging
.
SPAM
,
"blue"
)

```

Warning This feature and its API are considered experimental and might change between releases without a deprecation notice.

# Release notes¶

This feature was introduced as a drop-in replacement for the pytest-catchlog plugin and they conflict with each other. The backward compatibility API with pytest-capturelog has been dropped when this feature was introduced, so if for that reason you still need pytest-catchlog you can disable the internal feature by adding to your pytest.ini :

```

[pytest]
addopts
=
-p no:logging

```

# Incompatible changes in pytest 3.4¶

This feature was introduced in 3.3 and some incompatible changes have been made in 3.4 after community feedback: Log levels are no longer changed unless explicitly requested by the log_level configuration or --log-level command-line options. This allows users to configure logger objects themselves. Setting log_level will set the level that is captured globally so if a specific test requires a lower level than this, use the caplog.set_level() functionality otherwise that test will be prone to failure. Live Logs is now disabled by default and can be enabled setting the log_cli configuration option to true . When enabled, the verbosity is increased so logging for each test is visible. Live Logs are now sent to sys.stdout and no longer require the -s command-line option to work. If you want to partially restore the logging behavior of version 3.3 , you can add this options to your ini file:

```

[pytest]
log_cli
=
true
log_level
=
NOTSET

```


---


# How to write and report assertions in tests - pytest documentation

URL: https://docs.pytest.org/en/stable/assert.html


# How to write and report assertions in tests¶

# Asserting with theassertstatement¶

pytest allows you to use the standard Python assert for verifying expectations and values in Python tests. For example, you can write the following:

```

# content of test_assert1.py
def
f
():
return
3
def
test_function
():
assert
f
()
==
4

```

to assert that your function returns a certain value. If this assertion fails you will see the return value of the function call:

```

$ pytest test_assert1.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_assert1.py
F
[100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
def test_function():
>       assert f() == 4
E       assert 3 == 4
E        +  where 3 = f()
test_assert1.py
:6: AssertionError
========================= short test summary info ==========================
FAILED
test_assert1.py::
test_function
- assert 3 == 4
============================
1 failed
in 0.12s =============================

```

pytest has support for showing the values of the most common subexpressions including calls, attributes, comparisons, and binary and unary operators. (See Demo of Python failure reports with pytest ). This allows you to use the idiomatic python constructs without boilerplate code while not losing introspection information. If a message is specified with the assertion like this:

```

assert
a
%
2
==
0
,
"value was odd, should be even"

```

it is printed alongside the assertion introspection in the traceback. See Assertion introspection details for more information on assertion introspection.

# Assertions about expected exceptions¶

In order to write assertions about raised exceptions, you can use pytest.raises() as a context manager like this:

```

import
pytest
def
test_zero_division
():
with
pytest
.
raises
(
ZeroDivisionError
):
1
/
0

```

and if you need to have access to the actual exception info you may use:

```

def
test_recursion_depth
():
with
pytest
.
raises
(
RuntimeError
)
as
excinfo
:
def
f
():
f
()
f
()
assert
"maximum recursion"
in
str
(
excinfo
.
value
)

```

excinfo is an ExceptionInfo instance, which is a wrapper around the actual exception raised. The main attributes of interest are .type , .value and .traceback . Note that pytest.raises will match the exception type or any subclasses (like the standard except statement). If you want to check if a block of code is raising an exact exception type, you need to check that explicitly:

```

def
test_foo_not_implemented
():
def
foo
():
raise
NotImplementedError
with
pytest
.
raises
(
RuntimeError
)
as
excinfo
:
foo
()
assert
excinfo
.
type
is
RuntimeError

```

The pytest.raises() call will succeed, even though the function raises NotImplementedError , because NotImplementedError is a subclass of RuntimeError ; however the following assert statement will catch the problem.

# Matching exception messages¶

You can pass a match keyword parameter to the context-manager to test that a regular expression matches on the string representation of an exception (similar to the TestCase.assertRaisesRegex method from unittest ):

```

import
pytest
def
myfunc
():
raise
ValueError
(
"Exception 123 raised"
)
def
test_match
():
with
pytest
.
raises
(
ValueError
,
match
=
r
".* 123 .*"
):
myfunc
()

```

Notes: The match parameter is matched with the re.search() function, so in the above example match='123' would have worked as well. The match parameter also matches against PEP-678 __notes__ .

# Matching exception groups¶

You can also use the excinfo.group_contains() method to test for exceptions returned as part of an ExceptionGroup :

```

def
test_exception_in_group
():
with
pytest
.
raises
(
ExceptionGroup
)
as
excinfo
:
raise
ExceptionGroup
(
"Group message"
,
[
RuntimeError
(
"Exception 123 raised"
),
],
)
assert
excinfo
.
group_contains
(
RuntimeError
,
match
=
r
".* 123 .*"
)
assert
not
excinfo
.
group_contains
(
TypeError
)

```

The optional match keyword parameter works the same way as for pytest.raises() . By default group_contains() will recursively search for a matching exception at any level of nested ExceptionGroup instances. You can specify a depth keyword parameter if you only want to match an exception at a specific level; exceptions contained directly in the top ExceptionGroup would match depth=1 .

```

def
test_exception_in_group_at_given_depth
():
with
pytest
.
raises
(
ExceptionGroup
)
as
excinfo
:
raise
ExceptionGroup
(
"Group message"
,
[
RuntimeError
(),
ExceptionGroup
(
"Nested group"
,
[
TypeError
(),
],
),
],
)
assert
excinfo
.
group_contains
(
RuntimeError
,
depth
=
1
)
assert
excinfo
.
group_contains
(
TypeError
,
depth
=
2
)
assert
not
excinfo
.
group_contains
(
RuntimeError
,
depth
=
2
)
assert
not
excinfo
.
group_contains
(
TypeError
,
depth
=
1
)

```

# Alternate form (legacy)¶

There is an alternate form where you pass a function that will be executed, along *args and **kwargs , and pytest.raises() will execute the function with the arguments and assert that the given exception is raised:

```

def
func
(
x
):
if
x
<=
0
:
raise
ValueError
(
"x needs to be larger than zero"
)
pytest
.
raises
(
ValueError
,
func
,
x
=-
1
)

```

The reporter will provide you with helpful output in case of failures such as no exception or wrong exception . This form was the original pytest.raises() API, developed before the with statement was added to the Python language. Nowadays, this form is rarely used, with the context-manager form (using with ) being considered more readable. Nonetheless, this form is fully supported and not deprecated in any way.

# xfail mark and pytest.raises¶

It is also possible to specify a raises argument to pytest.mark.xfail , which checks that the test is failing in a more specific way than just having any exception raised:

```

def
f
():
raise
IndexError
()
@pytest
.
mark
.
xfail
(
raises
=
IndexError
)
def
test_f
():
f
()

```

This will only “xfail” if the test fails by raising IndexError or subclasses. Using pytest.mark.xfail with the raises parameter is probably better for something like documenting unfixed bugs (where the test describes what “should” happen) or bugs in dependencies. Using pytest.raises() is likely to be better for cases where you are testing exceptions your own code is deliberately raising, which is the majority of cases.

# Assertions about expected warnings¶

You can check that code raises a particular warning using pytest.warns .

# Making use of context-sensitive comparisons¶

pytest has rich support for providing context-sensitive information when it encounters comparisons. For example:

```

# content of test_assert2.py
def
test_set_comparison
():
set1
=
set
(
"1308"
)
set2
=
set
(
"8035"
)
assert
set1
==
set2

```

if you run this module:

```

$ pytest test_assert2.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_assert2.py
F
[100%]
================================= FAILURES =================================
___________________________ test_set_comparison ____________________________
def test_set_comparison():
        set1 = set("1308")
        set2 = set("8035")
>       assert set1 == set2
E       AssertionError: assert {'0', '1', '3', '8'} == {'0', '3', '5', '8'}
E
E         Extra items in the left set:
E         '1'
E         Extra items in the right set:
E         '5'
E         Use -v to get more diff
test_assert2.py
:4: AssertionError
========================= short test summary info ==========================
FAILED
test_assert2.py::
test_set_comparison
- AssertionError: assert {'0'...
============================
1 failed
in 0.12s =============================

```

Special comparisons are done for a number of cases: comparing long strings: a context diff is shown comparing long sequences: first failing indices comparing dicts: different entries See the reporting demo for many more examples.

# Defining your own explanation for failed assertions¶

It is possible to add your own detailed explanations by implementing the pytest_assertrepr_compare hook. Return explanation for comparisons in failing assert expressions. Return None for no custom explanation, otherwise return a list of strings. The strings will be joined by newlines but any newlines in a string will be escaped. Note that all but the first line will be indented slightly, the intention is for the first line to be a summary. config ( Config ) – The pytest config object. op ( str ) – The operator, e.g. "==" , "!=" , "not in" . left ( object ) – The left operand. right ( object ) – The right operand.

# Use in conftest plugins¶

Any conftest file can implement this hook. For a given item, only conftest files in the item’s directory and its parent directories are consulted. As an example consider adding the following hook in a conftest.py file which provides an alternative explanation for Foo objects:

```

# content of conftest.py
from
test_foocompare
import
Foo
def
pytest_assertrepr_compare
(
op
,
left
,
right
):
if
isinstance
(
left
,
Foo
)
and
isinstance
(
right
,
Foo
)
and
op
==
"=="
:
return
[
"Comparing Foo instances:"
,
f
"   vals:
{
left
.
val
}
!=
{
right
.
val
}
"
,
]

```

now, given this test module:

```

# content of test_foocompare.py
class
Foo
:
def
__init__
(
self
,
val
):
self
.
val
=
val
def
__eq__
(
self
,
other
):
return
self
.
val
==
other
.
val
def
test_compare
():
f1
=
Foo
(
1
)
f2
=
Foo
(
2
)
assert
f1
==
f2

```

you can run the test module and get the custom output defined in the conftest file:

```

$ pytest -q test_foocompare.py
F
[100%]
================================= FAILURES =================================
_______________________________ test_compare _______________________________
def test_compare():
        f1 = Foo(1)
        f2 = Foo(2)
>       assert f1 == f2
E       assert Comparing Foo instances:
E            vals: 1 != 2
test_foocompare.py
:12: AssertionError
========================= short test summary info ==========================
FAILED
test_foocompare.py::
test_compare
- assert Comparing Foo instances:
1 failed
in 0.12s

```

# Assertion introspection details¶

Reporting details about a failing assertion is achieved by rewriting assert statements before they are run. Rewritten assert statements put introspection information into the assertion failure message. pytest only rewrites test modules directly discovered by its test collection process, so asserts in supporting modules which are not themselves test modules will not be rewritten . You can manually enable assertion rewriting for an imported module by calling register_assert_rewrite before you import it (a good place to do that is in your root conftest.py ). For further information, Benjamin Peterson wrote up Behind the scenes of pytest’s new assertion rewriting .

# Assertion rewriting caches files on disk¶

pytest will write back the rewritten modules to disk for caching. You can disable this behavior (for example to avoid leaving stale .pyc files around in projects that move files around a lot) by adding this to the top of your conftest.py file:

```

import
sys
sys
.
dont_write_bytecode
=
True

```

Note that you still get the benefits of assertion introspection, the only change is that the .pyc files won’t be cached on disk. Additionally, rewriting will silently skip caching if it cannot write new .pyc files, i.e. in a read-only filesystem or a zipfile.

# Disabling assert rewriting¶


---


# How to use unittest-based tests with pytest - pytest documentation

URL: https://docs.pytest.org/en/stable/unittest.html


# How to useunittest-based tests with pytest¶

pytest supports running Python unittest -based tests out of the box. It’s meant for leveraging existing unittest -based test suites to use pytest as a test runner and also allow to incrementally adapt the test suite to take full advantage of pytest’s features. To run an existing unittest -style test suite using pytest , type:

```

pytest
tests

```

pytest will automatically collect unittest.TestCase subclasses and their test methods in test_*.py or *_test.py files. Almost all unittest features are supported: @unittest.skip style decorators; setUp/tearDown ; setUpClass/tearDownClass ; setUpModule/tearDownModule ; Additionally, subtests are supported by the pytest-subtests plugin. Up to this point pytest does not have support for the following features: load_tests protocol ;

# Benefits out of the box¶

By running your test suite with pytest you can make use of several features, in most cases without having to modify existing code: Obtain more informative tracebacks ; stdout and stderr capturing; Test selection options using -k and -m flags; Stopping after the first (or N) failures ; –pdb command-line option for debugging on test failures (see note below); Distribute tests to multiple CPUs using the pytest-xdist plugin; Use plain assert-statements instead of self.assert* functions ( unittest2pytest is immensely helpful in this);

# pytest features inunittest.TestCasesubclasses¶

The following pytest features work in unittest.TestCase subclasses: Marks : skip , skipif , xfail ; Auto-use fixtures ; The following pytest features do not work, and probably never will due to different design philosophies: Fixtures (except for autouse fixtures, see below ); Parametrization ; Custom hooks ; Third party plugins may or may not work well, depending on the plugin and the test suite.

# Mixing pytest fixtures intounittest.TestCasesubclasses using marks¶

Running your unittest with pytest allows you to use its fixture mechanism with unittest.TestCase style tests. Assuming you have at least skimmed the pytest fixture features, let’s jump-start into an example that integrates a pytest db_class fixture, setting up a class-cached database object, and then reference it from a unittest-style test:

```

# content of conftest.py
# we define a fixture function below and it will be "used" by
# referencing its name from tests
import
pytest
@pytest
.
fixture
(
scope
=
"class"
)
def
db_class
(
request
):
class
DummyDB
:
pass
# set a class attribute on the invoking test context
request
.
cls
.
db
=
DummyDB
()

```

This defines a fixture function db_class which - if used - is called once for each test class and which sets the class-level db attribute to a DummyDB instance. The fixture function achieves this by receiving a special request object which gives access to the requesting test context such as the cls attribute, denoting the class from which the fixture is used. This architecture de-couples fixture writing from actual test code and allows reuse of the fixture by a minimal reference, the fixture name. So let’s write an actual unittest.TestCase class using our fixture definition:

```

# content of test_unittest_db.py
import
unittest
import
pytest
@pytest
.
mark
.
usefixtures
(
"db_class"
)
class
MyTest
(
unittest
.
TestCase
):
def
test_method1
(
self
):
assert
hasattr
(
self
,
"db"
)
assert
0
,
self
.
db
# fail for demo purposes
def
test_method2
(
self
):
assert
0
,
self
.
db
# fail for demo purposes

```

The @pytest.mark.usefixtures("db_class") class-decorator makes sure that the pytest fixture function db_class is called once per class. Due to the deliberately failing assert statements, we can take a look at the self.db values in the traceback:

```

$ pytest test_unittest_db.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items

test_unittest_db.py
FF
[100%]
================================= FAILURES =================================
___________________________ MyTest.test_method1 ____________________________
self = <test_unittest_db.MyTest testMethod=test_method1>

    def test_method1(self):
        assert hasattr(self, "db")
>       assert 0, self.db  # fail for demo purposes
E       AssertionError: <conftest.db_class.<locals>.DummyDB object at 0xdeadbeef0001>
E       assert 0
test_unittest_db.py
:11: AssertionError
___________________________ MyTest.test_method2 ____________________________
self = <test_unittest_db.MyTest testMethod=test_method2>

    def test_method2(self):
>       assert 0, self.db  # fail for demo purposes
E       AssertionError: <conftest.db_class.<locals>.DummyDB object at 0xdeadbeef0001>
E       assert 0
test_unittest_db.py
:14: AssertionError
========================= short test summary info ==========================
FAILED
test_unittest_db.py::
MyTest::test_method1
- AssertionError: <conft...
FAILED
test_unittest_db.py::
MyTest::test_method2
- AssertionError: <conft...
============================
2 failed
in 0.12s =============================

```

This default pytest traceback shows that the two test methods share the same self.db instance which was our intention when writing the class-scoped fixture function above.

# Using autouse fixtures and accessing other fixtures¶

Although it’s usually better to explicitly declare use of fixtures you need for a given test, you may sometimes want to have fixtures that are automatically used in a given context. After all, the traditional style of unittest-setup mandates the use of this implicit fixture writing and chances are, you are used to it or like it. You can flag fixture functions with @pytest.fixture(autouse=True) and define the fixture function in the context where you want it used. Let’s look at an initdir fixture which makes all test methods of a TestCase class execute in a temporary directory with a pre-initialized samplefile.ini . Our initdir fixture itself uses the pytest builtin tmp_path fixture to delegate the creation of a per-test temporary directory:

```

# content of test_unittest_cleandir.py
import
unittest
import
pytest
class
MyTest
(
unittest
.
TestCase
):
@pytest
.
fixture
(
autouse
=
True
)
def
initdir
(
self
,
tmp_path
,
monkeypatch
):
monkeypatch
.
chdir
(
tmp_path
)
# change to pytest-provided temporary directory
tmp_path
.
joinpath
(
"samplefile.ini"
)
.
write_text
(
"# testdata"
,
encoding
=
"utf-8"
)
def
test_method
(
self
):
with
open
(
"samplefile.ini"
,
encoding
=
"utf-8"
)
as
f
:
s
=
f
.
read
()
assert
"testdata"
in
s

```

Due to the autouse flag the initdir fixture function will be used for all methods of the class where it is defined. This is a shortcut for using a @pytest.mark.usefixtures("initdir") marker on the class like in the previous example. Running this test module …:

```

$ pytest -q test_unittest_cleandir.py
.
[100%]
1 passed
in 0.12s

```


---


# How to invoke pytest - pytest documentation

URL: https://docs.pytest.org/en/stable/usage.html


# How to invoke pytest¶

See also Complete pytest command-line flag reference In general, pytest is invoked with the command pytest (see below for other ways to invoke pytest ). This will execute all tests in all files whose names follow the form test_*.py or \*_test.py in the current directory and its subdirectories. More generally, pytest follows standard test discovery rules .

# Specifying which tests to run¶

Pytest supports several ways to run and select tests from the command-line or from a file (see below for reading arguments from file ). Run tests in a module

```

pytest
test_mod.py

```

Run tests in a directory

```

pytest
testing/

```

Run tests by keyword expressions

```

pytest
-k
'MyClass and not method'

```

This will run tests which contain names that match the given string expression (case-insensitive), which can include Python operators that use filenames, class names and function names as variables. The example above will run TestMyClass.test_something but not TestMyClass.test_method_simple . Use "" instead of '' in expression when running this on Windows Run tests by collection arguments Pass the module filename relative to the working directory, followed by specifiers like the class name and function name separated by :: characters, and parameters from parameterization enclosed in [] . To run a specific test within a module:

```

pytest
tests/test_mod.py::test_func

```

To run all tests in a class:

```

pytest
tests/test_mod.py::TestClass

```

Specifying a specific test method:

```

pytest
tests/test_mod.py::TestClass::test_method

```

Specifying a specific parametrization of a test:

```

pytest
tests/test_mod.py::test_func
[
x1,y2
]

```

Run tests by marker expressions To run all tests which are decorated with the @pytest.mark.slow decorator:

```

pytest
-m
slow

```

To run all tests which are decorated with the annotated @pytest.mark.slow(phase=1) decorator, with the phase keyword argument set to 1 :

```

pytest
-m
"slow(phase=1)"

```

For more information see marks . Run tests from packages

```

pytest
--pyargs
pkg.testing

```

This will import pkg.testing and use its filesystem location to find and run tests from. Read arguments from file Added in version 8.2. All of the above can be read from a file using the @ prefix:

```

pytest
@tests_to_run.txt

```

where tests_to_run.txt contains an entry per line, e.g.:

```

tests/test_file.py
tests/test_mod.py::test_func[x1,y2]
tests/test_mod.py::TestClass
-m slow

```

This file can also be generated using pytest --collect-only -q and modified as needed.

# Getting help on version, option names, environment variables¶

```

pytest
--version
# shows where pytest was imported from
pytest
--fixtures
# show available builtin function arguments
pytest
-h
|
--help
# show help on command line and config file options

```

# Profiling test execution duration¶

Changed in version 6.0. To get a list of the slowest 10 test durations over 1.0s long:

```

pytest
--durations
=
10
--durations-min
=
1
.0

```

By default, pytest will not show test durations that are too small (<0.005s) unless -vv is passed on the command-line.

# Managing loading of plugins¶

# Early loading plugins¶

You can early-load plugins (internal and external) explicitly in the command-line with the -p option:

```

pytest
-
p
mypluginmodule

```

The option receives a name parameter, which can be: A full module dotted name, for example myproject.plugins . This dotted name must be importable. The entry-point name of a plugin. This is the name passed to importlib when the plugin is registered. For example to early-load the pytest-cov plugin you can use:

```

pytest
-
p
pytest_cov

```

# Disabling plugins¶

To disable loading specific plugins at invocation time, use the -p option together with the prefix no: . Example: to disable loading the plugin doctest , which is responsible for executing doctest tests from text files, invoke pytest like this:

```

pytest
-p
no:doctest

```

# Other ways of calling pytest¶

# Calling pytest throughpython-mpytest¶

You can invoke testing through the Python interpreter from the command line:

```

python -m pytest [...]

```

This is almost equivalent to invoking the command line script pytest [...] directly, except that calling via python will also add the current directory to sys.path .

# Calling pytest from Python code¶

You can invoke pytest from Python code directly:

```

retcode
=
pytest
.
main
()

```

this acts as if you would call “pytest” from the command line. It will not raise SystemExit but return the exit code instead. If you don’t pass it any arguments, main reads the arguments from the command line arguments of the process ( sys.argv ), which may be undesirable. You can pass in options and arguments explicitly:

```

retcode
=
pytest
.
main
([
"-x"
,
"mytestdir"
])

```

You can specify additional plugins to pytest.main :

```

# content of myinvoke.py
import
sys
import
pytest
class
MyPlugin
:
def
pytest_sessionfinish
(
self
):
print
(
"*** test run reporting finishing"
)
if
__name__
==
"__main__"
:
sys
.
exit
(
pytest
.
main
([
"-qq"
],
plugins
=
[
MyPlugin
()]))

```

Running it will show that MyPlugin was added and its hook was invoked:

```

$ python myinvoke.py
*** test run reporting finishing

```


---


# How to use skip and xfail to deal with tests that cannot succeed - pytest documentation

URL: https://docs.pytest.org/en/stable/skipping.html


# How to use skip and xfail to deal with tests that cannot succeed¶

You can mark test functions that cannot be run on certain platforms or that you expect to fail so pytest can deal with them accordingly and present a summary of the test session, while keeping the test suite green . A skip means that you expect your test to pass only if some conditions are met, otherwise pytest should skip running the test altogether. Common examples are skipping windows-only tests on non-windows platforms, or skipping tests that depend on an external resource which is not available at the moment (for example a database). An xfail means that you expect a test to fail for some reason. A common example is a test for a feature not yet implemented, or a bug not yet fixed. When a test passes despite being expected to fail (marked with pytest.mark.xfail ), it’s an xpass and will be reported in the test summary. pytest counts and lists skip and xfail tests separately. Detailed information about skipped/xfailed tests is not shown by default to avoid cluttering the output. You can use the -r option to see details corresponding to the “short” letters shown in the test progress:

```

pytest
-rxXs
# show extra info on xfailed, xpassed, and skipped tests

```

More details on the -r option can be found by running pytest -h . (See Builtin configuration file options )

# Skipping test functions¶

The simplest way to skip a test function is to mark it with the skip decorator which may be passed an optional reason :

```

@pytest
.
mark
.
skip
(
reason
=
"no way of currently testing this"
)
def
test_the_unknown
():
...

```

Alternatively, it is also possible to skip imperatively during test execution or setup by calling the pytest.skip(reason) function:

```

def
test_function
():
if
not
valid_config
():
pytest
.
skip
(
"unsupported configuration"
)

```

The imperative method is useful when it is not possible to evaluate the skip condition during import time. It is also possible to skip the whole module using pytest.skip(reason, allow_module_level=True) at the module level:

```

import
sys
import
pytest
if
not
sys
.
platform
.
startswith
(
"win"
):
pytest
.
skip
(
"skipping windows-only tests"
,
allow_module_level
=
True
)

```

Reference : pytest.mark.skip

# skipif¶

If you wish to skip something conditionally then you can use skipif instead. Here is an example of marking a test function to be skipped when run on an interpreter earlier than Python3.10:

```

import
sys
@pytest
.
mark
.
skipif
(
sys
.
version_info
<
(
3
,
10
),
reason
=
"requires python3.10 or higher"
)
def
test_function
():
...

```

If the condition evaluates to True during collection, the test function will be skipped, with the specified reason appearing in the summary when using -rs . You can share skipif markers between modules. Consider this test module:

```

# content of test_mymodule.py
import
mymodule
minversion
=
pytest
.
mark
.
skipif
(
mymodule
.
__versioninfo__
<
(
1
,
1
),
reason
=
"at least mymodule-1.1 required"
)
@minversion
def
test_function
():
...

```

You can import the marker and reuse it in another test module:

```

# test_myothermodule.py
from
test_mymodule
import
minversion
@minversion
def
test_anotherfunction
():
...

```

For larger test suites it’s usually a good idea to have one file where you define the markers which you then consistently apply throughout your test suite. Alternatively, you can use condition strings instead of booleans, but they can’t be shared between modules easily so they are supported mainly for backward compatibility reasons. Reference : pytest.mark.skipif

# Skip all test functions of a class or module¶

You can use the skipif marker (as any other marker) on classes:

```

@pytest
.
mark
.
skipif
(
sys
.
platform
==
"win32"
,
reason
=
"does not run on windows"
)
class
TestPosixCalls
:
def
test_function
(
self
):
"will not be setup or run under 'win32' platform"

```

If the condition is True , this marker will produce a skip result for each of the test methods of that class. If you want to skip all test functions of a module, you may use the pytestmark global:

```

# test_module.py
pytestmark
=
pytest
.
mark
.
skipif
(
...
)

```

If multiple skipif decorators are applied to a test function, it will be skipped if any of the skip conditions is true.

# Skipping files or directories¶

Sometimes you may need to skip an entire file or directory, for example if the tests rely on Python version-specific features or contain code that you do not wish pytest to run. In this case, you must exclude the files and directories from collection. Refer to Customizing test collection for more information.

# Skipping on a missing import dependency¶

You can skip tests on a missing import by using pytest.importorskip at module level, within a test, or test setup function.

```

docutils
=
pytest
.
importorskip
(
"docutils"
)

```

If docutils cannot be imported here, this will lead to a skip outcome of the test. You can also skip based on the version number of a library:

```

docutils
=
pytest
.
importorskip
(
"docutils"
,
minversion
=
"0.3"
)

```

The version will be read from the specified module’s __version__ attribute.

# Summary¶

Here’s a quick guide on how to skip tests in a module in different situations: Skip all tests in a module unconditionally:

```

pytestmark
=
pytest
.
mark
.
skip
(
"all tests still WIP"
)

```

Skip all tests in a module based on some condition:

```

pytestmark
=
pytest
.
mark
.
skipif
(
sys
.
platform
==
"win32"
,
reason
=
"tests for linux only"
)

```

Skip all tests in a module if some import is missing:

```

pexpect
=
pytest
.
importorskip
(
"pexpect"
)

```

# XFail: mark test functions as expected to fail¶

You can use the xfail marker to indicate that you expect a test to fail:

```

@pytest
.
mark
.
xfail
def
test_function
():
...

```

This test will run but no traceback will be reported when it fails. Instead, terminal reporting will list it in the “expected to fail” ( XFAIL ) or “unexpectedly passing” ( XPASS ) sections. Alternatively, you can also mark a test as XFAIL from within the test or its setup function imperatively:

```

def
test_function
():
if
not
valid_config
():
pytest
.
xfail
(
"failing configuration (but should work)"
)

```

```

def
test_function2
():
import
slow_module
if
slow_module
.
slow_function
():
pytest
.
xfail
(
"slow_module taking too long"
)

```

These two examples illustrate situations where you don’t want to check for a condition at the module level, which is when a condition would otherwise be evaluated for marks. This will make test_function XFAIL . Note that no other code is executed after the pytest.xfail() call, differently from the marker. That’s because it is implemented internally by raising a known exception. Reference : pytest.mark.xfail

# conditionparameter¶

If a test is only expected to fail under a certain condition, you can pass that condition as the first parameter:

```

@pytest
.
mark
.
xfail
(
sys
.
platform
==
"win32"
,
reason
=
"bug in a 3rd party library"
)
def
test_function
():
...

```

Note that you have to pass a reason as well (see the parameter description at pytest.mark.xfail ).

# reasonparameter¶

You can specify the motive of an expected failure with the reason parameter:

```

@pytest
.
mark
.
xfail
(
reason
=
"known parser issue"
)
def
test_function
():
...

```

# raisesparameter¶

If you want to be more specific as to why the test is failing, you can specify a single exception, or a tuple of exceptions, in the raises argument.

```

@pytest
.
mark
.
xfail
(
raises
=
RuntimeError
)
def
test_function
():
...

```

Then the test will be reported as a regular failure if it fails with an exception not mentioned in raises .

# runparameter¶

If a test should be marked as xfail and reported as such but should not be even executed, use the run parameter as False :

```

@pytest
.
mark
.
xfail
(
run
=
False
)
def
test_function
():
...

```

This is specially useful for xfailing tests that are crashing the interpreter and should be investigated later.

# strictparameter¶

Both XFAIL and XPASS don’t fail the test suite by default. You can change this by setting the strict keyword-only parameter to True :

```

@pytest
.
mark
.
xfail
(
strict
=
True
)
def
test_function
():
...

```

This will make XPASS (“unexpectedly passing”) results from this test to fail the test suite. You can change the default value of the strict parameter using the xfail_strict ini option:

```

[pytest]
xfail_strict
=
true

```

# Ignoring xfail¶

By specifying on the commandline:

```

pytest
--runxfail

```

you can force the running and reporting of an xfail marked test as if it weren’t marked at all. This also causes pytest.xfail() to produce no effect.

# Examples¶

Here is a simple test file with the several usages:

```

from
__future__
import
annotations
import
pytest
xfail
=
pytest
.
mark
.
xfail
@xfail
def
test_hello
():
assert
0
@xfail
(
run
=
False
)
def
test_hello2
():
assert
0
@xfail
(
"hasattr(os, 'sep')"
)
def
test_hello3
():
assert
0
@xfail
(
reason
=
"bug 110"
)
def
test_hello4
():
assert
0
@xfail
(
'pytest.__version__[0] != "17"'
)
def
test_hello5
():
assert
0
def
test_hello6
():
pytest
.
xfail
(
"reason"
)
@xfail
(
raises
=
IndexError
)
def
test_hello7
():
x
=
[]
x
[
1
]
=
1

```

Running it with the report-on-xfail option gives this output:

```

! pytest -rx xfail_demo.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR/example
collected 7 items

xfail_demo.py
xxxxxxx
[100%]
========================= short test summary info ==========================
XFAIL xfail_demo.py::test_hello
XFAIL xfail_demo.py::test_hello2
  reason: [NOTRUN]
XFAIL xfail_demo.py::test_hello3
  condition: hasattr(os, 'sep')
XFAIL xfail_demo.py::test_hello4
  bug 110
XFAIL xfail_demo.py::test_hello5
  condition: pytest.__version__[0] != "17"
XFAIL xfail_demo.py::test_hello6
  reason: reason
XFAIL xfail_demo.py::test_hello7
============================
7 xfailed
in 0.12s ============================

```

# Skip/xfail with parametrize¶

It is possible to apply markers like skip and xfail to individual test instances when using parametrize:

```

import
sys
import
pytest
@pytest
.
mark
.
parametrize
(
(
"n"
,
"expected"
),
[
(
1
,
2
),
pytest
.
param
(
1
,
0
,
marks
=
pytest
.
mark
.
xfail
),
pytest
.
param
(
1
,
3
,
marks
=
pytest
.
mark
.
xfail
(
reason
=
"some bug"
)),
(
2
,
3
),
(
3
,
4
),
(
4
,
5
),
pytest
.
param
(
10
,
11
,
marks
=
pytest
.
mark
.
skipif
(
sys
.
version_info
>=
(
3
,
0
),
reason
=
"py2k"
)
),
],
)
def
test_increment
(
n
,
expected
):
assert
n
+
1
==
expected

```


---


# How to re-run failed tests and maintain state between test runs - pytest documentation

URL: https://docs.pytest.org/en/stable/cache.html


# How to re-run failed tests and maintain state between test runs¶

# Usage¶

The plugin provides two command line options to rerun failures from the last pytest invocation: --lf , --last-failed - to only re-run the failures. --ff , --failed-first - to run the failures first and then the rest of the tests. For cleanup (usually not needed), a --cache-clear option allows to remove all cross-session cache contents ahead of a test run. Other plugins may access the config.cache object to set/get json encodable values between pytest invocations. Note This plugin is enabled by default, but can be disabled if needed: see Deactivating / unregistering a plugin by name (the internal name for this plugin is cacheprovider ).

# Rerunning only failures or failures first¶

First, let’s create 50 test invocation of which only 2 fail:

```

# content of test_50.py
import
pytest
@pytest
.
mark
.
parametrize
(
"i"
,
range
(
50
))
def
test_num
(
i
):
if
i
in
(
17
,
25
):
pytest
.
fail
(
"bad luck"
)

```

If you run this for the first time you will see two failures:

```

$ pytest -q
.................
F
.......
F
........................
[100%]
================================= FAILURES =================================
_______________________________ test_num[17] _______________________________
i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
_______________________________ test_num[25] _______________________________
i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
========================= short test summary info ==========================
FAILED
test_50.py::
test_num[17]
- Failed: bad luck
FAILED
test_50.py::
test_num[25]
- Failed: bad luck
2 failed
,
48 passed
in 0.12s

```

If you then run it with --lf :

```

$ pytest --lf
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 2 items
run-last-failure: rerun previous 2 failures

test_50.py
FF
[100%]
================================= FAILURES =================================
_______________________________ test_num[17] _______________________________
i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
_______________________________ test_num[25] _______________________________
i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
========================= short test summary info ==========================
FAILED
test_50.py::
test_num[17]
- Failed: bad luck
FAILED
test_50.py::
test_num[25]
- Failed: bad luck
============================
2 failed
in 0.12s =============================

```

You have run only the two failing tests from the last run, while the 48 passing tests have not been run (“deselected”). Now, if you run with the --ff option, all tests will be run but the first previous failures will be executed first (as can be seen from the series of FF and dots):

```

$ pytest --ff
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 50 items
run-last-failure: rerun previous 2 failures first

test_50.py
FF
................................................
[100%]
================================= FAILURES =================================
_______________________________ test_num[17] _______________________________
i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
_______________________________ test_num[25] _______________________________
i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
>           pytest.fail("bad luck")
E           Failed: bad luck
test_50.py
:7: Failed
========================= short test summary info ==========================
FAILED
test_50.py::
test_num[17]
- Failed: bad luck
FAILED
test_50.py::
test_num[25]
- Failed: bad luck
=======================
2 failed
,
48 passed
in 0.12s =======================

```

New --nf , --new-first options: run new tests first followed by the rest of the tests, in both cases tests are also sorted by the file modified time, with more recent files coming first.

# Behavior when no tests failed in the last run¶

The --lfnf/--last-failed-no-failures option governs the behavior of --last-failed . Determines whether to execute tests when there are no previously (known) failures or when no cached lastfailed data was found. There are two options: all : when there are no known test failures, runs all tests (the full test suite). This is the default. none : when there are no known test failures, just emits a message stating this and exit successfully. Example:

```

pytest
--last-failed
--last-failed-no-failures
all
# runs the full test suite (default behavior)
pytest
--last-failed
--last-failed-no-failures
none
# runs no tests and exits successfully

```

# The new config.cache object¶

Plugins or conftest.py support code can get a cached value using the pytest config object. Here is a basic example plugin which implements a fixture which re-uses previously created state across pytest invocations:

```

# content of test_caching.py
import
pytest
def
expensive_computation
():
print
(
"running expensive computation..."
)
@pytest
.
fixture
def
mydata
(
pytestconfig
):
val
=
pytestconfig
.
cache
.
get
(
"example/value"
,
None
)
if
val
is
None
:
expensive_computation
()
val
=
42
pytestconfig
.
cache
.
set
(
"example/value"
,
val
)
return
val
def
test_function
(
mydata
):
assert
mydata
==
23

```

If you run this command for the first time, you can see the print statement:

```

$ pytest -q
F
[100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
mydata = 42

    def test_function(mydata):
>       assert mydata == 23
E       assert 42 == 23
test_caching.py
:19: AssertionError
-------------------------- Captured stdout setup ---------------------------
running expensive computation...
========================= short test summary info ==========================
FAILED
test_caching.py::
test_function
- assert 42 == 23
1 failed
in 0.12s

```

If you run it a second time, the value will be retrieved from the cache and nothing will be printed:

```

$ pytest -q
F
[100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
mydata = 42

    def test_function(mydata):
>       assert mydata == 23
E       assert 42 == 23
test_caching.py
:19: AssertionError
========================= short test summary info ==========================
FAILED
test_caching.py::
test_function
- assert 42 == 23
1 failed
in 0.12s

```

See the config.cache fixture for more details.

# Inspecting Cache content¶

You can always peek at the content of the cache using the --cache-show command line option:

```

$ pytest --cache-show
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
cachedir: /home/sweet/project/.pytest_cache
--------------------------- cache values for '*' ---------------------------
cache/lastfailed contains:
  {'test_caching.py::test_function': True}
cache/nodeids contains:
  ['test_caching.py::test_function']
cache/stepwise contains:
  []
example/value contains:
  42
========================== no tests ran in 0.12s ===========================

```

--cache-show takes an optional argument to specify a glob pattern for filtering:

```

$ pytest --cache-show example/*
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
cachedir: /home/sweet/project/.pytest_cache
----------------------- cache values for 'example/*' -----------------------
example/value contains:
  42
========================== no tests ran in 0.12s ===========================

```

# Clearing Cache content¶

You can instruct pytest to clear all cache files and values by adding the --cache-clear option like this:

```

pytest
--cache-clear

```

This is recommended for invocations from Continuous Integration servers where isolation and correctness is more important than speed.

# Stepwise¶


---


# How to run doctests - pytest documentation

URL: https://docs.pytest.org/en/stable/doctest.html


# How to run doctests¶

By default, all files matching the test*.txt pattern will be run through the python standard doctest module. You can change the pattern by issuing:

```

pytest
--doctest-glob
=
"*.rst"

```

on the command line. --doctest-glob can be given multiple times in the command-line. If you then have a text file like this:

```

# content of test_example.txt

hello this is a doctest
>>> x = 3
>>> x
3

```

then you can just invoke pytest directly:

```

$ pytest
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y
rootdir: /home/sweet/project
collected 1 item

test_example.txt
.
[100%]
============================
1 passed
in 0.12s =============================

```

By default, pytest will collect test*.txt files looking for doctest directives, but you can pass additional globs using the --doctest-glob option (multi-allowed). In addition to text files, you can also execute doctests directly from docstrings of your classes and functions, including from test modules:

```

# content of mymodule.py
def
something
():
"""a doctest in a docstring
>>> something()
42
"""
return
42

```

```

$
pytest
--doctest-modules
===========================
test
session
starts
============================
platform
linux
--
Python
3
.x.y,
pytest-8.x.y,
pluggy-1.x.y
rootdir:
/home/sweet/project
collected
2
items

mymodule.py
.
[
50
%
]
test_example.txt
.
[
100
%
]
============================
2
passed
in
0
.12s
=============================

```

You can make these changes permanent in your project by putting them into a pytest.ini file like this:

```

# content of pytest.ini
[pytest]
addopts
=
--doctest-modules

```

# Encoding¶

The default encoding is UTF-8 , but you can specify the encoding that will be used for those doctest files using the doctest_encoding ini option:

```

# content of pytest.ini
[pytest]
doctest_encoding
=
latin1

```

# Using ‘doctest’ options¶

Python’s standard doctest module provides some options to configure the strictness of doctest tests. In pytest, you can enable those flags using the configuration file. For example, to make pytest ignore trailing whitespaces and ignore lengthy exception stack traces you can just write:

```

[pytest]
doctest_optionflags
=
NORMALIZE_WHITESPACE IGNORE_EXCEPTION_DETAIL

```

Alternatively, options can be enabled by an inline comment in the doc test itself:

```

>>> something_that_raises()  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
ValueError: ...

```

pytest also introduces new options: ALLOW_UNICODE : when enabled, the u prefix is stripped from unicode strings in expected doctest output. This allows doctests to run in Python 2 and Python 3 unchanged. ALLOW_BYTES : similarly, the b prefix is stripped from byte strings in expected doctest output. NUMBER : when enabled, floating-point numbers only need to match as far as the precision you have written in the expected doctest output. The numbers are compared using pytest.approx() with relative tolerance equal to the precision. For example, the following output would only need to match to 2 decimal places when comparing 3.14 to pytest.approx(math.pi, rel=10**-2) :

```

>>>
math
.
pi
3.14

```

If you wrote 3.1416 then the actual output would need to match to approximately 4 decimal places; and so on. This avoids false positives caused by limited floating-point precision, like this:

```

Expected
:
0.233
Got
:
0.23300000000000001

```

NUMBER also supports lists of floating-point numbers – in fact, it matches floating-point numbers appearing anywhere in the output, even inside a string! This means that it may not be appropriate to enable globally in doctest_optionflags in your configuration file. Added in version 5.1.

# Continue on failure¶

By default, pytest would report only the first failure for a given doctest. If you want to continue the test even when you have failures, do:

```

pytest
--doctest-modules
--doctest-continue-on-failure

```

# Output format¶

You can change the diff output format on failure for your doctests by using one of standard doctest modules format in options (see doctest.REPORT_UDIFF , doctest.REPORT_CDIFF , doctest.REPORT_NDIFF , doctest.REPORT_ONLY_FIRST_FAILURE ):

```

pytest
--doctest-modules
--doctest-report
none
pytest
--doctest-modules
--doctest-report
udiff
pytest
--doctest-modules
--doctest-report
cdiff
pytest
--doctest-modules
--doctest-report
ndiff
pytest
--doctest-modules
--doctest-report
only_first_failure

```

# pytest-specific features¶

Some features are provided to make writing doctests easier or with better integration with your existing test suite. Keep in mind however that by using those features you will make your doctests incompatible with the standard doctests module.

# Using fixtures¶

It is possible to use fixtures using the getfixture helper:

```

# content of example.rst
>>> tmp = getfixture('tmp_path')
>>> ...
>>>

```

Note that the fixture needs to be defined in a place visible by pytest, for example, a conftest.py file or plugin; normal python files containing docstrings are not normally scanned for fixtures unless explicitly configured by python_files . Also, the usefixtures mark and fixtures marked as autouse are supported when executing text doctest files.

# ‘doctest_namespace’ fixture¶

The doctest_namespace fixture can be used to inject items into the namespace in which your doctests run. It is intended to be used within your own fixtures to provide the tests that use them with context. doctest_namespace is a standard dict object into which you place the objects you want to appear in the doctest namespace:

```

# content of conftest.py
import
pytest
import
numpy
@pytest
.
fixture
(
autouse
=
True
)
def
add_np
(
doctest_namespace
):
doctest_namespace
[
"np"
]
=
numpy

```

which can then be used in your doctests directly:

```

# content of numpy.py
def
arange
():
"""
>>> a = np.arange(10)
>>> len(a)
10
"""

```

Note that like the normal conftest.py , the fixtures are discovered in the directory tree conftest is in. Meaning that if you put your doctest with your source code, the relevant conftest.py needs to be in the same directory tree. Fixtures will not be discovered in a sibling directory tree!

# Skipping tests¶

For the same reasons one might want to skip normal tests, it is also possible to skip tests inside doctests. To skip a single check inside a doctest you can use the standard doctest.SKIP directive:

```

def
test_random
(
y
):
"""
>>> random.random()  # doctest: +SKIP
0.156231223
>>> 1 + 1
2
"""

```

This will skip the first check, but not the second. pytest also allows using the standard pytest functions pytest.skip() and pytest.xfail() inside doctests, which might be useful because you can then skip/xfail tests based on external conditions:

```

>>> import sys, pytest
>>> if sys.platform.startswith('win'):
...     pytest.skip('this doctest does not work on Windows')
...
>>> import fcntl
>>> ...

```

However using those functions is discouraged because it reduces the readability of the docstring. Note pytest.skip() and pytest.xfail() behave differently depending if the doctests are in a Python file (in docstrings) or a text file containing doctests intermingled with text: Python modules (docstrings): the functions only act in that specific docstring, letting the other docstrings in the same module execute as normal. Text files: the functions will skip/xfail the checks for the rest of the entire file.

# Alternatives¶


---


# How to implement xunit-style set-up - pytest documentation

URL: https://docs.pytest.org/en/stable/xunit_setup.html


# How to implement xunit-style set-up¶

This section describes a classic and popular way how you can implement fixtures (setup and teardown test state) on a per-module/class/function basis. Note While these setup/teardown methods are simple and familiar to those coming from a unittest or nose background, you may also consider using pytest’s more powerful fixture mechanism which leverages the concept of dependency injection, allowing for a more modular and more scalable approach for managing test state, especially for larger projects and for functional testing. You can mix both fixture mechanisms in the same file but test methods of unittest.TestCase subclasses cannot receive fixture arguments.

# Module level setup/teardown¶

If you have multiple test functions and test classes in a single module you can optionally implement the following fixture methods which will usually be called once for all the functions:

```

def
setup_module
(
module
):
"""setup any state specific to the execution of the given module."""
def
teardown_module
(
module
):
"""teardown any state that was previously setup with a setup_module
method.
"""

```

As of pytest-3.0, the module parameter is optional.

# Class level setup/teardown¶

Similarly, the following methods are called at class level before and after all test methods of the class are called:

```

@classmethod
def
setup_class
(
cls
):
"""setup any state specific to the execution of the given class (which
usually contains tests).
"""
@classmethod
def
teardown_class
(
cls
):
"""teardown any state that was previously setup with a call to
setup_class.
"""

```

# Method and function level setup/teardown¶

Similarly, the following methods are called around each method invocation:

```

def
setup_method
(
self
,
method
):
"""setup any state tied to the execution of the given method in a
class.  setup_method is invoked for every test method of a class.
"""
def
teardown_method
(
self
,
method
):
"""teardown any state that was previously setup with a setup_method
call.
"""

```

As of pytest-3.0, the method parameter is optional. If you would rather define test functions directly at module level you can also use the following functions to implement fixtures:

```

def
setup_function
(
function
):
"""setup any state tied to the execution of the given function.
Invoked for every test function in the module.
"""
def
teardown_function
(
function
):
"""teardown any state that was previously setup with a setup_function
call.
"""

```


---


# How to set up bash completion - pytest documentation

URL: https://docs.pytest.org/en/stable/bash-completion.html


# How to set up bash completion¶

When using bash as your shell, pytest can use argcomplete ( https://kislyuk.github.io/argcomplete/ ) for auto-completion. For this argcomplete needs to be installed and enabled. Install argcomplete using:

```

sudo
pip
install
'argcomplete>=0.5.7'

```

For global activation of all argcomplete enabled python applications run:

```

sudo
activate-global-python-argcomplete

```

For permanent (but not global) pytest activation, use:

```

register-python-argcomplete
pytest
>>
~/.bashrc

```

For one-time activation of argcomplete for pytest only, use:

```

eval
"
$(
register-python-argcomplete
pytest
)
"

```


---


# How to mark test functions with attributes - pytest documentation

URL: https://docs.pytest.org/en/stable/mark.html


# How to mark test functions with attributes¶

By using the pytest.mark helper you can easily set metadata on your test functions. You can find the full list of builtin markers in the API Reference . Or you can list all the markers, including builtin and custom, using the CLI - pytest --markers . Here are some of the builtin markers: usefixtures - use fixtures on a test function or class filterwarnings - filter certain warnings of a test function skip - always skip a test function skipif - skip a test function if a certain condition is met xfail - produce an “expected failure” outcome if a certain condition is met parametrize - perform multiple calls to the same test function. It’s easy to create custom markers or to apply markers to whole test classes or modules. Those markers can be used by plugins, and also are commonly used to select tests on the command-line with the -m option. See Working with custom markers for examples which also serve as documentation. Note Marks can only be applied to tests, having no effect on fixtures .

# Registering marks¶

You can register custom marks in your pytest.ini file like this:

```

[pytest]
markers
=
slow
:
marks tests as slow (deselect with '-m "not slow"')
serial

```

or in your pyproject.toml file like this:

```

[tool.pytest.ini_options]
markers
=
[
"slow: marks tests as slow (deselect with '-m
\"
not slow
\"
')"
,
"serial"
,
]

```

Note that everything past the : after the mark name is an optional description. Alternatively, you can register new markers programmatically in a pytest_configure hook:

```

def
pytest_configure
(
config
):
config
.
addinivalue_line
(
"markers"
,
"env(name): mark test to run only on named environment"
)

```

Registered marks appear in pytest’s help text and do not emit warnings (see the next section). It is recommended that third-party plugins always register their markers .

# Raising errors on unknown marks¶

Unregistered marks applied with the @pytest.mark.name_of_the_mark decorator will always emit a warning in order to avoid silently doing something surprising due to mistyped names. As described in the previous section, you can disable the warning for custom marks by registering them in your pytest.ini file or using a custom pytest_configure hook. When the --strict-markers command-line flag is passed, any unknown marks applied with the @pytest.mark.name_of_the_mark decorator will trigger an error. You can enforce this validation in your project by adding --strict-markers to addopts :

```

[pytest]
addopts
=
--strict-markers
markers
=
slow
:
marks tests as slow (deselect with '-m "not slow"')
serial

```


---


# How to use pytest with an existing test suite - pytest documentation

URL: https://docs.pytest.org/en/stable/existingtestsuite.html


# How to use pytest with an existing test suite¶

Pytest can be used with most existing test suites, but its behavior differs from other test runners such as Python’s default unittest framework. Before using this section you will want to install pytest .

# Running an existing test suite with pytest¶

Say you want to contribute to an existing repository somewhere. After pulling the code into your development space using some flavor of version control and (optionally) setting up a virtualenv you will want to run:

```

cd
<repository>
pip
install
-e
.
# Environment dependent alternatives include
# 'python setup.py develop' and 'conda develop'

```


---


# pytest-3.8.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.8.0.html


# pytest-3.8.0¶


---


# pytest-3.6.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.6.1.html


# pytest-3.6.1¶

pytest 3.6.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.3.1: fix regression with factory functions - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.3.1.html


# pytest-2.3.1: fix regression with factory functions¶

pytest-2.3.1 is a quick follow-up release: fix issue202 - regression with fixture functions/funcarg factories: using “self” is now safe again and works as in 2.2.4. Thanks to Eduard Schettino for the quick bug report. disable pexpect pytest self tests on Freebsd - thanks Koob for the quick reporting fix/improve interactive docs with –markers See http://pytest.org/ for general information. To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest best, holger krekel

# Changes between 2.3.0 and 2.3.1¶


---


# pytest-4.2.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.2.1.html


# pytest-4.2.1¶

pytest 4.2.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.4.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.4.1.html


# pytest-3.4.1¶

pytest 3.4.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.7.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.7.1.html


# pytest-3.7.1¶

pytest 3.7.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.7.0: fixes, features, speed improvements - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.7.0.html


# pytest-2.7.0: fixes, features, speed improvements¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.6.X. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed, among them: Anatoly Bubenkoff Floris Bruynooghe Brianna Laugher Eric Siegerman Daniel Hahler Charles Cloud Tom Viner Holger Peters Ldiary Translations almarklein have fun, holger krekel

# 2.7.0 (compared to 2.6.4)¶


---


# pytest-3.7.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.7.4.html


# pytest-3.7.4¶

pytest 3.7.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.2.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.2.2.html


# pytest-8.2.2¶

pytest 8.2.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.2.4: bug fixes, better junitxml/unittest/python3 compat - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.2.4.html


# pytest-2.2.4: bug fixes, better junitxml/unittest/python3 compat¶

pytest-2.2.4 is a minor backward-compatible release of the versatile py.test testing tool. It contains bug fixes and a few refinements to junitxml reporting, better unittest- and python3 compatibility. For general information see here: http://pytest.org/ To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest Special thanks for helping on this release to Ronny Pfannschmidt and Benjamin Peterson and the contributors of issues. best, holger krekel

# Changes between 2.2.3 and 2.2.4¶


---


# pytest-7.4.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.4.3.html


# pytest-7.4.3¶

pytest 7.4.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.2.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.2.5.html


# pytest-3.2.5¶

pytest 3.2.5 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.6.7 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.7.html


# pytest-4.6.7¶

pytest 4.6.7 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.5.0: now down to ZERO reported bugs! - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.5.0.html


# pytest-2.5.0: now down to ZERO reported bugs!¶

pytest-2.5.0 is a big fixing release, the result of two community bug fixing days plus numerous additional works from many people and reporters. The release should be fully compatible to 2.4.2, existing plugins and test suites. We aim at maintaining this level of ZERO reported bugs because it’s no fun if your testing tool has bugs, is it? Under a condition, though: when submitting a bug report please provide clear information about the circumstances and a simple example which reproduces the problem. The issue tracker is of course not empty now. We have many remaining “enhancement” issues which we’ll hopefully can tackle in 2014 with your help. For those who use older Python versions, please note that pytest is not automatically tested on python2.5 due to virtualenv, setuptools and tox not supporting it anymore. Manual verification shows that it mostly works fine but it’s not going to be part of the automated release process and thus likely to break in the future. As usual, current docs are at http://pytest.org and you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Particular thanks for helping with this release go to Anatoly Bubenkoff, Floris Bruynooghe, Marc Abramowitz, Ralph Schmitt, Ronny Pfannschmidt, Donald Stufft, James Lan, Rob Dennis, Jason R. Coombs, Mathieu Agopian, Virgil Dupras, Bruno Oliveira, Alex Gaynor and others. have fun, holger krekel

# 2.5.0¶

dropped python2.5 from automated release testing of pytest itself which means it’s probably going to break soon (but still works with this release we believe). simplified and fixed implementation for calling finalizers when parametrized fixtures or function arguments are involved. finalization is now performed lazily at setup time instead of in the “teardown phase”. While this might sound odd at first, it helps to ensure that we are correctly handling setup/teardown even in complex code. User-level code should not be affected unless it’s implementing the pytest_runtest_teardown hook and expecting certain fixture instances are torn down within (very unlikely and would have been unreliable anyway). PR90: add –color=yes|no|auto option to force terminal coloring mode (“auto” is default). Thanks Marc Abramowitz. fix issue319 - correctly show unicode in assertion errors. Many thanks to Floris Bruynooghe for the complete PR. Also means we depend on py>=1.4.19 now. fix issue396 - correctly sort and finalize class-scoped parametrized tests independently from number of methods on the class. refix issue323 in a better way – parametrization should now never cause Runtime Recursion errors because the underlying algorithm for re-ordering tests per-scope/per-fixture is not recursive anymore (it was tail-call recursive before which could lead to problems for more than >966 non-function scoped parameters). fix issue290 - there is preliminary support now for parametrizing with repeated same values (sometimes useful to test if calling a second time works as with the first time). close issue240 - document precisely how pytest module importing works, discuss the two common test directory layouts, and how it interacts with PEP420-namespace packages. fix issue246 fix finalizer order to be LIFO on independent fixtures depending on a parametrized higher-than-function scoped fixture. (was quite some effort so please bear with the complexity of this sentence :) Thanks Ralph Schmitt for the precise failure example. fix issue244 by implementing special index for parameters to only use indices for parametrized test ids fix issue287 by running all finalizers but saving the exception from the first failing finalizer and re-raising it so teardown will still have failed. We reraise the first failing exception because it might be the cause for other finalizers to fail. fix ordering when mock.patch or other standard decorator-wrappings are used with test methods. This fixes issue346 and should help with random “xdist” collection failures. Thanks to Ronny Pfannschmidt and Donald Stufft for helping to isolate it. fix issue357 - special case “-k” expressions to allow for filtering with simple strings that are not valid python expressions. Examples: “-k 1.3” matches all tests parametrized with 1.3. “-k None” filters all tests that have “None” in their name and conversely “-k ‘not None’”. Previously these examples would raise syntax errors. fix issue384 by removing the trial support code since the unittest compat enhancements allow trial to handle it on its own don’t hide an ImportError when importing a plugin produces one. fixes issue375. fix issue275 - allow usefixtures and autouse fixtures for running doctest text files. fix issue380 by making –resultlog only rely on longrepr instead of the “reprcrash” attribute which only exists sometimes. address issue122: allow @pytest.fixture(params=iterator) by exploding into a list early on. fix pexpect-3.0 compatibility for pytest’s own tests. (fixes issue386) allow nested parametrize-value markers, thanks James Lan for the PR. fix unicode handling with new monkeypatch.setattr(import_path, value) API. Thanks Rob Dennis. Fixes issue371. fix unicode handling with junitxml, fixes issue368. In assertion rewriting mode on Python 2, fix the detection of coding cookies. See issue #330. make “–runxfail” turn imperative pytest.xfail calls into no ops (it already did neutralize pytest.mark.xfail markers) refine pytest / pkg_resources interactions: The AssertionRewritingHook PEP302 compliant loader now registers itself with setuptools/pkg_resources properly so that the pkg_resources.resource_stream method works properly. Fixes issue366. Thanks for the investigations and full PR to Jason R. Coombs. pytestconfig fixture is now session-scoped as it is the same object during the whole test run. Fixes issue370. avoid one surprising case of marker malfunction/confusion:

```

@pytest
.
mark
.
some
(
lambda
arg
:
...
)
def
test_function
():

```


---


# pytest-7.2.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.2.1.html


# pytest-7.2.1¶

pytest 7.2.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.2.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.2.0.html


# pytest-8.2.0¶


---


# pytest-5.2.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.2.4.html


# pytest-5.2.4¶

pytest 5.2.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.0.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.0.2.html


# pytest-8.0.2¶

pytest 8.0.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.7.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.7.2.html


# pytest-3.7.2¶

pytest 3.7.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.0.0rc1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.0.0rc1.html


# pytest-6.0.0rc1¶

pytest 6.0.0rc1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.3.5: bug fixes and little improvements - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.3.5.html


# pytest-2.3.5: bug fixes and little improvements¶

pytest-2.3.5 is a maintenance release with many bug fixes and little improvements. See the changelog below for details. No backward compatibility issues are foreseen and all plugins which worked with the prior version are expected to work unmodified. Speaking of which, a few interesting new plugins saw the light last month: pytest-instafail: show failure information while tests are running pytest-qt: testing of GUI applications written with QT/Pyside pytest-xprocess: managing external processes across test runs pytest-random: randomize test ordering And several others like pytest-django saw maintenance releases. For a more complete list, check out https://pypi.org/search/?q=pytest For general information see: http://pytest.org/ To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest Particular thanks to Floris, Ronny, Benjamin and the many bug reporters and fix providers. may the fixtures be with you, holger krekel

# Changes between 2.3.4 and 2.3.5¶


---


# pytest-3.10.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.10.1.html


# pytest-3.10.1¶

pytest 3.10.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.0.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.0.html


# pytest-3.0.0¶


---


# pytest-3.2.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.2.4.html


# pytest-3.2.4¶

pytest 3.2.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.2.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.2.3.html


# pytest-5.2.3¶

pytest 5.2.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.3.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.3.4.html


# pytest-5.3.4¶

pytest 5.3.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# py.test 2.1.3: just some more fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.1.3.html


# py.test 2.1.3: just some more fixes¶

pytest-2.1.3 is a minor backward compatible maintenance release of the popular py.test testing tool. It is commonly used for unit, functional- and integration testing. See extensive docs with examples here: http://pytest.org/ The release contains another fix to the perfected assertions introduced with the 2.1 series as well as the new possibility to customize reporting for assertion expressions on a per-directory level. If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

Thanks to the bug reporters and to Ronny Pfannschmidt, Benjamin Peterson and Floris Bruynooghe who implemented the fixes. best, holger krekel

# Changes between 2.1.2 and 2.1.3¶


---


# pytest-3.1.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.1.3.html


# pytest-3.1.3¶

pytest 3.1.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.6.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.3.html


# pytest-4.6.3¶

pytest 4.6.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.0.7 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.7.html


# pytest-3.0.7¶

pytest 3.0.7 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# py.test 2.0.2: bug fixes, improved xfail/skip expressions, speed ups - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.0.2.html


# py.test 2.0.2: bug fixes, improved xfail/skip expressions, speed ups¶

Welcome to pytest-2.0.2, a maintenance and bug fix release of pytest, a mature testing tool for Python, supporting CPython 2.4-3.2, Jython and latest PyPy interpreters. See the extensive docs with tested examples here: http://pytest.org/ If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

Many thanks to all issue reporters and people asking questions or complaining, particularly Jurko for his insistence, Laura, Victor and Brianna for helping with improving and Ronny for his general advise. best, holger krekel

# Changes between 2.0.1 and 2.0.2¶

tackle issue32 - speed up test runs of very quick test functions by reducing the relative overhead fix issue30 - extended xfail/skipif handling and improved reporting. If you have a syntax error in your skip/xfail expressions you now get nice error reports. Also you can now access module globals from xfail/skipif expressions so that this for example works now:

```

import
pytest
import
mymodule
@pytest
.
mark
.
skipif
(
"mymodule.__version__[0] == "
1
")
def
test_function
():
pass

```


---


# pytest-2.9.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.9.2.html


# pytest-2.9.2¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Adam Chainz Benjamin Dopplinger Bruno Oliveira Florian Bruhin John Towler Martin Prusse Meng Jue MengJueM Omar Kohl Quentin Pradet Ronny Pfannschmidt Thomas Güttler TomV Tyler Goodlet Happy testing, The py.test Development Team

# 2.9.2 (compared to 2.9.1)¶


---


# pytest-2.8.6 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.8.6.html


# pytest-2.8.6¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.8.5. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: AMiT Kumar Bruno Oliveira Erik M. Bray Florian Bruhin Georgy Dyuldin Jeff Widman Kartik Singhal Loïc Estève Manu Phatak Peter Demin Rick van Hattem Ronny Pfannschmidt Ulrich Petri foxx Happy testing, The py.test Development Team

# 2.8.6 (compared to 2.8.5)¶


---


# pytest-5.3.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.3.1.html


# pytest-5.3.1¶

pytest 5.3.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.3.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.3.0.html


# pytest-8.3.0¶


---


# pytest-4.6.6 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.6.html


# pytest-4.6.6¶

pytest 4.6.6 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.6.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.6.0.html


# pytest-3.6.0¶


---


# pytest-2.6.3: fixes and little improvements - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.6.3.html


# pytest-2.6.3: fixes and little improvements¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is drop-in compatible to 2.5.2 and 2.6.X. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed, among them: Floris Bruynooghe Oleg Sinyavskiy Uwe Schmitt Charles Cloud Wolfgang Schnerring have fun, holger krekel

# Changes 2.6.3¶


---


# py.test 2.0.1: bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.0.1.html


# py.test 2.0.1: bug fixes¶

Welcome to pytest-2.0.1, a maintenance and bug fix release of pytest, a mature testing tool for Python, supporting CPython 2.4-3.2, Jython and latest PyPy interpreters. See extensive docs with tested examples here: http://pytest.org/ If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

Many thanks to all issue reporters and people asking questions or complaining. Particular thanks to Floris Bruynooghe and Ronny Pfannschmidt for their great coding contributions and many others for feedback and help. best, holger krekel

# Changes between 2.0.0 and 2.0.1¶


---


# pytest-4.6.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.4.html


# pytest-4.6.4¶

pytest 4.6.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.3.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.3.1.html


# pytest-3.3.1¶

pytest 3.3.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.0.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.0.1.html


# pytest-7.0.1¶

pytest 7.0.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.5.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.5.0.html


# pytest-3.5.0¶


---


# pytest-3.4.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.4.0.html


# pytest-3.4.0¶


---


# pytest-6.2.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.2.4.html


# pytest-6.2.4¶

pytest 6.2.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.0.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.0.1.html


# pytest-4.0.1¶

pytest 4.0.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.3.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.3.0.html


# pytest-4.3.0¶


---


# pytest-3.6.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.6.2.html


# pytest-3.6.2¶

pytest 3.6.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.6.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.6.4.html


# pytest-3.6.4¶

pytest 3.6.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.2.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.2.1.html


# pytest-6.2.1¶

pytest 6.2.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.3.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.3.2.html


# pytest-8.3.2¶

pytest 8.3.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.1.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.1.1.html


# pytest-7.1.1¶

pytest 7.1.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.6.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.2.html


# pytest-4.6.2¶

pytest 4.6.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.9.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.9.2.html


# pytest-3.9.2¶

pytest 3.9.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.2.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.2.5.html


# pytest-6.2.5¶

pytest 6.2.5 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.1.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.1.0.html


# pytest-6.1.0¶


---


# pytest-3.2.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.2.3.html


# pytest-3.2.3¶

pytest 3.2.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.3.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.3.2.html


# pytest-7.3.2¶

pytest 7.3.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.0.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.2.html


# pytest-3.0.2¶

pytest 3.0.2 has just been released to PyPI. This release fixes some regressions and bugs reported in version 3.0.1, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.8.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.8.1.html


# pytest-3.8.1¶

pytest 3.8.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.2.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.2.0.html


# pytest-4.2.0¶


---


# pytest-5.2.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.2.0.html


# pytest-5.2.0¶


---


# pytest-8.2.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.2.1.html


# pytest-8.2.1¶

pytest 8.2.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.8.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.8.2.html


# pytest-3.8.2¶

pytest 3.8.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.1.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.1.3.html


# pytest-7.1.3¶

pytest 7.1.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.4.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.4.0.html


# pytest-5.4.0¶


---


# pytest-3.2.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.2.1.html


# pytest-3.2.1¶

pytest 3.2.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.0.6 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.6.html


# pytest-3.0.6¶

pytest 3.0.6 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.4.2: colorama on windows, plugin/tmpdir fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.4.2.html


# pytest-2.4.2: colorama on windows, plugin/tmpdir fixes¶

pytest-2.4.2 is another bug-fixing release: on Windows require colorama and a newer py lib so that py.io.TerminalWriter() now uses colorama instead of its own ctypes hacks. (fixes issue365) thanks Paul Moore for bringing it up. fix “-k” matching of tests where “repr” and “attr” and other names would cause wrong matches because of an internal implementation quirk (don’t ask) which is now properly implemented. fixes issue345. avoid tmpdir fixture to create too long filenames especially when parametrization is used (issue354) fix pytest-pep8 and pytest-flakes / pytest interactions (collection names in mark plugin was assuming an item always has a function which is not true for those plugins etc.) Thanks Andi Zeidler. introduce node.get_marker/node.add_marker API for plugins like pytest-pep8 and pytest-flakes to avoid the messy details of the node.keywords pseudo-dicts. Adapted docs. remove attempt to “dup” stdout at startup as it’s icky. the normal capturing should catch enough possibilities of tests messing up standard FDs. add pluginmanager.do_configure(config) as a link to config.do_configure() for plugin-compatibility as usual, docs at http://pytest.org and upgrades via:

```

pip
install
-
U
pytest

```


---


# pytest-2.8.3: bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.8.3.html


# pytest-2.8.3: bug fixes¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.8.2. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Bruno Oliveira Florian Bruhin Gabe Hollombe Gabriel Reis Hartmut Goebel John Vandenberg Lee Kamentsky Michael Birtwell Raphael Pierzina Ronny Pfannschmidt William Martin Stewart Happy testing, The py.test Development Team

# 2.8.3 (compared to 2.8.2)¶


---


# pytest-3.10.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.10.0.html


# pytest-3.10.0¶


---


# pytest-6.0.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.0.0.html


# pytest-6.0.0¶


---


# pytest-2.6.2: few fixes and cx_freeze support - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.6.2.html


# pytest-2.6.2: few fixes and cx_freeze support¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is drop-in compatible to 2.5.2 and 2.6.X. It also brings support for including pytest with cx_freeze or similar freezing tools into your single-file app distribution. For details see the CHANGELOG below. See docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed, among them: Floris Bruynooghe Benjamin Peterson Bruno Oliveira have fun, holger krekel

# 2.6.2¶


---


# pytest-3.2.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.2.0.html


# pytest-3.2.0¶


---


# pytest-5.3.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.3.5.html


# pytest-5.3.5¶

pytest 5.3.5 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.3.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.3.5.html


# pytest-8.3.5¶


---


# pytest-4.1.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.1.1.html


# pytest-4.1.1¶

pytest 4.1.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.2.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.2.0.html


# pytest-6.2.0¶


---


# pytest-5.0.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.0.1.html


# pytest-5.0.1¶

pytest 5.0.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.5.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.5.0.html


# pytest-4.5.0¶


---


# pytest-8.3.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.3.1.html


# pytest-8.3.1¶

pytest 8.3.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.0.0rc1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.0.0rc1.html


# pytest-8.0.0rc1¶


---


# pytest-3.0.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.5.html


# pytest-3.0.5¶

pytest 3.0.5 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.1.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.1.0.html


# pytest-3.1.0¶


---


# pytest-2.8.7 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.8.7.html


# pytest-2.8.7¶

This is a hotfix release to solve a regression in the builtin monkeypatch plugin that got introduced in 2.8.6. pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.8.5. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Ronny Pfannschmidt Happy testing, The py.test Development Team

# 2.8.7 (compared to 2.8.6)¶


---


# pytest-5.3.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.3.2.html


# pytest-5.3.2¶

pytest 5.3.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.4.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.4.1.html


# pytest-5.4.1¶

pytest 5.4.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.0.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.0.0.html


# pytest-5.0.0¶


---


# pytest-4.6.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.1.html


# pytest-4.6.1¶

pytest 4.6.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.3.2: some fixes and more traceback-printing speed - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.3.2.html


# pytest-2.3.2: some fixes and more traceback-printing speed¶

pytest-2.3.2 is another stabilization release: issue 205: fixes a regression with conftest detection issue 208/29: fixes traceback-printing speed in some bad cases fix teardown-ordering for parametrized setups fix unittest and trial compat behaviour with respect to runTest() methods issue 206 and others: some improvements to packaging fix issue127 and others: improve some docs See http://pytest.org/ for general information. To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest best, holger krekel

# Changes between 2.3.1 and 2.3.2¶


---


# pytest-2.2.2: bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.2.2.html


# pytest-2.2.2: bug fixes¶

pytest-2.2.2 (updated to 2.2.3 to fix packaging issues) is a minor backward-compatible release of the versatile py.test testing tool. It contains bug fixes and a few refinements particularly to reporting with “–collectonly”, see below for details. For general information see here: http://pytest.org/ To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest Special thanks for helping on this release to Ronny Pfannschmidt and Ralf Schmitt and the contributors of issues. best, holger krekel

# Changes between 2.2.1 and 2.2.2¶


---


# pytest-8.3.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.3.4.html


# pytest-8.3.4¶

pytest 8.3.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# python testing sprint June 20th-26th 2016 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/sprint2016.html


# python testing sprint June 20th-26th 2016¶

The pytest core group held the biggest sprint in its history in June 2016, taking place in the black forest town Freiburg in Germany. In February 2016 we started a funding campaign on Indiegogo to cover expenses The page also mentions some preliminary topics: improving pytest-xdist test scheduling to take into account fixture setups and explicit user hints. provide info on fixture dependencies during –collect-only tying pytest-xdist to tox so that you can do “py.test -e py34” to run tests in a particular tox-managed virtualenv. Also look into making pytest-xdist use tox environments on remote ssh-sides so that remote dependency management becomes easier. refactoring the fixture system so more people understand it :) integrating PyUnit setup methods as autouse fixtures. possibly adding ways to influence ordering of same-scoped fixtures (so you can make a choice of which fixtures come before others) fixing bugs and issues from the tracker, really an endless source :)

# Participants¶

Over 20 participants took part from 4 continents, including employees from Splunk, Personalkollen, Cobe.io, FanDuel and Dolby. Some newcomers mixed with developers who have worked on pytest since its beginning, and of course everyone in between.

# Sprint organisation, schedule¶

People arrived in Freiburg on the 19th, with sprint development taking place on 20th, 21st, 22nd, 24th and 25th. On the 23rd we took a break day for some hot hiking in the Black Forest. Sprint activity was organised heavily around pairing, with plenty of group discussions to take advantage of the high bandwidth, and lightning talks as well.

# Money / funding¶


---


# pytest-8.1.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.1.2.html


# pytest-8.1.2¶

pytest 8.1.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# py.test 2.0.0: asserts++, unittest++, reporting++, config++, docs++ - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.0.0.html


# py.test 2.0.0: asserts++, unittest++, reporting++, config++, docs++¶

Welcome to pytest-2.0.0, a major new release of “py.test”, the rapid easy Python testing tool. There are many new features and enhancements, see below for summary and detailed lists. A lot of long-deprecated code has been removed, resulting in a much smaller and cleaner implementation. See the new docs with examples here: http://pytest.org/en/stable/index.html A note on packaging: pytest used to part of the “py” distribution up until version py-1.3.4 but this has changed now: pytest-2.0.0 only contains py.test related code and is expected to be backward-compatible to existing test code. If you want to install pytest, just type one of:

```

pip
install
-
U
pytest
easy_install
-
U
pytest

```

Many thanks to all issue reporters and people asking questions or complaining. Particular thanks to Floris Bruynooghe and Ronny Pfannschmidt for their great coding contributions and many others for feedback and help. best, holger krekel

# New Features¶

new invocations through Python interpreter and from Python:

```

python
-
m
pytest
# on all pythons >= 2.5

```

or from a python program:

```

import
pytest
;
pytest
.
main
(
arglist
,
pluginlist
)

```

see http://pytest.org/en/stable/how-to/usage.html for details. new and better reporting information in assert expressions if comparing lists, sequences or strings. see http://pytest.org/en/stable/how-to/assert.html#newreport new configuration through ini-files (setup.cfg or tox.ini recognized), for example:

```

[
pytest
]
norecursedirs
=
.
hg
data
*
# don't ever recurse in such dirs
addopts
=
-
x
--
pyargs
# add these command line options by default

```

see http://pytest.org/en/stable/reference/customize.html improved standard unittest support. In general py.test should now better be able to run custom unittest.TestCases like twisted trial or Django based TestCases. Also you can now run the tests of an installed ‘unittest’ package with py.test:

```

py
.
test
--
pyargs
unittest

```

new “-q” option which decreases verbosity and prints a more nose/unittest-style “dot” output. many, many, more detailed improvements details

# Fixes¶

fix issue126 - introduce py.test.set_trace() to trace execution via PDB during the running of tests even if capturing is ongoing. fix issue124 - make reporting more resilient against tests opening files on filedescriptor 1 (stdout). fix issue109 - sibling conftest.py files will not be loaded. (and Directory collectors cannot be customized anymore from a Directory’s conftest.py - this needs to happen at least one level up). fix issue88 (finding custom test nodes from command line arg) fix issue93 stdout/stderr is captured while importing conftest.py fix bug: unittest collected functions now also can have “pytestmark” applied at class/module level

# Important Notes¶

The usual way in pre-2.0 times to use py.test in python code was to import “py” and then e.g. use “py.test.raises” for the helper. This remains valid and is not planned to be deprecated. However, in most examples and internal code you’ll find “import pytest” and “pytest.raises” used as the recommended default way. pytest now first performs collection of the complete test suite before running any test. This changes for example the semantics of when pytest_collectstart/pytest_collectreport are called. Some plugins may need upgrading. The pytest package consists of a 400 LOC core.py and about 20 builtin plugins, summing up to roughly 5000 LOCs, including docstrings. To be fair, it also uses generic code from the “pylib”, and the new “py” package to help with filesystem and introspection/code manipulation.

# (Incompatible) Removals¶


---


# py.test 2.2.0: test marking++, parametrization++ and duration profiling - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.2.0.html


# py.test 2.2.0: test marking++, parametrization++ and duration profiling¶

pytest-2.2.0 is a test-suite compatible release of the popular py.test testing tool. Plugins might need upgrades. It comes with these improvements: easier and more powerful parametrization of tests: new @pytest.mark.parametrize decorator to run tests with different arguments new metafunc.parametrize() API for parametrizing arguments independently see examples at http://pytest.org/en/stable/example/how-to/parametrize.html NOTE that parametrize() related APIs are still a bit experimental and might change in future releases. improved handling of test markers and refined marking mechanism: “-m markexpr” option for selecting tests according to their mark a new “markers” ini-variable for registering test markers for your project the new “–strict” bails out with an error if using unregistered markers. see examples at http://pytest.org/en/stable/example/markers.html duration profiling: new “–duration=N” option showing the N slowest test execution or setup/teardown calls. This is most useful if you want to find out where your slowest test code is. also 2.2.0 performs more eager calling of teardown/finalizers functions resulting in better and more accurate reporting when they fail Besides there is the usual set of bug fixes along with a cleanup of pytest’s own test suite allowing it to run on a wider range of environments. For general information, see extensive docs with examples here: http://pytest.org/ If you want to install or upgrade pytest you might just type:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

Thanks to Ronny Pfannschmidt, David Burns, Jeff Donner, Daniel Nouri, Alfredo Deza and all who gave feedback or sent bug reports. best, holger krekel

# notes on incompatibility¶

While test suites should work unchanged you might need to upgrade plugins: You need a new version of the pytest-xdist plugin (1.7) for distributing test runs. Other plugins might need an upgrade if they implement the pytest_runtest_logreport hook which now is called unconditionally for the setup/teardown fixture phases of a test. You may choose to ignore setup/teardown failures by inserting “if rep.when != ‘call’: return” or something similar. Note that most code probably “just” works because the hook was already called for failing setup/teardown phases of a test so a plugin should have been ready to grok such reports already.

# Changes between 2.1.3 and 2.2.0¶


---


# pytest-4.4.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.4.0.html


# pytest-4.4.0¶


---


# pytest-4.6.9 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.9.html


# pytest-4.6.9¶

pytest 4.6.9 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.1.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.1.2.html


# pytest-5.1.2¶

pytest 5.1.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.3.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.3.2.html


# pytest-3.3.2¶

pytest 3.3.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.4.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.4.2.html


# pytest-7.4.2¶

pytest 7.4.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.1.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.1.1.html


# pytest-8.1.1¶

pytest 8.1.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.0.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.0.0.html


# pytest-7.0.0¶


---


# pytest-3.3.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.3.0.html


# pytest-3.3.0¶


---


# pytest-6.2.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.2.2.html


# pytest-6.2.2¶

pytest 6.2.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.6.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.6.3.html


# pytest-3.6.3¶

pytest 3.6.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.3.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.3.0.html


# pytest-7.3.0¶


---


# pytest-3.5.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.5.1.html


# pytest-3.5.1¶

pytest 3.5.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.1.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.1.2.html


# pytest-6.1.2¶

pytest 6.1.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.7.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.7.0.html


# pytest-3.7.0¶


---


# pytest-5.3.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.3.3.html


# pytest-5.3.3¶

pytest 5.3.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.3.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.3.1.html


# pytest-4.3.1¶

pytest 4.3.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.4.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.4.2.html


# pytest-5.4.2¶

pytest 5.4.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.4.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.4.2.html


# pytest-4.4.2¶

pytest 4.4.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.1.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.1.0.html


# pytest-4.1.0¶


---


# pytest-2.9.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.9.0.html


# pytest-2.9.0¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Anatoly Bubenkov Bruno Oliveira Buck Golemon David Vierra Florian Bruhin Galaczi Endre Georgy Dyuldin Lukas Bednar Luke Murphy Marcin Biernat Matt Williams Michael Aquilina Raphael Pierzina Ronny Pfannschmidt Ryan Wooden Tiemo Kieft TomV holger krekel jab Happy testing, The py.test Development Team

# 2.9.0 (compared to 2.8.7)¶


---


# pytest-5.1.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.1.0.html


# pytest-5.1.0¶


---


# pytest-2.9.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.9.1.html


# pytest-2.9.1¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Bruno Oliveira Daniel Hahler Dmitry Malinovsky Florian Bruhin Floris Bruynooghe Matt Bachmann Ronny Pfannschmidt TomV Vladimir Bolshakov Zearin palaviv Happy testing, The py.test Development Team

# 2.9.1 (compared to 2.9.0)¶


---


# pytest-7.4.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.4.4.html


# pytest-7.4.4¶

pytest 7.4.4 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# py.test 2.1.2: bug fixes and fixes for jython - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.1.2.html


# py.test 2.1.2: bug fixes and fixes for jython¶

pytest-2.1.2 is a minor backward compatible maintenance release of the popular py.test testing tool. pytest is commonly used for unit, functional- and integration testing. See extensive docs with examples here: http://pytest.org/ Most bug fixes address remaining issues with the perfected assertions introduced in the 2.1 series - many thanks to the bug reporters and to Benjamin Peterson for helping to fix them. pytest should also work better with Jython-2.5.1 (and Jython trunk). If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

best, holger krekel / https://merlinux.eu/

# Changes between 2.1.1 and 2.1.2¶


---


# pytest-6.2.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.2.3.html


# pytest-6.2.3¶

pytest 6.2.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.3.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.3.1.html


# pytest-7.3.1¶

pytest 7.3.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.1.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.1.1.html


# pytest-3.1.1¶

pytest 3.1.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.2.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.2.1.html


# pytest-5.2.1¶

pytest 5.2.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.2.1: bug fixes, perfect teardowns - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.2.1.html


# pytest-2.2.1: bug fixes, perfect teardowns¶

pytest-2.2.1 is a minor backward-compatible release of the py.test testing tool. It contains bug fixes and little improvements, including documentation fixes. If you are using the distributed testing pluginmake sure to upgrade it to pytest-xdist-1.8. For general information see here: http://pytest.org/ To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest Special thanks for helping on this release to Ronny Pfannschmidt, Jurko Gospodnetic and Ralf Schmitt. best, holger krekel

# Changes between 2.2.0 and 2.2.1¶


---


# pytest-3.9.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.9.3.html


# pytest-3.9.3¶

pytest 3.9.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.1.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.1.2.html


# pytest-3.1.2¶

pytest 3.1.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.0.0rc2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.0.0rc2.html


# pytest-8.0.0rc2¶


---


# pytest-2.4.0: new fixture features/hooks and bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.4.0.html


# pytest-2.4.0: new fixture features/hooks and bug fixes¶

The just released pytest-2.4.0 brings many improvements and numerous bug fixes while remaining plugin- and test-suite compatible apart from a few supposedly very minor incompatibilities. See below for a full list of details. A few feature highlights: new yield-style fixtures pytest.yield_fixture , allowing to use existing with-style context managers in fixture functions. improved pdb support: import pdb ; pdb.set_trace() now works without requiring prior disabling of stdout/stderr capturing. Also the --pdb options works now on collection and internal errors and we introduced a new experimental hook for IDEs/plugins to intercept debugging: pytest_exception_interact(node, call, report) . shorter monkeypatch variant to allow specifying an import path as a target, for example: monkeypatch.setattr("requests.get", myfunc) better unittest/nose compatibility: all teardown methods are now only called if the corresponding setup method succeeded. integrate tab-completion on command line options if you have argcomplete configured. allow boolean expression directly with skipif/xfail if a “reason” is also specified. a new hook pytest_load_initial_conftests allows plugins like pytest-django to influence the environment before conftest files import django . reporting: color the last line red or green depending if failures/errors occurred or everything passed. The documentation has been updated to accommodate the changes, see http://pytest.org To install or upgrade pytest:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

Many thanks to all who helped, including Floris Bruynooghe, Brianna Laugher, Andreas Pelme, Anthon van der Neut, Anatoly Bubenkoff, Vladimir Keleshev, Mathieu Agopian, Ronny Pfannschmidt, Christian Theunert and many others. may passing tests be with you, holger krekel

# Changes between 2.3.5 and 2.4¶


---


# pytest-3.7.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.7.3.html


# pytest-3.7.3¶

pytest 3.7.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.5.2: fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.5.2.html


# pytest-2.5.2: fixes¶

pytest is a mature Python testing tool with more than 1000 tests against itself, passing on many different interpreters and platforms. The 2.5.2 release fixes a few bugs with two maybe-bugs remaining and actively being worked on (and waiting for the bug reporter’s input). We also have a new contribution guide thanks to Piotr Banaszkiewicz and others. See docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to the following people who contributed to this release: Anatoly Bubenkov Ronny Pfannschmidt Floris Bruynooghe Bruno Oliveira Andreas Pelme Jurko Gospodnetić Piotr Banaszkiewicz Simon Liedtke lakka Lukasz Balcerzak Philippe Muller Daniel Hahler have fun, holger krekel

# 2.5.2¶


---


# pytest-3.4.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.4.2.html


# pytest-3.4.2¶

pytest 3.4.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.4.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.4.0.html


# pytest-7.4.0¶


---


# pytest-7.2.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.2.0.html


# pytest-7.2.0¶


---


# pytest-4.6.8 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.8.html


# pytest-4.6.8¶

pytest 4.6.8 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.1.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.1.1.html


# pytest-5.1.1¶

pytest 5.1.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.0.0rc1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.0.0rc1.html


# pytest-7.0.0rc1¶


---


# pytest-3.9.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.9.1.html


# pytest-3.9.1¶

pytest 3.9.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.0.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.1.html


# pytest-3.0.1¶


---


# pytest-3.0.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.3.html


# pytest-3.0.3¶

pytest 3.0.3 has just been released to PyPI. This release fixes some regressions and bugs reported in the last version, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.6.1: fixes and new xfail feature - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.6.1.html


# pytest-2.6.1: fixes and new xfail feature¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. The 2.6.1 release is drop-in compatible to 2.5.2 and actually fixes some regressions introduced with 2.6.0. It also brings a little feature to the xfail marker which now recognizes expected exceptions, see the CHANGELOG below. See docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed, among them: Floris Bruynooghe Bruno Oliveira Nicolas Delaby have fun, holger krekel

# Changes 2.6.1¶


---


# pytest-2.7.2: bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.7.2.html


# pytest-2.7.2: bug fixes¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.7.1. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Bruno Oliveira Floris Bruynooghe Punyashloka Biswal Aron Curzon Benjamin Peterson Thomas De Schampheleire Edison Gustavo Muenz Holger Krekel Happy testing, The py.test Development Team

# 2.7.2 (compared to 2.7.1)¶


---


# pytest-2.6.0: shorter tracebacks, new warning system, test runner compat - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.6.0.html


# pytest-2.6.0: shorter tracebacks, new warning system, test runner compat¶

pytest is a mature Python testing tool with more than 1000 tests against itself, passing on many different interpreters and platforms. The 2.6.0 release should be drop-in backward compatible to 2.5.2 and fixes a number of bugs and brings some new features, mainly: shorter tracebacks by default: only the first (test function) entry and the last (failure location) entry are shown, the ones between only in “short” format. Use --tb=long to get back the old behaviour of showing “long” entries everywhere. a new warning system which reports oddities during collection and execution. For example, ignoring collecting Test* classes with an __init__ now produces a warning. various improvements to nose/mock/unittest integration Note also that 2.6.0 departs with the “zero reported bugs” policy because it has been too hard to keep up with it, unfortunately. Instead we are for now rather bound to work on “upvoted” issues in the https://bitbucket.org/pytest-dev/pytest/issues?status=new&status=open&sort=-votes issue tracker. See docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed, among them: Benjamin Peterson Jurko Gospodnetić Floris Bruynooghe Marc Abramowitz Marc Schlaich Trevor Bekolay Bruno Oliveira Alex Groenholm have fun, holger krekel

# 2.6.0¶


---


# pytest-2.4.1: fixing three regressions compared to 2.3.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.4.1.html


# pytest-2.4.1: fixing three regressions compared to 2.3.5¶

pytest-2.4.1 is a quick follow up release to fix three regressions compared to 2.3.5 before they hit more people: When using parser.addoption() unicode arguments to the “type” keyword should also be converted to the respective types. thanks Floris Bruynooghe, @dnozay. (fixes issue360 and issue362) fix dotted filename completion when using argcomplete thanks Anthon van der Neuth. (fixes issue361) fix regression when a 1-tuple (“arg”,) is used for specifying parametrization (the values of the parametrization were passed nested in a tuple). Thanks Donald Stufft. also merge doc typo fixes, thanks Andy Dirnberger as usual, docs at http://pytest.org and upgrades via:

```

pip
install
-
U
pytest

```


---


# py.test 2.1.1: assertion fixes and improved junitxml output - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.1.1.html


# py.test 2.1.1: assertion fixes and improved junitxml output¶

pytest-2.1.1 is a backward compatible maintenance release of the popular py.test testing tool. See extensive docs with examples here: http://pytest.org/ Most bug fixes address remaining issues with the perfected assertions introduced with 2.1.0 - many thanks to the bug reporters and to Benjamin Peterson for helping to fix them. Also, junitxml output now produces system-out/err tags which lead to better displays of tracebacks with Jenkins. Also a quick note to package maintainers and others interested: there now is a “pytest” man page which can be generated with “make man” in doc/. If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

best, holger krekel / https://merlinux.eu/

# Changes between 2.1.0 and 2.1.1¶


---


# pytest-2.7.1: bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.7.1.html


# pytest-2.7.1: bug fixes¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.7.0. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Bruno Oliveira Holger Krekel Ionel Maries Cristian Floris Bruynooghe Happy testing, The py.test Development Team

# 2.7.1 (compared to 2.7.0)¶


---


# pytest-2.3.3: integration fixes, py24 support, */** shown in traceback - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.3.3.html


# pytest-2.3.3: integration fixes, py24 support,*/**shown in traceback¶

pytest-2.3.3 is another stabilization release of the py.test tool which offers uebersimple assertions, scalable fixture mechanisms and deep customization for testing with Python. Particularly, this release provides: integration fixes and improvements related to flask, numpy, nose, unittest, mock makes pytest work on py24 again (yes, people sometimes still need to use it) show *,** args in pytest tracebacks Thanks to Manuel Jacob, Thomas Waldmann, Ronny Pfannschmidt, Pavel Repin and Andreas Taumoefolau for providing patches and all for the issues. See http://pytest.org/ for general information. To install or upgrade pytest: pip install -U pytest # or easy_install -U pytest best, holger krekel

# Changes between 2.3.2 and 2.3.3¶


---


# pytest-7.1.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.1.2.html


# pytest-7.1.2¶

pytest 7.1.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.1.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.1.1.html


# pytest-6.1.1¶

pytest 6.1.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.0.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.0.0.html


# pytest-8.0.0¶


---


# pytest-5.4.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.4.3.html


# pytest-5.4.3¶

pytest 5.4.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-7.2.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.2.2.html


# pytest-7.2.2¶

pytest 7.2.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-5.2.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.2.2.html


# pytest-5.2.2¶

pytest 5.2.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.6.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.5.html


# pytest-4.6.5¶

pytest 4.6.5 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.0.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.0.0.html


# pytest-4.0.0¶


---


# pytest-7.1.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.1.0.html


# pytest-7.1.0¶


---


# pytest-7.4.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-7.4.1.html


# pytest-7.4.1¶

pytest 7.4.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.8.2: bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.8.2.html


# pytest-2.8.2: bug fixes¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.8.1. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Bruno Oliveira Demian Brecht Florian Bruhin Ionel Cristian Mărieș Raphael Pierzina Ronny Pfannschmidt holger krekel Happy testing, The py.test Development Team

# 2.8.2 (compared to 2.7.2)¶


---


# pytest-5.1.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.1.3.html


# pytest-5.1.3¶

pytest 5.1.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-3.0.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.0.4.html


# pytest-3.0.4¶

pytest 3.0.4 has just been released to PyPI. This release fixes some regressions and bugs reported in the last version, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-8.3.3 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.3.3.html


# pytest-8.3.3¶

pytest 8.3.3 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-2.5.1: fixes and new home page styling - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.5.1.html


# pytest-2.5.1: fixes and new home page styling¶

pytest is a mature Python testing tool with more than 1000 tests against itself, passing on many different interpreters and platforms. The 2.5.1 release maintains the “zero-reported-bugs” promise by fixing the three bugs reported since the last release a few days ago. It also features a new home page styling implemented by Tobias Bieniek, based on the flask theme from Armin Ronacher: http://pytest.org If you have anything more to improve styling and docs, we’d be very happy to merge further pull requests. On the coding side, the release also contains a little enhancement to fixture decorators allowing to directly influence generation of test ids, thanks to Floris Bruynooghe. Other thanks for helping with this release go to Anatoly Bubenkoff and Ronny Pfannschmidt. As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

have fun and a nice remaining “bug-free” time of the year :) holger krekel

# 2.5.1¶


---


# pytest-5.3.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-5.3.0.html


# pytest-5.3.0¶


---


# py.test 2.0.3: bug fixes and speed ups - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.0.3.html


# py.test 2.0.3: bug fixes and speed ups¶

Welcome to pytest-2.0.3, a maintenance and bug fix release of pytest, a mature testing tool for Python, supporting CPython 2.4-3.2, Jython and latest PyPy interpreters. See the extensive docs with tested examples here: http://pytest.org/ If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

There also is a bugfix release 1.6 of pytest-xdist, the plugin that enables seamless distributed and “looponfail” testing for Python. best, holger krekel

# Changes between 2.0.2 and 2.0.3¶


---


# pytest-8.1.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.1.0.html


# pytest-8.1.0¶


---


# pytest-8.0.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-8.0.1.html


# pytest-8.0.1¶

pytest 8.0.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.0.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.0.2.html


# pytest-6.0.2¶

pytest 6.0.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-6.0.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-6.0.1.html


# pytest-6.0.1¶

pytest 6.0.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.6.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.6.0.html


# pytest-4.6.0¶


---


# pytest-3.9.0 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.9.0.html


# pytest-3.9.0¶


---


# pytest-2.3: improved fixtures / better unittest integration - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.3.0.html


# pytest-2.3: improved fixtures / better unittest integration¶

pytest-2.3 comes with many major improvements for fixture/funcarg management and parametrized testing in Python. It is now easier, more efficient and more predictable to re-run the same tests with different fixture instances. Also, you can directly declare the caching “scope” of fixtures so that dependent tests throughout your whole test suite can reuse database or other expensive fixture objects with ease. Lastly, it’s possible for fixture functions (formerly known as funcarg factories) to use other fixtures, allowing for a completely modular and reusable fixture design. For detailed info and tutorial-style examples, see: http://pytest.org/en/stable/explanation/fixtures.html Moreover, there is now support for using pytest fixtures/funcargs with unittest-style suites, see here for examples: http://pytest.org/en/stable/how-to/unittest.html Besides, more unittest-test suites are now expected to “simply work” with pytest. All changes are backward compatible and you should be able to continue to run your test suites and 3rd party plugins that worked with pytest-2.2.4. If you are interested in the precise reasoning (including examples) of the pytest-2.3 fixture evolution, please consult http://pytest.org/en/stable/funcarg_compare.html For general info on installation and getting started: http://pytest.org/en/stable/getting-started.html Docs and PDF access as usual at: http://pytest.org and more details for those already in the knowing of pytest can be found in the CHANGELOG below. Particular thanks for this release go to Floris Bruynooghe, Alex Okrushko Carl Meyer, Ronny Pfannschmidt, Benjamin Peterson and Alex Gaynor for helping to get the new features right and well integrated. Ronny and Floris also helped to fix a number of bugs and yet more people helped by providing bug reports. have fun, holger krekel

# Changes between 2.2.4 and 2.3.0¶


---


# pytest-3.2.2 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-3.2.2.html


# pytest-3.2.2¶

pytest 3.2.2 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# pytest-4.4.1 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-4.4.1.html


# pytest-4.4.1¶

pytest 4.4.1 has just been released to PyPI. This is a bug-fix release, being a drop-in replacement. To upgrade:

```

pip
install
--
upgrade
pytest

```


---


# py.test 2.1.0: perfected assertions and bug fixes - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.1.0.html


# py.test 2.1.0: perfected assertions and bug fixes¶

Welcome to the release of pytest-2.1, a mature testing tool for Python, supporting CPython 2.4-3.2, Jython and latest PyPy interpreters. See the improved extensive docs (now also as PDF!) with tested examples here: http://pytest.org/ The single biggest news about this release are perfected assertions courtesy of Benjamin Peterson. You can now safely use assert statements in test modules without having to worry about side effects or python optimization (“-OO”) options. This is achieved by rewriting assert statements in test modules upon import, using a PEP302 hook. See https://docs.pytest.org/en/stable/how-to/assert.html for detailed information. The work has been partly sponsored by my company, merlinux GmbH. For further details on bug fixes and smaller enhancements see below. If you want to install or upgrade pytest, just type one of:

```

pip
install
-
U
pytest
# or
easy_install
-
U
pytest

```

best, holger krekel / https://merlinux.eu/

# Changes between 2.0.3 and 2.1.0¶


---


# pytest-2.8.4 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.8.4.html


# pytest-2.8.4¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.8.2. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Bruno Oliveira Florian Bruhin Jeff Widman Mehdy Khoshnoody Nicholas Chammas Ronny Pfannschmidt Tim Chan Happy testing, The py.test Development Team

# 2.8.4 (compared to 2.8.3)¶


---


# pytest-2.8.5 - pytest documentation

URL: https://docs.pytest.org/en/stable/announce/release-2.8.5.html


# pytest-2.8.5¶

pytest is a mature Python testing tool with more than 1100 tests against itself, passing on many different interpreters and platforms. This release is supposed to be drop-in compatible to 2.8.4. See below for the changes and see docs at: http://pytest.org As usual, you can upgrade from pypi via:

```

pip
install
-
U
pytest

```

Thanks to all who contributed to this release, among them: Alex Gaynor aselus-hub Bruno Oliveira Ronny Pfannschmidt Happy testing, The py.test Development Team

# 2.8.5 (compared to 2.8.4)¶


---


# 

URL: https://docs.pytest.org/en/stable/_images/freiburg2.jpg



---
