# Java Platform, Standard Edition Documentation - Releases

URL: https://docs.oracle.com/en/java/javase/


# Java Platform, Standard Edition Documentation

Java Platform, Standard Edition (Java SE) helps you develop and deploy Java applications on desktops and servers. Java offers the rich user interface, performance, versatility, portability, and security that today's applications require.

# Current Java SE Versions

# Versions inSustaining Support


---


# JDK 19 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/19/index.html


# JDK 19 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 11 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/11/index.html


# JDK 11 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 24 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/24/index.html


# JDK 24 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 22 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/22/index.html


# JDK 22 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 18 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/18/index.html


# JDK 18 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 15 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/15/index.html


# JDK 15 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 17 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/17/index.html


# JDK 17 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# Java Platform, Standard Edition Documentation - Releases

URL: https://docs.oracle.com/en/java/javase/index.html


# Java Platform, Standard Edition Documentation

Java Platform, Standard Edition (Java SE) helps you develop and deploy Java applications on desktops and servers. Java offers the rich user interface, performance, versatility, portability, and security that today's applications require.

# Current Java SE Versions

# Versions inSustaining Support


---


# JDK 12 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/12


# JDK 12 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 23 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/23/index.html


# JDK 23 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 16 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/16/index.html


# JDK 16 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 21 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/21/index.html


# JDK 21 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 14 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/14


# JDK 14 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 13 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/13


# JDK 13 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# JDK 20 Documentation - Home

URL: https://docs.oracle.com/en/java/javase/20/index.html


# JDK 20 Documentation

# Home

Java Components page Looking for a different release? Other releases

# Overview

# Tools

# Language and Libraries

# Specifications

# Security

# HotSpot Virtual Machine

# Manage and Troubleshoot

# Client Technologies


---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/19/gctuning/introduction-garbage-collection-tuning.html



---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/19/core/java-core-libraries1.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/19/jpackage/packaging-overview.html



---


# JVM(TM) Tool Interface 19.0.0

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Suspend All Virtual Threads

```

jvmtiError
SuspendAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume All Virtual Threads

```

jvmtiError
ResumeAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int can_support_virtual_threads : 1;
    unsigned int : 3;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

jvmtiError (JNICALL *SuspendAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *ResumeAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
    jvmtiEventVirtualThreadStart VirtualThreadStart;
    jvmtiEventVirtualThreadEnd VirtualThreadEnd;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Virtual Thread Start

```

void JNICALL
VirtualThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Virtual Thread End

```

void JNICALL
VirtualThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Java SE 19 & JDK 19

URL: https://docs.oracle.com/en/java/javase/19/docs/api/overview-summary.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/19/install/overview-jdk-installation.html



---


# Java Development Kit Version 19 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/man/index.html


# JavaDevelopment Kit Version 19 Tool Specifications

# All Platforms

# Windows Only


---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/19/vm/java-virtual-machine-technology-overview.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/19/management/overview-java-se-monitoring-and-management.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/19/jmx/introduction-jmx-technology.html



---


# JDK 19 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/19/books.html


# JDK 19 Documentation


---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/19/install/version-string-format.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/19/access/java-accessibility-overview.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 19

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 19


---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/19/security/java-security-overview1.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/19/troubleshoot/general-java-troubleshooting.html



---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/19/jshell/introduction-jshell.html



---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/19/migrate/getting-started.html



---


# JDK 19 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/19/related-resources.html


# JDK 19 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/19/jfapi/why-use-jfr-api.html



---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/19/language/java-language-changes.html



---


# Documentation Comment Specification for the Standard Doclet (JDK 19)

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 19, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, enum member, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. The overall form of a documentation comment is an initial main description , followed by a series of block tags , which provide additional information about the declaration to which the comment applies. Descriptive text may include inline tags and HTML content , as described below. Leading asterisks at the beginning of each line, and any preceding whitespace, are ignored. It is possible to have a comment with only block tags and no main description. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html .

# Main Description

The main description in a documentation comment is the content from the beginning of the comment, up to the first block tag, if there are any, or to the end of the comment, if there are none. Leading and trailing whitespace is ignored. If there is no such content, the main description is said to be missing. The main description cannot continue after any block tags. The first sentence of the main description should be a summary sentence that contains a concise but complete description of the declared entity.

# Block Tags

Block tags are of the form @ identifier content and give additional details to be incorporated into the generated documentation. Each block tag must appear at the beginning of a line, ignoring leading asterisks, whitespace characters, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . The content of a block tag is any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. The content can span multiple lines. There can be any number of block tags; some types of tags can be repeated while others cannot.

# Inline Tags

Inline tags are of the form {@ identifier content } and provide details within the context of the enclosing description. They may generally appear wherever descriptive text and HTML is permitted, although some inline tags may only be used at the beginning of the main description. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , \ , and @ . Lines beginning with @ that are enclosed within an inline tag are not considered as beginning a block tag. When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading whitespace is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# References

References are the constructs in a documentation comment that refer to elements in the surrounding declarations. Depending on the context, they may refer to modules, packages, classes and interfaces, constructors, methods, annotation members, fields, enum members, parameters, record components and the names of exceptions that may be thrown by a method or constructor. The most general form of a reference is: This form is used by the @see , {@link} and {@linkplain} tags. Leading components can be omitted when they can be inferred from the surrounding context. Trailing components can be omitted when they are not required. Generally, the reference is evaluated in the scope in which the documentation comment exists. In particular, import statements for the compilation unit are taken into account when evaluating class and interface names. The class may be any top-level or nested class or interface. The member may be any constructor, method, annotation member, field or enum member, but not a nested class or interface. As in Java source code, a constructor is identified by using the name of its class. The name of a constructor or method should normally be followed by the list of its parameter types, enclosed in parentheses, although the parameter types and parentheses can be omitted if the method or constructor is not overloaded and the name is not also that of a field or enum member in the same class or interface. When a parameter list is given, whitespace characters may appear between tokens in the parameter list; whitespace characters may not appear elsewhere in the reference. When the reference is to a member of the same class as that containing the documentation comment, all parts of the reference up to and including the # may be omitted, although the '#' may be retained for clarity. Parameterized types may be used in the class and member parts of the reference; annotations may not be used anywhere in the reference. Whitespace characters may occur between tokens within the parameter list for a constructor or method. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. Note: you cannot refer to the declaration of a specific parameter or record component with this form. Other tags, such as @param , @throws , and @serialField may only provide support for the specific kinds of references that are relevant to each tag. See the description of individual tags for more details.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the description part of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the third form of the @see tag. The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example,

```

Refer to {@linkplain #add() the overridden method}.

```

is displayed as: Refer to the overridden method . Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the given description, providing details about the values that may be returned by the method. As an inline tag, provides content for the first sentence of a method's main description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's main description. Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified program element that is referenced. reference can refer to any valid program element. If this element is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text to be used as the link label. The label can contain whitespace characters. If no label is provided, a default is generated, based on the target of the reference. Use the label when you want the text to be different from the auto-generated text. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the @snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the @snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the {@snippet ...} tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline {@link ...} tag. Introduced in JDK 18.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a main description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain whitespace characters, or characters such as } . No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in all documentation comments. Introduced in JDK 12.

# @throws

Adds an exception with the specified name followed by the specified description to the "Throws" section. exception-name should refer to an exception that might be thrown by the method, and should either be the name of an exception class or a type variable. This tag is valid only in the documentation comment for a method or constructor. A documentation comment may use multiple @throws tags for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as if it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. The @exception tag is equivalent to this tag, although the @throws form is now recommended. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithms

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/19/javadoc/javadoc.html



---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/19/intl/internationalization-overview.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/11/docs/specs/jdwp/jdwp-spec.html



---


# Java SE 11 & JDK 11

URL: https://docs.oracle.com/en/java/javase/11/docs/api/overview-summary.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html



---


# JDK 11 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/11/related-resources.html


# JDK 11 Documentation

# Related Resources

# Java SE on OTN

# Java Components

# Java Training

# Java SE Subscriptions

# Java Forums

# Java Platform Group - Product Management Blog

# Java Source blog

# Java Tutorials blog


---


# Documentation Comment Specification for the Standard Doclet

URL: https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html



---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/index.html



---


# JDK 11 Documentation - Books

URL: https://docs.oracle.com/en/java/javase/11/books.html


# JDK 11 Documentation


---


# JVM(TM) Tool Interface 11.0.0

URL: https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 24

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 24


---


# Java Development Kit Version 24 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/man/index.html


# JavaDevelopment Kit Version 24 Tool Specifications

# All Platforms

# Windows Only


---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/jni/index.html



---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/24/jfapi/why-use-jfr-api.html



---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/24/jpackage/packaging-overview.html



---


# JavaDoc Documentation Comment Specification for the Standard Doclet (JDK 24)

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 24, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# Documentation Comments

Documentation comments are stylized comments appearing in source code, near to the declarations that they serve to document. Documentation comments are recognized only when placed immediately before the declaration of a module, package, class, interface, constructor, method, annotation interface element, enum member, or field. In other words, a documentation comment should appear before any annotation, modifier, keyword, identifier, or other Java construct that is part of the declaration. There are two kinds of documentation comments: traditional documentation comments , and Markdown documentation comments . Either kind, or both kinds, may be used in any one source file. Only one documentation comment per declaration statement is recognized. If there are multiple documentation comments before a declaration, the one closest to the beginning of the declaration is used. Documentation may also be provided in certain files: HTML files are identified by a filename ending in .html . The content of the <main> element of an HTML file, or the <body> element if there is no <main> element is processed as if it were the content of a traditional documentation comment. Markdown files are identified by a filename ending in .md . The content of a Markdown file is processed as if it were the content of a Markdown documentation comment.

# Traditional Documentation Comments

Traditional documentation comments are traditional comments that begin with /** . If any line in such a comment begins with asterisks after any leading whitespace, the leading whitespace and asterisks are removed. Any whitespace appearing after the asterisks is not removed. A traditional documentation comment may contain HTML content , inline tags , and block tags . You can also use escape sequences to represent characters that would otherwise be inconvenient or difficult to represent.

# Markdown Documentation Comments

Documentation comments containing Markdown are composed of a series of consecutive lines, each beginning with optional whitespace followed by /// . A Markdown documentation comment may contain Markdown content (including HTML where necessary), inline tags , and block tags .

# General Syntax

The overall form of a documentation comment is an initial main description , followed by a series of block tags , which provide additional information about the declaration to which the comment applies. Descriptive text may include inline tags , HTML content , and Markdown content , as described below. It is possible to have a comment with only block tags and no main description. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html .

# Main Description

The main description in a documentation comment is the content from the beginning of the comment, up to the first block tag, if there are any, or to the end of the comment, if there are none. Leading and trailing whitespace is ignored. If there is no such content, the main description is said to be missing. The main description cannot continue after any block tags. Examples of a missing main description. No content before the first block tag:

```

/**
 * @param ...
 * ...
 */

```

An empty documentation comment:

```

/**
 *
 */

```

The first sentence of the main description should be a summary sentence that contains a concise but complete description of the declared entity.

# Block Tags

Block tags are of the form @ identifier content and give additional details to be incorporated into the generated documentation. Each block tag must appear at the beginning of a line, ignoring leading asterisks, whitespace characters, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text, and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . The content of a block tag is any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. The content can span multiple lines. There can be any number of block tags; some types of tags can be repeated while others cannot.

# Inline Tags

Inline tags are of the form {@ identifier content } and provide details within the context of the enclosing description. They may generally appear wherever descriptive text and HTML is permitted, although some inline tags may only be used at the beginning of the main description. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , \ , and @ . Lines beginning with @ that are enclosed within an inline tag are not considered as beginning a block tag. When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at heading level 2 and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at heading level 4. In standalone HTML files, such as in a doc-files subdirectory, headings should start at heading level 1. To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Markdown Content

Because horizontal whitespace at the beginning and end of each line of Markdown code may be significant, the content of such a comment is determined as follows: Note: The policy to remove leading incidental whitespace is similar to that for String.stripIndent , except that there is no need for any special treatment for a trailing blank line. There are no restrictions on the characters that may appear after the /// on each line of the comment. In particular, the comment may contain code samples which may contain comments of their own:

```

/// Here is an example:
///
/// ```
/// /** Hello World! */
/// public class HelloWorld {
///     public static void main(String... args) {
///         System.out.println("Hello World!"); // the traditional example
///     }
/// }
/// ```

```

As well as serving to visually distinguish the new kind of documentation comment, the use of end-of-line ( // ) comments eliminates the restrictions on the content of the comment that are inherent with the use of traditional ( /* ... */ ) comments. In particular, it is not possible to use the character sequence */ within a traditional comment, ( JLS 3.7 ) although it may be desirable to do so when writing example code containing traditional comments, strings containing "glob" expressions, and strings containing regular expressions. Note: For a blank line to be included in the comment, it must begin with any optional whitespace followed by /// . A completely blank line will cause any preceding and following comment to be treated as separate comments, in which case, all but the last comment will be discarded, and only the last comment will be considered as a documentation comment for any declaration that may follow. For example:

```

/// This is an example ...
///
/// ... of a 3-line comment containing a blank line.

```

The blank line in the following example will terminate the first comment, so that the comment that comes after the blank line will be treated as a separate comment.

```

/// This comment will be treated as a "dangling comment" and will be ignored.

/// This is the comment for the following declaration.
public void m() { }

```

The same is true for any other comment not beginning with /// that may appear between two /// comments.

# Syntax

The overall syntax of a Markdown documentation comment is that of the CommonMark variant of Markdown. Enhancements to links allow convenient linking to other program elements. Simple GFM pipe tables are supported, as are all JavaDoc tags.

# Headings

Both ATX headings and setext headings are supported. Unlike HTML headings, Markdown headings should start at level 1 and increase from there, whatever the context of the documentation comment. (They will be translated to the correct heading level in the generated documentation.)

# Links

The general form of a reference link is [text][label] where text is the text to be displayed, and label is a label for the destination of the link, and which is subsequently defined by a line of the form [label]:  uri . Collapsed and shortcut forms can also be used when the label is the same as the text . In a documentation comment, if the label for a reference link is to be defined explicitly, it must be defined in the same documentation comment. But, if it is not defined and if it syntactically matches that of a reference to a program element, then it is implicitly defined as a reference to that program element. It is an error if the label looks like a reference to a program element but there is no such element. The following all represent links to java.lang.Object#hashCode() , albeit with different text to be displayed: You can link to any kind of program element, as shown in the following examples:

```

/// * a module [java.base/]
/// * a package [java.util]
/// * a class [String]
/// * a field [String#CASE_INSENSITIVE_ORDER]
/// * a method [String#chars()]

```

Inline links are also supported in documentation comments, but the helpful recognition of program elements as labels means that reference links are generally more useful than inline links. According to the standard rules for reference links, you must escape any use of square brackets within a reference. This might occur when you are creating a reference to a method with an array parameter. The following shows a link to String.copyValueOf(char[]) The normal rendering for a reference link is to use the default plain font. If you wish to use a monospace font, you must enclose the text within a code span, using backticks. For references to program elements, monospace font will be used automatically if the text is the same as the reference (such as when using the collapsed or shortcut forms), and the default plain font otherwise. The following shows how these forms correspond to the existing link and linkplain tags. Note: You cannot use a reference link in the first sentence of any documentation comment that refers to a user-defined link reference definition elsewhere in the documentation comment; you can use an inline link in this situation instead.

# Tables

Simple tables are supported, using the syntax defined in GitHub Flavored Markdown . For example, a simple table might be written as follows:

```

/// | Latin | Greek |
/// |-------|-------|
/// | a     | alpha |
/// | b     | beta  |
/// | c     | gamma |

```

Note: Captions and other features that may be required for accessibility are not supported. In such situations, the use of HTML tables is still recommended.

# Inline Tags and Block Tags

Both inline tags and block tags may be used in Markdown documentation comments, although neither may be used within the literal text of code spans and fenced or indented code blocks. For those tags that may contain text with markup, in a Markdown documentation comment that markup will also be in Markdown format. As in traditional documentation comments, the content of inline tags may span multiple lines, including blank lines. When using a reference link with an explicit link label , the reference and the label must appear in the same part of the comment: in either the main description, or in any inline or block tag. A reference link may not refer to a label defined in a different part of the comment, or in a different comment altogether. The inheritDoc tag is used to include documentation from one or more supertypes. There is no requirement that the format of the comment containing the tag is the same as the format of the comment containing the documentation to be inherited. While it may be the case that comments within a library may all use the same format, that may be less likely when handling comments in different libraries, written by different authors.

# Syntax Highlighting and Embedded Languages

The opening fence in a fenced code block may be followed by an info string , the first word of which is used to derive the CSS class name in the corresponding generated HTML, and which may be used by JavaScript libraries to enable syntax highlighting (such as with Prism ) or rendering diagrams (such as with Mermaid ). Note: You can add JavaScript libraries to your documentation by using the javadoc --add-script option.

# Escape Sequences

The following escape sequences are supported in traditional documentation comments wherever text, entities and HTML may appear, to represent characters that would otherwise be inconvenient or difficult to represent: Escape sequences are context-sensitive, and can only be used where the use of the escaped character by itself would have a different syntactic interpretation. In other situations, these character sequences are taken literally, without additional interpretation. Escape sequences cannot be used in inline tags that contain literal text; this includes code , literal , snippet , and user-defined tags.

# References

References are the constructs in a documentation comment that refer to elements in the surrounding declarations. Depending on the context, they may refer to modules, packages, classes and interfaces, constructors, methods, annotation members, fields, enum members, parameters, record components and the names of exceptions that may be thrown by a method or constructor. The most general form of a reference is: This form is used by the see , link and linkplain tags. Leading components can be omitted when they can be inferred from the surrounding context. Trailing components can be omitted when they are not required. Generally, the reference is evaluated in the scope in which the documentation comment exists. In particular, import statements for the compilation unit are taken into account when evaluating class and interface names. The class may be any top-level or nested class or interface. The member may be any constructor, method, annotation member, field or enum member, but not a nested class or interface. As in Java source code, a constructor is identified by using the name of its class. The name of a constructor or method should normally be followed by the list of its parameter types, enclosed in parentheses, although the parameter types and parentheses can be omitted if the method or constructor is not overloaded and the name is not also that of a field or enum member in the same class or interface. When a parameter list is given, whitespace characters may appear between tokens in the parameter list; whitespace characters may not appear elsewhere in the reference. When the reference is to a member of the same class as that containing the documentation comment, all parts of the reference up to and including the # may be omitted, although the '#' may be retained for clarity. Parameterized types may be used in the class and member parts of the reference; annotations may not be used anywhere in the reference. Whitespace characters may occur between tokens within the parameter list for a constructor or method. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. Note: You cannot refer to the declaration of a specific parameter or record component with this form. An alternative form is provided to generate references to arbitrary URI fragments in the generated documentation such as headings in documentation comments. This form uses a double hash mark ( ## ) as separator: fragment is interpreted as URI fragment within the page documenting the specified program element. Other tags, such as param , throws , and serialField may only provide support for the specific kinds of references that are relevant to each tag. See the description of individual tags for more details.

# Method Documentation

A documentation comment for a method declaration must at least provide the following: the main description , a param tag per method type parameter, if any, a return tag for the result, if the return type is not void , a param tag per formal parameter, if any, a throws tag per exception type, checked or unchecked, in the throws clause, if any. It is an error if any item described in that list is missing from a documentation comment of a method declaration and either of following is true: Otherwise, a missing item is considered as if it were provided with {@inheritDoc} as its content. For the purpose of this specification an overriding method declaration is a method declaration that could be annotated with @Override ( JLS 9.6.4.4 ), but is not an accessor method declaration for a record component. Method documentation allows inheritance by omission: if a documentation comment for a method declaration provides only some of the items, the rest are assumed to be inherited. For example, if this is provided:

```

/**
 * @param scale a non-zero number
 * @throws IllegalArgumentException if scale is 0
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

This is assumed:

```

/**
 * {@inheritDoc}
 *
 * @param <T> {@inheritDoc}
 * @param scale a non-zero number
 * @param element {@inheritDoc}
 * @return {@inheritDoc}
 * @throws IllegalArgumentException if scale is 0
 * @throws MagnificationException {@inheritDoc}
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

However, not all missing items can be inherited. For example, if a method declares an exception X that is not documented by any of the methods that this method overrides, then documentation item for that exception cannot be inherited and can only be provided by this method's documentation comment. (Adding or assuming @throws X {@inheritDoc} would be an error.) If that item is not provided, it is considered missing. ( @Override is only added to these examples to emphasize that the declarations are overriding; that annotation has no effect on documentation.) Note : A documentation comment consisting of a sole inheritDoc tag explicitly provides only the main description of a method:

```

/**
 * {@inheritDoc}
 */

```

Other items, if any, are inherited by omission. Note: It is the overriding method, not the overridden method, that determines which items are missing and which are not. For example, if an overriding method declares a thrown exception X , but that method's documentation comment does not contain @throws X ... , then that documentation item is missing. If an overriding method does NOT declare a thrown exception, even if the overridden method does, then that documentation item is NOT missing. This behavior is usually noticed when dealing with unchecked exceptions. Since unchecked exceptions do not normally appear in the throws clause, unless explicitly documented, they will not be missing. This gives rise to a misconception that the standard doclet treats checked exceptions differently from unchecked exceptions, which it does not. In fact, a similar behavior might be replicated with checked exceptions. Consider a method that declares two checked exceptions X and Y , such that X is a supertype of Y . If an overriding method declares X but not Y , then @throws Y ... won't be missing.

# Overriding Methods in Classes and Interfaces

When a method declaration overrides a method in the superclass or an extended superinterface, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. When a method declaration in a class overrides a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. In both cases, a link to the overridden method is included.

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple author tags. You can specify one name per author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. If there are no author tags in the description for a member class or interface, the standard doclet will (recursively) look for any such tags in the enclosing class or interface. Introduced in JDK 1.0.

# code

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the literal tag. Introduced in JDK 1.5.

# deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include a link tag that points to the replacement API. Note: Introduced in JDK 1.0.

# docRoot

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. The docRoot tag can be used both on the command line and in a documentation comment. The tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the return , param and deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the docRoot tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# exception

This tag is equivalent to the throws tag, which is now the recommended form. Introduced in JDK 1.0.

# hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# index

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# inheritDoc

Indicates that a method documentation comment part that contains this tag is the same as that of the overridden method in a superclass or superinterface, which is either determined automatically or specified. It is an error if the overridden method is missing the corresponding part. This tag enables you to write more general comments higher up the inheritance hierarchy and to write around the inherited parts. This tag is valid only in these places in a documentation comment of an overriding declaration of a method: If the corresponding part of the overridden method's documentation comment itself uses an inheritDoc tag, then that tag is processed first. (This might be applied recursively as required.) Let m be a method declaration in a class or interface T . If the documentation comment for m contains an inheritDoc tag then the superclass or superinterface (whose overridden method this tag will use the corresponding part of) is determined as follows:

# Automatic Supertype Search

The search for the supertype is performed in two phases: the recursive phase, then the final phase. For simplicity, the search starts from S , where S = T , although there's nothing to be found in T (otherwise, the search would not be required). When starting from S , where S = T , the first condition always breaks into "otherwise" because a method does not override itself ( JLS 8.4.8.1 ).

# Recursive phase

If S declares a method that T.m overrides, then S is a supertype, otherwise: If S is a class that has a direct superclass ( JLS 8.1.4 ) that is not java.lang.Object , then the recursive phase of the search is applied to that superclass. If that application has not found a supertype, then: If S has direct superinterfaces ( JLS 8.1.5 ), then the recursive phase of the search is applied to each of those superinterfaces, in the order that they are listed in the extends (if S is a class) or implements (if S is an interface) clause, until the supertype found or superinterfaces are exhausted.

# Final phase

If the recursive phase of search has not found the supertype, then one final attempt is made to see if java.lang.Object is the supertype. If T is a class and m overrides a method in java.lang.Object , or T is an interface and m 's signature is override-equivalent to the signature of a public method in java.lang.Object ( JLS 8.4.2 ), then java.lang.Object is the supertype. Otherwise, the search has not found the supertype. Note: The search is performed in two phases so as to not prematurely consider java.lang.Object as the supertype. Sometimes java.lang.Object provides overly general documentation for its public methods (such as equals , hashCode , toString ) when more specific documentation is available. For example, consider this schematic hierarchy:

```

interface A
interface B extends A
interface C
class D implements B, C
interface E
class F extends D implements E

```

```

(A)
     ^
      \
      (B) (C)    [java.lang.Object]
       ^   ^
        \ /
        [D] (E)
         ^   ^
          \ /
          [F]

```

```

(4)
     ^
      \
      (3) (5)    [7]
       ^   ^
        \ /
        [2] (6)
         ^   ^
          \ /
          [1]

```

Note: The source file for an inherited method must be on the source path for the documentation comment to be available for copy. Neither the class nor its package needs to be passed in on the command line. Note: When using Markdown comments , there is no requirement that the comment containing the tag and the comment containing the documentation inherited by that tag should either be both Markdown documentation comments or both traditional (not Markdown) comments. Introduced in JDK 1.4; accepts an optional argument since JDK 22.

# link

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the description part of any tag, such as the return , param and deprecated tags. This tag is similar to the third form of the see tag. The main difference is that the link tag generates an inline link rather than placing the link in the "See Also" section. The link tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of link tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# linkplain

Behaves the same as the link tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example,

```

Refer to {@linkplain #add() the overridden method}.

```

is displayed as: Refer to the overridden method . Introduced in JDK 1.4.

# literal

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the code tag. Introduced in JDK 1.5.

# param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

When an inheritDoc tag is used in the description of a method formal or type parameter, the corresponding part of the overridden method documentation is matched using the parameter's position, not the parameter's name ( JLS 8.4.2 and JLS 8.4.4 ). For example, consider the following method declaration:

```

/**
 ...
 * @param scale a non-zero number
 ...
 * @param <T> the type of the element being magnified
 ...
 */
 <T> T magnify(int scale, T element) throws MagnificationException

```

Then as far as the documentation inheritance is concerned, these two comments are equivalent:

```

/**
 ...
 * @param s {@inheritDoc}
 * @param e {@inheritDoc}
 ...
 * @param <E> {@inheritDoc}
 */
 @Override
 <E> E magnify(int s, E e) throws MagnificationException

/**
 ...
 * @param scale {@inheritDoc}
 * @param element {@inheritDoc}
 ...
 * @param <T> {@inheritDoc}
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

If parameter names differ, care should be taken when inheriting such parameter documentation because that parameter name might be referred to from elsewhere both in the overridden and overriding methods. Introduced in JDK 1.0.

# provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# return

As a block tag, adds a "Returns" section with the given description, providing details about the values that may be returned by the method. As an inline tag, provides content for the first sentence of a method's main description, and a "Returns" section, as if " @return description " were also present. In the default English locale, the first sentence is " Returns description . ". This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's main description. When inheriting documentation, either form of a return tag can be used:

```

/**
 * {@return {@inheritDoc}}
 ...
 */
<T> T magnify(int scale, T element) throws MagnificationException

/**
 ...
 * @return {@inheritDoc}
 */
 <T> T magnify(int scale, T element) throws MagnificationException

```

Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of see tags, which are all grouped under the same heading. The see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, use a link tag. @see " string " Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. @see <a href=" url "> label </a> Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. @see reference label Adds a link with a visible text label that points to the documentation for the specified program element that is referenced. reference can refer to any valid program element. If this element is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is text to be used as the link label and is optional for references to program elements. If no label is provided for an element reference, a default is generated, based on the target of the reference. Use the label when you want the text to be different from the auto-generated text. For references to URI fragments a label must be provided. The label can contain whitespace characters. If the content of the label appears to be a phrase, and not just a possibly-abbreviated form of a reference to the target link, the link will be displayed in plain font; otherwise, the link will be displayed in monospace font. Introduced in JDK 1.0.

# serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. A serial tag at the class level overrides any serial tag at the package level. Introduced in JDK 1.2.

# serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExternal method. The serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# since

Adds a "Since" heading with the specified since-text value to the generated documentation. The tag indicates that the associated program element has existed since it was introduced in the software release specified by the since-text value. For example, @since 11 . The text has no special internal structure, meaning that commas, whitespace characters and other punctuation have no special significance. Multiple since tags are allowed; for example, you could use multiple tags when the program element is part of more than one API. However, when used in conjunction with the feature in the standard doclet to generate a summary page of what API is new in each release, the since-text value of the first tag should be a simple string with no formatting markup. It is recommended that each top-level program element (module, package, class or interface) should contain an appropriate since tag. In addition, each member element (constructor, method, field, nested class or interface) should have a tag in those cases where the value is different from that of the enclosing class or interface. If there are no since tags in the description for a member class or interface, the standard doclet will (recursively) look for any such tags in the enclosing class or interface. Note: One or more methods may be added implicitly to a class or interface as a result of adding additional supertypes in an extends or implements clause, after the class or interface was first created. Note: Changing the return type of a method to a covariant return type is tantamount to adding a new method with that signature, and should be given an updated since tag. This is because the method with that new return type could not be called in any prior release to leverage that new return type. Introduced in JDK 1.1.

# snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external or a hybrid snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the snippet tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline link tag. Introduced in JDK 18.

# spec

Identifies an external specification in terms of its URL and title. The URL may be absolute or relative. Relative URLs will be evaluated against a "base URL". All tags specifying the same URL must provide the same corresponding title; conversely, tags with different URLs must have different titles. Introduced in JDK 20.

# summary

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a main description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# systemProperty

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain whitespace characters, or characters such as } . No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in all documentation comments. Introduced in JDK 12.

# throws

Adds an exception with the specified name followed by the specified description to the "Throws" section of a Method or Constructor detail. exception-name should refer to an exception that might be thrown by the method, and should either be the name of an exception class or a type variable. This tag is valid only in the documentation comment for a method or constructor. A documentation comment may use multiple throws tags for the same or different exceptions. If such a comment is then targeted by an inheritDoc tag, it copies all exceptions of that kind into the "Throws" section. Note: An unchecked exception class may be omitted from the throws clause, and so won't be considered missing in a method documentation. To inherit a description of such an exception, add a corresponding throws tag with an inheritDoc tag in its description. To ensure that all checked exceptions are documented, when a throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as if it were documented with the throws tag. The exception tag is equivalent to this tag, although using a throws tag is now recommended. Introduced in JDK 1.2.

# uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# value

Displays the value of a static field with a compile-time constant value. The format string may be omitted, in which case a default format will be used, appropriate to the type of the field. If the format string is given, it must either begin with a percent character ( % ) or be enclosed in double-quote characters ( " ). It must contain exactly one percent character. The string must conform to the definition of a format string, as specified in the documentation for java.util.Formatter . The conversion specified in the format string must be appropriate for the type of the constant value. When the value tag is used without a field_reference argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with a field-reference argument in any documentation comment, the value tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

Introduced in JDK 1.4; format added in JDK 20.

# version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple version tags. When it makes sense, you can specify one release number per version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. If there are no version tags in the description for a member class or interface, the standard doclet will (recursively) look for any such tags in the enclosing class or interface. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/24/jshell/introduction-jshell.html



---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/24/core/java-core-libraries1.html



---


# JVM(TM) Tool Interface 24.0.0

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Null Pointers

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_IN_OBJECT_WAIT

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Suspend All Virtual Threads

```

jvmtiError
SuspendAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume All Virtual Threads

```

jvmtiError
ResumeAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int can_support_virtual_threads : 1;
    unsigned int : 3;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

jvmtiError (JNICALL *SuspendAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *ResumeAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
    jvmtiEventVirtualThreadStart VirtualThreadStart;
    jvmtiEventVirtualThreadEnd VirtualThreadEnd;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Virtual Thread Start

```

void JNICALL
VirtualThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Virtual Thread End

```

void JNICALL
VirtualThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/24/vm/java-virtual-machine-technology-overview.html



---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/24/gctuning/introduction-garbage-collection-tuning.html



---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/24/intl/internationalization-overview.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/24/install/overview-jdk-installation.html



---


# JDK 24 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/24/related-resources.html


# JDK 24 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/24/management/overview-java-se-monitoring-and-management.html



---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/24/security/java-security-overview1.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/24/troubleshoot/general-java-troubleshooting.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups: In addition to the above Main attributes defined by the Java Platform, the JDK Reference Implementation also supports the following attributes for stand-alone applications that are bundled into executable JAR files. These attributes are ignored for JAR files that are not run with " java -jar x.jar ".

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
        Created-By: 1.8 (Oracle Inc.)
        Sealed: true

        Name: foo/bar/
        Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files not using the PKCS #7 format must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. ` For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF` file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/24/migrate/getting-started.html



---


# JDK 24 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/24/books.html


# JDK 24 Documentation


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java SE 24 & JDK 24

URL: https://docs.oracle.com/en/java/javase/24/docs/api/overview-summary.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/24/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithms

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KDFAlgorithms

The algorithm names in this section can be specified when requesting an instance of KDF .

# KEMAlgorithms

The algorithm names in this section can be specified when generating an instance of KEM .

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

# NamedParameterSpec

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names.

# ECGenParameterSpec

The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PSSParameterSpec

The PSSParameterSpec class in the java.security.spec package may be used to specify the hash and mask generation function algorithms for the RSASSA-PSS signature algorithm using the following names.

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/24/javadoc/javadoc-tool.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/24/jmx/introduction-jmx-technology.html



---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/24/install/version-string-format.html



---


# Java Language Changes by Release

URL: https://docs.oracle.com/en/java/javase/24/language/java-language-changes-release.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/24/access/java-accessibility-overview.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/22/access/java-accessibility-overview.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/22/troubleshoot/general-java-troubleshooting.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/22/install/overview-jdk-installation.html



---


# JDK 22 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/22/books.html


# JDK 22 Documentation


---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/22/language/java-language-changes.html



---


# Java Development Kit Version 22 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/man/index.html


# JavaDevelopment Kit Version 22 Tool Specifications

# All Platforms

# Windows Only


---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/22/vm/java-virtual-machine-technology-overview.html



---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/22/gctuning/introduction-garbage-collection-tuning.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 22

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 22


---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithms

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KEMAlgorithms

The algorithm names in this section can be specified when generating an instance of KEM .

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# JavaDoc Documentation Comment Specification for the Standard Doclet (JDK 22)

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 22, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are stylized comments appearing in source code, near to the declarations that they serve to document. Documentation comments are recognized only when placed immediately before the declaration of a module, package, class, interface, constructor, method, enum member, or field. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. The overall form of a documentation comment is an initial main description , followed by a series of block tags , which provide additional information about the declaration to which the comment applies. Descriptive text may include inline tags and HTML content , as described below. Leading asterisks at the beginning of each line, and any preceding whitespace, are ignored. It is possible to have a comment with only block tags and no main description. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html .

# Main Description

The main description in a documentation comment is the content from the beginning of the comment, up to the first block tag, if there are any, or to the end of the comment, if there are none. Leading and trailing whitespace is ignored. If there is no such content, the main description is said to be missing. The main description cannot continue after any block tags. Examples of a missing main description. No content before the first block tag:

```

/**
 * @param ...
 * ...
 */

```

An empty documentation comment:

```

/**
 *
 */

```

The first sentence of the main description should be a summary sentence that contains a concise but complete description of the declared entity.

# Block Tags

Block tags are of the form @ identifier content and give additional details to be incorporated into the generated documentation. Each block tag must appear at the beginning of a line, ignoring leading asterisks, whitespace characters, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . The content of a block tag is any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. The content can span multiple lines. There can be any number of block tags; some types of tags can be repeated while others cannot.

# Inline Tags

Inline tags are of the form {@ identifier content } and provide details within the context of the enclosing description. They may generally appear wherever descriptive text and HTML is permitted, although some inline tags may only be used at the beginning of the main description. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , \ , and @ . Lines beginning with @ that are enclosed within an inline tag are not considered as beginning a block tag. When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading whitespace is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# Escape Sequences

The following escape sequences are supported wherever text, entities and HTML may appear, to represent characters that would otherwise be inconvenient or difficult to represent: Escape sequences are context-sensitive, and can only be used where the use of the escaped character by itself would have a different syntactic interpretation. In other situations, these character sequences are taken literally, without additional interpretation. Escape sequences cannot be used in inline tags that contain literal text; this includes {@code} , {@literal} , {@snippet} , and user-defined tags.

# References

References are the constructs in a documentation comment that refer to elements in the surrounding declarations. Depending on the context, they may refer to modules, packages, classes and interfaces, constructors, methods, annotation members, fields, enum members, parameters, record components and the names of exceptions that may be thrown by a method or constructor. The most general form of a reference is: This form is used by the @see , {@link} and {@linkplain} tags. Leading components can be omitted when they can be inferred from the surrounding context. Trailing components can be omitted when they are not required. Generally, the reference is evaluated in the scope in which the documentation comment exists. In particular, import statements for the compilation unit are taken into account when evaluating class and interface names. The class may be any top-level or nested class or interface. The member may be any constructor, method, annotation member, field or enum member, but not a nested class or interface. As in Java source code, a constructor is identified by using the name of its class. The name of a constructor or method should normally be followed by the list of its parameter types, enclosed in parentheses, although the parameter types and parentheses can be omitted if the method or constructor is not overloaded and the name is not also that of a field or enum member in the same class or interface. When a parameter list is given, whitespace characters may appear between tokens in the parameter list; whitespace characters may not appear elsewhere in the reference. When the reference is to a member of the same class as that containing the documentation comment, all parts of the reference up to and including the # may be omitted, although the '#' may be retained for clarity. Parameterized types may be used in the class and member parts of the reference; annotations may not be used anywhere in the reference. Whitespace characters may occur between tokens within the parameter list for a constructor or method. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. Note: you cannot refer to the declaration of a specific parameter or record component with this form. An alternative form is provided to generate references to arbitrary URI fragments in the generated documentation such as headings in documentation comments. This form uses a double hash mark ( ## ) as separator: fragment is interpreted as URI fragment within the page documenting the specified program element. Other tags, such as @param , @throws , and @serialField may only provide support for the specific kinds of references that are relevant to each tag. See the description of individual tags for more details.

# Method Documentation

A documentation comment for a method declaration must at least provide the following: the main description , a @param tag per method type parameter, if any, a @return tag for the result, if the return type is not void , a @param tag per formal parameter, if any, a @throws tag per exception type, checked or unchecked, in the throws clause, if any. It is an error if any item described in that list is missing from a documentation comment of a method declaration and either of following is true: Otherwise, a missing item is considered as if it were provided with {@inheritDoc} as its content. For the purpose of this specification an overriding method declaration is a method declaration that could be annotated with @Override ( JLS 9.6.4.4 ), but is not an accessor method declaration for a record component. Method documentation allows inheritance by omission: if a documentation comment for a method declaration provides only some of the items, the rest are assumed to be inherited. For example, if this is provided:

```

/**
 * @param scale a non-zero number
 * @throws IllegalArgumentException if scale is 0
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

This is assumed:

```

/**
 * {@inheritDoc}
 *
 * @param <T> {@inheritDoc}
 * @param scale a non-zero number
 * @param element {@inheritDoc}
 * @return {@inheritDoc}
 * @throws IllegalArgumentException if scale is 0
 * @throws MagnificationException {@inheritDoc}
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

However, not all missing items can be inherited. For example, if a method declares an exception X that is not documented by any of the methods that this method overrides, then documentation item for that exception cannot be inherited and can only be provided by this method's documentation comment. (Adding or assuming @throws X {@inheritDoc} would be an error.) If that item is not provided, it is considered missing. ( @Override is only added to these examples to emphasize that the declarations are overriding; that annotation has no effect on documentation.) Note: a documentation comment consisting of a sole {@inheritDoc} explicitly provides only the main description of a method:

```

/**
 * {@inheritDoc}
 */

```

Other items, if any, are inherited by omission. Note: it's the overriding method, not the overridden method, that determines which items are missing and which aren't. For example, if an overriding method declares a thrown exception X , but that method's documentation comment does not contain @throws X ... , then that documentation item is missing. If an overriding method does NOT declare a thrown exception, even if the overridden method does, then that documentation item is NOT missing. This behavior is usually noticed when dealing with unchecked exceptions. Since unchecked exceptions do not normally appear in the throws clause, unless explicitly documented, they will not be missing. This gives rise to a misconception that the standard doclet treats checked exceptions differently from unchecked exceptions, which it does not. In fact, a similar behavior might be replicated with checked exceptions. Consider a method that declares two checked exceptions X and Y , such that X is a supertype of Y . If an overriding method declares X but not Y , then @throws Y ... won't be missing.

# Overriding Methods in Classes and Interfaces

When a method declaration overrides a method in the superclass or an extended superinterface, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. When a method declaration in a class overrides a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. In both cases, a link to the overridden method is included.

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Indicates that a method documentation comment part that contains this tag is the same as that of the overridden method in a superclass or superinterface, which is either determined automatically or specified. It is an error if the overridden method is missing the corresponding part. This tag enables you to write more general comments higher up the inheritance hierarchy and to write around the inherited parts. This tag is valid only in these places in a documentation comment of an overriding declaration of a method: If the corresponding part of the overridden method's documentation comment itself uses {@inheritDoc} or {@inheritDoc supertype } , then that tag is processed first. (This might be applied recursively as required.) Let m be a method declaration in a class or interface T . If the documentation comment for m contains {@inheritDoc} or {@inheritDoc supertype } then the superclass or superinterface (whose overridden method this tag will use the corresponding part of) is determined as follows:

# Automatic Supertype Search

The search for the supertype is performed in two phases: the recursive phase, then the final phase. For simplicity, the search starts from S , where S = T , although there's nothing to be found in T (otherwise, the search would not be required). When starting from S , where S = T , the first condition always breaks into "otherwise" because a method does not override itself ( JLS 8.4.8.1 ).

# Recursive phase

If S declares a method that T.m overrides, then S is a supertype, otherwise: If S is a class that has a direct superclass ( JLS 8.1.4 ) that is not java.lang.Object , then the recursive phase of the search is applied to that superclass. If that application has not found a supertype, then: If S has direct superinterfaces ( JLS 8.1.5 ), then the recursive phase of the search is applied to each of those superinterfaces, in the order that they are listed in the extends (if S is a class) or implements (if S is an interface) clause, until the supertype found or superinterfaces are exhausted.

# Final phase

If the recursive phase of search has not found the supertype, then one final attempt is made to see if java.lang.Object is the supertype. If T is a class and m overrides a method in java.lang.Object , or T is an interface and m 's signature is override-equivalent to the signature of a public method in java.lang.Object ( JLS 8.4.2 ), then java.lang.Object is the supertype. Otherwise, the search has not found the supertype. Note: The search is performed in two phases so as to not prematurely consider java.lang.Object as the supertype. Sometimes java.lang.Object provides overly general documentation for its public methods (such as equals , hashCode , toString ) when more specific documentation is available. For example, consider this schematic hierarchy:

```

interface A
interface B extends A
interface C
class D implements B, C
interface E
class F extends D implements E

```

```

(A)
     ^
      \
      (B) (C)    [java.lang.Object]
       ^   ^
        \ /
        [D] (E)
         ^   ^
          \ /
          [F]

```

```

(4)
     ^
      \
      (3) (5)    [7]
       ^   ^
        \ /
        [2] (6)
         ^   ^
          \ /
          [1]

```

Note: The source file for an inherited method must be on the source path for the documentation comment to be available for copy. Neither the class nor its package needs to be passed in on the command line. Introduced in JDK 1.4; accepts an optional argument since JDK 22.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the description part of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the third form of the @see tag. The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example,

```

Refer to {@linkplain #add() the overridden method}.

```

is displayed as: Refer to the overridden method . Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

When {@inheritDoc} is used in the description of a method formal or type parameter, the corresponding part of the overridden method documentation is matched using the parameter's position, not the parameter's name ( JLS 8.4.2 and JLS 8.4.4 ). For example, consider the following method declaration:

```

/**
 ...
 * @param scale a non-zero number
 ...
 * @param <T> the type of the element being magnified
 ...
 */
 <T> T magnify(int scale, T element) throws MagnificationException

```

Then as far as the documentation inheritance is concerned, these two comments are equivalent:

```

/**
 ...
 * @param s {@inheritDoc}
 * @param e {@inheritDoc}
 ...
 * @param <E> {@inheritDoc}
 */
 @Override
 <E> E magnify(int s, E e) throws MagnificationException

/**
 ...
 * @param scale {@inheritDoc}
 * @param element {@inheritDoc}
 ...
 * @param <T> {@inheritDoc}
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

If parameter names differ, care should be taken when inheriting such parameter documentation because that parameter name might be referred to from elsewhere both in the overridden and overriding methods. Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the given description, providing details about the values that may be returned by the method. As an inline tag, provides content for the first sentence of a method's main description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's main description. When inheriting documentation, either form of @return can be used:

```

/**
 * {@return {@inheritDoc}}
 ...
 */
<T> T magnify(int scale, T element) throws MagnificationException

/**
 ...
 * @return {@inheritDoc}
 */
 <T> T magnify(int scale, T element) throws MagnificationException

```

Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . @see " string " Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. @see <a href=" url "> label </a> Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. @see reference label Adds a link with a visible text label that points to the documentation for the specified program element that is referenced. reference can refer to any valid program element. If this element is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is text to be used as the link label and is optional for references to program elements. If no label is provided for an element reference, a default is generated, based on the target of the reference. Use the label when you want the text to be different from the auto-generated text. For references to URI fragments a label must be provided. The label can contain whitespace characters. If the content of the label appears to be a phrase, and not just a possibly-abbreviated form of a reference to the target link, the link will be displayed in plain font; otherwise, the link will be displayed in monospace font. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExternal method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the @snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the @snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the {@snippet ...} tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline {@link ...} tag. Introduced in JDK 18.

# @spec

Identifies an external specification in terms of its URL and title. The URL may be absolute or relative. Relative URLs will be evaluated against a "base URL". All tags specifying the same URL must provide the same corresponding title; conversely, tags with different URLs must have different titles. Introduced in JDK 20.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a main description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain whitespace characters, or characters such as } . No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in all documentation comments. Introduced in JDK 12.

# @throws

Adds an exception with the specified name followed by the specified description to the "Throws" section of a Method or Constructor detail. exception-name should refer to an exception that might be thrown by the method, and should either be the name of an exception class or a type variable. This tag is valid only in the documentation comment for a method or constructor. A documentation comment may use multiple @throws tags for the same or different exceptions. If such a comment then targeted by {@inheritDoc} , it copies all exceptions of that kind into the "Throws" section. Note: an unchecked exception class may be omitted from the throws clause, and so won't be considered missing in a method documentation. To inherit a description of such an exception, add a corresponding @throws tag with {@inheritDoc} in its description. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as if it were documented with the @throws tag. The @exception tag is equivalent to this tag, although the @throws form is now recommended. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays the value of a static field with a compile-time constant value. The format string may be omitted, in which case a default format will be used, appropriate to the type of the field. If the format string is given, it must either begin with a percent character (%) or be enclosed in double-quote characters ("). It must contain exactly one percent character. The string must conform to the definition of a format string, as specified in the documentation for java.util.Formatter . The conversion specified in the format string must be appropriate for the type of the constant value. When the {@value} tag is used without a field_reference argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with a field-reference argument in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

Introduced in JDK 1.4; format added in JDK 20.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/22/migrate/getting-started.html



---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/22/javadoc/javadoc.html



---


# Java SE 22 & JDK 22

URL: https://docs.oracle.com/en/java/javase/22/docs/api/overview-summary.html



---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/22/jpackage/packaging-overview.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files not using the PKCS #7 format must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. ` For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF` file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/22/intl/internationalization-overview.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/22/management/overview-java-se-monitoring-and-management.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/22/jmx/introduction-jmx-technology.html



---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/22/jfapi/why-use-jfr-api.html



---


# JVM(TM) Tool Interface 22.0.0

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_IN_OBJECT_WAIT

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Suspend All Virtual Threads

```

jvmtiError
SuspendAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume All Virtual Threads

```

jvmtiError
ResumeAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int can_support_virtual_threads : 1;
    unsigned int : 3;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

jvmtiError (JNICALL *SuspendAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *ResumeAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
    jvmtiEventVirtualThreadStart VirtualThreadStart;
    jvmtiEventVirtualThreadEnd VirtualThreadEnd;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Virtual Thread Start

```

void JNICALL
VirtualThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Virtual Thread End

```

void JNICALL
VirtualThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/22/install/version-string-format.html



---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/22/core/java-core-libraries1.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/22/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/22/security/java-security-overview1.html



---


# JDK 22 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/22/related-resources.html


# JDK 22 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/22/jshell/introduction-jshell.html



---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/18/language/java-language-changes.html



---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/18/gctuning/introduction-garbage-collection-tuning.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/18/jmx/introduction-jmx-technology.html



---


# Java Development Kit Version 18 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/man/index.html


# JavaDevelopment Kit Version 18 Tool Specifications

# All Platforms

# Windows Only


---


# Java Platform, Standard Edition Troubleshooting Guide, Release 18

URL: https://docs.oracle.com/en/java/javase/18/troubleshoot/



---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/18/install/version-string-format.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# JDK 18 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/18/books.html


# JDK 18 Documentation


---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/18/vm/java-virtual-machine-technology-overview.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/18/management/overview-java-se-monitoring-and-management.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 18

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 18


---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/18/intl/internationalization-overview.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/18/install/overview-jdk-installation.html



---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/18/migrate/getting-started.html



---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/18/core/java-core-libraries1.html



---


# JDK 18 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/18/related-resources.html


# JDK 18 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/18/access/java-accessibility-overview.html



---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/18/javadoc/javadoc.html



---


# Java SE 18 & JDK 18

URL: https://docs.oracle.com/en/java/javase/18/docs/api/overview-summary.html



---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/18/security/java-security-overview1.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# JVM(TM) Tool Interface 18.0.0

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int : 4;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

void *reserved118;

```

```

void *reserved119;

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Documentation Comment Specification for the Standard Doclet (JDK 18)

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 18, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html . The overall form of a documentation comment is an initial (main) description, followed by a series of block tags that provide additional information about the declaration to which the comment applies. The first sentence of the initial description should be a summary sentence that contains a concise but complete description of the declared entity. Descriptive text may include HTML tags and entities, and inline tags as described below. It is possible to have a comment with only a tag section and no initial description. The description cannot continue after the tag section begins. The argument to a tag can span multiple lines. There can be any number of tags; some types of tags can be repeated while others cannot.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading white space is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Block Tags

A block tag must appear at the beginning of a line, ignoring leading asterisks, white space, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . Each block tag has associated text, which includes any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. This associated text can span multiple lines.

# Inline Tags

Inline tags are enclosed within braces ( { } ) and may generally appear wherever descriptive text and HTML is permitted. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , and \ . When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the @see tag. Both tags require the same references and accept the same syntax for module / package . class # member and label . The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example, Refer to {@linkplain add() the overridden method}. displays as: Refer to the overridden method. Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the description text. This text should describe the return type and permissible range of values. As an inline tag, provides content for the first sentence of a method's description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's description. Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified name that is referenced. The label is optional; if it is omitted, then the program element name appears instead as visible text, suitably shortened. Use the -noqualifier option to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto-generated visible text. module / package . class # member is any valid program element name that is referenced, such as a module, package, class, interface, constructor, method or field name. Parts of the name can be omitted as appropriate. The class represents any top-level or nested class or interface. The member represents any constructor, method, or field (not a nested class or interface). Parameterized types may be used in the class and member parts of the name. Annotations may not be used anywhere in the signature. Whitespace characters may occur between tokens within the parameter list for a constructor or method. If this name is in the documented classes, then the standard doclet creates a link to it. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text that is visible as the link label. The label can contain white space. If label is omitted, then package . class . member appears, suitably shortened relative to the current class and package. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the @snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the @snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the {@snippet ...} tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline {@link ...} tag. Introduced in JDK 18.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain white space characters, or characters such as }. No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in the documentation comments for modules, packages, types, fields and executable members. Introduced in JDK 12.

# @throws

Behaves the same as the @exception tag. The @throws tag adds a "Throws" subheading to the generated documentation, with the class-name and description text. The class name is the name of the exception that might be thrown by the method. This tag is valid only in the documentation comment for a method or constructor. If the class name is not fully qualified, then the standard doclet uses the search order to look up this class. Multiple @throws tags can be used in a specified documentation comment for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as though it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/18/jshell/introduction-jshell.html



---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/18/jpackage/packaging-overview.html



---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/18/jfapi/why-use-jfr-api.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/18/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithm Names

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# JVM(TM) Tool Interface 15.0.0

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, jint myInt, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int : 4;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

void *reserved118;

```

```

void *reserved119;

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# JDK 15 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/15/related-resources.html


# JDK 15 Documentation

# Related Resources

# Java SE on OTN

# Java Components

# Java Training

# Java SE Subscriptions

# Java Forums

# Java Platform Group - Product Management Blog

# Java Source blog

# Java Tutorials blog


---


# JDK 15 Documentation - Books

URL: https://docs.oracle.com/en/java/javase/15/books.html


# JDK 15 Documentation


---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 15

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 15


---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the type of digital signature. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Security Providers document. In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Security Providers document contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The type in this section can be specified when generating an instance of CertStore .

# CipherAlgorithm Names

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Documentation Comment Specification for the Standard Doclet (JDK 15)

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 15, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html . The overall form of a documentation comment is an initial (main) description, followed by a series of block tags that provide additional information about the declaration to which the comment applies. The first sentence of the initial description should be a summary sentence that contains a concise but complete description of the declared entity. Descriptive text may include HTML tags and entities, and inline tags as described below. It is possible to have a comment with only a tag section and no initial description. The description cannot continue after the tag section begins. The argument to a tag can span multiple lines. There can be any number of tags; some types of tags can be repeated while others cannot.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading white space is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# Block Tags

A block tag must appear at the beginning of a line, ignoring leading asterisks, white space, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . Each block tag has associated text, which includes any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. This associated text can span multiple lines.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

Adds a "Returns" section with the description text. This text should describe the return type and permissible range of values. This tag is valid only in a documentation comment for a method. Introduced in JDK 1.0.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified name that is referenced. The label is optional; if it is omitted, then the program element name appears instead as visible text, suitably shortened. Use the -noqualifier option to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto-generated visible text. module / package . class # member is any valid program element name that is referenced, such as a module, package, class, interface, constructor, method or field name. Parts of the name can be omitted as appropriate. The class represents any top-level or nested class or interface. The member represents any constructor, method, or field (not a nested class or interface). Parameterized types may be used in the class and member parts of the name. If this name is in the documented classes, then the standard doclet creates a link to it. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text that is visible as the link label. The label can contain white space. If label is omitted, then package . class . member appears, suitably shortened relative to the current class and package. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @throws

Behaves the same as the @exception tag. The @throws tag adds a "Throws" subheading to the generated documentation, with the class-name and description text. The class name is the name of the exception that might be thrown by the method. This tag is valid only in the documentation comment for a method or constructor. If the class name is not fully qualified, then the standard doclet uses the search order to look up this class. Multiple @throws tags can be used in a specified documentation comment for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as though it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Inline Tags

Inline tags are enclosed within braces ( { } ) and may generally appear wherever descriptive text and HTML is permitted. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , and \ . When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the @see tag. Both tags require the same references and accept the same syntax for module / package . class # member and label . The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example, Refer to {@linkplain add() the overridden method}. displays as: Refer to the overridden method. Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain white space characters, or characters such as }. No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in the documentation comments for modules, packages, types, fields and executable members. Introduced in JDK 12.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# Where Tags Can Be Used


---


# Java SE 15 & JDK 15

URL: https://docs.oracle.com/en/java/javase/15/docs/api/overview-summary.html



---


# Java Development Kit Version 15 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/15/docs/specs/man/index.html


# JavaDevelopment Kit Version 15 Tool Specifications

# All Platforms

# Windows Only


---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/17/javadoc/javadoc.html



---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/17/vm/java-virtual-machine-technology-overview.html



---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/17/jpackage/packaging-overview.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/17/access/java-accessibility-overview.html



---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/17/core/java-core-libraries1.html



---


# Java SE 17 & JDK 17

URL: https://docs.oracle.com/en/java/javase/17/docs/api/overview-summary.html



---


# JDK 17 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/17/related-resources.html


# JDK 17 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/17/jfapi/why-use-jfr-api.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/17/jmx/introduction-jmx-technology.html



---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/17/migrate/getting-started.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithm Names

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/17/intl/internationalization-overview.html



---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/17/security/java-security-overview1.html



---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/17/language/java-language-changes.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/17/management/overview-java-se-monitoring-and-management.html



---


# JDK 17 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/17/books.html


# JDK 17 Documentation


---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/17/install/version-string-format.html



---


# JVM(TM) Tool Interface 17.0.0

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int : 4;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

void *reserved118;

```

```

void *reserved119;

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Java Platform, Standard Edition Troubleshooting Guide, Release 17

URL: https://docs.oracle.com/en/java/javase/17/troubleshoot/



---


# Documentation Comment Specification for the Standard Doclet (JDK 17)

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 17, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html . The overall form of a documentation comment is an initial (main) description, followed by a series of block tags that provide additional information about the declaration to which the comment applies. The first sentence of the initial description should be a summary sentence that contains a concise but complete description of the declared entity. Descriptive text may include HTML tags and entities, and inline tags as described below. It is possible to have a comment with only a tag section and no initial description. The description cannot continue after the tag section begins. The argument to a tag can span multiple lines. There can be any number of tags; some types of tags can be repeated while others cannot.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading white space is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Block Tags

A block tag must appear at the beginning of a line, ignoring leading asterisks, white space, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . Each block tag has associated text, which includes any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. This associated text can span multiple lines.

# Inline Tags

Inline tags are enclosed within braces ( { } ) and may generally appear wherever descriptive text and HTML is permitted. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , and \ . When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the @see tag. Both tags require the same references and accept the same syntax for module / package . class # member and label . The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example, Refer to {@linkplain add() the overridden method}. displays as: Refer to the overridden method. Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the description text. This text should describe the return type and permissible range of values. As an inline tag, provides content for the first sentence of a method's description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's description. Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified name that is referenced. The label is optional; if it is omitted, then the program element name appears instead as visible text, suitably shortened. Use the -noqualifier option to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto-generated visible text. module / package . class # member is any valid program element name that is referenced, such as a module, package, class, interface, constructor, method or field name. Parts of the name can be omitted as appropriate. The class represents any top-level or nested class or interface. The member represents any constructor, method, or field (not a nested class or interface). Parameterized types may be used in the class and member parts of the name. If this name is in the documented classes, then the standard doclet creates a link to it. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text that is visible as the link label. The label can contain white space. If label is omitted, then package . class . member appears, suitably shortened relative to the current class and package. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain white space characters, or characters such as }. No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in the documentation comments for modules, packages, types, fields and executable members. Introduced in JDK 12.

# @throws

Behaves the same as the @exception tag. The @throws tag adds a "Throws" subheading to the generated documentation, with the class-name and description text. The class name is the name of the exception that might be thrown by the method. This tag is valid only in the documentation comment for a method or constructor. If the class name is not fully qualified, then the standard doclet uses the search order to look up this class. Multiple @throws tags can be used in a specified documentation comment for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as though it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/17/jshell/introduction-jshell.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 17

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 17


---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/17/gctuning/introduction-garbage-collection-tuning.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/17/install/overview-jdk-installation.html



---


# Java Development Kit Version 17 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/17/docs/specs/man/index.html


# JavaDevelopment Kit Version 17 Tool Specifications

# All Platforms

# Windows Only


---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/jni/index.html



---


# JVM(TM) Tool Interface 11.0.0

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/jvmti.html



---


# Documentation Comment Specification for the Standard Doclet

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/doc-comment-spec.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/jar/jar.html



---


# Java SE 12 & JDK 12

URL: https://docs.oracle.com/en/java/javase/12/docs/api/overview-summary.html



---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/serialization/index.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/jdwp/jdwp-spec.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/12/docs/specs/security/standard-names.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithms

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KEMAlgorithms

The algorithm names in this section can be specified when generating an instance of KEM .

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/23/vm/java-virtual-machine-technology-overview.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/23/install/overview-jdk-installation.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/23/jmx/introduction-jmx-technology.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/23/troubleshoot/general-java-troubleshooting.html



---


# JavaDoc Documentation Comment Specification for the Standard Doclet (JDK 23)

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 23, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# Documentation Comments

Documentation comments are stylized comments appearing in source code, near to the declarations that they serve to document. Documentation comments are recognized only when placed immediately before the declaration of a module, package, class, interface, constructor, method, annotation interface element, enum member, or field. In other words, a documentation comment should appear before any annotation, modifier, keyword, identifier, or other Java construct that is part of the declaration. There are two kinds of documentation comments: traditional documentation comments , and Markdown documentation comments . Either kind, or both kinds, may be used in any one source file. Only one documentation comment per declaration statement is recognized. If there are multiple documentation comments before a declaration, the one closest to the beginning of the declaration is used. Documentation may also be provided in certain files: HTML files are identified by a filename ending in .html . The content of the <main> element of an HTML file, or the <body> element if there is no <main> element is processed as if it were the content of a traditional documentation comment. Markdown files are identified by a filename ending in .md . The content of a Markdown file is processed as if it were the content of a Markdown documentation comment.

# Traditional Documentation Comments

Traditional documentation comments are traditional comments that begin with /** . If any line in such a comment begins with asterisks after any leading whitespace, the leading whitespace and asterisks are removed. Any whitespace appearing after the asterisks is not removed. A traditional documentation comment may contain HTML content , inline tags , and block tags . You can also use escape sequences to represent characters that would otherwise be inconvenient or difficult to represent.

# Markdown Documentation Comments

Documentation comments containing Markdown are composed of a series of consecutive lines, each beginning with optional whitespace followed by /// . A Markdown documentation comment may contain Markdown content (including HTML where necessary), inline tags , and block tags .

# General Syntax

The overall form of a documentation comment is an initial main description , followed by a series of block tags , which provide additional information about the declaration to which the comment applies. Descriptive text may include inline tags , HTML content , and Markdown content , as described below. It is possible to have a comment with only block tags and no main description. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html .

# Main Description

The main description in a documentation comment is the content from the beginning of the comment, up to the first block tag, if there are any, or to the end of the comment, if there are none. Leading and trailing whitespace is ignored. If there is no such content, the main description is said to be missing. The main description cannot continue after any block tags. Examples of a missing main description. No content before the first block tag:

```

/**
 * @param ...
 * ...
 */

```

An empty documentation comment:

```

/**
 *
 */

```

The first sentence of the main description should be a summary sentence that contains a concise but complete description of the declared entity.

# Block Tags

Block tags are of the form @ identifier content and give additional details to be incorporated into the generated documentation. Each block tag must appear at the beginning of a line, ignoring leading asterisks, whitespace characters, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text, and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . The content of a block tag is any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. The content can span multiple lines. There can be any number of block tags; some types of tags can be repeated while others cannot.

# Inline Tags

Inline tags are of the form {@ identifier content } and provide details within the context of the enclosing description. They may generally appear wherever descriptive text and HTML is permitted, although some inline tags may only be used at the beginning of the main description. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , \ , and @ . Lines beginning with @ that are enclosed within an inline tag are not considered as beginning a block tag. When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at heading level 2 and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at heading level 4. In standalone HTML files, such as in a doc-files subdirectory, headings should start at heading level 1. To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Markdown Content

Because horizontal whitespace at the beginning and end of each line of Markdown code may be significant, the content of such a comment is determined as follows: Note: The policy to remove leading incidental whitespace is similar to that for String.stripIndent , except that there is no need for any special treatment for a trailing blank line. There are no restrictions on the characters that may appear after the /// on each line of the comment. In particular, the comment may contain code samples which may contain comments of their own:

```

/// Here is an example:
///
/// ```
/// /** Hello World! */
/// public class HelloWorld {
///     public static void main(String... args) {
///         System.out.println("Hello World!"); // the traditional example
///     }
/// }
/// ```

```

As well as serving to visually distinguish the new kind of documentation comment, the use of end-of-line ( // ) comments eliminates the restrictions on the content of the comment that are inherent with the use of traditional ( /* ... */ ) comments. In particular, it is not possible to use the character sequence */ within a traditional comment, ( JLS 3.7 ) although it may be desirable to do so when writing example code containing traditional comments, strings containing "glob" expressions, and strings containing regular expressions. Note: For a blank line to be included in the comment, it must begin with any optional whitespace followed by /// . A completely blank line will cause any preceding and following comment to be treated as separate comments, in which case, all but the last comment will be discarded, and only the last comment will be considered as a documentation comment for any declaration that may follow. For example:

```

/// This is an example ...
///
/// ... of a 3-line comment containing a blank line.

```

The blank line in the following example will terminate the first comment, so that the comment that comes after the blank line will be treated as a separate comment.

```

/// This comment will be treated as a "dangling comment" and will be ignored.

/// This is the comment for the following declaration.
public void m() { }

```

The same is true for any other comment not beginning with /// that may appear between two /// comments.

# Syntax

The overall syntax of a Markdown documentation comment is that of the CommonMark variant of Markdown. Enhancements to links allow convenient linking to other program elements. Simple GFM pipe tables are supported, as are all JavaDoc tags.

# Headings

Both ATX headings and setext headings are supported. Unlike HTML headings, Markdown headings should start at level 1 and increase from there, whatever the context of the documentation comment. (They will be translated to the correct heading level in the generated documentation.)

# Links

The general form of a reference link is [text][label] where text is the text to be displayed, and label is a label for the destination of the link, and which is subsequently defined by a line of the form [label]:  uri . Collapsed and shortcut forms can also be used when the label is the same as the text . In a documentation comment, if the label for a reference link is to be defined explicitly, it must be defined in the same documentation comment. But, if it is not defined and if it syntactically matches that of a reference to a program element, then it is implicitly defined as a reference to that program element. It is an error if the label looks like a reference to a program element but there is no such element. The following all represent links to java.lang.Object#hashCode() , albeit with different text to be displayed: You can link to any kind of program element, as shown in the following examples:

```

/// * a module [java.base/]
/// * a package [java.util]
/// * a class [String]
/// * a field [String#CASE_INSENSITIVE_ORDER]
/// * a method [String#chars()]

```

Inline links are also supported in documentation comments, but the helpful recognition of program elements as labels means that reference links are generally more useful than inline links. According to the standard rules for reference links, you must escape any use of square brackets within a reference. This might occur when you are creating a reference to a method with an array parameter. The following shows a link to String.copyValueOf(char[]) The normal rendering for a reference link is to use the default plain font. If you wish to use a monospace font, you must enclose the text within a code span, using backticks. For references to program elements, monospace font will be used automatically if the text is the same as the reference (such as when using the collapsed or shortcut forms), and the default plain font otherwise. The following shows how these forms correspond to the existing link and linkplain tags. Note: You cannot use a reference link in the first sentence of any documentation comment that refers to a user-defined link reference definition elsewhere in the documentation comment; you can use an inline link in this situation instead.

# Tables

Simple tables are supported, using the syntax defined in GitHub Flavored Markdown . For example, a simple table might be written as follows:

```

/// | Latin | Greek |
/// |-------|-------|
/// | a     | alpha |
/// | b     | beta  |
/// | c     | gamma |

```

Note: Captions and other features that may be required for accessibility are not supported. In such situations, the use of HTML tables is still recommended.

# Inline Tags and Block Tags

Both inline tags and block tags may be used in Markdown documentation comments, although neither may be used within the literal text of code spans and fenced or indented code blocks. For those tags that may contain text with markup, in a Markdown documentation comment that markup will also be in Markdown format. As in traditional documentation comments, the content of inline tags may span multiple lines, including blank lines. When using a reference link with an explicit link label , the reference and the label must appear in the same part of the comment: in either the main description, or in any inline or block tag. A reference link may not refer to a label defined in a different part of the comment, or in a different comment altogether. The inheritDoc tag is used to include documentation from one or more supertypes. There is no requirement that the format of the comment containing the tag is the same as the format of the comment containing the documentation to be inherited. While it may be the case that comments within a library may all use the same format, that may be less likely when handling comments in different libraries, written by different authors.

# Syntax Highlighting and Embedded Languages

The opening fence in a fenced code block may be followed by an info string , the first word of which is used to derive the CSS class name in the corresponding generated HTML, and which may be used by JavaScript libraries to enable syntax highlighting (such as with Prism ) or rendering diagrams (such as with Mermaid ). Note: You can add JavaScript libraries to your documentation by using the javadoc --add-script option.

# Escape Sequences

The following escape sequences are supported in traditional documentation comments wherever text, entities and HTML may appear, to represent characters that would otherwise be inconvenient or difficult to represent: Escape sequences are context-sensitive, and can only be used where the use of the escaped character by itself would have a different syntactic interpretation. In other situations, these character sequences are taken literally, without additional interpretation. Escape sequences cannot be used in inline tags that contain literal text; this includes code , literal , snippet , and user-defined tags.

# References

References are the constructs in a documentation comment that refer to elements in the surrounding declarations. Depending on the context, they may refer to modules, packages, classes and interfaces, constructors, methods, annotation members, fields, enum members, parameters, record components and the names of exceptions that may be thrown by a method or constructor. The most general form of a reference is: This form is used by the see , link and linkplain tags. Leading components can be omitted when they can be inferred from the surrounding context. Trailing components can be omitted when they are not required. Generally, the reference is evaluated in the scope in which the documentation comment exists. In particular, import statements for the compilation unit are taken into account when evaluating class and interface names. The class may be any top-level or nested class or interface. The member may be any constructor, method, annotation member, field or enum member, but not a nested class or interface. As in Java source code, a constructor is identified by using the name of its class. The name of a constructor or method should normally be followed by the list of its parameter types, enclosed in parentheses, although the parameter types and parentheses can be omitted if the method or constructor is not overloaded and the name is not also that of a field or enum member in the same class or interface. When a parameter list is given, whitespace characters may appear between tokens in the parameter list; whitespace characters may not appear elsewhere in the reference. When the reference is to a member of the same class as that containing the documentation comment, all parts of the reference up to and including the # may be omitted, although the '#' may be retained for clarity. Parameterized types may be used in the class and member parts of the reference; annotations may not be used anywhere in the reference. Whitespace characters may occur between tokens within the parameter list for a constructor or method. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. Note: You cannot refer to the declaration of a specific parameter or record component with this form. An alternative form is provided to generate references to arbitrary URI fragments in the generated documentation such as headings in documentation comments. This form uses a double hash mark ( ## ) as separator: fragment is interpreted as URI fragment within the page documenting the specified program element. Other tags, such as param , throws , and serialField may only provide support for the specific kinds of references that are relevant to each tag. See the description of individual tags for more details.

# Method Documentation

A documentation comment for a method declaration must at least provide the following: the main description , a param tag per method type parameter, if any, a return tag for the result, if the return type is not void , a param tag per formal parameter, if any, a throws tag per exception type, checked or unchecked, in the throws clause, if any. It is an error if any item described in that list is missing from a documentation comment of a method declaration and either of following is true: Otherwise, a missing item is considered as if it were provided with {@inheritDoc} as its content. For the purpose of this specification an overriding method declaration is a method declaration that could be annotated with @Override ( JLS 9.6.4.4 ), but is not an accessor method declaration for a record component. Method documentation allows inheritance by omission: if a documentation comment for a method declaration provides only some of the items, the rest are assumed to be inherited. For example, if this is provided:

```

/**
 * @param scale a non-zero number
 * @throws IllegalArgumentException if scale is 0
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

This is assumed:

```

/**
 * {@inheritDoc}
 *
 * @param <T> {@inheritDoc}
 * @param scale a non-zero number
 * @param element {@inheritDoc}
 * @return {@inheritDoc}
 * @throws IllegalArgumentException if scale is 0
 * @throws MagnificationException {@inheritDoc}
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

However, not all missing items can be inherited. For example, if a method declares an exception X that is not documented by any of the methods that this method overrides, then documentation item for that exception cannot be inherited and can only be provided by this method's documentation comment. (Adding or assuming @throws X {@inheritDoc} would be an error.) If that item is not provided, it is considered missing. ( @Override is only added to these examples to emphasize that the declarations are overriding; that annotation has no effect on documentation.) Note : A documentation comment consisting of a sole inheritDoc tag explicitly provides only the main description of a method:

```

/**
 * {@inheritDoc}
 */

```

Other items, if any, are inherited by omission. Note: It is the overriding method, not the overridden method, that determines which items are missing and which are not. For example, if an overriding method declares a thrown exception X , but that method's documentation comment does not contain @throws X ... , then that documentation item is missing. If an overriding method does NOT declare a thrown exception, even if the overridden method does, then that documentation item is NOT missing. This behavior is usually noticed when dealing with unchecked exceptions. Since unchecked exceptions do not normally appear in the throws clause, unless explicitly documented, they will not be missing. This gives rise to a misconception that the standard doclet treats checked exceptions differently from unchecked exceptions, which it does not. In fact, a similar behavior might be replicated with checked exceptions. Consider a method that declares two checked exceptions X and Y , such that X is a supertype of Y . If an overriding method declares X but not Y , then @throws Y ... won't be missing.

# Overriding Methods in Classes and Interfaces

When a method declaration overrides a method in the superclass or an extended superinterface, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. When a method declaration in a class overrides a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. In both cases, a link to the overridden method is included.

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple author tags. You can specify one name per author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. If there are no @author tags in the description for a member class or interface, the standard doclet will (recursively) look for any such tags in the enclosing class or interface. Introduced in JDK 1.0.

# code

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the literal tag. Introduced in JDK 1.5.

# deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include a link tag that points to the replacement API. Note: Introduced in JDK 1.0.

# docRoot

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. The docRoot tag can be used both on the command line and in a documentation comment. The tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the return , param and deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# exception

This tag is equivalent to the throws tag, which is now the recommended form. Introduced in JDK 1.0.

# hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# index

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# inheritDoc

Indicates that a method documentation comment part that contains this tag is the same as that of the overridden method in a superclass or superinterface, which is either determined automatically or specified. It is an error if the overridden method is missing the corresponding part. This tag enables you to write more general comments higher up the inheritance hierarchy and to write around the inherited parts. This tag is valid only in these places in a documentation comment of an overriding declaration of a method: If the corresponding part of the overridden method's documentation comment itself uses an inheritDoc tag, then that tag is processed first. (This might be applied recursively as required.) Let m be a method declaration in a class or interface T . If the documentation comment for m contains an inheritDoc tag then the superclass or superinterface (whose overridden method this tag will use the corresponding part of) is determined as follows:

# Automatic Supertype Search

The search for the supertype is performed in two phases: the recursive phase, then the final phase. For simplicity, the search starts from S , where S = T , although there's nothing to be found in T (otherwise, the search would not be required). When starting from S , where S = T , the first condition always breaks into "otherwise" because a method does not override itself ( JLS 8.4.8.1 ).

# Recursive phase

If S declares a method that T.m overrides, then S is a supertype, otherwise: If S is a class that has a direct superclass ( JLS 8.1.4 ) that is not java.lang.Object , then the recursive phase of the search is applied to that superclass. If that application has not found a supertype, then: If S has direct superinterfaces ( JLS 8.1.5 ), then the recursive phase of the search is applied to each of those superinterfaces, in the order that they are listed in the extends (if S is a class) or implements (if S is an interface) clause, until the supertype found or superinterfaces are exhausted.

# Final phase

If the recursive phase of search has not found the supertype, then one final attempt is made to see if java.lang.Object is the supertype. If T is a class and m overrides a method in java.lang.Object , or T is an interface and m 's signature is override-equivalent to the signature of a public method in java.lang.Object ( JLS 8.4.2 ), then java.lang.Object is the supertype. Otherwise, the search has not found the supertype. Note: The search is performed in two phases so as to not prematurely consider java.lang.Object as the supertype. Sometimes java.lang.Object provides overly general documentation for its public methods (such as equals , hashCode , toString ) when more specific documentation is available. For example, consider this schematic hierarchy:

```

interface A
interface B extends A
interface C
class D implements B, C
interface E
class F extends D implements E

```

```

(A)
     ^
      \
      (B) (C)    [java.lang.Object]
       ^   ^
        \ /
        [D] (E)
         ^   ^
          \ /
          [F]

```

```

(4)
     ^
      \
      (3) (5)    [7]
       ^   ^
        \ /
        [2] (6)
         ^   ^
          \ /
          [1]

```

Note: The source file for an inherited method must be on the source path for the documentation comment to be available for copy. Neither the class nor its package needs to be passed in on the command line. Note: When using Markdown comments , there is no requirement that the comment containing the tag and the comment containing the documentation inherited by that tag should either be both Markdown documentation comments or both traditional (not Markdown) comments. Introduced in JDK 1.4; accepts an optional argument since JDK 22.

# link

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the description part of any tag, such as the return , param and deprecated tags. This tag is similar to the third form of the see tag. The main difference is that the link tag generates an inline link rather than placing the link in the "See Also" section. The link tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of link tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# linkplain

Behaves the same as the link tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example,

```

Refer to {@linkplain #add() the overridden method}.

```

is displayed as: Refer to the overridden method . Introduced in JDK 1.4.

# literal

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the code tag. Introduced in JDK 1.5.

# param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

When an inheritDoc tag is used in the description of a method formal or type parameter, the corresponding part of the overridden method documentation is matched using the parameter's position, not the parameter's name ( JLS 8.4.2 and JLS 8.4.4 ). For example, consider the following method declaration:

```

/**
 ...
 * @param scale a non-zero number
 ...
 * @param <T> the type of the element being magnified
 ...
 */
 <T> T magnify(int scale, T element) throws MagnificationException

```

Then as far as the documentation inheritance is concerned, these two comments are equivalent:

```

/**
 ...
 * @param s {@inheritDoc}
 * @param e {@inheritDoc}
 ...
 * @param <E> {@inheritDoc}
 */
 @Override
 <E> E magnify(int s, E e) throws MagnificationException

/**
 ...
 * @param scale {@inheritDoc}
 * @param element {@inheritDoc}
 ...
 * @param <T> {@inheritDoc}
 */
 @Override
 <T> T magnify(int scale, T element) throws MagnificationException

```

If parameter names differ, care should be taken when inheriting such parameter documentation because that parameter name might be referred to from elsewhere both in the overridden and overriding methods. Introduced in JDK 1.0.

# provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# return

As a block tag, adds a "Returns" section with the given description, providing details about the values that may be returned by the method. As an inline tag, provides content for the first sentence of a method's main description, and a "Returns" section, as if " @return description " were also present. In the default English locale, the first sentence is " Returns description . ". This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's main description. When inheriting documentation, either form of a return tag can be used:

```

/**
 * {@return {@inheritDoc}}
 ...
 */
<T> T magnify(int scale, T element) throws MagnificationException

/**
 ...
 * @return {@inheritDoc}
 */
 <T> T magnify(int scale, T element) throws MagnificationException

```

Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of see tags, which are all grouped under the same heading. The see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, use a link tag. @see " string " Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. @see <a href=" url "> label </a> Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. @see reference label Adds a link with a visible text label that points to the documentation for the specified program element that is referenced. reference can refer to any valid program element. If this element is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is text to be used as the link label and is optional for references to program elements. If no label is provided for an element reference, a default is generated, based on the target of the reference. Use the label when you want the text to be different from the auto-generated text. For references to URI fragments a label must be provided. The label can contain whitespace characters. If the content of the label appears to be a phrase, and not just a possibly-abbreviated form of a reference to the target link, the link will be displayed in plain font; otherwise, the link will be displayed in monospace font. Introduced in JDK 1.0.

# serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. A serial tag at the class level overrides any serial tag at the package level. Introduced in JDK 1.2.

# serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExternal method. The serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple since tags are allowed and are treated like multiple author tags. You could use multiple tags when the program element is used by more than one API. If there are no @since tags in the description for a member class or interface, the standard doclet will (recursively) look for any such tags in the enclosing class or interface. Introduced in JDK 1.1.

# snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the snippet tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline link tag. Introduced in JDK 18.

# spec

Identifies an external specification in terms of its URL and title. The URL may be absolute or relative. Relative URLs will be evaluated against a "base URL". All tags specifying the same URL must provide the same corresponding title; conversely, tags with different URLs must have different titles. Introduced in JDK 20.

# summary

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a main description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# systemProperty

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain whitespace characters, or characters such as } . No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in all documentation comments. Introduced in JDK 12.

# throws

Adds an exception with the specified name followed by the specified description to the "Throws" section of a Method or Constructor detail. exception-name should refer to an exception that might be thrown by the method, and should either be the name of an exception class or a type variable. This tag is valid only in the documentation comment for a method or constructor. A documentation comment may use multiple throws tags for the same or different exceptions. If such a comment is then targeted by an inheritDoc tag, it copies all exceptions of that kind into the "Throws" section. Note: An unchecked exception class may be omitted from the throws clause, and so won't be considered missing in a method documentation. To inherit a description of such an exception, add a corresponding throws tag with an inheritDoc tag in its description. To ensure that all checked exceptions are documented, when a throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as if it were documented with the throws tag. The exception tag is equivalent to this tag, although using a throws tag is now recommended. Introduced in JDK 1.2.

# uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# value

Displays the value of a static field with a compile-time constant value. The format string may be omitted, in which case a default format will be used, appropriate to the type of the field. If the format string is given, it must either begin with a percent character ( % ) or be enclosed in double-quote characters ( " ). It must contain exactly one percent character. The string must conform to the definition of a format string, as specified in the documentation for java.util.Formatter . The conversion specified in the format string must be appropriate for the type of the constant value. When the value tag is used without a field_reference argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with a field-reference argument in any documentation comment, the value tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

Introduced in JDK 1.4; format added in JDK 20.

# version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple version tags. When it makes sense, you can specify one release number per version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. If there are no @version tags in the description for a member class or interface, the standard doclet will (recursively) look for any such tags in the enclosing class or interface. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Java SE 23 & JDK 23

URL: https://docs.oracle.com/en/java/javase/23/docs/api/overview-summary.html



---


# JDK 23 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/23/related-resources.html


# JDK 23 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/23/jpackage/packaging-overview.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/23/access/java-accessibility-overview.html



---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/23/gctuning/introduction-garbage-collection-tuning.html



---


# Java Development Kit Version 23 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/man/index.html


# JavaDevelopment Kit Version 23 Tool Specifications

# All Platforms

# Windows Only


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/23/javadoc/javadoc-tool.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups: In addition to the above Main attributes defined by the Java Platform, the JDK Reference Implementation also supports the following attributes for stand-alone applications that are bundled into executable JAR files. These attributes are ignored for JAR files that are not run with " java -jar x.jar ".

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
        Created-By: 1.8 (Oracle Inc.)
        Sealed: true

        Name: foo/bar/
        Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files not using the PKCS #7 format must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. ` For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF` file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# JDK 23 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/23/books.html


# JDK 23 Documentation


---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/23/core/java-core-libraries1.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/jni/index.html



---


# JVM(TM) Tool Interface 23.0.0

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Null Pointers

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_IN_OBJECT_WAIT

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Suspend All Virtual Threads

```

jvmtiError
SuspendAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume All Virtual Threads

```

jvmtiError
ResumeAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int can_support_virtual_threads : 1;
    unsigned int : 3;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

jvmtiError (JNICALL *SuspendAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *ResumeAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
    jvmtiEventVirtualThreadStart VirtualThreadStart;
    jvmtiEventVirtualThreadEnd VirtualThreadEnd;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Virtual Thread Start

```

void JNICALL
VirtualThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Virtual Thread End

```

void JNICALL
VirtualThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/23/security/java-security-overview1.html



---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/23/install/version-string-format.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 23

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 23


---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/23/language/java-language-changes.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/23/management/overview-java-se-monitoring-and-management.html



---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/23/jfapi/why-use-jfr-api.html



---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/23/intl/internationalization-overview.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/23/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/23/jshell/introduction-jshell.html



---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/23/migrate/getting-started.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/16/jmx/introduction-jmx-technology.html



---


# Documentation Comment Specification for the Standard Doclet (JDK 16)

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 16, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html . The overall form of a documentation comment is an initial (main) description, followed by a series of block tags that provide additional information about the declaration to which the comment applies. The first sentence of the initial description should be a summary sentence that contains a concise but complete description of the declared entity. Descriptive text may include HTML tags and entities, and inline tags as described below. It is possible to have a comment with only a tag section and no initial description. The description cannot continue after the tag section begins. The argument to a tag can span multiple lines. There can be any number of tags; some types of tags can be repeated while others cannot.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading white space is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Block Tags

A block tag must appear at the beginning of a line, ignoring leading asterisks, white space, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . Each block tag has associated text, which includes any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. This associated text can span multiple lines.

# Inline Tags

Inline tags are enclosed within braces ( { } ) and may generally appear wherever descriptive text and HTML is permitted. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , and \ . When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the @see tag. Both tags require the same references and accept the same syntax for module / package . class # member and label . The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example, Refer to {@linkplain add() the overridden method}. displays as: Refer to the overridden method. Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the description text. This text should describe the return type and permissible range of values. As an inline tag, provides content for the first sentence of a method's description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's description. Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified name that is referenced. The label is optional; if it is omitted, then the program element name appears instead as visible text, suitably shortened. Use the -noqualifier option to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto-generated visible text. module / package . class # member is any valid program element name that is referenced, such as a module, package, class, interface, constructor, method or field name. Parts of the name can be omitted as appropriate. The class represents any top-level or nested class or interface. The member represents any constructor, method, or field (not a nested class or interface). Parameterized types may be used in the class and member parts of the name. If this name is in the documented classes, then the standard doclet creates a link to it. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text that is visible as the link label. The label can contain white space. If label is omitted, then package . class . member appears, suitably shortened relative to the current class and package. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain white space characters, or characters such as }. No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in the documentation comments for modules, packages, types, fields and executable members. Introduced in JDK 12.

# @throws

Behaves the same as the @exception tag. The @throws tag adds a "Throws" subheading to the generated documentation, with the class-name and description text. The class name is the name of the exception that might be thrown by the method. This tag is valid only in the documentation comment for a method or constructor. If the class name is not fully qualified, then the standard doclet uses the search order to look up this class. Multiple @throws tags can be used in a specified documentation comment for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as though it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/16/language/java-language-changes.html



---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/16/intl/internationalization-overview.html



---


# JDK 16 Documentation - Books

URL: https://docs.oracle.com/en/java/javase/16/books.html


# JDK 16 Documentation


---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/16/javadoc/javadoc.html



---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Security Providers document. In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Security Providers document contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The type in this section can be specified when generating an instance of CertStore .

# CipherAlgorithm Names

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/16/jpackage/packaging-overview.html



---


# Java Development Kit Version 16 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/man/index.html


# JavaDevelopment Kit Version 16 Tool Specifications

# All Platforms

# Windows Only


---


# JVM(TM) Tool Interface 16.0.0

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int : 4;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

void *reserved118;

```

```

void *reserved119;

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the type of digital signature. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/16/install/overview-jdk-installation.html



---


# Java SE 16 & JDK 16

URL: https://docs.oracle.com/en/java/javase/16/docs/api/overview-summary.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# JDK 16 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/16/related-resources.html


# JDK 16 Documentation

# Related Resources

# Java SE on OTN

# Java Components

# Java Training

# Java SE Subscriptions

# Java Forums

# Java Platform Group - Product Management Blog

# Java Source blog

# Java Tutorials blog


---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/16/security/java-security-overview1.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/16/management/overview-java-se-monitoring-and-management.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 16

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 16


---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/16/jfapi/why-use-jfr-api.html



---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/16/jshell/introduction-jshell.html



---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/16/install/version-string-format.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/16/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/16/vm/java-virtual-machine-technology-overview.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/16/access/java-accessibility-overview.html



---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/16/migrate/getting-started.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/16/troubleshoot/general-java-troubleshooting.html



---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/16/core/java-core-libraries1.html



---


# JDK 21 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/21/books.html


# JDK 21 Documentation


---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/21/jpackage/packaging-overview.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html



---


# JDK 21 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/21/related-resources.html


# JDK 21 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/21/language/java-language-changes.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/21/troubleshoot/general-java-troubleshooting.html



---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 21

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 21


---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithms

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KEMAlgorithms

The algorithm names in this section can be specified when generating an instance of KEM .

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Java SE 21 & JDK 21

URL: https://docs.oracle.com/en/java/javase/21/docs/api/overview-summary.html



---


# JVM(TM) Tool Interface 21.0.0

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Suspend All Virtual Threads

```

jvmtiError
SuspendAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume All Virtual Threads

```

jvmtiError
ResumeAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int can_support_virtual_threads : 1;
    unsigned int : 3;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

jvmtiError (JNICALL *SuspendAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *ResumeAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
    jvmtiEventVirtualThreadStart VirtualThreadStart;
    jvmtiEventVirtualThreadEnd VirtualThreadEnd;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Virtual Thread Start

```

void JNICALL
VirtualThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Virtual Thread End

```

void JNICALL
VirtualThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Development Kit Version 21 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/man/index.html


# JavaDevelopment Kit Version 21 Tool Specifications

# All Platforms

# Windows Only


---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/21/jshell/introduction-jshell.html



---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/21/management/overview-java-se-monitoring-and-management.html



---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/21/migrate/getting-started.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/21/security/java-security-overview1.html



---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/21/intl/internationalization-overview.html



---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/21/core/java-core-libraries1.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/21/access/java-accessibility-overview.html



---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/21/jmx/introduction-jmx-technology.html



---


# Documentation Comment Specification for the Standard Doclet (JDK 21)

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 21, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, enum member, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. The overall form of a documentation comment is an initial main description , followed by a series of block tags , which provide additional information about the declaration to which the comment applies. Descriptive text may include inline tags and HTML content , as described below. Leading asterisks at the beginning of each line, and any preceding whitespace, are ignored. It is possible to have a comment with only block tags and no main description. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html .

# Main Description

The main description in a documentation comment is the content from the beginning of the comment, up to the first block tag, if there are any, or to the end of the comment, if there are none. Leading and trailing whitespace is ignored. If there is no such content, the main description is said to be missing. The main description cannot continue after any block tags. The first sentence of the main description should be a summary sentence that contains a concise but complete description of the declared entity.

# Block Tags

Block tags are of the form @ identifier content and give additional details to be incorporated into the generated documentation. Each block tag must appear at the beginning of a line, ignoring leading asterisks, whitespace characters, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . The content of a block tag is any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. The content can span multiple lines. There can be any number of block tags; some types of tags can be repeated while others cannot.

# Inline Tags

Inline tags are of the form {@ identifier content } and provide details within the context of the enclosing description. They may generally appear wherever descriptive text and HTML is permitted, although some inline tags may only be used at the beginning of the main description. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , \ , and @ . Lines beginning with @ that are enclosed within an inline tag are not considered as beginning a block tag. When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading whitespace is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# Escape Sequences

The following escape sequences are supported wherever text, entities and HTML may appear, to represent characters that would otherwise be inconvenient or difficult to represent: Escape sequences are context-sensitive, and can only be used where the use of the escaped character by itself would have a different syntactic interpretation. In other situations, these character sequences are taken literally, without additional interpretation. Escape sequences cannot be used in inline tags that contain literal text; this includes {@code} , {@literal} , {@snippet} , and user-defined tags.

# References

References are the constructs in a documentation comment that refer to elements in the surrounding declarations. Depending on the context, they may refer to modules, packages, classes and interfaces, constructors, methods, annotation members, fields, enum members, parameters, record components and the names of exceptions that may be thrown by a method or constructor. The most general form of a reference is: This form is used by the @see , {@link} and {@linkplain} tags. Leading components can be omitted when they can be inferred from the surrounding context. Trailing components can be omitted when they are not required. Generally, the reference is evaluated in the scope in which the documentation comment exists. In particular, import statements for the compilation unit are taken into account when evaluating class and interface names. The class may be any top-level or nested class or interface. The member may be any constructor, method, annotation member, field or enum member, but not a nested class or interface. As in Java source code, a constructor is identified by using the name of its class. The name of a constructor or method should normally be followed by the list of its parameter types, enclosed in parentheses, although the parameter types and parentheses can be omitted if the method or constructor is not overloaded and the name is not also that of a field or enum member in the same class or interface. When a parameter list is given, whitespace characters may appear between tokens in the parameter list; whitespace characters may not appear elsewhere in the reference. When the reference is to a member of the same class as that containing the documentation comment, all parts of the reference up to and including the # may be omitted, although the '#' may be retained for clarity. Parameterized types may be used in the class and member parts of the reference; annotations may not be used anywhere in the reference. Whitespace characters may occur between tokens within the parameter list for a constructor or method. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. Note: you cannot refer to the declaration of a specific parameter or record component with this form. An alternative form is provided to generate references to arbitrary URI fragments in the generated documentation such as headings in documentation comments. This form uses a double hash mark ( ## ) as separator: fragment is interpreted as URI fragment within the page documenting the specified program element. Other tags, such as @param , @throws , and @serialField may only provide support for the specific kinds of references that are relevant to each tag. See the description of individual tags for more details.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the description part of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the third form of the @see tag. The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example,

```

Refer to {@linkplain #add() the overridden method}.

```

is displayed as: Refer to the overridden method . Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the given description, providing details about the values that may be returned by the method. As an inline tag, provides content for the first sentence of a method's main description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's main description. Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified program element that is referenced. reference can refer to any valid program element. If this element is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is text to be used as the link label and is optional for references to program elements. If no label is provided for an element reference, a default is generated, based on the target of the reference. Use the label when you want the text to be different from the auto-generated text. For references to URI fragments a label must be provided. The label can contain whitespace characters. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExternal method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the @snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the @snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the {@snippet ...} tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline {@link ...} tag. Introduced in JDK 18.

# @spec

Identifies an external specification in terms of its URL and title. The URL may be absolute or relative. Relative URLs will be evaluated against a "base URL". All tags specifying the same URL must provide the same corresponding title; conversely, tags with different URLs must have different titles. Introduced in JDK 20.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a main description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain whitespace characters, or characters such as } . No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in all documentation comments. Introduced in JDK 12.

# @throws

Adds an exception with the specified name followed by the specified description to the "Throws" section. exception-name should refer to an exception that might be thrown by the method, and should either be the name of an exception class or a type variable. This tag is valid only in the documentation comment for a method or constructor. A documentation comment may use multiple @throws tags for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as if it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. The @exception tag is equivalent to this tag, although the @throws form is now recommended. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays the value of a static field with a compile-time constant value. The format string may be omitted, in which case a default format will be used, appropriate to the type of the field. If the format string is given, it must either begin with a percent character (%) or be enclosed in double-quote characters ("). It must contain exactly one percent character. The string must conform to the definition of a format string, as specified in the documentation for java.util.Formatter . The conversion specified in the format string must be appropriate for the type of the constant value. When the {@value} tag is used without a field_reference argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with a field-reference argument in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

Introduced in JDK 1.4; format added in JDK 20.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/21/jfapi/why-use-jfr-api.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/21/install/overview-jdk-installation.html



---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/21/javadoc/javadoc.html



---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/21/install/version-string-format.html



---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/21/vm/java-virtual-machine-technology-overview.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/21/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Documentation Comment Specification for the Standard Doclet

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool, used to generate HTML API documentation. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet alse allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html . The overall form of a documentation comment is an initial (main) description, followed by a series of block tags that provide additional information about the declaration to which the comment applies. The first sentence of the initial description should be a summary sentence that contains a concise but complete description of the declared entity. Descriptive text may include HTML tags and entities, and inline tags as described below. It is possible to have a comment with only a tag section and no initial description. The description cannot continue after the tag section begins. The argument to a tag can span multiple lines. There can be any number of tags; some types of tags can be repeated while others cannot.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading white space is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc&#8209;files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified" by in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# Block Tags

A block tag must appear at the beginning of a line, ignoring leading asterisks, white space, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . Each block tag has associated text, which includes any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. This associated text can span multiple lines.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

Adds a "Returns" section with the description text. This text should describe the return type and permissible range of values. This tag is valid only in a documentation comment for a method. Introduced in JDK 1.0.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified name that is referenced. The label is optional; if it is omitted, then the program element name appears instead as visible text, suitably shortened. Use the -noqualifier option to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto-generated visible text. package . class # member is any valid program element name that is referenced, such as a package, class, interface, constructor, method or field name. Parts of the name can be omitted as appropriate. The class represents any top-level or nested class or interface. The member represents any constructor, method, or field (not a nested class or interface). If this name is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text that is visible as the link label. The label can contain white space. If label is omitted, then package . class . member appears, suitably shortened relative to the current class and package. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @throws

Behaves the same as the @exception tag. The @throws tag adds a "Throws" subheading to the generated documentation, with the class-name and description text. The class name is the name of the exception that might be thrown by the method. This tag is valid only in the documentation comment for a method or constructor. If the class name is not fully qualified, then the standard doclet uses the search order to look up this class. Multiple @throws tags can be used in a specified documentation comment for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as though it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Inline Tags

Inline tags are enclosed within braces ( { } ) and may generally appear wherever descriptive text and HTML is permitted.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the @see tag. Both tags require the same references and accept the same syntax for package . class # member and label . The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int, int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example, Refer to {@linkplain add() the overridden method}. displays as: Refer to the overridden method. Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain white space characters, or characters such as }. No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in the documentation comments for modules, packages, types, fields and executable members. Introduced in JDK 12.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# Where Tags Can Be Used


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 14

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 14


---


# Java SE 14 & JDK 14

URL: https://docs.oracle.com/en/java/javase/14/docs/api/overview-summary.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# JVM(TM) Tool Interface 14.0.0

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, jint myInt, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int : 4;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

void *reserved118;

```

```

void *reserved119;

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Security Providers document. In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Security Providers document contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The type in this section can be specified when generating an instance of CertStore .

# CipherAlgorithm Names

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the type of digital signature. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresonding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Java Development Kit Version 14 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/14/docs/specs/man/index.html


# JavaDevelopment Kit Version 14 Tool Specifications

# All Platforms

# Windows Only


---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Documentation Comment Specification for the Standard Doclet

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool, used to generate HTML API documentation. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet alse allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html . The overall form of a documentation comment is an initial (main) description, followed by a series of block tags that provide additional information about the declaration to which the comment applies. The first sentence of the initial description should be a summary sentence that contains a concise but complete description of the declared entity. Descriptive text may include HTML tags and entities, and inline tags as described below. It is possible to have a comment with only a tag section and no initial description. The description cannot continue after the tag section begins. The argument to a tag can span multiple lines. There can be any number of tags; some types of tags can be repeated while others cannot.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading white space is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. When writing documentation comments for members, it is best not to use HTML heading tags such as <h1> and <h2> , because the standard doclet creates an entire structured document, and these structural tags might interfere with the formatting of the generated document.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified" by in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# Block Tags

A block tag must appear at the beginning of a line, ignoring leading asterisks, white space, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . Each block tag has associated text, which includes any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. This associated text can span multiple lines.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

Adds a "Returns" section with the description text. This text should describe the return type and permissible range of values. This tag is valid only in a documentation comment for a method. Introduced in JDK 1.0.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified name that is referenced. The label is optional; if it is omitted, then the program element name appears instead as visible text, suitably shortened. Use the -noqualifier option to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto-generated visible text. package . class # member is any valid program element name that is referenced, such as a package, class, interface, constructor, method or field name. Parts of the name can be omitted as appropriate. The class represents any top-level or nested class or interface. The member represents any constructor, method, or field (not a nested class or interface). If this name is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text that is visible as the link label. The label can contain white space. If label is omitted, then package . class . member appears, suitably shortened relative to the current class and package. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExterna l method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @throws

Behaves the same as the @exception tag. The @throws tag adds a "Throws" subheading to the generated documentation, with the class-name and description text. The class name is the name of the exception that might be thrown by the method. This tag is valid only in the documentation comment for a method or constructor. If the class name is not fully qualified, then the standard doclet uses the search order to look up this class. Multiple @throws tags can be used in a specified documentation comment for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as though it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Inline Tags

Inline tags are enclosed within braces ( { } ) and may generally appear wherever descriptive text and HTML is permitted.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the @see tag. Both tags require the same references and accept the same syntax for package . class # member and label . The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int, int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example, Refer to {@linkplain add() the overridden method}. displays as: Refer to the overridden method. Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain white space characters, or characters such as }. No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in the documentation comments for modules, packages, types, fields and executable members. Introduced in JDK 12.

# {@value}

Displays constant values. When the {@value} tag is used without an argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with the argument package . class # field in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

The argument package . class # field takes a form similar to that of the @see tag argument, except that the member must be a static field. Introduced in JDK 1.4.

# Where Tags Can Be Used


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Security Providers document. In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Security Providers document contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The type in this section can be specified when generating an instance of CertStore .

# CipherAlgorithm Names

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Parameter Spec Names

The NamedParameterSpec class in the package java.security.spec may be used to specify a set of parameters by using a single name. These names are case-insensitive.

# Additional JSSE Standard Names

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type. The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to setEnabledProtocols or that may be returned by the SSLSocket and SSLEngine getSupportedProtocols and getEnabledProtocols methods. The protocols parameter returned from the getProtocol method in SSLSession . The protocols parameter passed to the setProtocols method of SSLParameters or that may be returned by the getProtocols method of SSLParameters . The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains. Endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm() method of javax.net.ssl.SSLParameters . The following table shows the currently recognized names.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE 12 implementations. The security algorithm requirements are intended to improve the interoperability of Java SE 12 implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the MD5 message digest algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of the Java SE 12 platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 13

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/index.html


# Java Platform, Standard Edition & Java Development Kit SpecificationsVersion 13


---


# Java Development Kit Version 13 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/man/index.html


# Java Development Kit Version 13 Tool Specifications

# All Platforms

# Windows Only


---


# Java SE 13 & JDK 13

URL: https://docs.oracle.com/en/java/javase/13/docs/api/overview-summary.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# JVM(TM) Tool Interface 13.0.0

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/jvmti.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/13/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the type of digital signature. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresonding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JAR???s URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Version-String Format

URL: https://docs.oracle.com/en/java/javase/20/install/version-string-format.html



---


# Java Development Kit Version 20 Tool Specifications

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/man/index.html


# JavaDevelopment Kit Version 20 Tool Specifications

# All Platforms

# Windows Only


---


# JDK 20 Documentation - Guides

URL: https://docs.oracle.com/en/java/javase/20/books.html


# JDK 20 Documentation


---


# JVM(TM) Tool Interface 20.0.0

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/jvmti.html


# What is the JVM Tool Interface?

# Architecture

# Writing Agents

```

#include <jvmti.h>

```

# Deploying Agents

# Statically Linked Agents (since version 1.2.3)

# Agent Command Line Options

# Agent Start-Up

# Agent Start-Up (OnLoad phase)

```

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)

```

Rationale: Early startup is required so that agents can set the desired capabilities, many of which must be set before the VM is initialized. In JVMDI, the -Xdebug command-line option provided very coarse-grain control of capabilities. JVMPI implementations use various tricks to provide a single "JVMPI on" switch. No reasonable command-line option could provide the fine-grain of control required to balance needed capabilities vs performance impact. Early startup is also needed so that agents can control the execution environment - modifying the file system and system properties to install their functionality.

# Agent Start-Up (Live phase)

```

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)

```

```

JNIEXPORT jint JNICALL
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)

```

# Agent Shutdown

```

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm)

```

```

JNIEXPORT void JNICALL
Agent_OnUnload_L(JavaVM *vm)

```

# JAVA_TOOL_OPTIONS

# Environments

# Bytecode Instrumentation

```

public Object() {
        MyProfiler.allocationTracker(this);
      }

```

```

static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }

```

# Bytecode Instrumentation of code in modules

# Modified UTF-8 String Encoding

# Specification Context

# Functions

# Accessing Functions

```

jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);

```

```

jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);

```

# Function Return Values

# Managing JNI Object References

# Prerequisite State for Calling Functions

# Exceptions and Functions

# Function Index

# Memory Management

# Allocate

```

jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)

```

Rationale: jlong is used for compatibility with JVMDI.

# Deallocate

```

jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)

```

# Thread

# Get Thread State

```

jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER

```

```

0

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING +
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                JVMTI_THREAD_STATE_MONITOR_WAITING

```

```

JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED

```

```

jint state;
        jvmtiError err;

        err = (*jvmti)->GetThreadState(jvmti, thread, &state);
        if (err == JVMTI_ERROR_NONE) {
           if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...

```

```

if (state & JVMTI_THREAD_STATE_WAITING) {  ...

```

```

if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...

```

```

if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }

```

```

err = (*jvmti)->GetThreadState(jvmti, thread, &state);
            abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }

```

# Get Current Thread

```

jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)

```

# Get All Threads

```

jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)

```

# Suspend Thread

```

jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)

```

# Suspend Thread List

```

jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Suspend All Virtual Threads

```

jvmtiError
SuspendAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Resume Thread

```

jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)

```

# Resume Thread List

```

jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)

```

# Resume All Virtual Threads

```

jvmtiError
ResumeAllVirtualThreads(jvmtiEnv* env,
            jint except_count,
            const jthread* except_list)

```

# Stop Thread

```

jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)

```

# Interrupt Thread

```

jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)

```

# Get Thread Info

```

typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;

```

```

jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)

```

# Get Owned Monitor Info

```

jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)

```

# Get Owned Monitor Stack Depth Info

```

typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;

```

```

jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)

```

# Get Current Contended Monitor

```

jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)

```

# Agent Start Function

```

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env,
     JNIEnv* jni_env,
     void* arg);

```

# Run Agent Thread

```

jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)

```

# Set Thread Local Storage

```

jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)

```

# Get Thread Local Storage

```

jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)

```

# Thread Group

# Get Top Thread Groups

```

jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Get Thread Group Info

```

typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;

```

```

jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)

```

# Get Thread Group Children

```

jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)

```

# Stack Frame

# Stack frame information structure

```

typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;

```

# Stack information structure

```

typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;

```

# Get Stack Trace

```

jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)

```

```

jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5,
                               frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0].method,
                       &methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}

```

# Get All Stack Traces

```

jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)

```

```

jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count);
if (err != JVMTI_ERROR_NONE) {
   ...
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info);

```

# Get Thread List Stack Traces

```

jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)

```

# Get Frame Count

```

jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)

```

# Pop Frame

```

jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)

```

# Get Frame Location

```

jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)

```

# Notify Frame Pop

```

jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)

```

# Force Early Return

# Force Early Return - Object

```

jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)

```

# Force Early Return - Int

```

jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)

```

# Force Early Return - Long

```

jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)

```

# Force Early Return - Float

```

jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)

```

# Force Early Return - Double

```

jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)

```

# Force Early Return - Void

```

jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)

```

# Heap

# Object Tags

# Heap Callback Functions

# Reference information structure for Field references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;

```

```

interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}

```

# Reference information structure for Array references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;

```

# Reference information structure for Constant Pool references

```

typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;

```

# Reference information structure for Local Variable references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;

```

# Reference information structure for JNI local references

```

typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;

```

# Reference information structure for Other references

```

typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;

```

# Reference information structure

```

typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;

```

# Heap callback function structure

```

typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;

```

Rationale: The heap dumping functionality (below) uses a callback for each object. While it would seem that a buffered approach would provide better throughput, tests do not show this to be the case--possibly due to locality of memory reference or array access overhead.

# Heap Iteration Callback

```

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint length,
     void* user_data);

```

# Heap Reference Callback

```

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind,
     const jvmtiHeapReferenceInfo* reference_info,
     jlong class_tag,
     jlong referrer_class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong* referrer_tag_ptr,
     jint length,
     void* user_data);

```

# Primitive Field Callback

```

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind,
     const jvmtiHeapReferenceInfo* info,
     jlong object_class_tag,
     jlong* object_tag_ptr,
     jvalue value,
     jvmtiPrimitiveType value_type,
     void* user_data);

```

# Array Primitive Value Callback

```

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jint element_count,
     jvmtiPrimitiveType element_type,
     const void* elements,
     void* user_data);

```

# String Primitive Value Callback

```

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     const jchar* value,
     jint value_length,
     void* user_data);

```

# reserved for future use Callback

```

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

```

# Follow References

```

jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Iterate Through Heap

```

jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)

```

# Get Tag

```

jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)

```

# Set Tag

```

jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)

```

# Get Objects With Tags

```

jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)

```

# Force Garbage Collection

```

jvmtiError
ForceGarbageCollection(jvmtiEnv* env)

```

# Heap (1.0)

Rationale: No known implementations used the 1.0 definition.

# Heap Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Heap Root Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     void* user_data);

```

# Stack Reference Object Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong thread_tag,
     jint depth,
     jmethodID method,
     jint slot,
     void* user_data);

```

# Object Reference Callback

```

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind,
     jlong class_tag,
     jlong size,
     jlong* tag_ptr,
     jlong referrer_tag,
     jint referrer_index,
     void* user_data);

```

# Iterate Over Objects Reachable From Object

```

jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)

```

# Iterate Over Reachable Objects

```

jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)

```

# Iterate Over Heap

```

jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Iterate Over Instances Of Class

```

jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)

```

# Local Variable

# Get Local Variable - Object

```

jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)

```

# Get Local Instance

```

jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)

```

# Get Local Variable - Int

```

jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)

```

# Get Local Variable - Long

```

jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)

```

# Get Local Variable - Float

```

jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)

```

# Get Local Variable - Double

```

jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)

```

# Set Local Variable - Object

```

jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)

```

# Set Local Variable - Int

```

jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)

```

# Set Local Variable - Long

```

jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)

```

# Set Local Variable - Float

```

jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)

```

# Set Local Variable - Double

```

jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)

```

# Breakpoint

# Set Breakpoint

```

jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Clear Breakpoint

```

jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

```

# Watched Field

# Set Field Access Watch

```

jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Access Watch

```

jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Set Field Modification Watch

```

jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Clear Field Modification Watch

```

jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)

```

# Module

# Get All Modules

```

jvmtiError
GetAllModules(jvmtiEnv* env,
            jint* module_count_ptr,
            jobject** modules_ptr)

```

# Get Named Module

```

jvmtiError
GetNamedModule(jvmtiEnv* env,
            jobject class_loader,
            const char* package_name,
            jobject* module_ptr)

```

# Add Module Reads

```

jvmtiError
AddModuleReads(jvmtiEnv* env,
            jobject module,
            jobject to_module)

```

# Add Module Exports

```

jvmtiError
AddModuleExports(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Opens

```

jvmtiError
AddModuleOpens(jvmtiEnv* env,
            jobject module,
            const char* pkg_name,
            jobject to_module)

```

# Add Module Uses

```

jvmtiError
AddModuleUses(jvmtiEnv* env,
            jobject module,
            jclass service)

```

# Add Module Provides

```

jvmtiError
AddModuleProvides(jvmtiEnv* env,
            jobject module,
            jclass service,
            jclass impl_class)

```

# Is Modifiable Module

```

jvmtiError
IsModifiableModule(jvmtiEnv* env,
            jobject module,
            jboolean* is_modifiable_module_ptr)

```

# Class

# Get Loaded Classes

```

jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Classloader Classes

```

jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)

```

# Get Class Signature

```

jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Class Status

```

jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)

```

# Get Source File Name

```

jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)

```

# Get Class Modifiers

```

jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)

```

# Get Class Methods

```

jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)

```

# Get Class Fields

```

jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)

```

# Get Implemented Interfaces

```

jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)

```

# Get Class Version Numbers

```

jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)

```

# Get Constant Pool

```

jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)

```

# Is Interface

```

jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)

```

# Is Array Class

```

jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)

```

# Is Modifiable Class

```

jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)

```

# Get Class Loader

```

jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)

```

# Get Source Debug Extension

```

jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)

```

# Retransform Classes

```

jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)

```

# Redefine Classes

```

typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;

```

```

jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)

```

# Object

# Get Object Size

```

jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)

```

# Get Object Hash Code

```

jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)

```

# Get Object Monitor Usage

```

typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;

```

```

jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)

```

# Field

# Get Field Name (and Signature)

```

jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Field Declaring Class

```

jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)

```

# Get Field Modifiers

```

jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)

```

# Is Field Synthetic

```

jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)

```

# Method

# Obsolete Methods

# Get Method Name (and Signature)

```

jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)

```

# Get Method Declaring Class

```

jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)

```

# Get Method Modifiers

```

jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)

```

# Get Max Locals

```

jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)

```

# Get Arguments Size

```

jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)

```

# Get Line Number Table

```

typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;

```

```

jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)

```

# Get Method Location

```

jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)

```

# Get Local Variable Table

```

typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;

```

```

jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)

```

# Get Bytecodes

```

jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)

```

# Is Method Native

```

jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)

```

# Is Method Synthetic

```

jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)

```

# Is Method Obsolete

```

jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)

```

# Set Native Method Prefix

```

jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)

```

```

native boolean foo(int x);

```

```

boolean foo(int x) {
... record entry to foo ...
return wrapped_foo(x);
}

native boolean wrapped_foo(int x);

```

```

Java_somePackage_someClass_foo(JNIEnv* env, jint x)

```

```

method(foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

```

method(wrapped_foo) -> nativeImplementation(wrapped_foo)

```

```

method(wrapped_foo) -> nativeImplementation(foo)

```

# Set Native Method Prefixes

```

jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)

```

# Raw Monitor

# Create Raw Monitor

```

jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)

```

# Destroy Raw Monitor

```

jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Enter

```

jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Exit

```

jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Wait

```

jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)

```

# Raw Monitor Notify

```

jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# Raw Monitor Notify All

```

jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)

```

# JNI Function Interception

```

JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}

```

# Set JNI Function Table

```

jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)

```

# Get JNI Function Table

```

jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)

```

# Event Management

# Set Event Callbacks

```

jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)

```

# Set Event Notification Mode

```

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

```

```

jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)

```

# Generate Events

```

jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)

```

# Extension Mechanism

# Extension Function/Event Parameter Info

```

typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;

```

# Extension Function

```

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,
      ...);

```

# Get Extension Functions

```

typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;

```

```

jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)

```

# Get Extension Events

```

typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;

```

```

jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)

```

# Extension Event

```

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,
      ...);

```

```

void JNICALL myHandler(jvmtiEnv* jvmti_env, ...)

```

# Set Extension Event Callback

```

jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)

```

# Capability

# Capability Examples

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           err = (*jvmti)->AddCapabilities(jvmti, &capa);

```

```

jvmtiCapabilities capa;
        jvmtiError err;

        err = (*jvmti)->GetCapabilities(jvmti, &capa);
        if (err == JVMTI_ERROR_NONE) {
           if (capa.can_get_bytecodes) { ... } }

```

# The Capabilities Structure

```

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int can_generate_early_vmstart : 1;
    unsigned int can_generate_early_class_hook_events : 1;
    unsigned int can_generate_sampled_object_alloc_events : 1;
    unsigned int can_support_virtual_threads : 1;
    unsigned int : 3;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;

```

# Get Potential Capabilities

```

jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Add Capabilities

```

jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Relinquish Capabilities

```

jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)

```

# Get Capabilities

```

jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)

```

# Timers

# Timer Info

```

typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;

```

# Get Current Thread CPU Timer Information

```

jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Current Thread CPU Time

```

jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

```

GetThreadCpuTime(env, NULL, nanos_ptr)

```

# Get Thread CPU Timer Information

```

jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Thread CPU Time

```

jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)

```

# Get Timer Information

```

jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)

```

# Get Time

```

jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)

```

# Get Available Processors

```

jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)

```

# Class Loader Search

# Add To Bootstrap Class Loader Search

```

jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# Add To System Class Loader Search

```

jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)

```

# System Properties

# Get System Properties

```

jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)

```

# Get System Property

```

jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)

```

# Set System Property

```

jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)

```

# General

# Get Phase

```

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

```

```

jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)

```

# Dispose Environment

```

jvmtiError
DisposeEnvironment(jvmtiEnv* env)

```

# Set Environment Local Storage

```

jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)

```

# Get Environment Local Storage

```

jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)

```

# Get Version Number

```

jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)

```

# Get Error Name

```

jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)

```

# Set Verbose Flag

```

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

```

```

jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)

```

# Get JLocation Format

```

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

```

```

jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)

```

# Heap Monitoring

# Set Heap Sampling Interval

```

jvmtiError
SetHeapSamplingInterval(jvmtiEnv* env,
            jint sampling_interval)

```

# Errors

# Universal Errors

# Function Specific Required Errors

# Function Specific Agent Errors

# Data Types

```

typedef jobject jthread;

```

```

typedef jobject jthreadGroup;

```

```

typedef jlong jlocation;

```

```

struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;

```

```

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
      ...
} jvmtiError;

```

```

typedef enum {
    JVMTI_EVENT_SINGLE_STEP = 1,
    JVMTI_EVENT_BREAKPOINT = 2,
      ...
} jvmtiEvent;

```

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ...
} jvmtiEventCallbacks;

```

```

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

```

```

typedef struct JNINativeInterface_ jniNativeInterface;

```

```

void *reserved1;

```

```

jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
                       jvmtiEventMode mode,
                       jvmtiEvent event_type,
                       jthread event_thread,
                        ...);

```

```

jvmtiError (JNICALL *GetAllModules) (jvmtiEnv* env,
                       jint* module_count_ptr,
                       jobject** modules_ptr);

```

```

jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
                       jint* threads_count_ptr,
                       jthread** threads_ptr);

```

```

jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
                       jthread thread,
                       jobject exception);

```

```

jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiThreadInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* owned_monitor_count_ptr,
                       jobject** owned_monitors_ptr);

```

```

jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
                       jthread thread,
                       jobject* monitor_ptr);

```

```

jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
                       jthread thread,
                       jvmtiStartFunction proc,
                       const void* arg,
                       jint priority);

```

```

jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
                       jthreadGroup group,
                       jvmtiThreadGroupInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
                       jthreadGroup group,
                       jint* thread_count_ptr,
                       jthread** threads_ptr,
                       jint* group_count_ptr,
                       jthreadGroup** groups_ptr);

```

```

jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
                       jthread thread,
                       jint* count_ptr);

```

```

jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
                       jthread thread,
                       jint* thread_state_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
                       jthread* thread_ptr);

```

```

jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jmethodID* method_ptr,
                       jlocation* location_ptr);

```

```

jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
                       jthread thread,
                       jint depth);

```

```

jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat* value_ptr);

```

```

jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble* value_ptr);

```

```

jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jobject value);

```

```

jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jint value);

```

```

jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jlong value);

```

```

jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jfloat value);

```

```

jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jint slot,
                       jdouble value);

```

```

jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
                       const char* name,
                       jrawMonitorID* monitor_ptr);

```

```

jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
                       jrawMonitorID monitor,
                       jlong millis);

```

```

jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
                       jrawMonitorID monitor);

```

```

jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation location);

```

```

jvmtiError (JNICALL *GetNamedModule) (jvmtiEnv* env,
                       jobject class_loader,
                       const char* package_name,
                       jobject* module_ptr);

```

```

jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field);

```

```

jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_modifiable_class_ptr);

```

```

jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
                       jlong size,
                       unsigned char** mem_ptr);

```

```

jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
                       unsigned char* mem);

```

```

jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
                       jclass klass,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
                       jclass klass,
                       jint* status_ptr);

```

```

jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
                       jclass klass,
                       char** source_name_ptr);

```

```

jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
                       jclass klass,
                       jint* method_count_ptr,
                       jmethodID** methods_ptr);

```

```

jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
                       jclass klass,
                       jint* field_count_ptr,
                       jfieldID** fields_ptr);

```

```

jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
                       jclass klass,
                       jint* interface_count_ptr,
                       jclass** interfaces_ptr);

```

```

jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_interface_ptr);

```

```

jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
                       jclass klass,
                       jboolean* is_array_class_ptr);

```

```

jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
                       jclass klass,
                       jobject* classloader_ptr);

```

```

jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
                       jobject object,
                       jint* hash_code_ptr);

```

```

jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
                       jobject object,
                       jvmtiMonitorUsage* info_ptr);

```

```

jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jint* modifiers_ptr);

```

```

jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
                       jclass klass,
                       jfieldID field,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
                       jmethodID method,
                       char** name_ptr,
                       char** signature_ptr,
                       char** generic_ptr);

```

```

jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
                       jmethodID method,
                       jclass* declaring_class_ptr);

```

```

jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
                       jmethodID method,
                       jint* modifiers_ptr);

```

```

void *reserved67;

```

```

jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
                       jmethodID method,
                       jint* max_ptr);

```

```

jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
                       jmethodID method,
                       jint* size_ptr);

```

```

jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLineNumberEntry** table_ptr);

```

```

jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
                       jmethodID method,
                       jlocation* start_location_ptr,
                       jlocation* end_location_ptr);

```

```

jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
                       jmethodID method,
                       jint* entry_count_ptr,
                       jvmtiLocalVariableEntry** table_ptr);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
                       const char* prefix);

```

```

jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
                       jint prefix_count,
                       char** prefixes);

```

```

jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
                       jmethodID method,
                       jint* bytecode_count_ptr,
                       unsigned char** bytecodes_ptr);

```

```

jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_native_ptr);

```

```

jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_synthetic_ptr);

```

```

jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
                       jobject initiating_loader,
                       jint* class_count_ptr,
                       jclass** classes_ptr);

```

```

jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
                       jthread thread,
                       jobject value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
                       jthread thread,
                       jint value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
                       jthread thread,
                       jlong value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
                       jthread thread,
                       jfloat value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
                       jthread thread,
                       jdouble value);

```

```

jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
                       jthread thread);

```

```

jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jvmtiClassDefinition* class_definitions);

```

```

jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
                       jint* version_ptr);

```

```

jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
                       jclass klass,
                       char** source_debug_extension_ptr);

```

```

jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
                       jmethodID method,
                       jboolean* is_obsolete_ptr);

```

```

jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
                       jint request_count,
                       const jthread* request_list,
                       jvmtiError* results);

```

```

jvmtiError (JNICALL *AddModuleReads) (jvmtiEnv* env,
                       jobject module,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleExports) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleOpens) (jvmtiEnv* env,
                       jobject module,
                       const char* pkg_name,
                       jobject to_module);

```

```

jvmtiError (JNICALL *AddModuleUses) (jvmtiEnv* env,
                       jobject module,
                       jclass service);

```

```

jvmtiError (JNICALL *AddModuleProvides) (jvmtiEnv* env,
                       jobject module,
                       jclass service,
                       jclass impl_class);

```

```

jvmtiError (JNICALL *IsModifiableModule) (jvmtiEnv* env,
                       jobject module,
                       jboolean* is_modifiable_module_ptr);

```

```

jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr,
                       jint* thread_count_ptr);

```

```

jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
                       jint thread_count,
                       const jthread* thread_list,
                       jint max_frame_count,
                       jvmtiStackInfo** stack_info_ptr);

```

```

jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
                       jthread thread,
                       const void* data);

```

```

jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
                       jthread thread,
                       jint start_depth,
                       jint max_frame_count,
                       jvmtiFrameInfo* frame_buffer,
                       jint* count_ptr);

```

```

void *reserved105;

```

```

jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong* tag_ptr);

```

```

jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
                       jobject object,
                       jlong tag);

```

```

jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
                       jobject object,
                       jvmtiObjectReferenceCallback object_reference_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
                       jvmtiHeapRootCallback heap_root_callback,
                       jvmtiStackReferenceCallback stack_ref_callback,
                       jvmtiObjectReferenceCallback object_ref_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
                       jclass klass,
                       jvmtiHeapObjectFilter object_filter,
                       jvmtiHeapObjectCallback heap_object_callback,
                       const void* user_data);

```

```

void *reserved113;

```

```

jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
                       jint tag_count,
                       const jlong* tags,
                       jint* count_ptr,
                       jobject** object_result_ptr,
                       jlong** tag_result_ptr);

```

```

jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       jobject initial_object,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
                       jint heap_filter,
                       jclass klass,
                       const jvmtiHeapCallbacks* callbacks,
                       const void* user_data);

```

```

void *reserved117;

```

```

jvmtiError (JNICALL *SuspendAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *ResumeAllVirtualThreads) (jvmtiEnv* env,
                       jint except_count,
                       const jthread* except_list);

```

```

jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
                       const jniNativeInterface* function_table);

```

```

jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
                       jniNativeInterface** function_table);

```

```

jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
                       const jvmtiEventCallbacks* callbacks,
                       jint size_of_callbacks);

```

```

jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
                       jvmtiEvent event_type);

```

```

jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionFunctionInfo** extensions);

```

```

jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
                       jint* extension_count_ptr,
                       jvmtiExtensionEventInfo** extensions);

```

```

jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
                       jint extension_event_index,
                       jvmtiExtensionEvent callback);

```

```

jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

```

```

jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
                       jvmtiError error,
                       char** name_ptr);

```

```

jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
                       jvmtiJlocationFormat* format_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
                       jint* count_ptr,
                       char*** property_ptr);

```

```

jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       char** value_ptr);

```

```

jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
                       const char* property,
                       const char* value_ptr);

```

```

jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
                       jvmtiPhase* phase_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
                       jthread thread,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
                       jvmtiTimerInfo* info_ptr);

```

```

jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
                       jlong* nanos_ptr);

```

```

jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
                       jvmtiCapabilities* capabilities_ptr);

```

```

void *reserved141;

```

```

jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
                       const jvmtiCapabilities* capabilities_ptr);

```

```

jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
                       jint* processor_count_ptr);

```

```

jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
                       jclass klass,
                       jint* minor_version_ptr,
                       jint* major_version_ptr);

```

```

jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
                       jclass klass,
                       jint* constant_pool_count_ptr,
                       jint* constant_pool_byte_count_ptr,
                       unsigned char** constant_pool_bytes_ptr);

```

```

jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
                       void** data_ptr);

```

```

jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
                       const void* data);

```

```

jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
                       jvmtiVerboseFlag flag,
                       jboolean value);

```

```

jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
                       const char* segment);

```

```

jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
                       jint class_count,
                       const jclass* classes);

```

```

jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
                       jthread thread,
                       jint* monitor_info_count_ptr,
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);

```

```

jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
                       jobject object,
                       jlong* size_ptr);

```

```

jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
                       jthread thread,
                       jint depth,
                       jobject* value_ptr);

```

```

jvmtiError (JNICALL *SetHeapSamplingInterval) (jvmtiEnv* env,
                       jint sampling_interval);

```

# Events

# Handling Events

# Enabling Events

# Multiple Co-located Events

# Event Callbacks

```

typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
    jvmtiEventReserved reserved85;
    jvmtiEventSampledObjectAlloc SampledObjectAlloc;
    jvmtiEventVirtualThreadStart VirtualThreadStart;
    jvmtiEventVirtualThreadEnd VirtualThreadEnd;
} jvmtiEventCallbacks;

```

# Event Index

# Single Step

```

void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Breakpoint

```

void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

```

# Field Access

```

void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)

```

# Field Modification

```

void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)

```

# Frame Pop

```

void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)

```

# Method Entry

```

void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)

```

# Method Exit

```

void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)

```

# Native Method Bind

```

void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)

```

# Exception

```

void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)

```

# Exception Catch

```

void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)

```

# Thread Start

```

void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Thread End

```

void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# Virtual Thread Start

```

void JNICALL
VirtualThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Virtual Thread End

```

void JNICALL
VirtualThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread virtual_thread)

```

# Class Load

```

void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class Prepare

```

void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)

```

# Class File Load Hook

```

void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)

```

# VM Start Event

```

void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# VM Initialization Event

```

void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)

```

# VM Death Event

```

void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)

```

# Compiled Method Load

```

typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;

```

```

void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)

```

# Compiled Method Unload

```

void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)

```

# Dynamic Code Generated

```

void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)

```

# Data Dump Request

```

void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)

```

# Monitor Contended Enter

```

void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Contended Entered

```

void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)

```

# Monitor Wait

```

void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)

```

# Monitor Waited

```

void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)

```

# Resource Exhausted

```

void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)

```

# VM Object Allocation

```

void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Sampled Object Allocation

```

void JNICALL
SampledObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)

```

# Object Free

```

void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)

```

# Garbage Collection Start

```

void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)

```

# Garbage Collection Finish

```

void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)

```

# Constant Index

# Change History


---


# Java Core Libraries

URL: https://docs.oracle.com/en/java/javase/20/core/java-core-libraries1.html



---


# Packaging Overview

URL: https://docs.oracle.com/en/java/javase/20/jpackage/packaging-overview.html



---


# Java Accessibility Overview

URL: https://docs.oracle.com/en/java/javase/20/access/java-accessibility-overview.html



---


# Java Debug Wire Protocol

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/jdwp/jdwp-spec.html


Protocol details

# Overview

The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs (hereafter called the target VM). JDWP is optional; it might not be available in some implementations of the JDK. The existence of JDWP can allow the same debugger to work The JDWP differs from many protocol specifications in that it only details format and layout, not transport. A JDWP implementation can be designed to accept different transport mechanisms through a simple API. A particular transport does not necessarily support each of the debugger/target VM combinations listed above. The JDWP is designed to be simple enough for easy implementation, yet it is flexible enough for future growth. Currently, the JDWP does not specify any mechanism for transport rendezvous or any directory services. This may be changed in the future, but it may be addressed in a separate document. JDWP is one layer within the Java Platform Debugger Architecture (JPDA). This architecture also contains the higher-level Java Debug Interface (JDI). The JDWP is designed to facilitate efficient use by the JDI; many of its abilities are tailored to that end. The JDI is more appropriate than JDWP for many debugger tools, particularly those written in the Java programming language. For more information on the Java Platform Debugger Architecture, see the Java Platform Debugger Architecture documentation for this release.

# JDWP Start Up

After the transport connection is established and before any packets are sent, a handshake occurs between the two sides of the connection: The handshake process has the following steps:

# JDWP Packets

The JDWP is packet based and is not stateful. There are two basic packet types: command packets and reply packets. Command packets may be sent by either the debugger or the target VM. They are used by the debugger to request information from the target VM, or to control program execution. Command packets are sent by the target VM to notify the debugger of some event in the target VM such as a breakpoint or exception. A reply packet is sent only in response to a command packet and always provides information success or failure of the command. Reply packets may also carry data requested in the command (for example, the value of a field or variable). Currently, events sent from the target VM do not require a response packet from the debugger. The JDWP is asynchronous; multiple command packets may be sent before the first reply packet is received. Command and reply packet headers are equal in size; this is to make transports easier to implement and abstract. The layout of each packet looks like this: All fields and data sent via JDWP should be in big-endian format. (See the Java Virtual Machine Specification for the definition of big-endian.) The first three fields are identical in both packet types.

# Command and Reply Packet Fields

# Shared Header Fields

# length

The length field is the size, in bytes, of the entire packet, including the length field. The header size is 11 bytes, so a packet with no data would set this field to 11.

# id

The id field is used to uniquely identify each packet command/reply pair. A reply packet has the same id as the command packet to which it replies. This allows asynchronous commands and replies to be matched. The id field must be unique among all outstanding commands sent from one source. (Outstanding commands originating from the debugger may use the same id as outstanding commands originating from the target VM.) Other than that, there are no requirements on the allocation of id's. A simple monotonic counter should be adequate for most implementations. It will allow 2^32 unique outstanding packets and is the simplest implementation alternative.

# flags

Flags are used to alter how any command is queued and processed and to tag command packets that originate from the target VM. There is currently one flag bits defined; future versions of the protocol may define additional flags. The reply bit, when set, indicates that this packet is a reply.

# Command Packet Header Fields

# command set

This field is useful as a means for grouping commands in a meaningful way. The Sun defined command sets are used to group commands by the interfaces they support in the JDI. For example, all commands that support the JDI VirtualMachine interface are grouped in a VirtualMachine command set. The command set space is roughly divided as follows:

# command

This field identifies a particular command in a command set. This field, together with the command set field, is used to indicate how the command packet should be processed. More succinctly, they tell the receiver what to do. Specific commands are presented later in this document.

# Reply Packet Header Fields

# error code

This field is used to indicate if the command packet that is being replied to was successfully processed. A value of zero indicates success, a non-zero value indicates an error. The error code returned may be specific to each command set/command, but it is often mapped to a JVM TI error code.

# Data

The data field is unique to each command set/command. It is also different between command and reply packet pairs. For example, a command packet that requests a field value will contain references to the object and field id's for the desired value in its data field. The reply packet's data field will contain the value of the field.

# Detailed Command Information


---


# Java Object Serialization Specification: Contents

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/serialization/index.html


# Table of Contents

# 1System Architecture

# 2Object Output Classes

# 3Object Input Classes

# 4Class Descriptors

# 5Versioning of Serializable Objects

# 6Object Serialization Stream Protocol

# ASecurity in Object Serialization

# BExceptions In Object Serialization

# CExample of Serializable Fields


---


# Introduction to Garbage Collection Tuning

URL: https://docs.oracle.com/en/java/javase/20/gctuning/introduction-garbage-collection-tuning.html



---


# Java Language Changes

URL: https://docs.oracle.com/en/java/javase/20/language/java-language-changes.html



---


# Java Native Interface Specification: Contents

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/jni/index.html


# Java Native Interface Specification Contents


---


# Overview of Java SE Monitoring and Management

URL: https://docs.oracle.com/en/java/javase/20/management/overview-java-se-monitoring-and-management.html



---


# Introduction to JShell

URL: https://docs.oracle.com/en/java/javase/20/jshell/introduction-jshell.html



---


# Overview of JDK Installation

URL: https://docs.oracle.com/en/java/javase/20/install/overview-jdk-installation.html



---


# Java Virtual Machine Technology Overview

URL: https://docs.oracle.com/en/java/javase/20/vm/java-virtual-machine-technology-overview.html



---


# JavaDoc Tool

URL: https://docs.oracle.com/en/java/javase/20/javadoc/javadoc.html



---


# Java Security Overview

URL: https://docs.oracle.com/en/java/javase/20/security/java-security-overview1.html



---


# Java SE 20 & JDK 20

URL: https://docs.oracle.com/en/java/javase/20/docs/api/overview-summary.html



---


# Documentation Comment Specification for the Standard Doclet (JDK 20)

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/javadoc/doc-comment-spec.html


This document specifies the form of documentation comments recognized by the standard doclet for the javadoc tool in JDK 20, used to generate HTML documentation for an API. In the context of the javadoc tool, the interpretation of the content of a documentation comment is up to doclet that is used to process the comment. Other doclets may accept the same syntax as the standard doclet, or they may support an alternate syntax. However, due to support in many tools, the syntax supported by the standard doclet has become a de facto standard.

# General Syntax

Documentation comments are recognized only when placed immediately before module, package, class, interface, constructor, method, enum member, or field declarations. Documentation comments placed in the body of a method are ignored. Only one documentation comment per declaration statement is recognized. The overall form of a documentation comment is an initial main description , followed by a series of block tags , which provide additional information about the declaration to which the comment applies. Descriptive text may include inline tags and HTML content , as described below. Leading asterisks at the beginning of each line, and any preceding whitespace, are ignored. It is possible to have a comment with only block tags and no main description. For historical reasons, the documentation comment for a package may instead be provided in a file called package.html in a source directory for the package. In this case, the documentation comment is the content of the <body> tag, and all references to Java types (for example, in @see tags) must be fully qualified. The standard doclet also allows additional documentation to be provided in files such as overview.html . The rules for such content are the same as for package.html .

# Main Description

The main description in a documentation comment is the content from the beginning of the comment, up to the first block tag, if there are any, or to the end of the comment, if there are none. Leading and trailing whitespace is ignored. If there is no such content, the main description is said to be missing. The main description cannot continue after any block tags. The first sentence of the main description should be a summary sentence that contains a concise but complete description of the declared entity.

# Block Tags

Block tags are of the form @ identifier content and give additional details to be incorporated into the generated documentation. Each block tag must appear at the beginning of a line, ignoring leading asterisks, whitespace characters, and the initial comment delimiter ( /** ). This means you can use the @ character elsewhere in the text and it will not be interpreted as the start of a tag. If you want to start a line with the @ character and not have it be interpreted, then use the HTML entity &#064; . The content of a block tag is any text following the tag up to, but not including, either the next block tag, or the end of the documentation comment. The content can span multiple lines. There can be any number of block tags; some types of tags can be repeated while others cannot.

# Inline Tags

Inline tags are of the form {@ identifier content } and provide details within the context of the enclosing description. They may generally appear wherever descriptive text and HTML is permitted, although some inline tags may only be used at the beginning of the main description. Some inline tags may contain free-form text. When such text explicitly contains braces, the braces must be "balanced", implying an equal number of appropriately nested left brace and right brace characters, so that the closing brace of the inline tag can be determined. No other lexical analysis of the text is performed; in particular, there is no special consideration of characters like ' , " , \ , and @ . Lines beginning with @ that are enclosed within an inline tag are not considered as beginning a block tag. When the text content is HTML, it may be possible to use entities &lbrace; and &rbrace; to represent unbalanced braces.

# HTML Content

HTML content is not formally checked, although some tools may provide some amount of checking to help catch common errors. In order to be able to generate documentation that conforms to the appropriate standards, the following considerations should be taken into account when using HTML constructs in a documentation comment: HTML constructs should be written in HTML 5 . To support properly structured headings within the pages of generated documentation, headings in the documentation comments for module, package, and type declarations (including nested types) should start at <h2> and increase accordingly as needed; likewise, headings in the documentation comments for constructors, methods, fields and other members should start at <h4> . In standalone HTML files, such as in a doc-files subdirectory, headings should start at <h1> . To avoid the possibility of a conflict with the unique identifiers used to identify positions within the generated documentation for the declaration of program elements, the values of user-defined id attributes should contain a character (such as - ) that is not a valid character in a Java identifier.

# Leading Asterisks

When a documentation comment is read, leading asterisks ( * ) on each line are discarded, and blanks and tabs that precede the initial asterisks ( * ) are also discarded. If you omit the leading asterisk on a line, then the leading whitespace is no longer removed so that you can paste code examples directly into a documentation comment inside a <pre> tag with its indentation preserved. Spaces are interpreted by browsers more uniformly than tabs. Indentation is relative to the left margin (rather than the separator /** or <pre> tag).

# References

References are the constructs in a documentation comment that refer to elements in the surrounding declarations. Depending on the context, they may refer to modules, packages, classes and interfaces, constructors, methods, annotation members, fields, enum members, parameters, record components and the names of exceptions that may be thrown by a method or constructor. The most general form of a reference is: This form is used by the @see , {@link} and {@linkplain} tags. Leading components can be omitted when they can be inferred from the surrounding context. Trailing components can be omitted when they are not required. Generally, the reference is evaluated in the scope in which the documentation comment exists. In particular, import statements for the compilation unit are taken into account when evaluating class and interface names. The class may be any top-level or nested class or interface. The member may be any constructor, method, annotation member, field or enum member, but not a nested class or interface. As in Java source code, a constructor is identified by using the name of its class. The name of a constructor or method should normally be followed by the list of its parameter types, enclosed in parentheses, although the parameter types and parentheses can be omitted if the method or constructor is not overloaded and the name is not also that of a field or enum member in the same class or interface. When a parameter list is given, whitespace characters may appear between tokens in the parameter list; whitespace characters may not appear elsewhere in the reference. When the reference is to a member of the same class as that containing the documentation comment, all parts of the reference up to and including the # may be omitted, although the '#' may be retained for clarity. Parameterized types may be used in the class and member parts of the reference; annotations may not be used anywhere in the reference. Whitespace characters may occur between tokens within the parameter list for a constructor or method. A trailing / can be added to a name to refer to a module in the presence of a package or class with the same name. Note: you cannot refer to the declaration of a specific parameter or record component with this form. Other tags, such as @param , @throws , and @serialField may only provide support for the specific kinds of references that are relevant to each tag. See the description of individual tags for more details.

# Comment Inheritance

# Class and Interface Inheritance

Comment inheritance occurs in all possible cases of inheritance from classes and interfaces: In the first two cases, the standard doclet generates the subheading "Overrides" in the documentation for the overriding method. A link to the method being overridden is included, whether or not the comment is inherited. In the third case, when a method in a specified class implements a method in an interface, the standard doclet generates the subheading "Specified by" in the documentation for the overriding method. A link to the method being implemented is included, whether or not the comment is inherited.

# Method Comment Inheritance

The standard doclet allows method comment inheritance in classes and interfaces to fill in missing text or to explicitly inherit method comments. Constructors, fields, and nested classes do not inherit documentation comments. Note: The source file for an inherited method must be on the path specified by the -sourcepath option for the documentation comment to be available to copy. Neither the class nor its package needs to be passed in on the command line.

# Fill in Missing Text

When a main description, or @return , @param , or @throws tag is missing from a method comment, the information is copied from the method it overrides or implements (if any). When an @param tag for a particular parameter is missing, the comment for that parameter is copied from the method further up the inheritance hierarchy. When an @throws tag for a particular exception is missing, the @throws tag is copied only when that exception is declared.

# Explicit Inheritance

Insert the {@inheritDoc} inline tag in a method main description or @return , @param , or @throws tag comment. The corresponding inherited main description or tag comment is copied into that spot.

# Method Comments Algorithm

If a method does not have a documentation comment, or has an {@inheritDoc} tag, then the standard doclet uses the following algorithm to search for an applicable comment. The algorithm is designed to find the most specific applicable documentation comment, and to give preference to interfaces over superclasses:

# Standard Tags

The following sections describe the standard block and inline tags supported by the standard doclet. Note: The standard doclet also supports user-defined tags conforming to the same general syntactic rules.

# @author

Adds an "Author" entry with the specified name text to the generated documents when the -author option is used. A documentation comment can contain multiple @author tags. You can specify one name per @author tag or multiple names per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than a comma. Introduced in JDK 1.0.

# {@code}

Equivalent to <code>{@literal text }</code> . Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use regular angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@code A<B>C} displayed in the generated HTML page unchanged as A<B>C . This means that the <B> is not interpreted as bold and is in code font. If you want the same functionality without the code font, then use the {@literal} tag. Introduced in JDK 1.5.

# @deprecated

This tag is used in conjunction with the @Deprecated annotation to indicate that this API should no longer be used (even though it may continue to work). The standard doclet moves deprecated text ahead of the main description, placing it in italics and preceding it with a bold warning. The first sentence of deprecated text should tell the user when the API was deprecated and what to use as a replacement. The standard doclet copies the first sentence to the summary section and index. Subsequent sentences can also explain why it was deprecated. You should include an {@link} tag that points to the replacement API. Introduced in JDK 1.0.

# {@docRoot}

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. This {@docRoot} tag can be used both on the command line and in a documentation comment. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the text portion of any tag (such as the @return , @param and @deprecated tags). For example, on the command line, where the header, footer, or bottom are defined:

```

javadoc -bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'.

```

When you use the {@docRoot} tag this way in a make file, some makefile programs require a special way to escape for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: {{@docRoot}} . It also requires double (rather than single) quotation marks to enclose arguments to options such as the -bottom option (with the quotation marks around the href argument omitted). For example, in a documentation comment:

```

/**
 * See the <a href="{@docRoot}/copyright.html">Copyright</a>.
 */

```

This tag is needed because the generated documents are in hierarchical directories, as deep as the number of subpackages. The expression <a href="{@docRoot}/copyright.html"> resolves to <a href="../../copyright.html"> for java/lang/Object.java and <a href="../../../copyright.html"> for java/lang/ref/Reference.java . Introduced in JDK 1.3.

# @exception

This tag is equivalent to the @throws tag, which is now the recommended form. Introduced in JDK 1.0.

# @hidden

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all. Introduced in JDK 9.

# {@index}

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym. Introduced in JDK 9.

# {@inheritDoc}

Inherits (copies) documentation from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text. This tag is valid only in these places in a documentation comment: See Method Comment Inheritance for a description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, then the comment is or is not automatically inherited according to rules described in that section. Introduced in JDK 1.4.

# {@link}

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. This tag is valid in all documentation comments: overview, module, package, class, interface, constructor, method and field, including the description part of any tag, such as the @return , @param and @deprecated tags. This tag is similar to the third form of the @see tag. The main difference is that the {@link} tag generates an inline link rather than placing the link in the "See Also" section. The {@link} tag begins and ends with braces to separate it from the rest of the inline text. If you need to use the right brace ( } ) inside the label, then use the HTML entity notation &#125; . There is no limit to the number of {@link} tags allowed in a sentence. For example, here is a comment that refers to the getComponentAt(int, int) method:

```

Use the {@link #getComponentAt(int, int) getComponentAt} method.

```

From this code, the standard doclet generates the following HTML (assuming it refers to another class in the same package):

```

Use the <a href="Component.html#getComponentAt(int,int)">getComponentAt</a> method.

```

The previous line appears on the web page as: Use the getComponentAt method. Introduced in JDK 1.2.

# {@linkplain}

Behaves the same as the {@link} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text. For example,

```

Refer to {@linkplain #add() the overridden method}.

```

is displayed as: Refer to the overridden method . Introduced in JDK 1.4.

# {@literal}

Displays text without interpreting the text as HTML markup or nested Javadoc tags. This enables you to use angle brackets ( < and > ) instead of the HTML entities ( &lt; and &gt; ) in documentation comments, such as in parameter types ( <Object> ), inequalities ( 3 < 4 ), or arrows ( -> ). For example, the documentation comment text {@literal A<B>C} displays unchanged in the generated HTML page in your browser, as A<B>C . The <B> is not interpreted as bold (and it is not in code font). If you want the same functionality with the text in code font, then use the {@code} tag. Introduced in JDK 1.5.

# @param

Adds a parameter with the specified parameter name followed by the specified description to the "Parameters" section. The description may continue onto multiple lines. This tag is valid only in a documentation comment for a method, constructor, or class. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets ( < > ) around such a parameter name to indicate the use of a type parameter. Example of a type parameter of a class:

```

/**
 * @param <E> Type of element stored in a list
 */
public interface List<E> extends Collection<E> { ... }

```

Example of parameters, including type parameters, of a method:

```

/**
 * @param string  the string to be converted
 * @param type    the type to convert the string to
 * @param <T>     the type of the element
 * @param <V>     the value of the element
 */
<T, V extends T> V convert(String string, Class<T> type) { ... }

```

Introduced in JDK 1.0.

# @provides

This tag may only appear in the documentation comment for a module declaration, and serves to document an implementation of a service provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider. Introduced in JDK 9.

# @return

As a block tag, adds a "Returns" section with the given description, providing details about the values that may be returned by the method. As an inline tag, provides content for the first sentence of a method's main description, and a "Returns" section, as if @return description were also present. In the default English locale, the first sentence is Returns description . This tag is valid only in a documentation comment for a method. As an inline tag, it may only occur at the beginning of a method's main description. Introduced as a block tag in JDK 1.0, and as an inline tag in JDK 16.

# @see

Adds a "See Also" heading with a link or text entry that points to a reference. A documentation comment can contain any number of @see tags, which are all grouped under the same heading. The @see tag has three variations. The form to reference other program elements is the most common. This tag is valid in all documentation comments. For inserting an inline link within a sentence to a package, class, or member, see {@link} . Adds a text entry for string . No link is generated. The string may be a reference to information which is not available by URL. The standard doclet distinguishes this from the other cases by searching for a double quotation mark ( " ) as the first character. Adds a link as defined by the url . The URL may be a relative or absolute URL. The standard doclet distinguishes this from other cases by searching for a less-than symbol ( < ) as the first character. Adds a link with a visible text label that points to the documentation for the specified program element that is referenced. reference can refer to any valid program element. If this element is in the documented classes, then the standard doclet creates a link to it. To create links to external referenced classes, use the -link option. External referenced classes are classes that are not passed into the javadoc tool on the command line. Links in the generated documentation to external referenced classes are called external references or external links. For example, if you run the standard doclet on only the java.awt package, then any class in java.lang , such as Object , is an external referenced class. Use the -link and -linkoffline options to link to external referenced classes. The source comments of external referenced classes are not available to the javadoc command run. Use either of the other two @see tag forms to refer to the documentation of a name that does not belong to a referenced class. label is optional text to be used as the link label. The label can contain whitespace characters. If no label is provided, a default is generated, based on the target of the reference. Use the label when you want the text to be different from the auto-generated text. Introduced in JDK 1.0.

# @serial

Used in the documentation comment for a default serializable field. See Documenting Serializable Fields and Data for a Class . See also Oracle's Criteria for Including Classes in the Serialized Form Specification . An optional field description should explain the meaning of the field and list the acceptable values. When needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. If a serializable field was added to a class after the class was made serializable, then a statement should be added to its main description to identify at which version it was added. The include and exclude arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: A public or protected class that implements Serializable is included unless that class (or its package) is marked with the @serial exclude tag. A private or package-private class that implements Serializable is excluded unless that class (or its package) is marked with the @serial include tag. For example, the javax.swing package is marked with the @serial exclude tag in package-info.java . The public class java.security.BasicPermission is marked with the @serial exclude tag. The package-private class java.util.PropertyPermissionCollection is marked with the @serial include tag. The @serial tag at the class level overrides the @serial tag at the package level. Introduced in JDK 1.2.

# @serialData

Uses the data description value to document the types and order of data in the serialized form. This data includes the optional data written by the writeObject method and all data (including base classes) written by the Externalizable.writeExternal method. The @serialData tag can be used in the documentation comment for the readObject , writeObject , readExternal , writeExternal , readResolve , and writeReplace methods. Introduced in JDK 1.2.

# @serialField

Documents an ObjectStreamField component of the serialPersistentFields member of a Serializable class . Use one @serialField tag for each ObjectStreamField component. Introduced in JDK 1.2.

# @since

Adds a "Since" heading with the specified since-text value to the generated documentation. The text has no special internal structure. This tag is valid in any documentation comment: overview, module, package, class, interface, constructor, method, or field. This tag means that this change or feature has existed since the software release specified by the since-text value, for example: @since 1.5 . For Java platform source code, the @since tag indicates the version of the Java platform API specification, which is not necessarily when the source code was added to the reference implementation. Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags when the program element is used by more than one API. Introduced in JDK 1.1.

# @snippet

Includes a fragment, or "snippet", of example code in the generated documentation. The code may be provided inline within the tag by specifying a body and /or in an external file, specified in the attributes . Within the content, markup tags can be placed in line comments to identify regions within the text and instruct how to present the text in these regions. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be an identifier, unsigned integer, or enclosed in either single or double quote characters; no escape characters are supported. An attribute value and the preceding = may be omitted when the presence of the attribute name is sufficient. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is generated to represent the snippet. Code fragments are typically Java source code, but they may also be fragments of properties files, source code in other languages, or plain text. A snippet may specify a lang attribute, which identifies the kind of content in the snippet. For an inline snippet, the default value is java . For an external snippet, the default value is derived from the extension of the name of the file containing the snippet's content.

# Inline snippets

An inline snippet contains the content of the snippet within the tag itself. The content of the snippet, which is included in the generated documentation, is the text between the first newline after the colon ( : ) and the closing curly brace ( } ). There is no need to escape characters such as < , > , and & with HTML entities, nor is there any need to escape documentation comment tags. Surrounding whitespace is stripped from the content using String::stripIndent . There are two limitations on the content of inline snippets: The character sequence */ cannot be used anywhere within the content, because the */ would terminate the enclosing documentation comment. This includes use of /* ... */ comments, or within a // comment, or within string literals, such as those used to represent regular expressions. This restriction applies to all content in documentation comments; it is not specific to the @snippet tag. The content of an inline snippet can only contain balanced pairs of curly-brace characters. The overall inline tag is terminated by the first right brace that matches the opening brace. This restriction applies to all inline tags; it is not specific to the @snippet tag.

# External snippets

An external snippet refers to a separate class or file that contains the content of the snippet. In an external snippet the colon, newline, and subsequent content can be omitted. Unlike inline snippets, external snippets have no limitations on their content. In particular, they may contain /* ... */ comments. The location of the external code can be specified either by class name, using the class attribute, or by a short relative file path, using the file attribute. In either case the file can be placed in a package hierarchy rooted in a snippet-files subdirectory of the directory containing the source code with the {@snippet ...} tag. Alternatively, the file can be placed on an auxiliary search path, specified by the --snippet-path option to the javadoc tool. The use of snippet-files subdirectories is similar to the use of doc-files subdirectories for auxiliary documentation files. The file for an external snippet may contain multiple regions, to be referenced in different snippet tags, appearing in different parts of the documentation.

# Hybrid snippets

A hybrid snippet is both an internal snippet and an external snippet. It contains the content of the snippet within the tag itself, for the convenience of anyone reading the source code for the class being documented, and it also refers to a separate file that contains the content of the snippet. It is an error if the result of processing a hybrid snippet as an inline snippet does not match the result of processing it as an external snippet.

# Markup tags

Markup tags define regions within the content of a snippet. They also control the presentation of the content, for example highlighting parts of the text, modifying the text, or linking to elsewhere in the documentation. They can be used in internal, external, and hybrid snippets. Markup tags begin with @ name , followed by any required arguments. They are placed in // comments (or the equivalent in other languages or formats), so as not to unduly interfere with the body of the source code, and also because /* ... */ comments cannot be used in inline snippets. Such comments are referred to as markup comments . Multiple markup tags can be placed in the same markup comment. The markup tags apply to the source line containing the comment unless the comment is terminated with a colon ( : ), in which case it is as if the tags were present on the immediately following line. The latter syntax may be useful if the markup comment is particularly long, or if the syntactic format of the content of a snippet does not permit comments to appear on the same line as non-comment source. Markup comments do not appear in the generated output. Because some other systems use meta-comments similar to markup comments, comments that begin with @ followed by an unrecognized name are ignored as markup comments and will appear in the generated output. If the name is recognized, but there are subsequent errors in the markup comment, then an error is reported. The generated output in such cases is undefined, with respect to the output generated from the snippet.

# Regions

A region is an optionally-named range of lines that identifies the text to be displayed by a snippet. They also define the scope of actions such as highlighting or modifying the text. The beginning of a region is marked by either The end of a region is marked by @end or @end region= name . If a name is given then the tag ends the region started with that name. If no name is given then the tag ends the most recently started region that does not already have a matching @end tag. There are no constraints on the regions created by different pairs of matching @start and @end tags. Regions can even overlap, although we do not expect such usage to be common.

# Highlighting

To highlight content on a line or in a range of lines, use @highlight followed by arguments that specify the scope of the text to be considered, the text within that scope to be highlighted, and the type of the highlighting. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To highlight each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To highlight each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is highlighted. The type of highlighting can be specified with the type parameter. Valid type names are bold , italic , and highlighted . The name of the type is converted to a CSS class name whose properties can be defined in the system stylesheet or overridden in a user-defined stylesheet.

# Modifying the displayed text

It is often convenient to write the content of a snippet as code that can be accessed and validated by external tools, but to display it in a form that does not compile. For example, it may be desirable to include import statements for illustrative purposes along with code that uses the imported types. Or, it may be desirable to display code with an ellipsis or some other marker to indicate that additional code should be inserted at that point. This can be done by replacing parts of the content of the snippet with some replacement text. To replace some text with replacement text, use @replace followed by arguments that specify the scope of the text to be considered, the text within that scope to be replaced, and the replacement text. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To replace each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To replace each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is replaced. Specify the replacement text with the replacement parameter. If a regular expression is used to specify the text to be replaced then $ number or $ name can be used to substitute groups found in the regular expression, as defined by String::replaceAll . To delete text, use @replace with an empty replacement string. To insert text, use @replace to replace some no-op text placed where the replacement text should be inserted. The no-op text might be a '//' marker, or an empty statement ( ; ).

# Linking text

To link text to declarations elsewhere in the API, use @link followed by arguments that specify the scope of the text to be considered, the text within that scope to be linked, and the target of the link. If region or region= name is specified then the scope is that region, up to the corresponding @end tag. Otherwise, the scope is just the current line. To link each instance of a literal string within the scope, specify the string with substring= string where string can be an identifier or text enclosed in single or double quotes. To link each instance of text matched by a regular expression within the scope, use regex= string . If neither of these attributes are specified then the entire scope is linked. Specify the target with the target parameter. The form of its value is the same as used by the standard inline {@link ...} tag. Introduced in JDK 18.

# @spec

Identifies an external specification in terms of its URL and title. The URL may be absolute or relative. Relative URLs will be evaluated against a "base URL". All tags specifying the same URL must provide the same corresponding title; conversely, tags with different URLs must have different titles. Introduced in JDK 20.

# {@summary}

Identify the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a main description. In all cases, the tag is rendered by simply rendering its content. Introduced in JDK 10.

# {@systemProperty}

Identify property-name as the name of a system property. The name should be a "dotted identifier". In particular, it must not contain whitespace characters, or characters such as } . No other content is permitted in the tag; the possibility of additional content is reserved for future use. The tag can be used in all documentation comments. Introduced in JDK 12.

# @throws

Adds an exception with the specified name followed by the specified description to the "Throws" section. exception-name should refer to an exception that might be thrown by the method, and should either be the name of an exception class or a type variable. This tag is valid only in the documentation comment for a method or constructor. A documentation comment may use multiple @throws tags for the same or different exceptions. To ensure that all checked exceptions are documented, when an @throws tag does not exist for an exception in the throws clause, the standard doclet adds that exception to the generated output (with no description) as if it were documented with the @throws tag. The @throws documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use the {@inheritDoc} tag to force the @throws tag to inherit documentation. The @exception tag is equivalent to this tag, although the @throws form is now recommended. Introduced in JDK 1.2.

# @uses

This tag may only appear in the documentation comment for a module declaration, and serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available. Introduced in JDK 9.

# {@value}

Displays the value of a static field with a compile-time constant value. The format string may be omitted, in which case a default format will be used, appropriate to the type of the field. If the format string is given, it must either begin with a percent character (%) or be enclosed in double-quote characters ("). It must contain exactly one percent character. The string must conform to the definition of a format string, as specified in the documentation for java.util.Formatter . The conversion specified in the format string must be appropriate for the type of the constant value. When the {@value} tag is used without a field_reference argument in the documentation comment of a static field, it displays the value of that constant:

```

/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"

```

When used with a field-reference argument in any documentation comment, the {@value} tag displays the value of the specified constant:

```

/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public String evalScript(String script) {}

```

Introduced in JDK 1.4; format added in JDK 20.

# @version

Adds a "Version" subheading with the specified version-text value to the generated documents when the -version option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the @since tag, which holds the release number where this code was introduced. The version-text value has no special internal structure. A documentation comment can contain multiple @version tags. When it makes sense, you can specify one release number per @version tag or multiple release numbers per tag. In the former case, the standard doclet inserts a comma ( , ) and a space between the names. In the latter case, the entire text is copied to the generated document without being parsed. Therefore, you can use multiple names per line when you want a localized separator other than a comma. Introduced in JDK 1.0.

# Where Tags Can Be Used


---


# JDK 20 Documentation - Related Resources

URL: https://docs.oracle.com/en/java/javase/20/related-resources.html


# JDK 20 Documentation

# Related Resources

# Java SE on Oracle.com

# Java Components

# Java SE Subscriptions

# Java Training

# Java Developers

# Java Blog

# Inside Java


---


# Java Platform, Standard Edition & Java Development Kit Specifications Version 20

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/index.html


# JavaPlatform, Standard Edition & Java Development Kit SpecificationsVersion 20


---


# Getting Started

URL: https://docs.oracle.com/en/java/javase/20/migrate/getting-started.html



---


# General Java Troubleshooting

URL: https://docs.oracle.com/en/java/javase/20/troubleshoot/general-java-troubleshooting.html



---


# Java Security Standard Algorithm Names

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/security/standard-names.html


The Java SE Security API requires and uses a set of standard names for algorithms, certificate and keystore types. You can find a list of standard algorithm names in this document. Note that an SE implementation may support additional algorithms that are not defined in this specification. As a best practice, if an algorithm is defined in a subsequent version of this specification and an implementation of an earlier specification supports that algorithm, the implementation should use the standard name of the algorithm that is defined in the subsequent specification. Each SE implementation should also document the algorithms that it supports or adds support for in subsequent update releases. The algorithms may be documented in release notes or in a separate document such as the JDK Providers Documentation . In some cases naming conventions are given for forming names that are not explicitly listed, to facilitate name consistency across provider implementations. Items in angle brackets (such as <digest> and <encryption> ) are placeholders to be replaced by a specific message digest, encryption algorithm, or other name. Note: Standard names are not case-sensitive. Note: The JDK Providers Documentation contains specific provider and algorithm information.

# AlgorithmParameterGeneratorAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameterGenerator .

# AlgorithmParametersAlgorithms

The algorithm names in this section can be specified when generating an instance of AlgorithmParameters .

# CertificateFactoryTypes

The type in this section can be specified when generating an instance of CertificateFactory .

# CertPathEncodings

The following encodings may be passed to the getEncoded method of CertPath or the generateCertPath(InputStream inStream, String encoding) method of CertificateFactory .

# CertPathBuilderAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathBuilder .

# CertPathValidatorAlgorithms

The algorithm in this section can be specified when generating an instance of CertPathValidator .

# CertStoreTypes

The types in this section can be specified when generating an instance of CertStore .

# CipherAlgorithms

The following names can be specified as the algorithm component in a transformation when requesting an instance of Cipher . Note: It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default for the mode and padding which may not meet the security requirements of your application.

# CipherAlgorithm Modes

The following names can be specified as the mode component in a transformation when requesting an instance of Cipher .

# CipherAlgorithm Paddings

The following names can be specified as the padding component in a transformation when requesting an instance of Cipher .

# ConfigurationTypes

The type in this section can be specified when generating an instance of javax.security.auth.login.Configuration .

# Exemption Mechanisms

The following exemption mechanism names can be specified in the permission policy file that accompanies an application considered "exempt" from cryptographic restrictions.

# GSSAPI Mechanisms

The following mechanisms can be specified when using GSSAPI. Note that Object Identifiers (OIDs) are specified instead of names to be consistent with the GSSAPI standard.

# KeyEncodings

The names of primary encoding formats returned by Key.getFormat() or EncodedKeySpec.getFormat() .

# KeyAgreementAlgorithms

The following algorithm names can be specified when requesting an instance of KeyAgreement .

# KeyFactoryAlgorithms

The algorithm names in this section can be specified when generating an instance of KeyFactory . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyGeneratorAlgorithms

The following algorithm names can be specified when requesting an instance of KeyGenerator . (These classes generate keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyManagerFactoryAlgorithms

The algorithm names that can be specified when generating an instance of KeyManagerFactory .

# KeyPairGeneratorAlgorithms

The algorithm names that can be specified when generating an instance of KeyPairGenerator . (Except as noted, these classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# KeyStoreTypes

The types in this section can be specified when generating an instance of KeyStore .

# MacAlgorithms

The following algorithm names can be specified when requesting an instance of Mac .

# MessageDigestAlgorithms

Algorithm names that can be specified when generating an instance of MessageDigest .

# ParameterSpecNames

The NamedParameterSpec class in the java.security.spec package may be used to specify a set of parameters using the following names. The ECGenParameterSpec class in the java.security.spec package may be used to specify a set of elliptic curve parameters using the following names.

# PolicyTypes

The type in this section can be specified when generating an instance of Policy .

# SaslClientMechanisms

The mechanisms in this section can be specified when generating an instance of SaslClient .

# SaslServerMechanisms

The mechanisms in this section can be specified when generating an instance of SaslServer .

# SecretKeyFactoryAlgorithms

The following algorithm names can be specified when requesting an instance of SecretKeyFactory . (These classes create keys for which Key.getAlgorithm() returns the standard algorithm name.)

# SecureRandomNumber Generation Algorithms

The algorithm names in this section can be specified when generating an instance of SecureRandom .

# Service Attributes

The attributes in this section are for cryptographic services. The service attributes can be used as filters for selecting providers. A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (for example, DSA), and a CertificateFactory service is always associated with a particular certificate type (for example, X.509). Note: The attribute name and value are case-insensitive. For example,

```

map.put("KeyPairGenerator.DSA",
            "sun.security.provider.DSAKeyPairGenerator");
    map.put("KeyPairGenerator.DSA KeySize", "2048");
    map.put("KeyPairGenerator.DSA ImplementedIn", "Software");

```

# SignatureAlgorithms

The algorithm names in this section can be specified when generating an instance of Signature .

# SSLContextAlgorithms

The algorithm names in this section can be specified when generating an instance of SSLContext .

# TrustManagerFactoryAlgorithms

The algorithm name in this section can be specified when generating an instance of TrustManagerFactory .

# XML Signature (XMLSignatureFactory/KeyInfoFactory/TransformService) Mechanisms

The mechanism that can be specified when generating an instance of XMLSignatureFactory , KeyInfoFactory , or TransformService . The mechanism identifies the XML processing mechanism that an implementation uses internally to parse and generate XML signature and KeyInfo structures. Also, note that each TransformService instance supports a specific transform algorithm in addition to a mechanism. The standard names for the transform algorithms are defined in the next section.

# XML Signature Transform (TransformService) Algorithms

The algorithms in this section can be specified when generating an instance of TransformService . Note: The URIs are specified instead of names to be consistent with the XML Signature standard. API constants have been defined for each URI, and are listed in parentheses after each URI in the following table.

# JSSE Cipher Suite Names

The following table contains the standard JSSE cipher suite names. Over time, various groups have added additional cipher suites to the SSL/TLS/DTLS namespace . Some JSSE cipher suite names were defined before TLSv1.0 was finalized, and were therefore given the SSL_ prefix. The names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent to the JSSE cipher suites prefixed with SSL_ .

# Additional JSSE Standard Names

# Key Types

The keyType parameter passed to the chooseClientAlias , chooseServerAlias , getClientAliases , and getServerAliases methods of X509KeyManager specifies the public key types. Each row of the table that follows lists the standard name that should be used for keyType , given the specified certificate type.

# Protocols

The protocols parameter passed to the setEnabledProtocols method of SSLSocket and SSLEngine specifies the protocol versions to be enabled for use on the connection. The table that follows lists the standard names that can be passed to the setEnabledProtocols method or that may be returned by the getSupportedProtocols and getEnabledProtocols methods of SSLSocket and SSLEngine . These names also apply to the protocol parameter returned from the getProtocol method of SSLSession , and the protocols parameter passed to the setProtocols method or that may be returned by the getProtocols method of SSLParameters .

# Authentication Types

The authType parameter passed to the checkClientTrusted and checkServerTrusted methods of X509TrustManager indicates the authentication type. The table that follows specifies what standard names should be used for the client or server certificate chains.

# Endpoint Identification Algorithms

The endpoint identification algorithm indicates the endpoint identification or verification procedures during SSL/TLS/DTLS handshaking. The algorithm name can be passed to the setEndpointIdentificationAlgorithm method of javax.net.ssl.SSLParameters . The following table shows the standard endpoint identification names.

# Signature Schemes

The following table contains the standard signature scheme names, which are the algorithms used in the digital signatures of TLS connections and are also defined in the SignatureScheme section of the IANA TLS Registry.

# Named Groups

The following table contains the standard group names, which are the named groups used in key exchange algorithms of TLS connections and are also defined in the Supported Groups section of the IANA TLS Registry.

# Security Algorithm Specification

This section specifies details concerning some of the algorithms defined in this document. Any provider supplying an implementation of the listed algorithms must comply with the specifications in this section.

# Specification Template

The following table shows the fields of the algorithm specifications.

# Algorithm Specifications

The following are the parameter values for keysizes of 512, 768, and 1024 bits: 512-bit Key Parameters

```

SEED =
     b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
 counter = 123
 p =
     fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
     ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
     bdc43ee7 37592e17
 q =
     962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
 g =
     678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
     14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
     6c416e50 be794ca4

```

768-bit key parameters

```

SEED =
     77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
 counter = 263
 p =
     e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
     d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
     22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
     ee3688c1 1a8c56ab 127a3daf
 q =
     9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
 g =
     30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
     a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
     1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
     7064f316 933a346d 3f529252

```

1024-bit key parameters

```

SEED =
     8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
 counter = 92
 p =
     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
     b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
     801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
     1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
     f3ae2b61 d72aeff2 2203199d d14801c7
 q =
     9760508f 15230bcc b292b982 a2eb840b f0581cf5
 g =
     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
     3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
     b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
     0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
     928b665e 807b5525 64014c3b fecf492a

```

The following are the default values for larger DSA key sizes identified by (L,N) pairs: (L,N) = (2048, 256)

```

SEED =
     b0b44176 01b59cbc 9d8ac8f9 35cadaec 4f5fbb2f 23785609 ae466748
     d9b5a536
 counter = 497
 p =
     95475cf5 d93e596c 3fcd1d90 2add02f4 27f5f3c7 210313bb 45fb4d5b
     b2e5fe1c bd678cd4 bbdd84c9 836be1f3 1c077772 5aeb6c2f c38b85f4
     8076fa76 bcd8146c c89a6fb2 f706dd71 9898c208 3dc8d896 f84062e2
     c9c94d13 7b054a8d 8096adb8 d5195239 8eeca852 a0af12df 83e475aa
     65d4ec0c 38a9560d 5661186f f98b9fc9 eb60eee8 b030376b 236bc73b
     e3acdbd7 4fd61c1d 2475fa30 77b8f080 467881ff 7e1ca56f ee066d79
     506ade51 edbb5443 a563927d bc4ba520 08674617 5c888592 5ebc64c6
     14790677 3496990c b714ec66 7304e261 faee33b3 cbdf008e 0c3fa906
     50d97d39 09c9275b f4ac86ff cb3d03e6 dfc8ada5 934242dd 6d3bcca2
     a406cb0b
 q =
     f8183668 ba5fc5bb 06b5981e 6d8b795d 30b8978d 43ca0ec5 72e37e09
     939a9773
 g =
     42debb9d a5b3d88c c956e087 87ec3f3a 09bba5f4 8b889a74 aaf53174
     aa0fbe7e 3c5b8fcd 7a53bef5 63b0e985 60328960 a9517f40 14d3325f
     c7962bf1 e049370d 76d1314a 76137e79 2f3f0db8 59d095e4 a5b93202
     4f079ecf 2ef09c79 7452b077 0e135078 2ed57ddf 794979dc ef23cb96
     f1830619 65c4ebc9 3c9c71c5 6b925955 a75f94cc cf1449ac 43d586d0
     beee4325 1b0b2287 349d68de 0d144403 f13e802f 4146d882 e057af19
     b6f6275c 6676c8fa 0e3ca271 3a3257fd 1b27d063 9f695e34 7d8d1cf9
     ac819a26 ca9b04cb 0eb9b7b0 35988d15 bbac6521 2a55239c fc7e58fa
     e38d7250 ab9991ff bc971340 25fe8ce0 4c4399ad 96569be9 1a546f49
     78693c7a

```

(L,N) = (2048, 224)

```

SEED =
     58423608 0cfa43c0 9b023541 35f4cc51 98a19efa da08bd86 6d601ba4
 counter = 2666
 p =
     8f7935d9 b9aae9bf abed887a cf4951b6 f32ec59e 3baf3718 e8eac496
     1f3efd36 06e74351 a9c41833 39b809e7 c2ae1c53 9ba7475b 85d011ad
     b8b47987 75498469 5cac0e8f 14b33608 28a22ffa 27110a3d 62a99345
     3409a0fe 696c4658 f84bdd20 819c3709 a01057b1 95adcd00 233dba54
     84b6291f 9d648ef8 83448677 979cec04 b434a6ac 2e75e998 5de23db0
     292fc111 8c9ffa9d 8181e733 8db792b7 30d7b9e3 49592f68 09987215
     3915ea3d 6b8b4653 c633458f 803b32a4 c2e0f272 90256e4e 3f8a3b08
     38a1c450 e4e18c1a 29a37ddf 5ea143de 4b66ff04 903ed5cf 1623e158
     d487c608 e97f211c d81dca23 cb6e3807 65f822e3 42be484c 05763939
     601cd667
 q =
     baf696a6 8578f7df dee7fa67 c977c785 ef32b233 bae580c0 bcd5695d
 g =
     16a65c58 20485070 4e7502a3 9757040d 34da3a34 78c154d4 e4a5c02d
     242ee04f 96e61e4b d0904abd ac8f37ee b1e09f31 82d23c90 43cb642f
     88004160 edf9ca09 b32076a7 9c32a627 f2473e91 879ba2c4 e744bd20
     81544cb5 5b802c36 8d1fa83e d489e94e 0fa0688e 32428a5c 78c478c6
     8d0527b7 1c9a3abb 0b0be12c 44689639 e7d3ce74 db101a65 aa2b87f6
     4c6826db 3ec72f4b 5599834b b4edb02f 7c90e9a4 96d3a55d 535bebfc
     45d4f619 f63f3ded bb873925 c2f224e0 7731296d a887ec1e 4748f87e
     fb5fdeb7 5484316b 2232dee5 53ddaf02 112b0d1f 02da3097 3224fe27
     aeda8b9d 4b2922d9 ba8be39e d9e103a6 3c52810b c688b7e2 ed4316e1
     ef17dbde

```

# Security Algorithm Implementation Requirements

This section defines the security algorithm requirements for Java SE implementations. The security algorithm requirements are intended to improve the interoperability of Java SE implementations and applications that use these algorithms. Note: The requirements in this section are not a measure of the strength or security of the algorithm. For example, recent advances in cryptanalysis have found weaknesses in the strength of the DESede (Triple DES) cipher algorithm. It is your responsibility to determine whether the algorithm meets the security requirements of your application. Every implementation of this version of the Java SE platform must support the specified algorithms in the table that follows. These requirements do not apply to 3rd party providers. Consult the release documentation for your implementation to see if any other algorithms are supported. [1] No specific Configuration type, Policy type or SecureRandom algorithm is required; however, an implementation-specific default must be provided.

# XML Signature Algorithms


---


# Internationalization Overview

URL: https://docs.oracle.com/en/java/javase/20/intl/internationalization-overview.html



---


# Why Use the API?

URL: https://docs.oracle.com/en/java/javase/20/jfapi/why-use-jfr-api.html



---


# JAR File Specification

URL: https://docs.oracle.com/en/java/javase/20/docs/specs/jar/jar.html


# Introduction

JAR file is a file format based on the popular ZIP file format and is used for aggregating many files into one. A JAR file is essentially a zip file that contains an optional META-INF directory. A JAR file can be created by the command-line jar tool, or by using the java.util.jar API in the Java platform. There is no restriction on the name of a JAR file, it can be any legal file name on a particular platform.

# Modular JAR files

A modular JAR file is a JAR file that has a module descriptor, module-info.class , in the top-level directory (or root) directory. The module descriptor is the binary form of a module declaration. (Note the section on multi-release JAR files further refines the definition of modular JAR files.) A modular JAR file deployed on the module path, as opposed to the class path, is an explicit module. Dependences and service providers are declared in the module descriptor. If the modular JAR file is deployed on the class path then it behaves as if a non-modular JAR file. A non-modular JAR file deployed on the module path is an automatic module . If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes ) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...) .

# Multi-release JAR files

A multi-release JAR file allows for a single JAR file to support multiple major versions of Java platform releases. For example, a multi-release JAR file can depend on both the Java 8 and Java 9 major platform releases, where some class files depend on APIs in Java 8 and other class files depend on APIs in Java 9. This enables library and framework developers to decouple the use of APIs in a specific major version of a Java platform release from the requirement that all their users migrate to that major version. Library and framework developers can gradually migrate to and support new Java features while still supporting the old features. A multi-release JAR file is identified by the main attribute:

```

Multi-Release: true

```

declared in the main section of the JAR Manifest . Classes and resource files dependent on a major version, 9 or greater, of a Java platform release may be located under a versioned directory instead of under the top-level (or root) directory. The versioned directory is located under the the META-INF directory and is of the form:

```

META-INF/versions/N

```

where N is the string representation of the major version number of a Java platform release. Specifically N must conform to the specification: Any versioned directory whose value of N is less than 9 is ignored as is a string representation of N that does not conform to the above specification. A class file under a versioned directory, of version N say, in a multi-release JAR must have a class file version less than or equal to the class file version associated with N th major version of a Java platform release. If the class of the class file is public or protected then that class must preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. By logical extension this applies to a class of a class file, if present, under a versioned directory whose version is less than N . If a multi-release JAR file is deployed on the class path or module path (as an automatic module or an explicit multi-release module ) of major version N of a Java platform release runtime, then a class loader loading classes from that JAR file will first search for class files under the N th versioned directory, then prior versioned directories in descending order (if present), down to a lower major version bound of 9 , and finally under the top-level directory. The public API exported by the classes in a multi-release JAR file must be exactly the same across versions, hence at a minimum why versioned public or protected classes for class files under a versioned directory must preside over classes for class files under the top-level directory. It is difficult and costly to perform extensive API verification checks as such tooling, such as the jar tool, is not required to perform extensive verification and a Java runtime is not required to perform any verification. A future release of this specification may relax the exact same API constraint to support careful evolution. Resources under the META-INF directory cannot be versioned (such as for service configuration). A multi-release JAR file can be signed. Multi-release JAR files are not supported by the boot class loader of a Java runtime. If a multi-release JAR file is appended to the boot class path (with the -Xbootclasspath/a option) then the JAR is treated as if it is an ordinary JAR file.

# Modular multi-release JAR files

A modular multi-release JAR file is a multi-release JAR file that has a module descriptor, module-info.class , in the top-level directory (as for a modular JAR file), or directly in a versioned directory. A public or protected class in a non-exported package (that is not declared as exported in the module descriptor) need not preside over a class of the same fully qualified name and access modifier whose class file is present under the top-level directory. A module descriptor is generally treated no differently to any other class or resource file. A module descriptor may be present under a versioned area but not present under the top-level directory. This ensures, for example, only Java 8 versioned classes can be present under the top-level directory while Java 9 versioned classes (including, or perhaps only, the module descriptor) can be present under the 9 versioned directory. Any versioned module descriptor that presides over a lesser versioned module descriptor or that at the top-level, M say, must be identical to M , with two exceptions: Tooling, such as the jar tool, should perform such verification of versioned module descriptors but a Java runtime is not required to perform any verification.

# The META-INF directory

The following files/directories in the META-INF directory are recognized and interpreted by the Java Platform to configure applications, class loaders and services: The manifest file that is used to define package related data. This file is generated by the new " -i" option of the jar tool, which contains location information for packages defined in an application. It is part of the JarIndex implementation and used by class loaders to speed up their class loading process. The signature file for the JAR file. 'x' stands for the base file name. The signature block file associated with the signature file with the same base file name. This file stores the digital signature of the corresponding signature file in a PKCS #7 structure. This directory stores all the service provider configuration files for JAR files deployed on the class path or JAR files deployed as automatic modules on the module path. See the specification of service provider development for more details. This directory contains underneath it versioned class and resource files for a multi-release JAR file.

# Name-Value pairs and Sections

Before we go to the details of the contents of the individual configuration files, some format convention needs to be defined. In most cases, information contained within the manifest file and signature files is represented as so-called "name: value" pairs inspired by the RFC822 standard. We also call these pairs headers or attributes. Groups of name-value pairs are known as a "section". Sections are separated from other sections by empty lines. Binary data of any form is represented as base64. Continuations are required for binary data which causes line length to exceed 72 bytes. Examples of binary data are digests and signatures. Implementations shall support header values of up to 65535 bytes. All the specifications in this document use the same grammar in which terminal symbols are shown in fixed width font and non-terminal symbols are shown in italic type face.

# Specification:

Non-terminal symbols defined in the above specification will be referenced in the following specifications.

# JAR Manifest

# Overview

A JAR file manifest consists of a main section followed by a list of sections for individual JAR file entries, each separated by a newline. Both the main section and individual sections follow the section syntax specified above. They each have their own specific restrictions and rules. The main section contains security and configuration information about the JAR file itself, as well as the application. It also defines main attributes that apply to every individual manifest entry. No attribute in this section can have its name equal to " Name ". This section is terminated by an empty line. The individual sections define various attributes for packages or files contained in this JAR file. Not all files in the JAR file need to be listed in the manifest as entries, but all files which are to be signed must be listed. The manifest file itself must not be listed. Each section must start with an attribute with the name as " Name ", and the value must be a relative path to the file, or an absolute URL referencing data outside the archive. If there are multiple individual sections for the same file entry, the attributes in these sections are merged. If a certain attribute have different values in different sections, the last one is recognized. Attributes which are not understood are ignored. Such attributes may include implementation specific information used by applications.

# Manifest Specification:

In the above specification, attributes that can appear in the main section are referred to as main attributes, whereas attributes that can appear in individual sections are referred to as per-entry attributes. Certain attributes can appear both in the main section and the individual sections, in which case the per-entry attribute value overrides the main attribute value for the specified entry. The two types of attributes are defined as follows.

# Main Attributes

Main attributes are the attributes that are present in the main section of the manifest. They fall into the following different groups:

# Per-Entry Attributes

Per-entry attributes apply only to the individual JAR file entry to which the manifest entry is associated with. If the same attribute also appeared in the main section, then the value of the per-entry attribute overwrites the main attribute's value. For example, if JAR file a.jar has the following manifest content:

```

Manifest-Version: 1.0
    Created-By: 1.8 (Oracle Inc.)
    Sealed: true
    Name: foo/bar/
    Sealed: false

```

It means that all the packages archived in a.jar are sealed, except that package foo.bar is not. The per-entry attributes fall into the following groups:

# Signed JAR File

# Overview

A JAR file can be signed by using the command line jarsigner tool or directly through the java.security API. Every file entry, including non-signature related files in the META-INF directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are: Note that if such files are located in META-INF subdirectories, they are not considered signature-related. Case-insensitive versions of these filenames are reserved and will also not be signed. Subsets of a JAR file can be signed by using the java.security API. A signed JAR file is exactly the same as the original JAR file, except that its manifest is updated and two additional files are added to the META-INF directory: a signature file and a signature block file. When jarsigner is not used, the signing program has to construct both the signature file and the signature block file. For every file entry signed in the signed JAR file, an individual manifest entry is created for it as long as it does not already exist in the manifest. Each manifest entry lists one or more digest attributes and an optional Magic attribute .

# Signature File

Each signer is represented by a signature file with extension .SF . The major part of the file is similar to the manifest file. It consists of a main section which includes information supplied by the signer but not specific to any particular jar file entry. In addition to the Signature-Version and Created-By attributes (see Main Attributes ), the main section can also include the following security attributes: The main section is followed by a list of individual entries whose names must also be present in the manifest file. Each individual entry must contain at least the digest of its corresponding entry in the manifest file. Paths or URLs appearing in the manifest file but not in the signature file are not used in the calculation.

# Signature Validation

A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: Verify the signature over the signature file when the manifest is first parsed. For efficiency, this verification can be remembered. Note that this verification only validates the signature directions themselves, not the actual archive files. If an x-Digest-Manifest attribute exists in the signature file, verify the value against a digest calculated over the entire manifest. If more than one x-Digest-Manifest attribute exists in the signature file, verify that at least one of them matches the calculated digest value. If an x-Digest-Manifest attribute does not exist in the signature file or none of the digest values calculated in the previous step match, then a less optimized verification is performed: If an x-Digest-Manifest-Main-Attributes entry exists in the signature file, verify the value against a digest calculated over the main attributes in the manifest file. If this calculation fails, then JAR file verification fails. This decision can be remembered for efficiency. If an x-Digest-Manifest-Main-Attributes entry does not exist in the signature file, its nonexistence does not affect JAR file verification and the manifest main attributes are not verified. Verify the digest value in each source file information section in the signature file against a digest value calculated against the corresponding entry in the manifest file. If any of the digest values don't match, then JAR file verification fails. One reason the digest value of the manifest file that is stored in the x-Digest-Manifest attribute may not equal the digest value of the current manifest file is that it might contain sections for newly added files after the file was signed. For example, suppose one or more files were added to the JAR file (using the jar tool) after the signature (and thus the signature file) was generated. If the JAR file is signed again by a different signer, then the manifest file is changed (sections are added to it for the new files by the jarsigner tool) and a new signature file is created, but the original signature file is unchanged. A verification on the original signature is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the digest values in the non-header sections of the signature file equal the digest values of the corresponding sections in the manifest file. For each entry in the manifest, verify the digest value in the manifest file against a digest calculated over the actual data referenced in the "Name:" attribute, which specifies either a relative file path or URL. If any of the digest values don't match, then JAR file verification fails. Example manifest file:

```

Manifest-Version: 1.0
    Created-By: 1.8.0 (Oracle Inc.)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA1-Digest: (base64 representation of SHA1 digest)
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

The corresponding signature file would be:

```

Signature-Version: 1.0
    SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
    SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

    Name: common/class1.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

    Name: common/class2.class
    SHA-256-Digest: (base64 representation of SHA-256 digest)

```

# The Magic Attribute

Another requirement to validate the signature on a given manifest entry is that the verifier understand the value or values of the Magic key-pair value in that entry's manifest entry. The Magic attribute is optional but it is required that a parser understand the value of an entry's Magic key if it is verifying that entry's signature. The value or values of the Magic attribute are a set of comma-separated context-specific strings. The spaces before and after the commas are ignored. Case is ignored. The exact meaning of the magic attributes is application specific. These values indicate how to compute the hash value contained in the manifest entry, and are therefore crucial to the proper verification of the signature. The keywords may be used for dynamic or embedded content, multiple hashes for multilingual documents, etc. Here are two examples of the potential use of Magic attribute in the manifest file:

```

Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual

```

In the first example, these Magic values may indicate that the result of an http query is the script embedded in the document, as opposed to the document itself, and also that the script is generated dynamically. These two pieces of information indicate how to compute the hash value against which to compare the manifest's digest value, thus comparing a valid signature. In the second example, the Magic value indicates that the document retrieved may have been content-negotiated for a specific language, and that the digest to verify against is dependent on which language the document retrieved is written in.

# Digital Signatures

A digital signature is a signed version of the .SF signature file. These are binary files not intended to be interpreted by humans. Digital signature files have the same filenames as the .SF files but different extensions. The extension varies depending on the algorithm of the signer's private key. Digital signature files for signature algorithms not listed above must reside in the META-INF directory and have the prefix " SIG- ". The corresponding signature file ( .SF file) must also have the same prefix. For those formats that do not support external signed data, the file shall consist of a signed copy of the .SF file. Thus some data may be duplicated and a verifier should compare the two files. Formats that support external data either reference the .SF file, or perform calculations on it with implicit reference. Each .SF file may have multiple digital signatures, but those signatures should be generated by the same legal entity. File name extensions may be 1 to 3 alphanum characters. Unrecognized extensions are ignored.

# Notes on Manifest and Signature Files

Following is a list of additional restrictions and rules that apply to manifest and signature files.

# JAR Index

# Overview

Since 1.3, JarIndex is introduced to optimize the class searching process of class loaders for network applications, especially applets. Originally, an applet class loader uses a simple linear search algorithm to search each element on its internal search path, which is constructed from the "ARCHIVE" tag or the "Class-Path" main attribute. The class loader downloads and opens each element in its search path, until the class or resource is found. If the class loader tries to find a nonexistent resource, then all the jar files within the application or applet will have to be downloaded. For large network applications and applets this could result in slow startup, sluggish response and wasted network bandwidth. The JarIndex mechanism collects the contents of all the jar files defined in an applet and stores the information in an index file in the first jar file on the applet's class path. After the first jar file is downloaded, the applet class loader will use the collected content information for efficient downloading of jar files. The existing jar tool is enhanced to be able to examine a list of jar files and generate directory information as to which classes and resources reside in which jar file. This directory information is stored in a simple text file named INDEX.LIST in the META-INF directory of the root jar file. When the classloader loads the root jar file, it reads the INDEX.LIST file and uses it to construct a hash table of mappings from file and package names to lists of jar file names. In order to find a class or a resource, the class loader queries the hashtable to find the proper jar file and then downloads it if necessary. Once the class loader finds a INDEX.LIST file in a particular jar file, it always trusts the information listed in it. If a mapping is found for a particular class, but the class loader fails to find it by following the link, an unspecified Error or RuntimeException is thrown. When this occurs, the application developer should rerun the jar tool on the extension to get the right information into the index file. To prevent adding too much space overhead to the application and to speed up the construction of the in-memory hash table, the INDEX.LIST file is kept as small as possible. For classes with non-null package names, mappings are recorded at the package level. Normally one package name is mapped to one jar file, but if a particular package spans more than one jar file, then the mapped value of this package will be a list of jar files. For resource files with non-empty directory prefixes, mappings are also recorded at the directory level. Only for classes with null package name, and resource files which reside in the root directory, will the mapping be recorded at the individual file level.

# Index File Specification

The INDEX.LIST file contains one or more sections each separated by a single blank line. Each section defines the content of a particular jar file, with a header defining the jar file path name, followed by a list of package or file names, one per line. All the jar file paths are relative to the code base of the root jar file. These path names are resolved in the same way as the current extension mechanism does for bundled extensions. The UTF-8 encoding is used to support non ASCII characters in file or package names in the index file.

# Specification

The INDEX.LIST file is generated by running jar -i. See the jar man page for more details.

# Backward Compatibility

The new class loading scheme is totally backward compatible with applications developed on top of the current extension mechanism. When the class loader loads the first jar file and an INDEX.LIST file is found in the META-INF directory, it would construct the index hash table and use the new loading scheme for the extension. Otherwise, the class loader will simply use the original linear search algorithm.

# Class-Path Attribute

The manifest for an application can specify one or more relative URLs referring to the JAR files and directories for other libraries that it needs. These relative URLs will be treated relative to the code base that the containing application was loaded from (the " context JAR "). An application (or, more generally, JAR file) specifies the relative URLs of the libraries that it needs via the manifest attribute Class-Path . This attribute lists the URLs to search for implementations of other libraries if they cannot be found on the host Java Virtual Machine. These relative URLs may include JAR files and directories for any libraries or resources needed by the application. Relative URLs not ending with '/' are assumed to refer to JAR files. For example,

```

Class-Path: servlet.jar infobus.jar acme/beans.jar images/

```

At most one Class-Path header may be specified in a JAR file's manifest. A Class-Path entry is valid if the following conditions are true: It can be used to create a URL , by resolving it against the context JARs URL. It is relative, not absolute , i.e. it does not contain a scheme component, except for the case when the context JAR is loaded from the file system, in which case the file scheme is permitted for compatibility reasons. The location of the JAR file or directory represented by this entry is contained within the containing directory of the context JAR. Use of " ../ " to navigate to the parent directory is not permitted, except for the case when the context JAR is loaded from the file system. Invalid entries are ignored. Valid entries are resolved against the context JAR. If the resulting URL is invalid or refers to a resource that cannot be found, then it is ignored. Duplicate URLs are ignored. The resulting URLs are inserted into the class path, immediately following the URL of the context JAR. For example, given the following class path:

```

a.jar b.jar

```

If b.jar contained the following Class-Path manifest attribute:

```

Class-Path: lib/x.jar a.jar

```

Then the effective search path of such a URLClassLoader instance would be:

```

a.jar b.jar lib/x.jar

```

Of course, if x.jar had dependencies of its own then these would be added according to the same rules and so on for each subsequent URL. In the actual implementation, JAR file dependencies are processed lazily so that the JAR files are not actually opened until needed.

# Package Sealing

JAR files and packages can be optionally sealed , so that an package can enforce consistency within a version. A package sealed within a JAR specifies that all classes defined in that package must originate from the same JAR. Otherwise, a SecurityException is thrown. A sealed JAR specifies that all packages defined by that JAR are sealed unless overridden specifically for a package. A sealed package is specified via the manifest attribute, Sealed , whose value is true or false (case irrelevant). For example,

```

Name: javax/servlet/internal/
    Sealed: true

```

specifies that the javax.servlet.internal package is sealed, and that all classes in that package must be loaded from the same JAR file. If this attribute is missing, the package sealing attribute is that of the containing JAR file. A sealed JAR is specified via the same manifest header, Sealed , with the value again of either true or false . For example,

```

Sealed: true

```

specifies that all packages in this archive are sealed unless explicitly overridden for a particular package with the Sealed attribute in a manifest entry. If this attribute is missing, the JAR file is assumed to not be sealed, for backwards compatibility. The system then defaults to examining package headers for sealing information. Package sealing is also important for security, because it restricts access to package-protected members to only those classes defined in the package that originated from the same JAR file. The unnamed package is not sealable, so classes that are to be sealed must be placed in their own packages.

# API Details

Package java.util.jar

# See Also


---


# Introduction to JMX Technology

URL: https://docs.oracle.com/en/java/javase/20/jmx/introduction-jmx-technology.html



---


# Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide, Release 19

URL: https://docs.oracle.com/en/java/javase/19/gctuning/index.html



---


# Description of the illustration jsgct_dt_005_gph_pc_vs_tp.png

URL: https://docs.oracle.com/en/java/javase/19/gctuning/img_text/jsgct_dt_005_gph_pc_vs_tp.html



---


# Ergonomics

URL: https://docs.oracle.com/en/java/javase/19/gctuning/ergonomics.html



---


# Preface

URL: https://docs.oracle.com/en/java/javase/19/gctuning/preface.html



---


# Serialization Filtering

URL: https://docs.oracle.com/en/java/javase/19/core/serialization-filtering1.html



---


# Java Networking

URL: https://docs.oracle.com/en/java/javase/19/core/java-networking.html



---


# Preface

URL: https://docs.oracle.com/en/java/javase/19/core/preface.html



---


# XML Catalog API

URL: https://docs.oracle.com/en/java/javase/19/core/xml-catalog-api1.html



---


# Enhanced Deprecation

URL: https://docs.oracle.com/en/java/javase/19/core/enhanced-deprecation1.html



---


# Java Logging Overview

URL: https://docs.oracle.com/en/java/javase/19/core/java-logging-overview.html



---


# Foreign Function and Memory API

URL: https://docs.oracle.com/en/java/javase/19/core/foreign-function-and-memory-api.html



---


# Virtual Threads

URL: https://docs.oracle.com/en/java/javase/19/core/virtual-threads.html



---


# Preferences API

URL: https://docs.oracle.com/en/java/javase/19/core/preferences-api1.html



---


# Java NIO

URL: https://docs.oracle.com/en/java/javase/19/core/java-nio.html



---


# Pseudorandom Number Generators

URL: https://docs.oracle.com/en/java/javase/19/core/pseudorandom-number-generators.html



---


# Process API

URL: https://docs.oracle.com/en/java/javase/19/core/process-api1.html



---


# Creating Unmodifiable Lists, Sets, and Maps

URL: https://docs.oracle.com/en/java/javase/19/core/creating-immutable-lists-sets-and-maps.html



---


# Java Platform, Standard Edition Core Libraries, Release 19

URL: https://docs.oracle.com/en/java/javase/19/core/index.html



---


# Java Native Interface Specification: 1 - Introduction

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jni/intro.html


# Chapter 1: Introduction

This chapter introduces the Java Native Interface (JNI). The JNI is a native programming interface. It allows Java code that runs inside a Java Virtual Machine (VM) to interoperate with applications and libraries written in other programming languages, such as C, C++, and assembly. The most important benefit of the JNI is that it imposes no restrictions on the implementation of the underlying Java VM. Therefore, Java VM vendors can add support for the JNI without affecting other parts of the VM. Programmers can write one version of a native application or library and expect it to work with all Java VMs supporting the JNI. This chapter covers the following topics:

# Java Native Interface Overview

While you can write applications entirely in Java, there are situations where Java alone does not meet the needs of your application. Programmers use the JNI to write Java native methods to handle those situations when an application cannot be written entirely in Java. The following examples illustrate when you need to use Java native methods: By programming through the JNI, you can use native methods to: You can also use the JNI with the Invocation API to enable an arbitrary native application to embed the Java VM. This allows programmers to easily make their existing applications Java-enabled without having to link with the VM source code.

# Historical Background

VMs from different vendors offer different native method interfaces. These different interfaces force programmers to produce, maintain, and distribute multiple versions of native method libraries on a given platform. We briefly examine some of the native method interfaces, such as:

# JDK 1.0 Native Method Interface

JDK 1.0 was shipped with a native method interface. Unfortunately, there were two major reasons that this interface was unsuitable for adoption by other Java VMs. First, the native code accessed fields in Java objects as members of C structures. However, the Java Language Specification does not define how objects are laid out in memory. If a Java VM lays out objects differently in memory, then the programmer would have to recompile the native method libraries. Second, JDK 1.0's native method interface relied on a conservative garbage collector. The unrestricted use of the unhand macro, for example, made it necessary to conservatively scan the native stack.

# Java Runtime Interface

Netscape had proposed the Java Runtime Interface (JRI), a general interface for services provided in the Java virtual machine. JRI was designed with portability in mind---it makes few assumptions about the implementation details in the underlying Java VM. The JRI addressed a wide range of issues, including native methods, debugging, reflection, embedding (invocation), and so on.

# Raw Native Interface and Java/COM Interface

The Microsoft Java VM supports two native method interfaces. At the low level, it provides an efficient Raw Native Interface (RNI). The RNI offers a high degree of source-level backward compatibility with the JDKs native method interface, although it has one major difference. Instead of relying on conservative garbage collection, the native code must use RNI functions to interact explicitly with the garbage collector. At a higher level, Microsoft's Java/COM interface offers a language-independent standard binary interface to the Java VM. Java code can use a COM object as if it were a Java object. A Java class can also be exposed to the rest of the system as a COM class.

# Objectives

We believe that a uniform, well-thought-out standard interface offers the following benefits for everyone: The best way to achieve a standard native method interface is to involve all parties with an interest in Java VMs. Therefore we organized a series of discussions among the Java licensees on the design of a uniform native method interface. It is clear from the discussions that the standard native method interface must satisfy the following requirements:

# Java Native Interface Approach

We hoped to adopt one of the existing approaches as the standard interface, because this would have imposed the least burden on programmers who had to learn multiple interfaces in different VMs. Unfortunately, no existing solutions are completely satisfactory in achieving our goals. Netscapes JRI is the closest to what we envision as a portable native method interface, and was used as the starting point of our design. Readers familiar with the JRI will notice the similarities in the API naming convention, the use of method and field IDs, the use of local and global references, and so on. Despite our best efforts, however, the JNI is not binary-compatible with the JRI, although a VM can support both the JRI and the JNI. Microsofts RNI was an improvement over JDK 1.0 because it solved the problem of native methods working with a nonconservative garbage collector. The RNI, however, was not suitable as a VM-independent native method interface. Like the JDK, RNI native methods access Java objects as C structures, leading to two problems: As a binary standard, COM ensures complete binary compatibility across different VMs. Invoking a COM method requires only an indirect call, which carries little overhead. In addition, COM objects are a great improvement over dynamic-link libraries in solving versioning problems. The use of COM as the standard Java native method interface, however, is hampered by a few factors: Although Java objects are not exposed to the native code as COM objects, the JNI interface itself is binary-compatible with COM. JNI uses the same jump table structure and calling convention that COM does. This means that, as soon as cross-platform support for COM is available, the JNI can become a COM interface to the Java VM. JNI is not believed to be the only native method interface supported by a given Java VM. A standard interface benefits programmers, who would like to load their native code libraries into different Java VMs. In some cases, the programmer may have to use a lower-level, VM-specific interface to achieve top efficiency. In other cases, the programmer might use a higher-level interface to build software components. Indeed, as the Java environment and component software technologies become more mature, native methods will gradually lose their significance.

# Programming to the JNI


---


# Java Native Interface Specification: 2 - Design Overview

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jni/design.html


# Chapter 2: Design Overview

This chapter focuses on major design issues in the JNI. Most design issues in this section are related to native methods. The design of the Invocation API is covered in Chapter 5: The Invocation API . This chapter covers the following topics:

# JNI Interface Functions and Pointers

Native code accesses Java VM features by calling JNI functions. JNI functions are available through an interface pointer . An interface pointer is a pointer to a pointer. This pointer points to an array of pointers, each of which points to an interface function. Every interface function is at a predefined offset inside the array. The following figure, Interface Pointer , illustrates the organization of an interface pointer. Description of Figure Interface Pointer The JNI interface is organized like a C++ virtual function table or a COM interface. The advantage to using an interface table, rather than hard-wired function entries, is that the JNI name space becomes separate from the native code. A VM can easily provide multiple versions of JNI function tables. For example, the VM may support two JNI function tables: The JNI interface pointer is only valid in the current thread. A native method, therefore, must not pass the interface pointer from one thread to another. A VM implementing the JNI may allocate and store thread-local data in the area pointed to by the JNI interface pointer. Native methods receive the JNI interface pointer as an argument. The VM is guaranteed to pass the same interface pointer to a native method when it makes multiple calls to the native method from the same Java thread. However, a native method can be called from different Java threads, and therefore may receive different JNI interface pointers.

# Compiling, Loading and Linking Native Methods

Since the Java VM is multithreaded, native libraries should also be compiled and linked with multithread aware native compilers. For example, the -mt flag should be used for C++ code compiled with the Sun Studio compiler. For code complied with the GNU gcc compiler, the flags -D_REENTRANT or -D_POSIX_C_SOURCE should be used. For more information please refer to the native compiler documentation. Native methods are loaded with the System.loadLibrary method. In the following example, the class initialization method loads a platform-specific native library in which the native method f is defined:

```

package p.q.r;

class A {
    native double f(int i, String s);
    static {
        System.loadLibrary("p_q_r_A");
    }
}

```

The argument to System.loadLibrary is a library name chosen arbitrarily by the programmer. The system follows a standard, but platform-specific, approach to convert the library name to a native library name. For example, a Linux system converts the name p_q_r_A to libp_q_r_A.so , while a Windows system converts the same p_q_r_A name to p_q_r_A.dll . The programmer may use a single library to store all the native methods needed by any number of classes, as long as these classes are to be loaded with the same class loader. The VM internally maintains a list of loaded native libraries for each class loader. Vendors should choose native library names that minimize the chance of name clashes. Support for both dynamically and statically linked libraries, and their respective lifecycle management "load" and "unload" function hooks are detailed in the Invocation API section on Library and Version Management .

# Resolving Native Method Names

The JNI defines a 1:1 mapping from the name of a native method declared in Java to the name of a native method residing in a native library. The VM uses this mapping to dynamically link a Java invocation of a native method to the corresponding implementation in the native library. The mapping produces a native method name by concatenating the following components derived from a native method declaration: Escaping leaves every alphanumeric ASCII character ( A-Za-z0-9 ) unchanged, and replaces each UTF-16 code unit in the table below with the corresponding escape sequence. If the name to be escaped contains a surrogate pair, then the high-surrogate code unit and the low-surrogate code unit are escaped separately. The result of escaping is a string consisting only of the ASCII characters A-Za-z0-9 and underscore. Escaping is necessary for two reasons. First, to ensure that class and method names in Java source code, which may include Unicode characters, translate into valid function names in C source code. Second, to ensure that the parameter descriptor of a native method, which uses ";" and "[" characters to encode parameter types, can be encoded in a C function name. When a Java program invokes a native method, the VM searches the native library by looking first for the short version of the native method name, that is, the name without the escaped argument signature. If a native method with the short name is not found, then the VM looks for the long version of the native method name, that is, the name including the escaped argument signature. Looking for the short name first makes it easier to declare implementations in the native library. For example, given this native method in Java:

```

package p.q.r;
class A {
    native double f(int i, String s);
}

```

The corresponding C function can be named Java_p_q_r_A_f , rather than Java_p_q_r_A_f__ILjava_lang_String_2 . Declaring implementations with long names in the native library is only necessary when two or more native methods in a class have the same name. For example, given these native methods in Java:

```

package p.q.r;
class A {
    native double f(int i, String s);
    native double f(int i, Object s);
}

```

The corresponding C functions must be named Java_p_q_r_A_f__ILjava_lang_String_2 and Java_p_q_r_A_f__ILjava_lang_Object_2 , because the native methods are overloaded. Long names in the native library are not necessary if a native method in Java is overloaded by non- native methods only. In the following example, the native method g does not have to be linked using the long name because the other method g is not native and thus does not reside in the native library.

```

package p.q.r;
class B {
    int g(int i);
    native int g(double d);
}

```

Note that escape sequences can safely begin _0 , _1 , etc, because class and method names in Java source code never begin with a number. However, that is not the case in class files that were not generated from Java source code. To preserve the 1:1 mapping to a native method name, the VM checks the resulting name as follows. If the process of escaping any precursor string from the native method declaration (class or method name, or argument type) causes a " 0 ", " 1 ", " 2 ", or " 3 " character from the precursor string to appear unchanged in the result either immediately after an underscore or at the beginning of the escaped string (where it will follow an underscore in the fully assembled name), then the escaping process is said to have "failed". In such cases, no native library search is performed, and the attempt to link the native method invocation will throw UnsatisfiedLinkError . It would be possible to extend the present simple mapping scheme to cover such cases, but the complexity costs would outweigh any benefit. Both the native methods and the interface APIs follow the standard library-calling convention on a given platform. For example, UNIX systems use the C calling convention, while Win32 systems use __stdcall. Native methods can also be explicitly linked using the RegisterNatives function . Be aware that RegisterNatives can change the documented behavior of the JVM (including cryptographic algorithms, correctness, security, type safety), by changing the native code to be executed for a given native Java method. Therefore use applications that have native libraries utilizing the RegisterNatives function with caution.

# Native Method Arguments

The JNI interface pointer is the first argument to native methods. The JNI interface pointer is of type JNIEnv . The second argument differs depending on whether the native method is static or nonstatic. The second argument to a nonstatic native method is a reference to the object. The second argument to a static native method is a reference to its Java class. The remaining arguments correspond to regular Java method arguments. The native method call passes its result back to the calling routine via the return value. Chapter 3: JNI Types and Data Structures describes the mapping between Java and C types. The following code example illustrates using a C function to implement the native method f . The native method f is declared as follows:

```

package p.q.r;

class A {
    native double f(int i, String s);
    // ...
}

```

The C function with the long name Java_p_q_r_A_f_ILjava_lang_String_2 implements native method f :

```

jdouble Java_p_q_r_A_f__ILjava_lang_String_2 (
     JNIEnv *env,        /* interface pointer */
     jobject obj,        /* "this" pointer */
     jint i,             /* argument #1 */
     jstring s)          /* argument #2 */
{
     /* Obtain a C-copy of the Java string */
     const char *str = (*env)->GetStringUTFChars(env, s, 0);

     /* process the string */
     ...

     /* Now we are done with str */
     (*env)->ReleaseStringUTFChars(env, s, str);

     return ...
}

```

Note that we always manipulate Java objects using the interface pointer env . Using C++, you can write a slightly cleaner version of the code, as shown in the following code example:

```

extern "C" /* specify the C calling convention */

jdouble Java_p_q_r_A_f__ILjava_lang_String_2 (

     JNIEnv *env,        /* interface pointer */
     jobject obj,        /* "this" pointer */
     jint i,             /* argument #1 */
     jstring s)          /* argument #2 */

{
     const char *str = env->GetStringUTFChars(s, 0);

     // ...

     env->ReleaseStringUTFChars(s, str);

     // return ...
}

```

With C++, the extra level of indirection and the interface pointer argument disappear from the source code. However, the underlying mechanism is exactly the same as with C. In C++, JNI functions are defined as inline member functions that expand to their C counterparts.

# Referencing Java Objects

Primitive types, such as integers, characters, and so on, are copied between Java and native code. Arbitrary Java objects, on the other hand, are passed by reference. The VM must keep track of all objects that have been passed to the native code, so that these objects are not freed by the garbage collector. The native code, in turn, must have a way to inform the VM that it no longer needs the objects. In addition, the garbage collector must be able to move an object referred to by the native code.

# Global and Local References

The JNI divides object references used by the native code into two categories: local and global references . Local references are valid for the duration of a native method call, and are automatically freed after the native method returns. Global references remain valid until they are explicitly freed. Objects are passed to native methods as local references. All Java objects returned by JNI functions are local references. The JNI allows the programmer to create global references from local references. JNI functions that expect Java objects accept both global and local references. A native method may return a local or global reference to the VM as its result. In most cases, the programmer should rely on the VM to free all local references after the native method returns. However, there are times when the programmer should explicitly free a local reference. Consider, for example, the following situations: The JNI allows the programmer to manually delete local references at any point within a native method. To ensure that programmers can manually free local references, JNI functions are not allowed to create extra local references, except for references they return as the result. Local references are only valid in the thread in which they are created. The native code must not pass local references from one thread to another.

# Implementing Local References

To implement local references, the Java VM creates a registry for each transition of control from Java to a native method. A registry maps nonmovable local references to Java objects, and keeps the objects from being garbage collected. All Java objects passed to the native method (including those that are returned as the results of JNI function calls) are automatically added to the registry. The registry is deleted after the native method returns, allowing all of its entries to be garbage collected. There are different ways to implement a registry, such as using a table, a linked list, or a hash table. Although reference counting may be used to avoid duplicated entries in the registry, a JNI implementation is not obliged to detect and collapse duplicate entries. Note that local references cannot be faithfully implemented by conservatively scanning the native stack. The native code may store local references into global or heap data structures.

# Accessing Java Objects

The JNI provides a rich set of accessor functions on global and local references. This means that the same native method implementation works no matter how the VM represents Java objects internally. This is a crucial reason why the JNI can be supported by a wide variety of VM implementations. The overhead of using accessor functions through opaque references is higher than that of direct access to C data structures. We believe that, in most cases, Java programmers use native methods to perform nontrivial tasks that overshadow the overhead of this interface.

# Accessing Primitive Arrays

This overhead is not acceptable for large Java objects containing many primitive data types, such as integer arrays and strings. (Consider native methods that are used to perform vector and matrix calculations.) It would be grossly inefficient to iterate through a Java array and retrieve every element with a function call. One solution introduces a notion of "pinning" so that the native method can ask the VM to pin down the contents of an array. The native method then receives a direct pointer to the elements. This approach, however, has two implications: We adopt a compromise that overcomes both of the above problems. First, we provide a set of functions to copy primitive array elements between a segment of a Java array and a native memory buffer. Use these functions if a native method needs access to only a small number of elements in a large array. Second, programmers can use another set of functions to retrieve a pinned-down version of array elements. Keep in mind that these functions may require the Java VM to perform storage allocation and copying. Whether these functions in fact copy the array depends on the VM implementation, as follows: Lastly, the interface provides functions to inform the VM that the native code no longer needs to access the array elements. When you call these functions, the system either unpins the array, or it reconciles the original array with its non-movable copy and frees the copy. Our approach provides flexibility. A garbage collector algorithm can make separate decisions about copying or pinning for each given array. For example, the garbage collector may copy small objects, but pin the larger objects. A JNI implementation must ensure that native methods running in multiple threads can simultaneously access the same array. For example, the JNI may keep an internal counter for each pinned array so that one thread does not unpin an array that is also pinned by another thread. Note that the JNI does not need to lock primitive arrays for exclusive access by a native method. Simultaneously updating a Java array from different threads leads to nondeterministic results.

# Accessing Fields and Methods

The JNI allows native code to access the fields and to call the methods of Java objects. The JNI identifies methods and fields by their symbolic names and type signatures. A two-step process factors out the cost of locating the field or method from its name and signature. For example, to call the method f in class cls , the native code first obtains a method ID, as follows:

```

jmethodID mid = env->GetMethodID(cls, "f", "(ILjava/lang/String;)D");

```

The native code can then use the method ID repeatedly without the cost of method lookup, as follows:

```

jdouble result = env->CallDoubleMethod(obj, mid, 10, str);

```

A field or method ID does not prevent the VM from unloading the class from which the ID has been derived. After the class is unloaded, the method or field ID becomes invalid and may not be passed to any function taking such an ID. The native code, therefore, must make sure to: if it intends to use a method or field ID for an extended period of time. The JNI does not impose any restrictions on how field and method IDs are implemented internally.

# Calling Caller-Sensitive Methods

A small number of Java methods have a special property called caller sensitivity. A caller-sensitive method can behave differently depending on the identity of its immediate caller. For example, AccessibleObject::canAccess needs to know the caller to determine accessibility. When native code calls such a method, there may not be any Java caller on the call stack. It is the responsibility of the programmer to know whether the Java methods being called from their native code are caller-sensitive, and how those methods will respond if there is no Java caller. If necessary the programmer can provide Java code for the native code to call, which in turn calls the original Java method.

# Reporting Programming Errors

The JNI does not check for programming errors such as passing in NULL pointers or illegal argument types. Illegal argument types includes such things as using a normal Java object instead of a Java class object. The JNI does not check for these programming errors for the following reasons: Most C library functions do not guard against programming errors. The printf() function, for example, usually causes a runtime error, rather than returning an error code, when it receives an invalid address. Forcing C library functions to check for all possible error conditions would likely result in such checks to be duplicated--once in the user code, and then again in the library. The programmer must not pass illegal pointers or arguments of the wrong type to JNI functions. Doing so could result in arbitrary consequences, including a corrupted system state or VM crash.

# Java Exceptions

The JNI allows native methods to raise arbitrary Java exceptions. The native code may also handle outstanding Java exceptions. The Java exceptions left unhandled are propagated back to the VM.

# Exceptions and Error Codes

Certain JNI functions use the Java exception mechanism to report error conditions. In most cases, JNI functions report error conditions by returning an error code and throwing a Java exception. The error code is usually a special return value (such as NULL) that is outside of the range of normal return values. Therefore, the programmer can: There are two cases where the programmer needs to check for exceptions without being able to first check an error code: In all other cases, a non-error return value guarantees that no exceptions have been thrown.

# Asynchronous Exceptions

One thread may raise an asynchronous exception in another thread by calling the Thread.stop() method, which has been deprecated since Java 2 SDK release 1.2. Programmers are strongly discouraged from using Thread.stop() as it generally leads to an indeterminate application state. Furthermore, the JVM may produce exceptions in the current thread without being the direct result of a JNI API call, but because of various JVM internal errors, for example: VirtualMachineError like StackOverflowError or OutOfMemoryError . These are also referred to as asynchronous exceptions. Asynchronous exceptions do not immediately affect the execution of the native code in the current thread, until: Note that only those JNI functions that could potentially raise synchronous exceptions check for asynchronous exceptions. Native methods should insert ExceptionOccurred() checks in necessary places, such as in any long running code without other exception checks (this may include tight loops). This ensures that the current thread responds to asynchronous exceptions in a reasonable amount of time. However, because of their asynchronous nature, making an exception check before a call is no guarantee that an asynchronous exception won't be raised between the check and the call.

# Exception Handling

There are two ways to handle an exception in native code: After an exception has been raised, the native code must first clear the exception before making other JNI calls. When there is a pending exception, the JNI functions that are safe to call are:

```

ExceptionOccurred()
ExceptionDescribe()
ExceptionClear()
ExceptionCheck()
ReleaseStringChars()
ReleaseStringUTFChars()
ReleaseStringCritical()
Release<Type>ArrayElements()
ReleasePrimitiveArrayCritical()
DeleteLocalRef()
DeleteGlobalRef()
DeleteWeakGlobalRef()
MonitorExit()
PushLocalFrame()
PopLocalFrame()
DetachCurrentThread()

```


---


# Java Native Interface Specification: 3 - JNI Types and Data Structures

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jni/types.html


# Chapter 3: JNI Types and Data Structures

This chapter discusses how the JNI maps Java types to native C types. This chapter covers the following topics:

# Primitive Types

The following table describes Java primitive types and their machine-dependent native equivalents. The following definition is provided for convenience.

```

#define JNI_FALSE  0
#define JNI_TRUE   1

```

The jsize integer type is used to describe cardinal indices and sizes:

```

typedef jint jsize;

```

# Reference Types

The JNI includes a number of reference types that correspond to different kinds of Java objects. JNI reference types are organized in the following hierarchy: In C, all other JNI reference types are defined to be the same as jobject. For example:

```

typedef jobject jclass;

```

In C++, JNI introduces a set of dummy classes to enforce the subtyping relationship. For example:

```

class _jobject {};
class _jclass : public _jobject {};
// ...
typedef _jobject *jobject;
typedef _jclass *jclass;

```

# Field and Method IDs

Method and field IDs are regular C pointer types:

```

struct _jfieldID;              /* opaque structure */
typedef struct _jfieldID *jfieldID;   /* field IDs */

struct _jmethodID;              /* opaque structure */
typedef struct _jmethodID *jmethodID; /* method IDs */

```

# The Value Type

The jvalue union type is used as the element type in argument arrays. It is declared as follows:

```

typedef union jvalue {
    jboolean z;
    jbyte    b;
    jchar    c;
    jshort   s;
    jint     i;
    jlong    j;
    jfloat   f;
    jdouble  d;
    jobject  l;
} jvalue;

```

# Type Signatures

The JNI uses the Java VMs representation of type signatures. The following table shows these type signatures. For example, the Java method:

```

long f (int n, String s, int[] arr);

```

has the following type signature:

```

(ILjava/lang/String;[I)J

```

# Modified UTF-8 Strings


---


# Oracle Legal Notices

URL: https://docs.oracle.com/en/java/javase/19/docs/legal/copyright.html


# Oracle Legal Notices

# Copyright Notice

Copyright  1993, 2022, Oracle and/or its affiliates. All rights reserved.

# License Restrictions Warranty/Consequential Damages Disclaimer

This software and related documentation are provided under a license agreement containing restrictions on use and disclosure and are protected by intellectual property laws. Except as expressly permitted in your license agreement or allowed by law, you may not use, copy, reproduce, translate, broadcast, modify, license, transmit, distribute, exhibit, perform, publish, or display any part, in any form, or by any means. Reverse engineering, disassembly, or decompilation of this software, unless required by law for interoperability, is prohibited.

# Warranty Disclaimer

The information contained herein is subject to change without notice and is not warranted to be error-free. If you find any errors, please report them to us in writing.

# Restricted Rights Notice

If this is software or related documentation that is delivered to the U.S. Government or anyone licensing it on behalf of the U.S. Government, then the following notice is applicable: U.S. GOVERNMENT END USERS: Oracle programs, including any operating system, integrated software, any programs installed on the hardware, and/or documentation, delivered to U.S. Government end users are "commercial computer software" pursuant to the applicable Federal Acquisition Regulation and agency-specific supplemental regulations. As such, use, duplication, disclosure, modification, and adaptation of the programs, including any operating system, integrated software, any programs installed on the hardware, and/or documentation, shall be subject to license terms and license restrictions applicable to the programs. No other rights are granted to the U.S. Government.

# Hazardous Applications Notice

This software or hardware is developed for general use in a variety of information management applications. It is not developed or intended for use in any inherently dangerous applications, including applications that may create a risk of personal injury. If you use this software or hardware in dangerous applications, then you shall be responsible to take all appropriate fail-safe, backup, redundancy, and other measures to ensure its safe use. Oracle Corporation and its affiliates disclaim any liability for any damages caused by use of this software or hardware in dangerous applications.

# Trademark Notice

Oracle and Java are registered trademarks of Oracle and/or its affiliates. Other names may be trademarks of their respective owners. Intel and Intel Xeon are trademarks or registered trademarks of Intel Corporation. All SPARC trademarks are used under license and are trademarks or registered trademarks of SPARC International, Inc. AMD, Opteron, the AMD logo, and the AMD Opteron logo are trademarks or registered trademarks of Advanced Micro Devices. UNIX is a registered trademark of The Open Group.

# Third-Party Content, Products, and Services Disclaimer

This software or hardware and documentation may provide access to or information about content, products, and services from third parties. Oracle Corporation and its affiliates are not responsible for and expressly disclaim all warranties of any kind with respect to third-party content, products, and services unless otherwise set forth in an applicable agreement between you and Oracle. Oracle Corporation and its affiliates will not be responsible for any loss, costs, or damages incurred due to your access to or use of third-party content, products, or services, except as set forth in an applicable agreement between you and Oracle.

# Pre-General Availability Draft Documentation Notice


---


# Java Native Interface Specification: 5 - The Invocation API

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jni/invocation.html


# Chapter 5: The Invocation API

The Invocation API allows software vendors to load the Java VM into an arbitrary native application. Vendors can deliver Java-enabled applications without having to link with the Java VM source code. This chapter begins with an overview of the Invocation API. This is followed by reference pages for all Invocation API functions. It covers the following topics:

# Overview

The following code example illustrates how to use functions in the Invocation API. In this example, the C++ code creates a Java VM and invokes a static method, called Main.test . For clarity, we omit error checking.

```

#include <jni.h>       /* where everything is defined */
...
JavaVM *jvm;       /* denotes a Java VM */
JNIEnv *env;       /* pointer to native method interface */
JavaVMInitArgs vm_args; /* JDK/JRE 19 VM initialization arguments */
JavaVMOption* options = new JavaVMOption[1];
options[0].optionString = "-Djava.class.path=/usr/lib/java";
vm_args.version = JNI_VERSION_19;
vm_args.nOptions = 1;
vm_args.options = options;
vm_args.ignoreUnrecognized = false;
/* load and initialize a Java VM, return a JNI interface
 * pointer in env */
JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);
delete options;
/* invoke the Main.test method using the JNI */
jclass cls = env->FindClass("Main");
jmethodID mid = env->GetStaticMethodID(cls, "test", "(I)V");
env->CallStaticVoidMethod(cls, mid, 100);
/* We are done. */
jvm->DestroyJavaVM();

```

This example uses three functions in the API. The Invocation API allows a native application to use the JNI interface pointer to access VM features. The design is similar to Netscapes JRI Embedding Interface.

# Creating the VM

The JNI_CreateJavaVM() function loads and initializes a Java VM and returns a pointer to the JNI interface pointer. The thread that called JNI_CreateJavaVM() is considered to be the main thread . Note: Depending on the operating system, the primordial process thread may be subject to special handling that impacts its ability to function properly as a normal Java thread (such as having a limited stack size and being able to throw StackOverflowError ). It is strongly recommended that the primordial thread is not used to load the Java VM, but that a new thread is created just for that purpose.

# Attaching to the VM

The JNI interface pointer ( JNIEnv ) is valid only in the current thread. Should another thread need to access the Java VM, it must first call AttachCurrentThread() to attach itself to the VM and obtain a JNI interface pointer. Once attached to the VM, a native thread works just like an ordinary Java thread running inside a native method, with the one exception that there is no Java caller when calling caller-sensitive methods . The native thread remains attached to the VM until it calls DetachCurrentThread() to detach itself. The attached thread should have enough stack space to perform a reasonable amount of work. The allocation of stack space per thread is operating system-specific. For example, using pthreads, the stack size can be specified in the pthread_attr_t argument to pthread_create .

# Detaching from the VM

A native thread attached to the VM must call DetachCurrentThread() to detach itself before exiting. A thread cannot detach itself if there are Java methods on the call stack.

# Terminating the VM

The JNI_DestroyJavaVM() function terminates a Java VM. The VM waits until the current thread is the only non-daemon user thread before it actually terminates. User threads include both Java threads and attached native threads. This restriction exists because a Java thread or attached native thread may be holding system resources, such as locks, windows, and so on. The VM cannot automatically free these resources. By restricting the current thread to be the only running thread when the VM is terminated, the burden of releasing system resources held by arbitrary threads is on the programmer.

# Library and Version Management

A native library may be either dynamically linked or statically linked with the VM. The manner in which the library and VM image are combined is implementation dependent. A System.loadLibrary or equivalent API must succeed for a library to be considered loaded, this applies to both dynamically and even statically linked libraries. Once a native library is loaded, it is visible from all class loaders. Therefore two classes in different class loaders may link with the same native method. This leads to two problems: Each class loader manages its own set of native libraries. The same JNI native library cannot be loaded into more than one class loader. Doing so causes UnsatisfiedLinkError to be thrown. For example, System.loadLibrary throws an UnsatisfiedLinkError when used to load a native library into two class loaders. The benefits of this approach are:

# Support for Statically Linked Libraries

The following rules apply to statically linked libraries, for the statically linked library given in these examples named 'L': The programmer can also call the JNI function RegisterNatives() to register the native methods associated with a class. The RegisterNatives() function is particularly useful with statically linked functions. If dynamically linked library defines JNI_OnLoad_L and/or JNI_OnUnload_L functions, these functions will be ignored.

# Library Lifecycle Function Hooks

To facilitate version control and resource management, JNI libraries may define load and unload function hooks. Naming of these of functions depends upon whether the library was dynamically or statically linked.

# JNI_OnLoad

jint JNI_OnLoad(JavaVM *vm, void *reserved); Optional function defined by dynamically linked libraries. The VM calls JNI_OnLoad when the native library is loaded (for example, through System.loadLibrary ). In order to make use of functions defined at a certain version of the JNI API, JNI_OnLoad must return a constant defining at least that version. For example, libraries wishing to use AttachCurrentThreadAsDaemon function introduced in JDK 1.4, need to return at least JNI_VERSION_1_4 . If the native library does not export a JNI_OnLoad function, the VM assumes that the library only requires JNI version JNI_VERSION_1_1 . If the VM does not recognize the version number returned by JNI_OnLoad , the VM will unload the library and act as if the library was never loaded.

# LINKAGE:

Exported from dynamically linked native libraries that contain native method implementations.

# PARAMETERS:

vm : a pointer to the current VM structure. reserved : unused pointer.

# RETURNS:

Return the required JNI_VERSION constant (see also GetVersion ).

# JNI_OnUnload

void JNI_OnUnload(JavaVM *vm, void *reserved); Optional function defined by dynamically linked libraries. The VM calls JNI_OnUnload when the class loader containing the native library is garbage collected. This function can be used to perform cleanup operations. Because this function is called in an unknown context (such as from a finalizer), the programmer should be conservative on using Java VM services, and refrain from arbitrary Java call-backs.

# LINKAGE:

Exported from dynamically linked native libraries that contain native method implementations.

# PARAMETERS:

vm : a pointer to the current VM structure. reserved : unused pointer.

# JNI_OnLoad_L

jint JNI_Onload_<L>(JavaVM *vm, void *reserved); Mandatory function that must be defined by statically linked libraries . If a library, named 'L', is statically linked, then upon the first invocation of System.loadLibrary("L") or equivalent API, a JNI_OnLoad_L function will be invoked with the same arguments and expected return value as specified for the JNI_OnLoad function. JNI_OnLoad_L must return the JNI version needed by the native library. This version must be JNI_VERSION_1_8 or later. If the VM does not recognize the version number returned by JNI_OnLoad_L , the VM will act as if the library was never loaded.

# LINKAGE:

Exported from statically linked native libraries that contain native method implementations.

# PARAMETERS:

vm : a pointer to the current VM structure. reserved : unused pointer.

# RETURNS:

Return the required JNI_VERSION constant (see also GetVersion ). The minimum version returned being at least JNI_VERSION_1_8 .

# SINCE:

JDK/JRE 1.8

# JNI_OnUnload_L

void JNI_OnUnload_<L>(JavaVM *vm, void *reserved); Optional function defined by statically linked libraries. When the class loader containing a statically linked native library 'L' is garbage collected, the VM will invoke the JNI_OnUnload_L function of the library if such a function is exported. This function can be used to perform cleanup operations. Because this function is called in an unknown context (such as from a finalizer), the programmer should be conservative on using Java VM services, and refrain from arbitrary Java call-backs.

# LINKAGE:

Exported from statically linked native libraries that contain native method implementations.

# PARAMETERS:

vm : a pointer to the current VM structure. reserved : unused pointer.

# SINCE:

JDK/JRE 1.8

# Informational Note:

The act of loading a native library is the complete process of making the library and its native entry points known and registered to the Java VM and runtime. Note that simply performing operating system level operations to load a native library, such as dlopen on a UNIX(R) system, does not fully accomplish this goal. A native function is normally called from the Java class loader to perform a call to the host operating system that will load the library into memory and return a handle to the native library. This handle will be stored and used in subsequent searches for native library entry points. The Java native class loader will complete the load process once the handle is successfully returned to register the library.

# Invocation API Functions

The JavaVM type is a pointer to the Invocation API function table. The following code example shows this function table.

```

typedef const struct JNIInvokeInterface *JavaVM;

const struct JNIInvokeInterface ... = {
    NULL,
    NULL,
    NULL,

    DestroyJavaVM,
    AttachCurrentThread,
    DetachCurrentThread,

    GetEnv,

    AttachCurrentThreadAsDaemon
};

```

Note that three Invocation API functions, JNI_GetDefaultJavaVMInitArgs() , JNI_GetCreatedJavaVMs() , and JNI_CreateJavaVM() , are not part of the JavaVM function table. These functions can be used without a preexisting JavaVM structure.

# JNI_GetDefaultJavaVMInitArgs

jint JNI_GetDefaultJavaVMInitArgs(void *vm_args); Returns a default configuration for the Java VM. Before calling this function, native code must set the vm_args->version field to the JNI version it expects the VM to support. After this function returns, vm_args->version will be set to the actual JNI version the VM supports.

# LINKAGE:

Exported from the native library that implements the Java virtual machine.

# PARAMETERS:

vm_args : a pointer to a JavaVMInitArgs structure in to which the default arguments are filled, must not be NULL .

# RETURNS:

Returns JNI_OK if the requested version is supported; returns a JNI error code (a negative number) if the requested version is not supported.

# JNI_GetCreatedJavaVMs

jint JNI_GetCreatedJavaVMs(JavaVM **vmBuf, jsize bufLen, jsize *nVMs); Returns all Java VMs that have been created. Pointers to VMs are written in the buffer vmBuf in the order they are created. At most bufLen number of entries will be written. The total number of created VMs is returned in *nVMs. Creation of multiple VMs in a single process is not supported.

# LINKAGE:

Exported from the native library that implements the Java virtual machine.

# PARAMETERS:

vmBuf : pointer to the buffer where the VM structures will be placed, must not be NULL . bufLen : the length of the buffer. nVMs : a pointer to an integer. May be a NULL value.

# RETURNS:

Returns JNI_OK on success; returns a suitable JNI error code (a negative number) on failure.

# JNI_CreateJavaVM

jint JNI_CreateJavaVM(JavaVM **p_vm, void **p_env, void *vm_args); Loads and initializes a Java VM. The current thread becomes the main thread. Sets the env argument to the JNI interface pointer of the main thread. Creation of multiple VMs in a single process is not supported. The second argument to JNI_CreateJavaVM is always a pointer to JNIEnv * , while the third argument is a pointer to a JavaVMInitArgs structure which uses option strings to encode arbitrary VM start up options:

```

typedef struct JavaVMInitArgs {
    jint version;

    jint nOptions;
    JavaVMOption *options;
    jboolean ignoreUnrecognized;
} JavaVMInitArgs;

```

The options field is an array of the following type:

```

typedef struct JavaVMOption {
    char *optionString;  /* the option as a string in the default platform encoding */
    void *extraInfo;
} JavaVMOption;

```

The size of the array is denoted by the nOptions field in JavaVMInitArgs . If ignoreUnrecognized is JNI_TRUE , JNI_CreateJavaVM ignores all unrecognized option strings that begin with " -X " or " _ ". If ignoreUnrecognized is JNI_FALSE , JNI_CreateJavaVM returns JNI_ERR as soon as it encounters any unrecognized option strings. All Java VMs must recognize the following set of standard options: The module related options, --add-reads , --add-exports , --add-opens , --add-modules , --limit-modules , --module-path , --patch-module , and --upgrade-module-path must be passed as option strings using their "option=value" format instead of their "option value" format. (Note the required = between "option" and "value".) For example, to export java.management/sun.management to ALL-UNNAMED pass option string "--add-exports=java.management/sun.management=ALL-UNNAMED" . In addition, each VM implementation may support its own set of non-standard option strings. Non-standard option names must begin with " -X " or an underscore (" _ "). For example, the JDK/JRE supports -Xms and -Xmx options to allow programmers specify the initial and maximum heap size. Options that begin with " -X " are accessible from the " java " command line. Here is the example code that creates a Java VM in the JDK/JRE:

```

JavaVMInitArgs vm_args;
JavaVMOption options[4];

options[0].optionString = "-Djava.compiler=NONE";           /* disable JIT */
options[1].optionString = "-Djava.class.path=c:\myclasses"; /* user classes */
options[2].optionString = "-Djava.library.path=c:\mylibs";  /* set native library path */
options[3].optionString = "-verbose:jni";                   /* print JNI-related messages */

vm_args.version = JNI_VERSION_1_2;
vm_args.options = options;
vm_args.nOptions = 4;
vm_args.ignoreUnrecognized = TRUE;

/* Note that in the JDK/JRE, there is no longer any need to call
 * JNI_GetDefaultJavaVMInitArgs.
 */
res = JNI_CreateJavaVM(&vm, (void **)&env, &vm_args);
if (res < 0) ...

```

# LINKAGE:

Exported from the native library that implements the Java virtual machine.

# PARAMETERS:

p_vm : pointer to the location where the resulting VM structure will be placed, must not be NULL . p_env : pointer to the location where the JNI interface pointer for the main thread will be placed, must not be NULL . vm_args : Java VM initialization arguments, must not be NULL .

# RETURNS:

Returns JNI_OK on success; returns a suitable JNI error code (a negative number) on failure.

# DestroyJavaVM

```

jint DestroyJavaVM(JavaVM *vm);

```

Terminates the operation of the JVM, making a best-effort attempt to release resources. Any thread, whether attached or not, can invoke this function. If the current thread is attached, the VM waits until the current thread is the only non-daemon user-level Java thread. If the current thread is not attached, the VM attaches the current thread and then waits until the current thread is the only non-daemon user-level thread.

# LINKAGE:

Index 3 in the JavaVM interface function table.

# PARAMETERS:

vm : the Java VM that will be destroyed, must not be NULL .

# RETURNS:

Returns JNI_OK on success; returns a suitable JNI error code (a negative number) on failure.

# AttachCurrentThread

jint AttachCurrentThread(JavaVM *vm, void **p_env, void *thr_args); Attaches the current thread to a Java VM. Returns a JNI interface pointer in the JNIEnv argument. Trying to attach a thread that is already attached is a no-op. A native thread cannot be attached simultaneously to two Java VMs. When a thread is attached to the VM, the context class loader is the bootstrap loader.

# LINKAGE:

Index 4 in the JavaVM interface function table.

# PARAMETERS:

vm : the VM to which the current thread will be attached, must not be NULL . p_env : pointer to the location where the JNI interface pointer of the current thread will be placed, must not be NULL . thr_args : can be NULL or a pointer to a JavaVMAttachArgs structure to specify additional information: The second argument to AttachCurrentThread is always a pointer to JNIEnv . The third argument to AttachCurrentThread was reserved, and should be set to NULL . You pass a pointer to the following structure to specify additional information:

```

typedef struct JavaVMAttachArgs {
    jint version;
    char *name;    /* the name of the thread as a modified UTF-8 string, or NULL */
    jobject group; /* global ref of a ThreadGroup object, or NULL */
} JavaVMAttachArgs

```

# RETURNS:

Returns JNI_OK on success; returns a suitable JNI error code (a negative number) on failure.

# AttachCurrentThreadAsDaemon

jint AttachCurrentThreadAsDaemon(JavaVM* vm, void** penv, void* args); Same semantics as AttachCurrentThread , but the newly-created java.lang.Thread instance is a daemon . If the thread has already been attached via either AttachCurrentThread or AttachCurrentThreadAsDaemon , this routine simply sets the value pointed to by penv to the JNIEnv of the current thread. In this case neither AttachCurrentThread nor this routine have any effect on the daemon status of the thread.

# LINKAGE:

Index 7 in the JavaVM interface function table.

# PARAMETERS:

vm : the virtual machine instance to which the current thread will be attached, must not be NULL . penv : a pointer to the location in which the JNIEnv interface pointer for the current thread will be placed. args : a pointer to a JavaVMAttachArgs structure. May be a NULL value.

# RETURNS

Returns JNI_OK on success; returns a suitable JNI error code (a negative number) on failure.

# DetachCurrentThread

jint DetachCurrentThread(JavaVM *vm); Detaches the current thread from a Java VM. All Java monitors held by this thread are released. All Java threads waiting for this thread to die are notified. The main thread can be detached from the VM. Trying to detach a thread that is not attached is a no-op. If an exception is pending when DetachCurrentThread is called, the VM may choose to report its existence.

# LINKAGE:

Index 5 in the JavaVM interface function table.

# PARAMETERS:

vm : the VM from which the current thread will be detached, must not be NULL .

# RETURNS:

Returns JNI_OK on success; returns a suitable JNI error code (a negative number) on failure.

# GetEnv

jint GetEnv(JavaVM *vm, void **env, jint version);

# LINKAGE:

Index 6 in the JavaVM interface function table.

# PARAMETERS:

vm : The virtual machine instance from which the interface will be retrieved, must not be NULL . env : pointer to the location where the JNI interface pointer for the current thread will be placed, must not be NULL . version : The requested JNI version.

# RETURNS:


---


# Java Native Interface Specification: 4 - JNI Functions

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jni/functions.html


# Chapter 4: JNI Functions

This chapter serves as the reference section for the JNI functions. It provides a complete listing of all the JNI functions. It also presents the exact layout of the JNI function table. Note the use of the term "must" to describe restrictions on JNI programmers. For example, when you see that a certain JNI function must receive a non-NULL object, it is your responsibility to ensure that NULL is not passed to that JNI function. As a result, a JNI implementation does not need to perform NULL pointer checks in that JNI function. Passing NULL when explicity not allowed may result in an unexpected exception or a fatal crash. Functions whose definition may both return NULL and throw an exception on error, may choose only to return NULL to indicate an error, but not throw any exception. For example, a JNI implementation may consider an "out of memory" condition temporary, and may not wish to throw an OutOfMemoryError since this would appear fatal (JDK API java.lang.Error documentation: "indicates serious problems that a reasonable application should not try to catch" ). A portion of this chapter is adapted from Netscapes JRI documentation. The reference material groups functions by their usage. The reference section is organized by the following functional areas:

# Interface Function Table

Each function is accessible at a fixed offset through the JNIEnv argument. The JNIEnv type is a pointer to a structure storing all JNI function pointers. It is defined as follows:

```

typedef const struct JNINativeInterface *JNIEnv;

```

The VM initializes the function table, as shown by the following code example. Note that the first three entries are reserved for future compatibility with COM. In addition, we reserve a number of additional NULL entries near the beginning of the function table, so that, for example, a future class-related JNI operation can be added after FindClass, rather than at the end of the table. Note that the function table can be shared among all JNI interface pointers.

```

const struct JNINativeInterface ... = {

    NULL,
    NULL,
    NULL,
    NULL,
    GetVersion,

    DefineClass,
    FindClass,

    FromReflectedMethod,
    FromReflectedField,
    ToReflectedMethod,

    GetSuperclass,
    IsAssignableFrom,

    ToReflectedField,

    Throw,
    ThrowNew,
    ExceptionOccurred,
    ExceptionDescribe,
    ExceptionClear,
    FatalError,

    PushLocalFrame,
    PopLocalFrame,

    NewGlobalRef,
    DeleteGlobalRef,
    DeleteLocalRef,
    IsSameObject,
    NewLocalRef,
    EnsureLocalCapacity,

    AllocObject,
    NewObject,
    NewObjectV,
    NewObjectA,

    GetObjectClass,
    IsInstanceOf,

    GetMethodID,

    CallObjectMethod,
    CallObjectMethodV,
    CallObjectMethodA,
    CallBooleanMethod,
    CallBooleanMethodV,
    CallBooleanMethodA,
    CallByteMethod,
    CallByteMethodV,
    CallByteMethodA,
    CallCharMethod,
    CallCharMethodV,
    CallCharMethodA,
    CallShortMethod,
    CallShortMethodV,
    CallShortMethodA,
    CallIntMethod,
    CallIntMethodV,
    CallIntMethodA,
    CallLongMethod,
    CallLongMethodV,
    CallLongMethodA,
    CallFloatMethod,
    CallFloatMethodV,
    CallFloatMethodA,
    CallDoubleMethod,
    CallDoubleMethodV,
    CallDoubleMethodA,
    CallVoidMethod,
    CallVoidMethodV,
    CallVoidMethodA,

    CallNonvirtualObjectMethod,
    CallNonvirtualObjectMethodV,
    CallNonvirtualObjectMethodA,
    CallNonvirtualBooleanMethod,
    CallNonvirtualBooleanMethodV,
    CallNonvirtualBooleanMethodA,
    CallNonvirtualByteMethod,
    CallNonvirtualByteMethodV,
    CallNonvirtualByteMethodA,
    CallNonvirtualCharMethod,
    CallNonvirtualCharMethodV,
    CallNonvirtualCharMethodA,
    CallNonvirtualShortMethod,
    CallNonvirtualShortMethodV,
    CallNonvirtualShortMethodA,
    CallNonvirtualIntMethod,
    CallNonvirtualIntMethodV,
    CallNonvirtualIntMethodA,
    CallNonvirtualLongMethod,
    CallNonvirtualLongMethodV,
    CallNonvirtualLongMethodA,
    CallNonvirtualFloatMethod,
    CallNonvirtualFloatMethodV,
    CallNonvirtualFloatMethodA,
    CallNonvirtualDoubleMethod,
    CallNonvirtualDoubleMethodV,
    CallNonvirtualDoubleMethodA,
    CallNonvirtualVoidMethod,
    CallNonvirtualVoidMethodV,
    CallNonvirtualVoidMethodA,

    GetFieldID,

    GetObjectField,
    GetBooleanField,
    GetByteField,
    GetCharField,
    GetShortField,
    GetIntField,
    GetLongField,
    GetFloatField,
    GetDoubleField,
    SetObjectField,
    SetBooleanField,
    SetByteField,
    SetCharField,
    SetShortField,
    SetIntField,
    SetLongField,
    SetFloatField,
    SetDoubleField,

    GetStaticMethodID,

    CallStaticObjectMethod,
    CallStaticObjectMethodV,
    CallStaticObjectMethodA,
    CallStaticBooleanMethod,
    CallStaticBooleanMethodV,
    CallStaticBooleanMethodA,
    CallStaticByteMethod,
    CallStaticByteMethodV,
    CallStaticByteMethodA,
    CallStaticCharMethod,
    CallStaticCharMethodV,
    CallStaticCharMethodA,
    CallStaticShortMethod,
    CallStaticShortMethodV,
    CallStaticShortMethodA,
    CallStaticIntMethod,
    CallStaticIntMethodV,
    CallStaticIntMethodA,
    CallStaticLongMethod,
    CallStaticLongMethodV,
    CallStaticLongMethodA,
    CallStaticFloatMethod,
    CallStaticFloatMethodV,
    CallStaticFloatMethodA,
    CallStaticDoubleMethod,
    CallStaticDoubleMethodV,
    CallStaticDoubleMethodA,
    CallStaticVoidMethod,
    CallStaticVoidMethodV,
    CallStaticVoidMethodA,

    GetStaticFieldID,

    GetStaticObjectField,
    GetStaticBooleanField,
    GetStaticByteField,
    GetStaticCharField,
    GetStaticShortField,
    GetStaticIntField,
    GetStaticLongField,
    GetStaticFloatField,
    GetStaticDoubleField,

    SetStaticObjectField,
    SetStaticBooleanField,
    SetStaticByteField,
    SetStaticCharField,
    SetStaticShortField,
    SetStaticIntField,
    SetStaticLongField,
    SetStaticFloatField,
    SetStaticDoubleField,

    NewString,

    GetStringLength,
    GetStringChars,
    ReleaseStringChars,

    NewStringUTF,
    GetStringUTFLength,
    GetStringUTFChars,
    ReleaseStringUTFChars,

    GetArrayLength,

    NewObjectArray,
    GetObjectArrayElement,
    SetObjectArrayElement,

    NewBooleanArray,
    NewByteArray,
    NewCharArray,
    NewShortArray,
    NewIntArray,
    NewLongArray,
    NewFloatArray,
    NewDoubleArray,

    GetBooleanArrayElements,
    GetByteArrayElements,
    GetCharArrayElements,
    GetShortArrayElements,
    GetIntArrayElements,
    GetLongArrayElements,
    GetFloatArrayElements,
    GetDoubleArrayElements,

    ReleaseBooleanArrayElements,
    ReleaseByteArrayElements,
    ReleaseCharArrayElements,
    ReleaseShortArrayElements,
    ReleaseIntArrayElements,
    ReleaseLongArrayElements,
    ReleaseFloatArrayElements,
    ReleaseDoubleArrayElements,

    GetBooleanArrayRegion,
    GetByteArrayRegion,
    GetCharArrayRegion,
    GetShortArrayRegion,
    GetIntArrayRegion,
    GetLongArrayRegion,
    GetFloatArrayRegion,
    GetDoubleArrayRegion,
    SetBooleanArrayRegion,
    SetByteArrayRegion,
    SetCharArrayRegion,
    SetShortArrayRegion,
    SetIntArrayRegion,
    SetLongArrayRegion,
    SetFloatArrayRegion,
    SetDoubleArrayRegion,

    RegisterNatives,
    UnregisterNatives,

    MonitorEnter,
    MonitorExit,

    GetJavaVM,

    GetStringRegion,
    GetStringUTFRegion,

    GetPrimitiveArrayCritical,
    ReleasePrimitiveArrayCritical,

    GetStringCritical,
    ReleaseStringCritical,

    NewWeakGlobalRef,
    DeleteWeakGlobalRef,

    ExceptionCheck,

    NewDirectByteBuffer,
    GetDirectBufferAddress,
    GetDirectBufferCapacity,

    GetObjectRefType,

    GetModule,

    IsVirtualThread
  };

```

# Constants

There are a number of general constants used throughout the JNI API.

# Boolean values

```

#define JNI_FALSE 0
#define JNI_TRUE 1

```

# Return codes

General return value constants for JNI functions.

```

#define JNI_OK           0                 /* success */
#define JNI_ERR          (-1)              /* unknown error */
#define JNI_EDETACHED    (-2)              /* thread detached from the VM */
#define JNI_EVERSION     (-3)              /* JNI version error */
#define JNI_ENOMEM       (-4)              /* not enough memory */
#define JNI_EEXIST       (-5)              /* VM already created */
#define JNI_EINVAL       (-6)              /* invalid arguments */

```

# Version Information

# GetVersion

jint GetVersion(JNIEnv *env); Returns the version of the native method interface. For Java SE Platform 19 and later, it returns JNI_VERSION_19 . The following table gives the version of JNI included in each release of the Java SE Platform (for older versions of JNI, the JDK release is used instead of the Java SE Platform):

# LINKAGE:

Index 4 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL .

# RETURNS:

Returns the major version number in the higher 16 bits and the minor version number in the lower 16 bits.

# Version Constants

```

#define JNI_VERSION_1_1 0x00010001
#define JNI_VERSION_1_2 0x00010002
#define JNI_VERSION_1_4 0x00010004
#define JNI_VERSION_1_6 0x00010006
#define JNI_VERSION_1_8 0x00010008
#define JNI_VERSION_9   0x00090000
#define JNI_VERSION_10  0x000a0000
#define JNI_VERSION_19  0x00130000

```

# Class Operations

# DefineClass

jclass DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize bufLen); Loads a class from a buffer of raw class data. The buffer containing the raw class data is not referenced by the VM after the DefineClass call returns, and it may be discarded if desired.

# LINKAGE:

Index 5 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . name : the name of the class or interface to be defined. The string is encoded in modified UTF-8. This value may be NULL , or it must match the name encoded within the class file data. loader : a class loader assigned to the defined class. This value may be NULL , indicating the "null class loader" (or "bootstrap class loader" ). buf : buffer containing the .class file data. A NULL value will cause a ClassFormatError . bufLen : buffer length.

# RETURNS:

Returns a Java class object or NULL if an error occurs.

# THROWS:

ClassFormatError : if the class data does not specify a valid class. ClassCircularityError : if a class or interface would be its own superclass or superinterface. OutOfMemoryError : if the system runs out of memory. SecurityException : if the caller attempts to define a class in the "java" package tree.

# FindClass

jclass FindClass(JNIEnv *env, const char *name); In JDK release 1.1, this function loads a locally-defined class. It searches the directories and zip files specified by the CLASSPATH environment variable for the class with the specified name. Since JDK 1.2, the Java security model allows non-system classes to load and call native methods. FindClass locates the class loader associated with the current native method; that is, the class loader of the class that declared the native method. If the native method belongs to a system class, no class loader will be involved. Otherwise, the proper class loader will be invoked to load, link, and initialize, the named class. Since JDK 1.2, when FindClass is called through the Invocation Interface, there is no current native method or its associated class loader. In that case, the result of ClassLoader.getSystemClassLoader is used. This is the class loader the virtual machine creates for applications, and is able to locate classes listed in the java.class.path property. If FindClass is called from a library lifecycle function hook, the class loader is determined as follows: The name argument is a fully-qualified class name or an array type signature. For example, the fully-qualified class name for the java.lang.String class is:

```

"java/lang/String"

```

The array type signature of the array class java.lang.Object[] is:

```

"[Ljava/lang/Object;"

```

# LINKAGE:

Index 6 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . name : a fully-qualified class name (that is, a package name, delimited by " / ", followed by the class name). If the name begins with " [ " (the array signature character), it returns an array class. The string is encoded in modified UTF-8. A NULL value may cause NoClassDefFoundError to occur, or a crash.

# RETURNS:

Returns a class object from a fully-qualified name, or NULL if the class cannot be found.

# THROWS:

ClassFormatError : if the class data does not specify a valid class. ClassCircularityError : if a class or interface would be its own superclass or superinterface. NoClassDefFoundError : if no definition for a requested class or interface can be found. OutOfMemoryError : if the system runs out of memory.

# GetSuperclass

jclass GetSuperclass(JNIEnv *env, jclass clazz); If clazz represents any class other than the class Object , then this function returns the object that represents the superclass of the class specified by clazz . If clazz specifies the class Object , or clazz represents an interface, this function returns NULL .

# LINKAGE:

Index 10 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL .

# RETURNS:

Returns the superclass of the class represented by clazz , or NULL .

# IsAssignableFrom

jboolean IsAssignableFrom(JNIEnv *env, jclass clazz1, jclass clazz2); Determines whether an object of clazz1 can be safely cast to clazz2 .

# LINKAGE:

Index 11 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz1 : the first class argument, must not be NULL . clazz2 : the second class argument, must not be NULL .

# RETURNS:

Returns JNI_TRUE if either of the following is true:

# Module Operations

# GetModule

jobject GetModule(JNIEnv *env, jclass clazz); Returns the java.lang.Module object for the module that the class is a member of. If the class is not in a named module then the unnamed module of the class loader for the class is returned. If the class represents an array type then this function returns the Module object for the element type. If the class represents a primitive type or void , then the Module object for the java.base module is returned.

# LINKAGE:

Index 233 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL .

# RETURNS:

Returns the module that the class or interface is a member of.

# SINCE:

JDK/JRE 9

# Thread Operations

# IsVirtualThread

jboolean IsVirtualThread(JNIEnv *env, jobject obj); IsVirtualThread is a preview API of the Java platform. Preview features may be removed in a future release, or upgraded to permanent features of the Java platform. Tests whether an object is a virtual Thread.

# LINKAGE:

Index 234 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a Java object, possibly a NULL value.

# RETURNS:

Returns JNI_TRUE if the object is a virtual Thread.

# SINCE:

JDK/JRE 19

# Exceptions

# Throw

jint Throw(JNIEnv *env, jthrowable obj); Causes a java.lang.Throwable object to be thrown.

# LINKAGE:

Index 13 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a java.lang.Throwable object, must not be NULL .

# RETURNS:

Returns 0 on success; a negative value on failure.

# THROWS:

The java.lang.Throwable object obj .

# ThrowNew

jint ThrowNew(JNIEnv *env, jclass clazz, const char *message); Constructs an exception object from the specified class with the message specified by message and causes that exception to be thrown.

# LINKAGE:

Index 14 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a subclass of java.lang.Throwable , must not be NULL . message : the message used to construct the java.lang.Throwable object. The string is encoded in modified UTF-8. This value may be NULL .

# RETURNS:

Returns 0 on success; a negative value on failure.

# THROWS:

The newly constructed java.lang.Throwable object.

# ExceptionOccurred

jthrowable ExceptionOccurred(JNIEnv *env); Determines if an exception is being thrown. The exception stays being thrown until either the native code calls ExceptionClear() , or the Java code handles the exception.

# LINKAGE:

Index 15 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL .

# RETURNS:

Returns the exception object that is currently in the process of being thrown, or NULL if no exception is currently being thrown.

# ExceptionDescribe

void ExceptionDescribe(JNIEnv *env); Prints an exception and a backtrace of the stack to a system error-reporting channel, such as stderr . The pending exception is cleared as a side-effect of calling this function. This is a convenience routine provided for debugging.

# LINKAGE:

Index 16 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL .

# ExceptionClear

void ExceptionClear(JNIEnv *env); Clears any exception that is currently being thrown. If no exception is currently being thrown, this routine has no effect.

# LINKAGE:

Index 17 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL .

# FatalError

void FatalError(JNIEnv *env, const char *msg); Raises a fatal error and does not expect the VM to recover. This function does not return.

# LINKAGE:

Index 18 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . msg : an error message. The string is encoded in modified UTF-8. May be a NULL value.

# ExceptionCheck

We introduce a convenience function to check for pending exceptions without creating a local reference to the exception object. jboolean ExceptionCheck(JNIEnv *env); Returns JNI_TRUE when there is a pending exception; otherwise, returns JNI_FALSE .

# LINKAGE:

Index 228 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL .

# Global and Local References

# Global References

# NewGlobalRef

jobject NewGlobalRef(JNIEnv *env, jobject obj); Creates a new global reference to the object referred to by the obj argument. The obj argument may be a global or local reference. Global references must be explicitly disposed of by calling DeleteGlobalRef() .

# LINKAGE:

Index 21 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a global or local reference. May be a NULL value, in which case this function will return NULL .

# RETURNS:

Returns a global reference to the given obj . May return NULL if:

# DeleteGlobalRef

void DeleteGlobalRef(JNIEnv *env, jobject globalRef); Deletes the global reference pointed to by globalRef .

# LINKAGE:

Index 22 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . globalRef : a global reference. May be a NULL value, in which case this function does nothing.

# Local References

Local references are valid for the duration of a native method call. They are freed automatically after the native method returns. Each local reference costs some amount of Java Virtual Machine resource. Programmers need to make sure that native methods do not excessively allocate local references. Although local references are automatically freed after the native method returns to Java, excessive allocation of local references may cause the VM to run out of memory during the execution of a native method.

# DeleteLocalRef

void DeleteLocalRef(JNIEnv *env, jobject localRef); Deletes the local reference pointed to by localRef .

# LINKAGE:

Index 23 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . localRef : a local reference. The function does nothing in the case of a NULL value passed here. Note : JDK/JRE 1.1 provides the DeleteLocalRef function above so that programmers can manually delete local references. For example, if native code iterates through a potentially large array of objects and uses one element in each iteration, it is a good practice to delete the local reference to the no-longer-used array element before a new local reference is created in the next iteration. As of JDK/JRE 1.2 an additional set of functions are provided for local reference lifetime management. They are the four functions listed below.

# EnsureLocalCapacity

jint EnsureLocalCapacity(JNIEnv *env, jint capacity); Ensures that at least a given number of local references can be created in the current thread. Returns 0 on success; otherwise returns a negative number and throws an OutOfMemoryError . Before it enters a native method, the VM automatically ensures that at least 16 local references can be created. For backward compatibility, the VM allocates local references beyond the ensured capacity. (As a debugging support, the VM may give the user warnings that too many local references are being created. In the JDK, the programmer can supply the -verbose:jni command line option to turn on these messages.) The VM calls FatalError if no more local references can be created beyond the ensured capacity. Some Java Virtual Machine implementations may choose to limit the maximum capacity , which may cause the function to return an error (e.g. JNI_ERR or JNI_EINVAL ). The HotSpot JVM implementation, for example, uses the -XX:+MaxJNILocalCapacity flag (default: 65536).

# LINKAGE:

Index 26 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . capacity : the minimum number of required local references. Must be >= 0.

# RETURNS:

JNI_OK upon succcess.

# SINCE:

JDK/JRE 1.2

# PushLocalFrame

jint PushLocalFrame(JNIEnv *env, jint capacity); Creates a new local reference frame, in which at least a given number of local references can be created. Returns 0 on success, a negative number and a pending OutOfMemoryError on failure. Note that local references already created in previous local frames are still valid in the current local frame. As with EnsureLocalCapacity , some Java Virtual Machine implementations may choose to limit the maximum capacity , which may cause the function to return an error.

# LINKAGE:

Index 19 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . capacity : the minimum number of required local references. Must be > 0.

# RETURNS:

JNI_OK upon succcess.

# SINCE:

JDK/JRE 1.2

# PopLocalFrame

jobject PopLocalFrame(JNIEnv *env, jobject result); Pops off the current local reference frame, frees all the local references, and returns a local reference in the previous local reference frame for the given result object. Pass NULL as result if you do not need to return a reference to the previous frame.

# LINKAGE:

Index 20 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . result : an object to be passed to the previous local reference frame, may be NULL .

# RETURNS:

Returns a local reference in the previous local reference frame for the given result object, or NULL if the given result object was NULL .

# SINCE:

JDK/JRE 1.2

# NewLocalRef

jobject NewLocalRef(JNIEnv *env, jobject ref); Creates a new local reference that refers to the same object as ref . The given ref may be a global, a local reference or NULL . Returns NULL if ref refers to null .

# LINKAGE:

Index 25 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . ref : a reference to the object for which the function creates a new local reference. May be a NULL value.

# RETURNS:

Returns a new local reference that refers to the same object as ref . May return NULL if:

# SINCE:

JDK/JRE 1.2

# Weak Global References

Weak global references are a special kind of global reference. Unlike normal global references, a weak global reference allows the underlying Java object to be garbage collected. Weak global references may be used in any situation where global or local references are used. Weak global references are related to Java phantom references ( java.lang.ref.PhantomReference ). A weak global reference to a specific object is treated as a phantom reference referring to that object when determining whether the object is phantom reachable (see java.lang.ref ). Such a weak global reference will become functionally equivalent to NULL at the same time as a PhantomReference referring to that same object would be cleared by the garbage collector. Since garbage collection may occur while native methods are running, objects referred to by weak global references can be freed at any time. While weak global references can be used where global references are used, it is generally inappropriate to do so, as they may become functionally equivalent to NULL without notice. IsSameObject can be used to compare a weak global reference to a non- NULL local or global reference. If the objects are the same, the weak global reference won't become functionally equivalent to NULL so long as the other reference has not been deleted. IsSameObject can also be used to compare a weak global reference to NULL to determine whether the underlying object has been freed. However, programmers should not rely on this check to determine whether a weak global reference may be used (as a non- NULL reference) in any future JNI function call, since an intervening garbage collection could change the weak global reference. Instead, it is recommended that a (strong) local or global reference to the underlying object be acquired using one of the JNI functions NewLocalRef or NewGlobalRef . These functions will return NULL if the object has been freed. Otherwise, the new reference will prevent the underlying object from being freed. The new reference, if non- NULL , can then be used to access the underlying object, and deleted when such access is no longer needed.

# NewWeakGlobalRef

jweak NewWeakGlobalRef(JNIEnv *env, jobject obj); Creates a new weak global reference. The weak global reference will not prevent garbage collection of the given object. IsSameObject may be used to test if the object referred to by the reference has been freed. Returns NULL if obj refers to null , or if obj was a weak global reference, or if the VM runs out of memory. If the VM runs out of memory, an OutOfMemoryError will be thrown.

# LINKAGE:

Index 226 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : the object to create a global weak reference for.

# RETURNS:

Return a global weak reference to the given obj . May return NULL if:

# THROWS:

OutOfMemoryError if the system runs out of memory.

# SINCE:

JDK/JRE 1.2

# DeleteWeakGlobalRef

void DeleteWeakGlobalRef(JNIEnv *env, jweak obj); Delete the VM resources needed for the given weak global reference.

# LINKAGE:

Index 227 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : global weak reference to delete. This function does nothing if passed NULL .

# SINCE:

JDK/JRE 1.2

# Object Operations

# AllocObject

jobject AllocObject(JNIEnv *env, jclass clazz); Allocates a new Java object without invoking any of the constructors for the object . Returns a reference to the object. Note: The Java Language Specification, "Implementing Finalization" ( JLS 12.6.1 ) states: "An object o is not finalizable until its constructor has invoked the constructor for Object on o and that invocation has completed successfully". Since AllocObject() does not invoke a constructor, objects created with this function are not eligible for finalization. The clazz argument must not refer to an array class.

# LINKAGE:

Index 27 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a reference to a Java class object, must not be NULL .

# RETURNS:

Returns a Java object, or NULL if the object cannot be constructed.

# THROWS:

InstantiationException : if the class is an interface or an abstract class. OutOfMemoryError : if the system runs out of memory.

# NewObject, NewObjectA, NewObjectV

jobject NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...); jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args); jobject NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args); Constructs a new Java object. The method ID indicates which constructor method to invoke. This ID must be obtained by calling GetMethodID() with <init> as the method name and void ( V ) as the return type. The clazz argument must not refer to an array class.

# NewObject

Programmers place all arguments that are to be passed to the constructor immediately following the methodID argument. NewObject() accepts these arguments and passes them to the Java method that the programmer wishes to invoke.

# LINKAGE:

Index 28 in the JNIEnv interface function table.

# NewObjectA

Programmers place all arguments that are to be passed to the constructor in an args array of jvalues that immediately follows the methodID argument. NewObjectA() accepts the arguments in this array, and, in turn, passes them to the Java method that the programmer wishes to invoke.

# LINKAGE:

Index 30 in the JNIEnv interface function table.

# NewObjectV

Programmers place all arguments that are to be passed to the constructor in an args argument of type va_list that immediately follows the methodID argument. NewObjectV() accepts these arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke.

# LINKAGE:

Index 29 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a reference to a Java class object, must not be NULL . methodID : the method ID of the constructor.

# Additional Parameter for NewObject:

arguments to the constructor.

# Additional Parameter for NewObjectA:

args : an array of arguments to the constructor.

# Additional Parameter for NewObjectV:

args : a va_list of arguments to the constructor.

# RETURNS:

Returns a Java object, or NULL if the object cannot be constructed.

# THROWS:

InstantiationException : if the class is an interface or an abstract class. OutOfMemoryError : if the system runs out of memory. Any exceptions thrown by the constructor.

# GetObjectClass

jclass GetObjectClass(JNIEnv *env, jobject obj); Returns the class of an object.

# LINKAGE:

Index 31 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a Java object, must not be NULL .

# RETURNS:

Returns a Java class object.

# GetObjectRefType

jobjectRefType GetObjectRefType(JNIEnv* env, jobject obj); Returns the type of the object referred to by the obj argument. The argument obj can either be a local, global or weak global reference, or NULL .

# LINKAGE:

Index 232 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a local, global or weak global reference.

# RETURNS:

The function GetObjectRefType returns one of the following enumerated values defined as a jobjectRefType :

```

JNIInvalidRefType    = 0
JNILocalRefType      = 1
JNIGlobalRefType     = 2
JNIWeakGlobalRefType = 3

```

If the argument obj is a weak global reference type, the return will be JNIWeakGlobalRefType . If the argument obj is a global reference type, the return value will be JNIGlobalRefType . If the argument obj is a local reference type, the return will be JNILocalRefType . If the obj argument is not a valid reference, the return value for this function will be JNIInvalidRefType . An invalid reference is a reference which is not a valid handle. That is, the obj pointer address does not point to a location in memory which has been allocated from one of the Ref creation functions or returned from a JNI function. As such, NULL would be an invalid reference and GetObjectRefType(env,NULL) would return JNIInvalidRefType . On the other hand, a null reference, which is a reference that points to a null, would return the type of reference that the null reference was originally created as. GetObjectRefType cannot be used on deleted references. Since references are typically implemented as pointers to memory data structures that can potentially be reused by any of the reference allocation services in the VM, once deleted, it is not specified what value the GetObjectRefType will return.

# SINCE:

JDK/JRE 1.6

# IsInstanceOf

jboolean IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz); Tests whether an object is an instance of a class.

# LINKAGE:

Index 32 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a Java object, possibly a NULL value. clazz : a Java class object, must not be NULL .

# RETURNS:

Returns JNI_TRUE if obj can be cast to clazz ; otherwise, returns JNI_FALSE . A NULL object can be cast to any class.

# IsSameObject

jboolean IsSameObject(JNIEnv *env, jobject ref1, jobject ref2); Tests whether two references refer to the same Java object.

# LINKAGE:

Index 24 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . ref1 : a Java object, may be NULL . ref2 : a Java object, may be NULL .

# RETURNS:

Returns JNI_TRUE if ref1 and ref2 refer to the same Java object, or are both NULL ; otherwise, returns JNI_FALSE .

# Accessing Fields of Objects

# GetFieldID

jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig); Returns the field ID for an instance (nonstatic) field of a class. The field is specified by its name and signature. The Get<type>Field and Set<type>Field families of accessor functions use field IDs to retrieve object fields. GetFieldID() causes an uninitialized class to be initialized. GetFieldID() cannot be used to obtain the length field of an array. Use GetArrayLength() instead.

# LINKAGE:

Index 94 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . name : the field name in a 0-terminated modified UTF-8 string, must not be NULL . sig : the field signature in a 0-terminated modified UTF-8 string, must not be NULL .

# RETURNS:

Returns a field ID, or NULL if the operation fails.

# THROWS:

NoSuchFieldError : if the specified field cannot be found. ExceptionInInitializerError : if the class initializer fails due to an exception. OutOfMemoryError : if the system runs out of memory.

# Get<type>Field Routines

NativeType Get<type>Field (JNIEnv *env, jobject obj, jfieldID fieldID); This family of accessor routines returns the value of an instance (nonstatic) field of an object. The field to access is specified by a field ID obtained by calling GetFieldID() . The following table describes the Get<type>Field routine name and result type. You should replace type in Get<type>Field with the Java type of the field, or use one of the actual routine names from the table, and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table:

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a Java object, must not be NULL . fieldID : a valid field ID.

# RETURNS:

Returns the content of the field.

# Set<type>Field Routines

void Set<type>Field (JNIEnv *env, jobject obj, jfieldID fieldID, NativeType value); This family of accessor routines sets the value of an instance (nonstatic) field of an object. The field to access is specified by a field ID obtained by calling GetFieldID() . The following table describes the Set<type>Field routine name and value type. You should replace type in Set<type>Field with the Java type of the field, or use one of the actual routine names from the table, and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a Java object, must not be NULL . fieldID : a valid field ID. value : the new value of the field.

# Calling Instance Methods

When calling methods from native code be mindful of whether those methods may be caller-sensitive .

# GetMethodID

jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig); Returns the method ID for an instance (nonstatic) method of a class or interface. The method may be defined in one of the clazz s supertypes and inherited by clazz . The method is determined by its name and signature. GetMethodID() causes an uninitialized class to be initialized. To obtain the method ID of a constructor, supply <init> as the method name and void ( V ) as the return type.

# LINKAGE:

Index 33 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . name : the method name in a 0-terminated modified UTF-8 string, must not be NULL . sig : the method signature in 0-terminated modified UTF-8 string, must not be NULL .

# RETURNS:

Returns a method ID, or NULL if the specified method cannot be found.

# THROWS:

NoSuchMethodError : if the specified method cannot be found. ExceptionInInitializerError : if the class initializer fails due to an exception. OutOfMemoryError : if the system runs out of memory.

# Call<type>Method Routines, Call<type>MethodA Routines, Call<type>MethodV Routines

NativeType Call<type>Method (JNIEnv *env, jobject obj, jmethodID methodID, ...); NativeType Call<type>MethodA (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args); NativeType Call<type>MethodV (JNIEnv *env, jobject obj, jmethodID methodID, va_list args); Methods from these three families of operations are used to call a Java instance method from a native method.They only differ in their mechanism for passing parameters to the methods that they call. These families of operations invoke an instance (nonstatic) method on a Java object, according to the specified method ID. The methodID argument must be obtained by calling GetMethodID() . When these functions are used to call private methods and constructors, the method ID must be derived from the real class of obj , not from one of its superclasses.

# Call<type>Method Routines

Programmers place all arguments that are to be passed to the method immediately following the methodID argument. The Call<type>Method routine accepts these arguments and passes them to the Java method that the programmer wishes to invoke.

# Call<type>MethodA Routines

Programmers place all arguments to the method in an args array of jvalues that immediately follows the methodID argument. The Call<type>MethodA routine accepts the arguments in this array, and, in turn, passes them to the Java method that the programmer wishes to invoke.

# Call<type>MethodV Routines

Programmers place all arguments to the method in an args argument of type va_list that immediately follows the methodID argument. The Call<type>MethodV routine accepts the arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke. The following table describes each of the method calling routines according to their result type. You should replace type in Call<type>Method with the Java type of the method you are calling (or use one of the actual method calling routine names from the table) and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table:

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a Java object, must not be NULL . methodID : a valid method ID.

# Additional Parameter for Call<type>Method Routines:

arguments to the Java method.

# Additional Parameter for Call<type>MethodA Routines:

args : an array of arguments.

# Additional Parameter for Call<type>MethodV Routines:

args : a va_list of arguments.

# RETURNS:

Returns the result of calling the Java method.

# THROWS:

Exceptions raised during the execution of the Java method.

# CallNonvirtual<type>Method Routines, CallNonvirtual<type>MethodA Routines, CallNonvirtual<type>MethodV Routines

NativeType CallNonvirtual<type>Method (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...); NativeType CallNonvirtual<type>MethodA (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args); NativeType CallNonvirtual<type>MethodV (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args); These families of operations invoke an instance (nonstatic) method on a Java object, according to the specified class and method ID. The methodID argument must be obtained by calling GetMethodID() on the class clazz . The CallNonvirtual<type>Method families of routines and the Call<type>Method families of routines are different. Call<type>Method routines invoke the method based on the class or interface of the object, while CallNonvirtual<type>Method routines invoke the method based on the class, designated by the clazz parameter, from which the method ID is obtained. The method ID must be obtained from the real class of the object or from one of its supertypes. CallNonvirtual<type>Method routines are the mechanism for invoking "default interface methods" introduced in Java 8.

# CallNonvirtual<type>Method Routines

Programmers place all arguments that are to be passed to the method immediately following the methodID argument. The CallNonvirtual<type>Method routine accepts these arguments and passes them to the Java method that the programmer wishes to invoke.

# CallNonvirtual<type>MethodA Routines

Programmers place all arguments to the method in an args array of jvalues that immediately follows the methodID argument. The CallNonvirtual<type>MethodA routine accepts the arguments in this array, and, in turn, passes them to the Java method that the programmer wishes to invoke.

# CallNonvirtual<type>MethodV Routines

Programmers place all arguments to the method in an args argument of type va_list that immediately follows the methodID argument. The CallNonvirtualMethodV routine accepts the arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke. The following table describes each of the method calling routines according to their result type. You should replace type in CallNonvirtual<type>Method with the Java type of the method, or use one of the actual method calling routine names from the table, and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class, must not be NULL . obj : a Java object, must not be NULL . methodID : a method ID.

# Additional Parameter for CallNonvirtual<type>Method Routines:

arguments to the Java method.

# Additional Parameter for CallNonvirtual<type>MethodA Routines:

args : an array of arguments.

# Additional Parameter for CallNonvirtual<type>MethodV Routines:

args : a va_list of arguments.

# RETURNS:

Returns the result of calling the Java method.

# THROWS:

Exceptions raised during the execution of the Java method.

# Accessing Static Fields

# GetStaticFieldID

jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig); Returns the field ID for a static field of a class. The field is specified by its name and signature. The GetStatic<type>Field and SetStatic<type>Field families of accessor functions use field IDs to retrieve static fields. GetStaticFieldID() causes an uninitialized class to be initialized.

# LINKAGE:

Index 144 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . name : the static field name in a 0-terminated modified UTF-8 string, must not be NULL . sig : the field signature in a 0-terminated modified UTF-8 string, must not be NULL .

# RETURNS:

Returns a field ID, or NULL if the specified static field cannot be found.

# THROWS:

NoSuchFieldError : if the specified static field cannot be found. ExceptionInInitializerError : if the class initializer fails due to an exception. OutOfMemoryError : if the system runs out of memory.

# GetStatic<type>Field Routines

NativeType GetStatic<type>Field (JNIEnv *env, jclass clazz, jfieldID fieldID); This family of accessor routines returns the value of a static field of an object. The field to access is specified by a field ID, which is obtained by calling GetStaticFieldID() . The following table describes the family of get routine names and result types. You should replace type in GetStatic<type>Field with the Java type of the field, or one of the actual static field accessor routine names from the table, and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . fieldID : a valid static field ID.

# RETURNS:

Returns the content of the static field.

# SetStatic<type>Field Routines

void SetStatic<type>Field (JNIEnv *env, jclass clazz, jfieldID fieldID, NativeType value); This family of accessor routines sets the value of a static field of an object. The field to access is specified by a field ID, which is obtained by calling GetStaticFieldID() . The following table describes the set routine name and value types. You should replace type in SetStatic<type>Field with the Java type of the field, or one of the actual set static field routine names from the table, and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . fieldID : a valid static field ID. value : the new value of the field.

# Calling Static Methods

When calling methods from native code be mindful of whether those methods may be caller-sensitive .

# GetStaticMethodID

jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig); Returns the method ID for a static method of a class. The method is specified by its name and signature. GetStaticMethodID() causes an uninitialized class to be initialized.

# LINKAGE:

Index 113 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . name : the static method name in a 0-terminated modified UTF-8 string, must not be NULL . sig : the method signature in a 0-terminated modified UTF-8 string, must not be NULL .

# RETURNS:

Returns a method ID, or NULL if the operation fails.

# THROWS:

NoSuchMethodError : if the specified static method cannot be found. ExceptionInInitializerError : if the class initializer fails due to an exception. OutOfMemoryError : if the system runs out of memory.

# CallStatic<type>Method Routines, CallStatic<type>MethodA Routines, CallStatic<type>MethodV Routines

NativeType CallStatic<type>Method (JNIEnv *env, jclass clazz, jmethodID methodID, ...); NativeType CallStatic<type>MethodA (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args); NativeType CallStatic<type>MethodV (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args); This family of operations invokes a static method on a Java object, according to the specified method ID. The methodID argument must be obtained by calling GetStaticMethodID() . The method ID must be derived from clazz , not from one of its superclasses.

# CallStatic<type>Method Routines

Programmers should place all arguments that are to be passed to the method immediately following the methodID argument. The CallStatic<type>Method routine accepts these arguments and passes them to the Java method that the programmer wishes to invoke.

# CallStatic<type>MethodA Routines

Programmers should place all arguments to the method in an args array of jvalues that immediately follows the methodID argument. The CallStaticMethodA routine accepts the arguments in this array, and, in turn, passes them to the Java method that the programmer wishes to invoke.

# CallStatic<type>MethodV Routines

Programmers should place all arguments to the method in an args argument of type va_list that immediately follows the methodID argument. The CallStaticMethodV routine accepts the arguments, and, in turn, passes them to the Java method that the programmer wishes to invoke. The following table describes each of the method calling routines according to their result types. You should replace type in CallStatic<type>Method with the Java type of the method, or one of the actual method calling routine names from the table, and replace NativeType with the corresponding native type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . methodID : a valid static method ID.

# Additional Parameter for CallStatic<type>Method Routines:

arguments to the static method.

# Additional Parameter for CallStatic<type>MethodA Routines:

args : an array of arguments.

# Additional Parameter for CallStatic<type>MethodV Routines:

args : a va_list of arguments.

# RETURNS:

Returns the result of calling the static Java method.

# THROWS:

Exceptions raised during the execution of the Java method.

# String Operations

This specification makes no assumptions on how a JVM represent Java strings internally. Strings returned from these operations: are therefore not required to be NULL terminated. Programmers are expected to determine buffer capacity requirements via GetStringLength() or GetStringUTFLength() .

# NewString

jstring NewString(JNIEnv *env, const jchar *unicodeChars, jsize len); Constructs a new java.lang.String object from an array of Unicode characters.

# LINKAGE:

Index 163 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . unicodeChars : pointer to a Unicode string. May be a NULL value, in which case len must be 0. len : length of the Unicode string. May be 0.

# RETURNS:

Returns a Java string object, or NULL if the string cannot be constructed.

# THROWS:

OutOfMemoryError : if the system runs out of memory.

# GetStringLength

jsize GetStringLength(JNIEnv *env, jstring string); Returns the length (the count of Unicode characters) of a Java string.

# LINKAGE:

Index 164 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . string : a Java string object, must not be NULL .

# RETURNS:

Returns the length of the Java string.

# GetStringChars

const jchar * GetStringChars(JNIEnv *env, jstring string, jboolean *isCopy); Returns a pointer to the array of Unicode characters of the string. This pointer is valid until ReleaseStringChars() is called. If isCopy is not NULL , then *isCopy is set to JNI_TRUE if a copy is made; or it is set to JNI_FALSE if no copy is made.

# LINKAGE:

Index 165 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . string : a Java string object, must not be NULL . isCopy : a pointer to a boolean, may be a NULL value.

# RETURNS:

Returns a pointer to a Unicode string, or NULL if the operation fails.

# ReleaseStringChars

void ReleaseStringChars(JNIEnv *env, jstring string, const jchar *chars); Informs the VM that the native code no longer needs access to chars . The chars argument is a pointer obtained from string using GetStringChars() .

# LINKAGE:

Index 166 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . string : a Java string object, must not be NULL . chars : a pointer to a Unicode string, as previously returned by GetStringChars() .

# NewStringUTF

jstring NewStringUTF(JNIEnv *env, const char *bytes); Constructs a new java.lang.String object from an array of characters in modified UTF-8 encoding.

# LINKAGE:

Index 167 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . bytes : the pointer to a modified UTF-8 string, must not be NULL .

# RETURNS:

Returns a Java string object, or NULL if the string cannot be constructed.

# THROWS:

OutOfMemoryError : if the system runs out of memory.

# GetStringUTFLength

jsize GetStringUTFLength(JNIEnv *env, jstring string); Returns the length in bytes of the modified UTF-8 representation of a string.

# LINKAGE:

Index 168 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . string : a Java string object, must not be NULL .

# RETURNS:

Returns the UTF-8 length of the string.

# GetStringUTFChars

const char * GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy); Returns a pointer to an array of bytes representing the string in modified UTF-8 encoding. This array is valid until it is released by ReleaseStringUTFChars() . If isCopy is not NULL , then *isCopy is set to JNI_TRUE if a copy is made; or it is set to JNI_FALSE if no copy is made.

# LINKAGE:

Index 169 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . string : a Java string object, must not be NULL . isCopy : a pointer to a boolean, may be a NULL value.

# RETURNS:

Returns a pointer to a modified UTF-8 string, or NULL if the operation fails.

# ReleaseStringUTFChars

void ReleaseStringUTFChars(JNIEnv *env, jstring string, const char *utf); Informs the VM that the native code no longer needs access to utf . The utf argument is a pointer derived from string using GetStringUTFChars() .

# LINKAGE:

Index 170 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . string : a Java string object, must not be NULL . utf : a pointer to a modified UTF-8 string, previously returned by GetStringUTFChars() . Note : In JDK/JRE 1.1, programmers can get primitive array elements in a user-supplied buffer. As of JDK/JRE 1.2 additional set of functions are provided allowing native code to obtain characters in Unicode (UTF-16) or modified UTF-8 encoding in a user-supplied buffer. See the functions below.

# GetStringRegion

void GetStringRegion(JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf); Copies len number of Unicode characters beginning at offset start to the given buffer buf .

# LINKAGE:

Index 220 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . str : a Java string object, must not be NULL . start : the index of the first unicode character in the string to copy. Must be greater than or equal to zero, and less than string length (" GetStringLength() "). len : the number of unicode characters to copy. Must be greater than or equal to zero, and " start + len " must be less than string length (" GetStringLength() "). buf : the unicode character buffer into which to copy the string region. Must not be NULL if given len is > 0.

# THROWS:

StringIndexOutOfBoundsException : on index overflow.

# SINCE:

JDK/JRE 1.2

# GetStringUTFRegion

void GetStringUTFRegion(JNIEnv *env, jstring str, jsize start, jsize len, char *buf); Translates len number of Unicode characters beginning at offset start into modified UTF-8 encoding and place the result in the given buffer buf . The len argument specifies the number of unicode characters . The resulting number modified UTF-8 encoding characters may be greater than the given len argument. GetStringUTFLength() may be used to determine the maximum size of the required character buffer. Since this specification does not require the resulting string copy be NULL terminated, it is advisable to clear the given character buffer (e.g. " memset() ") before using this function, in order to safely perform strlen() .

# LINKAGE:

Index 221 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . str : a Java string object, must not be NULL . start : the index of the first unicode character in the string to copy. Must be greater than or equal to zero, and less than the string length. len : the number of unicode characters to copy. Must be greater than zero, and " start + len " must be less than string length (" GetStringLength() "). buf : the unicode character buffer into which to copy the string region. Must not be NULL if given len is > 0.

# THROWS:

StringIndexOutOfBoundsException : on index overflow.

# SINCE:

JDK/JRE 1.2

# GetStringCritical, ReleaseStringCritical

const jchar * GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy); void ReleaseStringCritical(JNIEnv *env, jstring string, const jchar *carray); The semantics of these two functions are similar to the existing Get/ReleaseStringChars functions. If possible, the VM returns a pointer to string elements; otherwise, a copy is made. However, there are significant restrictions on how these functions can be used. In a code segment enclosed by Get/ReleaseStringCritical calls, the native code must not issue arbitrary JNI calls, or cause the current thread to block. The restrictions on Get/ReleaseStringCritical are similar to those on Get/ReleasePrimitiveArrayCritical .

# LINKAGE (GetStringCritical):

Index 224 in the JNIEnv interface function table.

# LINKAGE (ReleaseStingCritical):

Index 225 in the JNIEnv interface function table.

# SEE ALSO:

GetStringChars ReleaseStringChars

# SINCE:

JDK/JRE 1.2

# Array Operations

# GetArrayLength

jsize GetArrayLength(JNIEnv *env, jarray array); Returns the number of elements in the array.

# LINKAGE:

Index 171 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array object, must not be NULL .

# RETURNS:

Returns the length of the array.

# NewObjectArray

jobjectArray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement); Constructs a new array holding objects in class elementClass . All elements are initially set to initialElement .

# LINKAGE:

Index 172 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . length : array size, must be >= 0. elementClass : array element class, must not be NULL . initialElement : initialization value, may be a NULL value.

# RETURNS:

Returns a Java array object, or NULL if the array cannot be constructed.

# THROWS:

OutOfMemoryError : if the system runs out of memory.

# GetObjectArrayElement

jobject GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index); Returns an element of an Object array.

# LINKAGE:

Index 173 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array, must not be NULL . index : array index, must be >= 0 and less than array length (" GetArrayLength() ").

# RETURNS:

Returns a Java object.

# THROWS:

ArrayIndexOutOfBoundsException : if index does not specify a valid index in the array.

# SetObjectArrayElement

void SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value); Sets an element of an Object array.

# LINKAGE:

Index 174 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array, must not be NULL . index : array index, must be >= 0 and less than array length (" GetArrayLength() "). value : the new value, may be a NULL value.

# THROWS:

ArrayIndexOutOfBoundsException : if index does not specify a valid index in the array. ArrayStoreException : if the class of value is not a subclass of the element class of the array.

# New<PrimitiveType>Array Routines

ArrayType New<PrimitiveType>Array (JNIEnv *env, jsize length); A family of operations used to construct a new primitive array object. The following table describes the specific primitive array constructors. You should replace New<PrimitiveType>Array with one of the actual primitive array constructor routine names from this table, and replace ArrayType with the corresponding array type for that routine.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . length : the array length, must be >= 0.

# RETURNS:

Returns a Java array, or NULL if the array cannot be constructed.

# THROWS:

OutOfMemoryError : if the system runs out of memory.

# Get<PrimitiveType>ArrayElements Routines

NativeType * Get<PrimitiveType>ArrayElements (JNIEnv *env, ArrayType array, jboolean *isCopy); A family of functions that returns the body of the primitive array. The result is valid until the corresponding Release<PrimitiveType>ArrayElements() function is called. Since the returned array may be a copy of the Java array, changes made to the returned array will not necessarily be reflected in the original array until Release<PrimitiveType>ArrayElements() is called. If isCopy is not NULL , then *isCopy is set to JNI_TRUE if a copy is made; or it is set to JNI_FALSE if no copy is made. The following table describes the specific primitive array element accessors. You should make the following substitutions: Regardless of how boolean arrays are represented in the Java VM, GetBooleanArrayElements() always returns a pointer to jbooleans , with each byte denoting an element (the unpacked representation). All arrays of other types are guaranteed to be contiguous in memory.

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array object, must not be NULL . isCopy : a pointer to a boolean, may be a NULL value.

# RETURNS:

Returns a pointer to the array elements, or NULL if the operation fails.

# THROWS:

OutOfMemoryError : if the system runs out of memory.

# Release<PrimitiveType>ArrayElements Routines

void Release<PrimitiveType>ArrayElements (JNIEnv *env, ArrayType array, NativeType *elems, jint mode); A family of functions that informs the VM that the native code no longer needs access to elems . The elems argument is a pointer derived from array using the corresponding Get<PrimitiveType>ArrayElements() function. If necessary, this function copies back all changes made to elems to the original array. The mode argument provides information on how the array buffer should be released. mode has no effect if elems is not a copy of the elements in array . Otherwise, mode has the following impact, as shown in the following table: Primitive Array Release Modes mode actions 0 copy back the content and free the elems buffer JNI_COMMIT copy back the content but do not free the elems buffer JNI_ABORT free the buffer without copying back the possible changes In most cases, programmers pass "0" as the mode argument to ensure consistent behavior for both pinned and copied arrays. The other options give the programmer more control over memory management and should be used with extreme care. If JNI_COMMIT is passed as the mode argument when elems is a copy of the elements in array , then a final call to Release<PrimitiveType>ArrayElements passing a mode argument of "0" or JNI_ABORT , should be made to free the elems buffer. The next table describes the specific routines that comprise the family of primitive array disposers. You should make the following substitutions:

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array object, must not be NULL . elems : a pointer to array elements, as returned by previous Get<PrimitiveType>ArrayElements call. mode : the release mode: 0 , JNI_COMMIT or JNI_ABORT .

# Get<PrimitiveType>ArrayRegion Routines

void Get<PrimitiveType>ArrayRegion (JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf); A family of functions that copies a region of a primitive array into a buffer. The following table describes the specific primitive array element accessors. You should do the following substitutions:

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array, must not be NULL . start : the starting index, must be greater than or equal to zero, and less than the array length ( GetArrayLength() ). len : the number of elements to be copied, must be greater than or equal to zero, and " start + len " must be less than array length (" GetArrayLength() "). buf : the destination buffer, must not be NULL .

# THROWS:

ArrayIndexOutOfBoundsException : if one of the indexes in the region is not valid.

# Set<PrimitiveType>ArrayRegion Routines

void Set<PrimitiveType>ArrayRegion (JNIEnv *env, ArrayType array, jsize start, jsize len, const NativeType *buf); A family of functions that copies back a region of a primitive array from a buffer. The following table describes the specific primitive array element accessors. You should make the following replacements:

# LINKAGE:

Indices in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array, must not be NULL . start : the starting index, must be greater than or equal to zero, and less than the array length ( GetArrayLength() ). len : the number of elements to be copied, must be greater than or equal to zero, and " start + len " must be less than array length (" GetArrayLength() "). buf : the source buffer, must not be NULL .

# THROWS:

ArrayIndexOutOfBoundsException : if one of the indexes in the region is not valid. Note : Programmers can use Get/Release<primitivetype>ArrayElements functions to obtain a pointer to primitive array elements. If the VM supports pinning, the pointer to the original data is returned; otherwise, a copy is made. The Get/Release<primitivetype>ArrayCritical functions allow native code to obtain a direct pointer to array elements even if the VM does not support pinning.

# GetPrimitiveArrayCritical, ReleasePrimitiveArrayCritical

void * GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy); void ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode); The semantics of these two functions are very similar to the existing Get/Release<primitivetype>ArrayElements functions. If possible, the VM returns a pointer to the primitive array; otherwise, a copy is made. However, there are significant restrictions on how these functions can be used. After calling GetPrimitiveArrayCritical , the native code should not run for an extended period of time before it calls ReleasePrimitiveArrayCritical . We must treat the code inside this pair of functions as running in a "critical region." Inside a critical region, native code must not call other JNI functions, or any system call that may cause the current thread to block and wait for another Java thread. (For example, the current thread must not call read on a stream being written by another Java thread.) These restrictions make it more likely that the native code will obtain an uncopied version of the array, even if the VM does not support pinning. For example, a VM may temporarily disable garbage collection when the native code is holding a pointer to an array obtained via GetPrimitiveArrayCritical . Multiple pairs of GetPrimtiveArrayCritical and ReleasePrimitiveArrayCritical may be nested. For example:

```

jint len = (*env)->GetArrayLength(env, arr1);
  jbyte *a1 = (*env)->GetPrimitiveArrayCritical(env, arr1, 0);
  jbyte *a2 = (*env)->GetPrimitiveArrayCritical(env, arr2, 0);
  /* We need to check in case the VM tried to make a copy. */
  if (a1 == NULL || a2 == NULL) {
    ... /* out of memory exception thrown */
  }
  memcpy(a1, a2, len);
  (*env)->ReleasePrimitiveArrayCritical(env, arr2, a2, 0);
  (*env)->ReleasePrimitiveArrayCritical(env, arr1, a1, 0);

```

Note that GetPrimitiveArrayCritical might still make a copy of the array if the VM internally represents arrays in a different format. Therefore we need to check its return value against NULL for possible out of memory situations.

# GetPrimitiveArrayCritical

# LINKAGE:

Linkage Index 222 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array, must not be NULL . isCopy : a pointer to a boolean, may be a NULL value.

# RETURNS:

Returns a pointer to the array elements, or NULL if the operation fails.

# THROWS:

OutOfMemoryError : if the system runs out of memory.

# SINCE:

JDK/JRE 1.2

# ReleasePrimitiveArrayCritical

# LINKAGE:

Linkage Index 223 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . array : a Java array, must not be NULL . carray : critical array pointer as returned by GetPrimitiveArrayCritical . mode : the release mode (see Primitive Array Release Modes ): 0 , JNI_COMMIT or JNI_ABORT . Ignored if carray was a not copy.

# SINCE:

JDK/JRE 1.2

# Registering Native Methods

# RegisterNatives

jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods); Registers native methods with the class specified by the clazz argument. The methods parameter specifies an array of JNINativeMethod structures that contain the names, signatures, and function pointers of the native methods. The name and signature fields of the JNINativeMethod structure are pointers to modified UTF-8 strings. The nMethods parameter specifies the number of native methods in the array. The JNINativeMethod structure is defined as follows:

```

typedef struct {
    char *name;
    char *signature;
    void *fnPtr;
} JNINativeMethod;

```

The function pointers nominally must have the following signature:

```

ReturnType (*fnPtr)(JNIEnv *env, jobject objectOrClass, ...);

```

Be aware that RegisterNatives can change the documented behavior of the JVM (including cryptographic algorithms, correctness, security, type safety), by changing the native code to be executed for a given native Java method. Therefore use applications that have native libraries utilizing the RegisterNatives function with caution.

# LINKAGE:

Index 215 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL . methods : the native methods in the class, must not be NULL . nMethods : the number of native methods in the class, must be greater than zero.

# RETURNS:

Returns "0" on success; returns a negative value on failure.

# THROWS:

NoSuchMethodError : if a specified method cannot be found or if the method is not native.

# UnregisterNatives

jint UnregisterNatives(JNIEnv *env, jclass clazz); Unregisters native methods of a class. The class goes back to the state before it was linked or registered with its native method functions. This function should not be used in normal native code. Instead, it provides special programs a way to reload and relink native libraries.

# LINKAGE:

Index 216 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . clazz : a Java class object, must not be NULL .

# RETURNS:

Returns "0" on success; returns a negative value on failure.

# Monitor Operations

# MonitorEnter

jint MonitorEnter(JNIEnv *env, jobject obj); Enters the monitor associated with the underlying Java object referred to by obj . Enters the monitor associated with the object referred to by obj. The obj reference must not be NULL . Each Java object has a monitor associated with it. If the current thread already owns the monitor associated with obj , it increments a counter in the monitor indicating the number of times this thread has entered the monitor. If the monitor associated with obj is not owned by any thread, the current thread becomes the owner of the monitor, setting the entry count of this monitor to 1. If another thread already owns the monitor associated with obj , the current thread waits until the monitor is released, then tries again to gain ownership. A monitor entered through a MonitorEnter JNI function call cannot be exited using the monitorexit Java virtual machine instruction or a synchronized method return. A MonitorEnter JNI function call and a monitorenter Java virtual machine instruction may race to enter the monitor associated with the same object. To avoid deadlocks, a monitor entered through a MonitorEnter JNI function call must be exited using the MonitorExit JNI call, unless the DetachCurrentThread call is used to implicitly release JNI monitors.

# LINKAGE:

Index 217 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a normal Java object or class object, must not be NULL .

# RETURNS:

Returns "0" on success; returns a negative value on failure.

# MonitorExit

jint MonitorExit(JNIEnv *env, jobject obj); The current thread must be the owner of the monitor associated with the underlying Java object referred to by obj . The thread decrements the counter indicating the number of times it has entered this monitor. If the value of the counter becomes zero, the current thread releases the monitor. Native code must not use MonitorExit to exit a monitor entered through a synchronized method or a monitorenter Java virtual machine instruction.

# LINKAGE:

Index 218 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . obj : a normal Java object or class object, must not be NULL .

# RETURNS:

Returns "0" on success; returns a negative value on failure.

# THROWS:

IllegalMonitorStateException : if the current thread does not own the monitor.

# NIO Support

The NIO-related entry points allow native code to access java.nio direct buffers . The contents of a direct buffer can, potentially, reside in native memory outside of the ordinary garbage-collected heap. For information about direct buffers, please see buffers in the NIO package and the specification of the java.nio.ByteBuffer class. Three functions allow JNI code to create, examine, and manipulate direct buffers: Every implementation of the Java virtual machine must support these functions, but not every implementation is required to support JNI access to direct buffers. If a JVM does not support such access then the NewDirectByteBuffer and GetDirectBufferAddress functions must always return NULL , and the GetDirectBufferCapacity function must always return -1 . If a JVM does support such access then these three functions must be implemented to return the appropriate values.

# NewDirectByteBuffer

jobject NewDirectByteBuffer(JNIEnv* env, void* address, jlong capacity); Allocates and returns a direct java.nio.ByteBuffer referring to the block of memory starting at the memory address address and extending capacity bytes. The byte order of the returned buffer is always big-endian (high byte first; java.nio.ByteOrder.BIG_ENDIAN ). Native code that calls this function and returns the resulting byte-buffer object to Java-level code should ensure that the buffer refers to a valid region of memory that is accessible for reading and, if appropriate, writing. An attempt to access an invalid memory location from Java code will either return an arbitrary value, have no visible effect, or cause an unspecified exception to be thrown.

# LINKAGE:

Index 229 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . address : the starting address of the memory region, must not be NULL . capacity : the size in bytes of the memory region, must be positive.

# RETURNS:

Returns a local reference to the newly-instantiated java.nio.ByteBuffer object. Returns NULL if an exception occurs, or if JNI access to direct buffers is not supported by this virtual machine.

# THROWS:

OutOfMemoryError : if allocation of the ByteBuffer object fails

# SINCE:

JDK/JRE 1.4

# GetDirectBufferAddress

void* GetDirectBufferAddress(JNIEnv* env, jobject buf); Fetches and returns the starting address of the memory region referenced by the given direct java.nio.Buffer . This function allows native code to access the same memory region that is accessible to Java code via the buffer object.

# LINKAGE:

Index 230 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . buf : a direct java.nio.Buffer object, must not be NULL .

# RETURNS:

Returns the starting address of the memory region referenced by the buffer. Returns NULL if the memory region is undefined, if the given object is not a direct java.nio.Buffer , or if JNI access to direct buffers is not supported by this virtual machine.

# SINCE:

JDK/JRE 1.4

# GetDirectBufferCapacity

jlong GetDirectBufferCapacity(JNIEnv* env, jobject buf); Fetches and returns the capacity of the memory region referenced by the given direct java.nio.Buffer . The capacity is the number of elements that the memory region contains.

# LINKAGE:

Index 231 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . buf : a direct java.nio.Buffer object, must not be NULL .

# RETURNS:

Returns the capacity of the memory region associated with the buffer. Returns -1 if the given object is not a direct java.nio.Buffer , if the object is an unaligned view buffer and the processor architecture does not support unaligned access, or if JNI access to direct buffers is not supported by this virtual machine.

# SINCE:

JDK/JRE 1.4

# Reflection Support

Programmers can use the JNI to call Java methods or access Java fields if they know the name and type of the methods or fields. The Java Core Reflection API allows programmers to introspect Java classes at runtime. JNI provides a set of conversion functions between field and method IDs used in the JNI to field and method objects used in the Java Core Reflection API.

# FromReflectedMethod

jmethodID FromReflectedMethod(JNIEnv *env, jobject method); Converts a java.lang.reflect.Method or java.lang.reflect.Constructor object to a method ID.

# LINKAGE:

Index 7 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . method : a java.lang.reflect.Method or java.lang.reflect.Constructor object, must not be NULL .

# RETURNS:

A JNI method ID that corresponds to the given Java reflection method, or NULL if the operation fails.

# SINCE:

JDK/JRE 1.2

# FromReflectedField

jfieldID FromReflectedField(JNIEnv *env, jobject field); Converts a java.lang.reflect.Field to a field ID.

# LINKAGE:

Index 8 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . field : a java.lang.reflect.Field object, must not be NULL .

# RETURNS:

A JNI field ID that corresponds to the given Java reflection field , or NULL if the operation fails.

# SINCE:

JDK/JRE 1.2

# ToReflectedMethod

jobject ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic); Converts a method ID derived from cls to a java.lang.reflect.Method or java.lang.reflect.Constructor object. isStatic must be set to JNI_TRUE if the method ID refers to a static field, and JNI_FALSE otherwise. Throws OutOfMemoryError and returns 0 if fails.

# LINKAGE:

Index 9 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . cls : a Java class object, must not be NULL . methodID : a method ID, must not be NULL . isStatic : denotes whether the given methodID is a static method.

# RETURNS:

Returns an instance of the java.lang.reflect.Method or java.lang.reflect.Constructor which corresponds to the given methodID , or NULL if the operation fails.

# SINCE:

JDK/JRE 1.2

# ToReflectedField

jobject ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic); Converts a field ID derived from cls to a java.lang.reflect.Field object. isStatic must be set to JNI_TRUE if fieldID refers to a static field, and JNI_FALSE otherwise. Throws OutOfMemoryError and returns 0 if fails.

# LINKAGE:

Index 12 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . cls : a Java class object, must not be NULL . fieldID : a field ID, must not be NULL . isStatic : denotes whether the given fieldID is a static field.

# RETURNS:

Returns an instance of the java.lang.reflect.Field which corresponds to the given fieldID , or NULL if the operation fails.

# SINCE:

JDK/JRE 1.2

# Java VM Interface

# GetJavaVM

jint GetJavaVM(JNIEnv *env, JavaVM **vm); Returns the Java VM interface (used in the Invocation API) associated with the current thread. The result is placed at the location pointed to by the second argument, vm .

# LINKAGE:

Index 219 in the JNIEnv interface function table.

# PARAMETERS:

env : the JNI interface pointer, must not be NULL . vm : a pointer to where the result should be placed, must not be NULL .

# RETURNS:


---


# Basic Packaging

URL: https://docs.oracle.com/en/java/javase/19/jpackage/basic-packaging.html



---


# Preface

URL: https://docs.oracle.com/en/java/javase/19/jpackage/preface.html



---


# Java Platform, Standard Edition Packaging Tool User's Guide, Release 19

URL: https://docs.oracle.com/en/java/javase/19/jpackage/index.html



---


# The jpackage Command

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/man/jpackage.html


# Name

jpackage - tool for packaging self-contained Java applications.

# Synopsis

jpackage [ options ]

# Description

The jpackage tool will take as input a Java application and a Java run-time image, and produce a Java application image that includes all the necessary dependencies. It will be able to produce a native package in a platform-specific format, such as an exe on Windows or a dmg on macOS. Each format must be built on the platform it runs on, there is no cross-platform support. The tool will have options that allow packaged applications to be customized in various ways.

# jpackage Options

# Generic Options:

Read options from a file. This option can be used multiple times. The type of package to create Valid values are: {"app-image", "exe", "msi", "rpm", "deb", "pkg", "dmg"} If this option is not specified a platform dependent default type will be created. Version of the application and/or package Copyright for the application Description of the application Print the usage text with a list and description of each valid option for the current platform to the output stream, and exit. Path of the icon of the application package (absolute path or relative to the current directory) Name of the application and/or package Path where generated output file is placed (absolute path or relative to the current directory). Defaults to the current working directory. Path of a new or empty directory used to create temporary files (absolute path or relative to the current directory) If specified, the temp dir will not be removed upon the task completion and must be removed manually. If not specified, a temporary directory will be created and removed upon the task completion. Vendor of the application Enables verbose output. Print the product version to the output stream and exit.

# Options for creating the runtime image:

A comma (",") separated list of modules to add This module list, along with the main module (if specified) will be passed to jlink as the --add-module argument. If not specified, either just the main module (if --module is specified), or the default set of modules (if --main-jar is specified) are used. This option can be used multiple times. A File.pathSeparator separated list of paths Each path is either a directory of modules or the path to a modular jar, and is absolute or relative to the current directory. This option can be used multiple times. A space separated list of options to pass to jlink If not specified, defaults to "--strip-native-commands --strip-debug --no-man-pages --no-header-files" This option can be used multiple times. Path of the predefined runtime image that will be copied into the application image (absolute path or relative to the current directory) If --runtime-image is not specified, jpackage will run jlink to create the runtime image using options specified by --jlink-options.

# Options for creating the application image:

Path of the input directory that contains the files to be packaged (absolute path or relative to the current directory) All files in the input directory will be packaged into the application image. A comma separated list of paths to files and/or directories to add to the application payload. This option can be used more than once.

# Options for creating the application launcher(s):

Name of launcher, and a path to a Properties file that contains a list of key, value pairs (absolute path or relative to the current directory) The keys "module", "main-jar", "main-class", "description", "arguments", "java-options", "app-version", "icon", "launcher-as-service", "win-console", "win-shortcut", "win-menu", "linux-app-category", and "linux-shortcut" can be used. These options are added to, or used to overwrite, the original command line options to build an additional alternative launcher. The main application launcher will be built from the command line options. Additional alternative launchers can be built using this option, and this option can be used multiple times to build multiple additional launchers. Command line arguments to pass to the main class if no command line arguments are given to the launcher This option can be used multiple times. Options to pass to the Java runtime This option can be used multiple times. Qualified name of the application main class to execute This option can only be used if --main-jar is specified. The main JAR of the application; containing the main class (specified as a path relative to the input path) Either --module or --main-jar option can be specified but not both. The main module (and optionally main class) of the application This module must be located on the module path. When this option is specified, the main module will be linked in the Java runtime image. Either --module or --main-jar option can be specified but not both.

# Platform dependent option for creating the application launcher:

# Windows platform options (available only when running on Windows):

Creates a console launcher for the application, should be specified for application which requires console interactions

# macOS platform options (available only when running on macOS):

An identifier that uniquely identifies the application for macOS Defaults to the main class name. May only use alphanumeric (A-Z,a-z,0-9), hyphen (-), and period (.) characters. Name of the application as it appears in the Menu Bar This can be different from the application name. This name must be less than 16 characters long and be suitable for displaying in the menu bar and the application Info window. Defaults to the application name. When signing the application package, this value is prefixed to all components that need to be signed that don't have an existing package identifier. Request that the package or the predefined application image be signed. Name of the keychain to search for the signing identity If not specified, the standard keychains are used. Team or user name portion in Apple signing identities Indicates that the jpackage output is intended for the Mac App Store. Path to file containing entitlements to use when signing executables and libraries in the bundle String used to construct LSApplicationCategoryType in application plist The default value is "utilities".

# Options for creating the application package:

URL of the application's home page Location of the predefined application image that is used to build an installable package (on all platforms) or to be signed (on macOS) (absolute path or relative to the current directory) Path to a Properties file that contains list of key, value pairs (absolute path or relative to the current directory) The keys "extension", "mime-type", "icon", and "description" can be used to describe the association. This option can be used multiple times. Absolute path of the installation directory of the application (on macOS or linux), or relative sub-path of the installation directory such as "Program Files" or "AppData" (on Windows) Path to the license file (absolute path or relative to the current directory) Path to override jpackage resources (absolute path or relative to the current directory) Icons, template files, and other resources of jpackage can be over-ridden by adding replacement resources to this directory. Path of the predefined runtime image to install (absolute path or relative to the current directory) Option is required when creating a runtime installer. Request to create an installer that will register the main application launcher as a background service-type application.

# Platform dependent options for creating the application package:

# Windows platform options (available only when running on Windows):

Adds a dialog to enable the user to choose a directory in which the product is installed. URL where user can obtain further information or technical support Request to add a Start Menu shortcut for this application Start Menu group this application is placed in Request to perform an install on a per-user basis Request to create a desktop shortcut for this application Adds a dialog to enable the user to choose if shortcuts will be created by installer URL of available application update information UUID associated with upgrades for this package

# Linux platform options (available only when running on Linux):

Name for Linux package Defaults to the application name. Maintainer for .deb bundle Menu group this application is placed in Required packages or capabilities for the application Type of the license ("License: value " of the RPM .spec) Release value of the RPM <name>.spec file or Debian revision value of the DEB control file Group value of the RPM / .spec file or Section value of DEB control file Creates a shortcut for the application.

# macOS platform options (available only when running on macOS):

Include all the referenced content in the dmg. This option can be used more than once.

# jpackage Examples

```

Generate an application package suitable for the host system:

```

```

For a modular application:
    jpackage -n name -p modulePath -m moduleName/className
For a non-modular application:
    jpackage -i inputDir -n name \
        --main-class className --main-jar myJar.jar
From a pre-built application image:
    jpackage -n name --app-image appImageDir

```

```

Generate an application image:

```

```

For a modular application:
    jpackage --type app-image -n name -p modulePath \
        -m moduleName/className
For a non-modular application:
    jpackage --type app-image -i inputDir -n name \
        --main-class className --main-jar myJar.jar
To provide your own options to jlink, run jlink separately:
    jlink --output appRuntimeImage -p modulePath \
        --add-modules moduleName \
        --no-header-files [<additional jlink options>...]
    jpackage --type app-image -n name \
        -m moduleName/className --runtime-image appRuntimeImage

```

```

Generate a Java runtime package:

```

```

jpackage -n name --runtime-image <runtime-image>

```

```

Sign the predefined application image (on macOS):

```

```

jpackage --type app-image --app-image <app-image> \
    --mac-sign [<additional signing options>...]

Note: the only additional options that are permitted in this mode are:
      the set of additional mac signing options and --verbose

```

# jpackage resource directory

Icons, template files, and other resources of jpackage can be over-ridden by adding replacement resources to this directory. jpackage will lookup files by specific names in the resource directory.

# Resource directory files considered only when running on Linux:

Application launcher icon Default resource is JavaApp.png A desktop file to be used with xdg-desktop-menu command Considered with application launchers registered for file associations and/or have an icon Default resource is template.desktop

# Resource directory files considered only when building Linux DEB/RPM installer:

systemd unit file for application launcher registered as a background service-type application Default resource is unit-template.service

# Resource directory files considered only when building Linux RPM installer:

RPM spec file Default resource is template.spec

# Resource directory files considered only when building Linux DEB installer:

Control file Default resource is template.control Copyright file Default resource is template.copyright Pre-install shell script Default resource is template.preinstall Pre-remove shell script Default resource is template.prerm Post-install shell script Default resource is template.postinstall Post-remove shell script Default resource is template.postrm

# Resource directory files considered only when running on Windows:

Application launcher icon Default resource is JavaApp.ico Properties file for application launcher executable Default resource is WinLauncher.template

# Resource directory files considered only when building Windows MSI/EXE installer:

A Windows Script File (WSF) to run after building application image Main WiX project file Default resource is main.wxs Overrides WiX project file Default resource is overrides.wxi Service installer executable Considered if some application launchers are registered as background service-type applications Service installer WiX project file Considered if some application launchers are registered as background service-type applications Default resource is service-install.wxi Service installer WiX project file Considered if some application launchers are registered as background service-type applications Default resource is service-config.wxi WiX project file for installer UI dialog checking installation directory doesn't exist or is empty Default resource is InstallDirNotEmptyDlg.wxs WiX project file for installer UI dialog configuring shortcuts Default resource is ShortcutPromptDlg.wxs WiX project file with the hierarchy of components of application image WiX project file for installer UI

# Resource directory files considered only when building Windows EXE installer:

Properties file for the installer executable Default resource is WinInstaller.template A Windows Script File (WSF) to run after building embedded MSI installer for EXE installer

# Resource directory files considered only when running on macOS:

Application launcher icon Default resource is JavaApp.icns Application property list file Default resource is Info-lite.plist.template Java Runtime property list file Default resource is Runtime-Info.plist.template Signing entitlements property list file Default resource is sandbox.plist

# Resource directory files considered only when building macOS PKG/DMG installer:

Shell script to run after building application image

# Resource directory files considered only when building macOS PKG installer:

Uninstaller shell script Considered if some application launchers are registered as background service-type applications Default resource is uninstall.command.template Pre-install shell script Default resource is preinstall.template Post-install shell script Default resource is postinstall.template Pre-install shell script for services package Considered if some application launchers are registered as background service-type applications Default resource is services-preinstall.template Post-install shell script for services package Considered if some application launchers are registered as background service-type applications Default resource is services-postinstall.template Background image Default resource is background_pkg.png Dark background image Default resource is background_pkg.png Package property list file Default resource is product-def.plist launchd property list file for application launcher registered as a background service-type application Default resource is launchd.plist.template

# Resource directory files considered only when building macOS DMG installer:


---


# Structure Overview

URL: https://docs.oracle.com/en/java/javase/19/docs/specs/jpda/architecture.html


# Structure Overview

The Java Platform Debugger Architecture is structured as follows:

```

Components                          Debugger Interfaces

                /    |--------------|
               /     |
VM
|
debuggee
----(      |--------------|  <-------
JVM TI
- Java VM Tool Interface
               \     |
back-end
|
                \    |--------------|
                /           |
comm channel
-(            |  <---------------
JDWP
- Java Debug Wire Protocol
                \           |
                     |--------------|
                     |
front-end
|
                     |--------------|  <-------
JDI
- Java Debug Interface
                     |
UI
|
                     |--------------|

```

# What is the Java Platform Debugger Architecture (JPDA)?

JPDA is a multi-tiered debugging architecture that allows tools developers to easily create debugger applications which run portably across platforms, virtual machine (VM) implementations and JDK versions. JPDA consists of three layers:

# Reference implementation

In addition to the specification of these interfaces, Oracle also provides a reference implementation, which consists of: This provides a layered implementation in which any layer may be substituted.

# Using JPDA

A debugger developer may hook into JPDA at any layer. Since the JDI is the highest level and easiest to use we encourage developers to use this interface. Suppose a company develops a debugger using JDI. They can use it with the reference implementation and it will automatically work with the VMs and platforms that Oracle supports. It can also work, for example, with the reference implementation front-end and a debuggee running another company's VM that implements JDWP (which might use or by-pass JVM TI). Some debuggers are built on top of lower layers, JDWP (for example if the front-end is not written in the Java language) or JVM TI (for specialized debuggers which need low-level functionality).

# Components

# debuggee

The debuggee is the process being debugged, it consists of the application being debugged (not shown), the VM running the application and the back-end of the debugger.

# Java Virtual Machine (VM)

This refers to the VM running the application being debugged. The debugger architecture is being designed for use in wide spectrum of VM implementations. The VM implements the Java Virtual Machine Tool Interface ( JVM TI ).

# back-end

The back-end of the debugger is responsible for communicating requests from the debugger front-end to the debuggee VM and for communicating the response to these requests (including desired events) to the front-end. The back-end communicates with the front-end over a communications channel using the Java Debug Wire Protocol ( JDWP ). The back-end communicates with the debuggee VM using the Java Virtual Machine Tool Interface ( JVM TI ). It is clear from experience that debugger support code, running on the debuggee and written in Java, contends with the debuggee in ways that cause hangs and other undesired behavior. Thus, the back-end is native code. This, in turn, implies that the JVM TI be a pure native interface.

# communications channel

The communications channel is the link between the front and back ends of the debugger. It can be thought of as consisting of two mechanisms: A connector. A connector is a JDI object that is the means by which a connection is established between the front and back-ends. JPDA defines three types of connectors: A transport. A transport is the underlying mechanism used to move bits between the front-end and the back-end. The transport mechanism used is unspecified; possible mechanisms include: sockets, serial lines, and shared memory. However, the format and semantics of the serialized bit-stream flowing over the channel is specified by the Java Debug Wire Protocol (JDWP). JPDA includes service provider interfaces to allow the development and deployment of connector and transport implementations. These service provider interfaces allow debugger and other tool vendors to develop new connector implementations and provide addition transport mechanisms over and beyond the socket and shared memory transport provided by Oracle. The service provider interfaces in JDI are specified in the com.sun.jdi.connect.spi package. In addition to the service provider interfaces in JDI, JPDA also defines a transport library interface called the Java Debug Wire Protocol Transport Interface . A transport library is loaded by the JDWP agent in the target VM and is used to establish a connection to the debugger and to transport JDWP packets between the debugger and the VM. See Java Platform Debugger Architecture - Service Provider Interfaces for more information on using these SPIs.

# front-end

The debugger front-end implements the high-level Java Debug Interface ( JDI ). The front-end uses the information from the low-level Java Debug Wire Protocol ( JDWP ).

# User Interface (UI)

The user interface to the debugger is not specified; the intent is that tool vendors will provide value added implementations. We provide an example simple graphical user interface (GUI) which serves as test harness and as a starting point for the development of more complex GUIs. A version of JDB is also available as an example. The example UIs are clients of the Java Debug Interface ( JDI ).

# Debugger Interfaces

# Java Virtual Machine Tool Interface (JVM TI)

A native interface implemented by the VM . Defines the services a VM must provide for debugging. Includes requests for information (for example, current stack frame), actions (for example, set a breakpoint), and notification (for example, when a breakpoint has been hit). A debugger may make use of VM information other than this (for example, Java Native Interface (JNI)), but this is the source of all debugger specific information. Specifying the VM Interface allows any VM implementor to plug easily into the debugging architecture. It also allows alternate communication channel implementations. VM implementations which do not adhere to this interface can still provide access via the Java Debug Wire Protocol ( JDWP ). See also: JVM TI Specification

# Java Debug Wire Protocol (JDWP)

Defines the format of information and requests transferred between the debuggee process and the debugger front-end . It does not define the transport mechanism (socket, serial line, shared memory, ...). The specification of the protocol allows the debuggee and debugger front-end to run under separate VM implementations and/or on separate platforms. It also allows the front-end to be written in a language other than Java, or the debuggee to be non-native (e.g. Java). Information and requests are roughly at the level of the Java Virtual Machine Debug Interface ( JVM TI ), but will include additional information and requests necessitated by bandwidth issues, examples include information filtering and batching. See also: JDWP Specification JDWP Transport Specification

# Java Debug Interface (JDI)


---


# Class (Java SE 19 & JDK 19)

URL: https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Class.html


# Class Class<T>

Class has no public constructor. Instead a Class object is constructed automatically by the Java Virtual Machine when a class is derived from the bytes of a class file through the invocation of one of the following methods: ClassLoader::defineClass java.lang.invoke.MethodHandles.Lookup::defineClass java.lang.invoke.MethodHandles.Lookup::defineHiddenClass The methods of class Class expose many characteristics of a class or interface. Most characteristics are derived from the class file that the class loader passed to the Java Virtual Machine or from the class file passed to Lookup::defineClass or Lookup::defineHiddenClass . A few characteristics are determined by the class loading environment at run time, such as the module returned by getModule() . The following example uses a Class object to print the class name of an object: void printClassName(Object obj) { System.out.println("The class of " + obj + " is " + obj.getClass().getName()); } It is also possible to get the Class object for a named class or interface (or for void ) using a class literal . For example: System.out.println("The name of class Foo is: "+Foo.class.getName());

```

void printClassName(Object obj) {
         System.out.println("The class of " + obj +
                            " is " + obj.getClass().getName());
     }

```

Some methods of class Class expose whether the declaration of a class or interface in Java source code was enclosed within another declaration. Other methods describe how a class or interface is situated in a nest . A nest is a set of classes and interfaces, in the same run-time package, that allow mutual access to their private members. The classes and interfaces are known as nestmates . One nestmate acts as the nest host , and enumerates the other nestmates which belong to the nest; each of them in turn records it as the nest host. The classes and interfaces which belong to a nest, including its host, are determined when class files are generated, for example, a Java compiler will typically record a top-level class as the host of a nest where the other members are the classes and interfaces whose declarations are enclosed within the top-level class declaration. A class or interface created by the invocation of Lookup::defineHiddenClass is a hidden class or interface. All kinds of class, including enum classes and record classes, may be hidden classes; all kinds of interface, including annotation interfaces, may be hidden interfaces. The name of a hidden class or interface is not a binary name , which means the following: A hidden class or interface cannot be referenced by the constant pools of other classes and interfaces. A hidden class or interface cannot be described in nominal form by Class::describeConstable , ClassDesc::of , or ClassDesc::ofDescriptor . A hidden class or interface cannot be discovered by Class::forName or ClassLoader::loadClass . A hidden class or interface is never an array class, but may be the element type of an array. In all other respects, the fact that a class or interface is hidden has no bearing on the characteristics exposed by the methods of class Class .

# Nested Class Summary

# Nested classes/interfaces declared in interface java.lang.invoke.TypeDescriptor

# Method Summary

# Methods declared in class java.lang.Object

# Method Details

# toString

# toGenericString

Note that since information about the runtime representation of a type is being generated, modifiers not present on the originating source code or illegal on the originating source code may be present.

# forName

For example, the following code fragment returns the runtime Class descriptor for the class named java.lang.Thread : Class t = Class.forName("java.lang.Thread") A call to forName("X") causes the class named X to be initialized. In cases where this method is called from a context where there is no caller frame on the stack (e.g. when called directly from a JNI attached thread), the system class loader is used.

# forName

If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name . Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void. If name denotes an array class, the component type of the array class is loaded but not initialized. For example, in an instance method the expression: Class.forName("Foo") is equivalent to: Class.forName("Foo", true, this.getClass().getClassLoader()) Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2 , 12.3 , and 12.4 of The Java Language Specification . Note that this method does not check whether the requested class is accessible to its caller.

# forName

This method attempts to locate and load the class or interface. It does not link the class, and does not run the class initializer. If the class is not found, this method returns null . If the class loader of the given module defines other modules and the given name is a class defined in a different module, this method returns null after the class is loaded. This method does not check whether the requested class is accessible to its caller.

# newInstance

The call clazz.newInstance() can be replaced by clazz.getDeclaredConstructor().newInstance() The latter sequence of calls is inferred to be able to throw the additional exception types InvocationTargetException and NoSuchMethodException . Both of these exception types are subclasses of ReflectiveOperationException .

```

clazz.newInstance()

```

```

clazz.getDeclaredConstructor().newInstance()

```

# isInstance

Specifically, if this Class object represents a declared class, this method returns true if the specified Object argument is an instance of the represented class (or of any of its subclasses); it returns false otherwise. If this Class object represents an array class, this method returns true if the specified Object argument can be converted to an object of the array class by an identity conversion or by a widening reference conversion; it returns false otherwise. If this Class object represents an interface, this method returns true if the class or any superclass of the specified Object argument implements this interface; it returns false otherwise. If this Class object represents a primitive type, this method returns false .

# isAssignableFrom

Specifically, this method tests whether the type represented by the specified Class parameter can be converted to the type represented by this Class object via an identity conversion or via a widening reference conversion. See The Java Language Specification , sections 5.1.1 and 5.1.4 , for details.

# isInterface

# isArray

# isPrimitive

There are nine predefined Class objects to represent the eight primitive types and void. These are created by the Java Virtual Machine, and have the same names as the primitive types that they represent, namely boolean , byte , char , short , int , long , float , and double . These objects may only be accessed via the following public static final variables, and are the only Class objects for which this method returns true .

# isAnnotation

# isSynthetic

# getName

If this Class object represents a class or interface, not an array class, then: If the class or interface is not hidden , then the binary name of the class or interface is returned. If the class or interface is hidden, then the result is a string of the form: N + '/' + <suffix> where N is the binary name indicated by the class file passed to Lookup::defineHiddenClass , and <suffix> is an unqualified name. If this Class object represents an array class, then the result is a string consisting of one or more ' [ ' characters representing the depth of the array nesting, followed by the element type as encoded using the following table: Element types and encodings Element Type Encoding boolean Z byte B char C class or interface with binary name N L N ; double D float F int I long J short S If this Class object represents a primitive type or void , then the result is a string with the same spelling as the Java language keyword which corresponds to the primitive type or void . Examples: String.class.getName() returns "java.lang.String" byte.class.getName() returns "byte" (new Object[3]).getClass().getName() returns "[Ljava.lang.Object;" (new int[3][4][5][6][7][8][9]).getClass().getName() returns "[[[[[[[I"

```

String.class.getName()
     returns "java.lang.String"
 byte.class.getName()
     returns "byte"
 (new Object[3]).getClass().getName()
     returns "[Ljava.lang.Object;"
 (new int[3][4][5][6][7][8][9]).getClass().getName()
     returns "[[[[[[[I"

```

# getClassLoader

If this Class object represents a primitive type or void, null is returned.

# getModule

# getTypeParameters

# getSuperclass

# getGenericSuperclass

If the superclass is a parameterized type, the Type object returned must accurately reflect the actual type arguments used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of ParameterizedType for the semantics of the creation process for parameterized types. If this Class object represents either the Object class, an interface, a primitive type, or void, then null is returned. If this Class object represents an array class then the Class object representing the Object class is returned.

# getPackage

If this class represents an array type, a primitive type or void, this method returns null .

# getPackageName

If this class is a top level class, then this method returns the fully qualified name of the package that the class is a member of, or the empty string if the class is in an unnamed package. If this class is a member class, then this method is equivalent to invoking getPackageName() on the enclosing class . If this class is a local class or an anonymous class , then this method is equivalent to invoking getPackageName() on the declaring class of the enclosing method or enclosing constructor . If this class represents an array type then this method returns the package name of the element type. If this class represents a primitive type or void then the package name " java.lang " is returned.

# getInterfaces

If this Class object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the implements clause of the declaration of the class represented by this Class object. For example, given the declaration: class Shimmer implements FloorWax, DessertTopping { ... } suppose the value of s is an instance of Shimmer ; the value of the expression: s.getClass().getInterfaces()[0] is the Class object that represents interface FloorWax ; and the value of: s.getClass().getInterfaces()[1] is the Class object that represents interface DessertTopping . If this Class object represents an interface, the array contains objects representing all interfaces directly extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the extends clause of the declaration of the interface represented by this Class object. If this Class object represents a class or interface that implements no interfaces, the method returns an array of length 0. If this Class object represents a primitive type or void, the method returns an array of length 0. If this Class object represents an array type, the interfaces Cloneable and java.io.Serializable are returned in that order.

# getGenericInterfaces

If a superinterface is a parameterized type, the Type object returned for it must accurately reflect the actual type arguments used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of ParameterizedType for the semantics of the creation process for parameterized types. If this Class object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the implements clause of the declaration of the class represented by this Class object. If this Class object represents an interface, the array contains objects representing all interfaces directly extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the extends clause of the declaration of the interface represented by this Class object. If this Class object represents a class or interface that implements no interfaces, the method returns an array of length 0. If this Class object represents a primitive type or void, the method returns an array of length 0. If this Class object represents an array type, the interfaces Cloneable and java.io.Serializable are returned in that order.

# getComponentType

# getModifiers

If the underlying class is an array class, then its public , private and protected modifiers are the same as those of its component type. If this Class object represents a primitive type or void, its public modifier is always true , and its protected and private modifiers are always false . If this Class object represents an array class, a primitive type or void, then its final modifier is always true and its interface modifier is always false . The values of its other modifiers are not determined by this specification. The modifier encodings are defined in section 4.1 of The Java Virtual Machine Specification .

# getSigners

# getEnclosingMethod

# getEnclosingConstructor

# getDeclaringClass

# getEnclosingClass

# getSimpleName

The simple name of an array class is the simple name of the component type with "[]" appended. In particular the simple name of an array class whose component type is anonymous is "[]".

# getTypeName

# getCanonicalName

An array type has a canonical name if and only if its component type has a canonical name. When an array type has a canonical name, it is equal to the canonical name of the component type followed by " [] ".

# isAnonymousClass

# isLocalClass

# isMemberClass

# getClasses

# getFields

If this Class object represents a class or interface with no accessible public fields, then this method returns an array of length 0. If this Class object represents a class, then this method returns the public fields of the class and of all its superclasses and superinterfaces. If this Class object represents an interface, then this method returns the fields of the interface and of all its superinterfaces. If this Class object represents an array type, a primitive type, or void, then this method returns an array of length 0. The elements in the returned array are not sorted and are not in any particular order.

# getMethods

If this Class object represents an array type, then the returned array has a Method object for each of the public methods inherited by the array type from Object . It does not contain a Method object for clone() . If this Class object represents an interface then the returned array does not contain any implicitly declared methods from Object . Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a Class object which represents a class always has public methods, inherited from Object .) The returned array never contains methods with names " <init> " or " <clinit> ". The elements in the returned array are not sorted and are not in any particular order. Generally, the result is computed as with the following 4 step algorithm. Let C be the class or interface represented by this Class object: A union of methods is composed of: C's declared public instance and static methods as returned by getDeclaredMethods() and filtered to include only public methods. If C is a class other than Object , then include the result of invoking this algorithm recursively on the superclass of C. Include the results of invoking this algorithm recursively on all direct superinterfaces of C, but include only instance methods. Union from step 1 is partitioned into subsets of methods with same signature (name, parameter types) and return type. Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if: N is declared by a class and M is declared by an interface; or N and M are both declared by classes or both by interfaces and N's declaring type is the same as or a subtype of M's declaring type (clearly, if M's and N's declaring types are the same type, then M and N are the same method). The result of this algorithm is the union of all selected methods from step 3.

# getConstructors

# getField

The field to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this Class object: If C declares a public field with the name specified, that is the field to be reflected. If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared. If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a NoSuchFieldException is thrown. If this Class object represents an array type, then this method does not find the length field of the array type.

# getMethod

If this Class object represents an array type, then this method finds any public method inherited by the array type from Object except method clone() . If this Class object represents an interface then this method does not find any implicitly declared method from Object . Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces, then this method does not find any method. This method does not find any method with name " <init> " or " <clinit> ". Generally, the method to be reflected is determined by the 4 step algorithm that follows. Let C be the class or interface represented by this Class object: A union of methods is composed of: C's declared public instance and static methods as returned by getDeclaredMethods() and filtered to include only public methods that match given name and parameterTypes If C is a class other than Object , then include the result of invoking this algorithm recursively on the superclass of C. Include the results of invoking this algorithm recursively on all direct superinterfaces of C, but include only instance methods. This union is partitioned into subsets of methods with same return type (the selection of methods from step 1 also guarantees that they have the same method name and parameter types). Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if: N is declared by a class and M is declared by an interface; or N and M are both declared by classes or both by interfaces and N's declaring type is the same as or a subtype of M's declaring type (clearly, if M's and N's declaring types are the same type, then M and N are the same method). The result of this algorithm is chosen arbitrarily from the methods with most specific return type among all selected methods from step 3. Let R be a return type of a method M from the set of all selected methods from step 3. M is a method with most specific return type if there is no such method N != M from the same set, having return type S != R, such that S is a subtype of R as determined by R.class. isAssignableFrom(java.lang.Class<?>) (S.class).

# getConstructor

The constructor to reflect is the public constructor of the class represented by this Class object whose formal parameter types match those specified by parameterTypes .

# getDeclaredClasses

# getDeclaredFields

If this Class object represents a class or interface with no declared fields, then this method returns an array of length 0. If this Class object represents an array type, a primitive type, or void, then this method returns an array of length 0. The elements in the returned array are not sorted and are not in any particular order.

# getRecordComponents

The components are returned in the same order that they are declared in the record header. The array is empty if this record class has no components. If the class is not a record class, that is isRecord() returns false , then this method returns null . Conversely, if isRecord() returns true , then this method returns a non-null value. The following method can be used to find the record canonical constructor: static <T extends Record> Constructor<T> getCanonicalConstructor(Class<T> cls) throws NoSuchMethodException { Class<?>[] paramTypes = Arrays.stream(cls.getRecordComponents()) .map(RecordComponent::getType) .toArray(Class<?>[]::new); return cls.getDeclaredConstructor(paramTypes); }

```

static <T extends Record> Constructor<T> getCanonicalConstructor(Class<T> cls)
     throws NoSuchMethodException {
   Class<?>[] paramTypes =
     Arrays.stream(cls.getRecordComponents())
           .map(RecordComponent::getType)
           .toArray(Class<?>[]::new);
   return cls.getDeclaredConstructor(paramTypes);
 }

```

# getDeclaredMethods

If this Class object represents a class or interface that has multiple declared methods with the same name and parameter types, but different return types, then the returned array has a Method object for each such method. If this Class object represents a class or interface that has a class initialization method <clinit> , then the returned array does not have a corresponding Method object. If this Class object represents a class or interface with no declared methods, then the returned array has length 0. If this Class object represents an array type, a primitive type, or void, then the returned array has length 0. The elements in the returned array are not sorted and are not in any particular order.

# getDeclaredConstructors

# getDeclaredField

If this Class object represents an array type, then this method does not find the length field of the array type.

# getDeclaredMethod

If this Class object represents an array type, then this method does not find the clone() method.

# getDeclaredConstructor

# getResourceAsStream

If this class is in a named Module then this method will attempt to find the resource in the module. This is done by delegating to the module's class loader findResource(String,String) method, invoking it with the module name and the absolute name of the resource. Resources in named modules are subject to the rules for encapsulation specified in the Module getResourceAsStream method and so this method returns null when the resource is a non-" .class " resource in a package that is not open to the caller's module. Otherwise, if this class is not in a named module then the rules for searching resources associated with a given class are implemented by the defining class loader of the class. This method delegates to this Class object's class loader. If this Class object was loaded by the bootstrap class loader, the method delegates to ClassLoader.getSystemResourceAsStream(java.lang.String) . Before delegation, an absolute resource name is constructed from the given resource name using this algorithm: If the name begins with a '/' ( '\u002f' ), then the absolute name of the resource is the portion of the name following the '/' . Otherwise, the absolute name is of the following form: modified_package_name/name Where the modified_package_name is the package name of this object with '/' substituted for '.' ( '\u002e' ). Where the modified_package_name is the package name of this object with '/' substituted for '.' ( '\u002e' ).

# getResource

If this class is in a named Module then this method will attempt to find the resource in the module. This is done by delegating to the module's class loader findResource(String,String) method, invoking it with the module name and the absolute name of the resource. Resources in named modules are subject to the rules for encapsulation specified in the Module getResourceAsStream method and so this method returns null when the resource is a non-" .class " resource in a package that is not open to the caller's module. Otherwise, if this class is not in a named module then the rules for searching resources associated with a given class are implemented by the defining class loader of the class. This method delegates to this Class object's class loader. If this Class object was loaded by the bootstrap class loader, the method delegates to ClassLoader.getSystemResource(java.lang.String) . Before delegation, an absolute resource name is constructed from the given resource name using this algorithm: If the name begins with a '/' ( '\u002f' ), then the absolute name of the resource is the portion of the name following the '/' . Otherwise, the absolute name is of the following form: modified_package_name/name Where the modified_package_name is the package name of this object with '/' substituted for '.' ( '\u002e' ). Where the modified_package_name is the package name of this object with '/' substituted for '.' ( '\u002e' ).

# getProtectionDomain

# desiredAssertionStatus

# isEnum

# isRecord

The direct superclass of a record class is java.lang.Record . A record class is final . A record class has (possibly zero) record components; getRecordComponents() returns a non-null but possibly empty value for a record. Note that class Record is not a record class and thus invoking this method on class Record returns false .

# getEnumConstants

# cast

# asSubclass

This method is useful when a client needs to "narrow" the type of a Class object to pass it to an API that restricts the Class objects that it is willing to accept. A cast would generate a compile-time warning, as the correctness of the cast could not be checked at runtime (because generic types are implemented by erasure).

# getAnnotation

Note that any annotation returned by this method is a declaration annotation.

# isAnnotationPresent

The truth value returned by this method is equivalent to: getAnnotation(annotationClass) != null

# getAnnotationsByType

Note that any annotations returned by this method are declaration annotations.

# getAnnotations

Note that any annotations returned by this method are declaration annotations.

# getDeclaredAnnotation

Note that any annotation returned by this method is a declaration annotation.

# getDeclaredAnnotationsByType

Note that any annotations returned by this method are declaration annotations.

# getDeclaredAnnotations

Note that any annotations returned by this method are declaration annotations.

# getAnnotatedSuperclass

If this Class object represents a class whose declaration does not explicitly indicate an annotated superclass, then the return value is an AnnotatedType object representing an element with no annotations. If this Class represents either the Object class, an interface type, an array type, a primitive type, or void, the return value is null .

# getAnnotatedInterfaces

If this Class object represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this Class object. If this Class object represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this Class object. If this Class object represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0. If this Class object represents either the Object class, an array type, a primitive type, or void, the return value is an array of length 0.

# getNestHost

If this Class object represents a primitive type, an array type, or void , then this method returns this , indicating that the represented entity belongs to the nest consisting only of itself, and is the nest host.

# isNestmateOf

# getNestMembers

If this Class object represents a primitive type, an array type, or void , then this method returns a single-element array containing this .

# descriptorString

If this Class object represents a class or interface, not an array class, then: If the class or interface is not hidden , then the result is a field descriptor (JVMS 4.3.2 ) for the class or interface. Calling ClassDesc::ofDescriptor with the result descriptor string produces a ClassDesc describing this class or interface. If the class or interface is hidden , then the result is a string of the form: "L" + N + "." + <suffix> + ";" where N is the binary name encoded in internal form indicated by the class file passed to Lookup::defineHiddenClass , and <suffix> is an unqualified name. A hidden class or interface has no nominal descriptor . The result string is not a type descriptor. If this Class object represents an array class, then the result is a string consisting of one or more ' [ ' characters representing the depth of the array nesting, followed by the descriptor string of the element type. If the element type is not a hidden class or interface, then this array class can be described nominally. Calling ClassDesc::ofDescriptor with the result descriptor string produces a ClassDesc describing this array class. If the element type is a hidden class or interface, then this array class cannot be described nominally. The result string is not a type descriptor. If this Class object represents a primitive type or void , then the result is a field descriptor string which is a one-letter code corresponding to a primitive type or void ( "B", "C", "D", "F", "I", "J", "S", "Z", "V" ) (JVMS 4.3.2 ).

# componentType

# arrayType

# describeConstable

# isHidden

# getPermittedSubclasses

# isSealed


---


# MethodHandles.Lookup (Java SE 19 & JDK 19)

URL: https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html


# Class MethodHandles.Lookup

A lookup class which needs to create method handles will call MethodHandles.lookup to create a factory for itself. When the Lookup factory object is created, the identity of the lookup class is determined, and securely stored in the Lookup object. The lookup class (or its delegates) may then use factory methods on the Lookup object to create method handles for access-checked members. This includes all methods, constructors, and fields which are allowed to the lookup class, even private ones.

# Lookup Factory Methods

The bytecode behavior for a findClass operation is a load of a constant class, as if by ldc CONSTANT_Class . The behavior is represented, not as a method handle, but directly as a Class constant. In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of variable arity . In all other cases, the returned method handle will be of fixed arity. Discussion: The equivalence between looked-up method handles and underlying class members and bytecode behaviors can break down in a few ways: If C is not symbolically accessible from the lookup class's loader, the lookup can still succeed, even when there is no equivalent Java expression or bytecoded constant. Likewise, if T or MT is not symbolically accessible from the lookup class's loader, the lookup can still succeed. For example, lookups for MethodHandle.invokeExact and MethodHandle.invoke will always succeed, regardless of requested type. If there is a security manager installed, it can forbid the lookup on various grounds ( see below ). By contrast, the ldc instruction on a CONSTANT_MethodHandle constant is not subject to security manager checks. If the looked-up method has a very large arity , the method handle creation may fail with an IllegalArgumentException , due to the method handle type having too many parameters.

# Access checking

All access checks start from a Lookup object, which compares its recorded lookup class against all requests to create method handles. A single Lookup object can be used to create any number of access-checked method handles, all checked against a single lookup class. A Lookup object can be shared with other trusted code, such as a metaobject protocol. A shared Lookup object delegates the capability to create method handles on private members of the lookup class. Even if privileged code uses the Lookup object, the access checking is confined to the privileges of the original lookup class. A lookup can fail, because the containing class is not accessible to the lookup class, or because the desired class member is missing, or because the desired class member is not accessible to the lookup class, or because the lookup object is not trusted enough to access the member. In the case of a field setter function on a final field, finality enforcement is treated as a kind of access control, and the lookup will fail, except in special cases of Lookup.unreflectSetter . In any of these cases, a ReflectiveOperationException will be thrown from the attempted lookup. The exact class will be one of the following: NoSuchMethodException  if a method is requested but does not exist NoSuchFieldException  if a field is requested but does not exist IllegalAccessException  if the member exists but an access check fails In general, the conditions under which a method handle may be looked up for a method M are no more restrictive than the conditions under which the lookup class could have compiled, verified, and resolved a call to M . Where the JVM would raise exceptions like NoSuchMethodError , a method handle lookup will generally raise a corresponding checked exception, such as NoSuchMethodException . And the effect of invoking the method handle resulting from the lookup is exactly equivalent to executing the compiled, verified, and resolved call to M . The same point is true of fields and constructors. Discussion: Access checks only apply to named and reflected methods, constructors, and fields. Other method handle creation methods, such as MethodHandle.asType , do not require any access checks, and are used independently of any Lookup object. If the desired member is protected , the usual JVM rules apply, including the requirement that the lookup class must either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections 4.9.2 , 5.4.3.5 , and 6.4 .) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading this parameter from C (which will necessarily be a superclass of the lookup class) to the lookup class itself. The JVM imposes a similar requirement on invokespecial instruction, that the receiver argument must match both the resolved method and the current class. Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle. (See the Java Virtual Machine Specification, section 4.10.1.9 .) The JVM represents constructors and static initializer blocks as internal methods with special names ( "<init>" and "<clinit>" ). The internal syntax of invocation instructions allows them to refer to such internal methods as if they were normal methods, but the JVM bytecode verifier rejects them. A lookup of such an internal method will produce a NoSuchMethodException . If the relationship between nested types is expressed directly through the NestHost and NestMembers attributes (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29 ), then the associated Lookup object provides direct access to the lookup class and all of its nestmates (see Class.getNestHost ). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class C.D can access private members within other related classes such as C , C.D.E , or C.B , but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a Lookup object on C.E would be unable to access those private members. A workaround for this limitation is the Lookup.in method, which can transform a lookup on C.E into one on any of those other classes, without special elevation of privilege. The accesses permitted to a given lookup object may be limited, according to its set of lookupModes , to a subset of members normally accessible to the lookup class. For example, the publicLookup method produces a lookup object which is only allowed to access public members in public classes of exported packages. The caller sensitive method lookup produces a lookup object with full capabilities relative to its caller class, to emulate all supported bytecode behaviors. Also, the Lookup.in method may produce a lookup object with fewer access modes than the original lookup object. Discussion of private and module access: We say that a lookup has private access if its lookup modes include the possibility of accessing private members (which includes the private members of nestmates). As documented in the relevant methods elsewhere, only lookups with private access possess the following capabilities: access private fields, methods, and constructors of the lookup class and its nestmates create method handles which emulate invokespecial instructions avoid package access checks for classes accessible to the lookup class create delegated lookup objects which have private access to other classes within the same package member Similarly, a lookup with module access ensures that the original lookup creator was a member in the same module as the lookup class. Private and module access are independently determined modes; a lookup may have either or both or neither. A lookup which possesses both access modes is said to possess full privilege access . A lookup with original access ensures that this lookup is created by the original lookup class and the bootstrap method invoked by the VM. Such a lookup with original access also has private and module access which has the following additional capability: create method handles which invoke caller sensitive methods, such as Class.forName obtain the class data associated with the lookup class Each of these permissions is a consequence of the fact that a lookup object with private access can be securely traced back to an originating class, whose bytecode behaviors and Java language access permissions can be reliably determined and emulated by method handles.

# Cross-module lookups

A Lookup on C can also teleport to a target class via Lookup.in and MethodHandles.privateLookupIn methods. Teleporting across modules will always record the original lookup class as the previous lookup class and drops MODULE access. If the target class is in the same module as the lookup class C , then the target class becomes the new lookup class and there is no change to the previous lookup class. If the target class is in a different module from M1 ( C 's module), C becomes the new previous lookup class and the target class becomes the new lookup class. In that case, if there was already a previous lookup class in M0 , and it differs from M1 and M2 , then the resulting lookup drops all privileges. For example, Lookup lookup = MethodHandles.lookup(); // in class C Lookup lookup2 = lookup.in(D.class); MethodHandle mh = lookup2.findStatic(E.class, "m", MT);

```

Lookup lookup = MethodHandles.lookup();   // in class C
 Lookup lookup2 = lookup.in(D.class);
 MethodHandle mh = lookup2.findStatic(E.class, "m", MT);

```

The MethodHandles.lookup() factory method produces a Lookup object with null previous lookup class. lookup.in(D.class) transforms the lookup on class C to class D without elevation of privileges. If C and D are in the same module, lookup2 records D as the new lookup class and keeps the same previous lookup class as the original lookup , or null if not present. When a Lookup teleports from a class in one nest to another nest, PRIVATE access is dropped. When a Lookup teleports from a class in one package to another package, PACKAGE access is dropped. When a Lookup teleports from a class in one module to another module, MODULE access is dropped. Teleporting across modules drops the ability to access non-exported classes in both the module of the new lookup class and the module of the old lookup class and the resulting Lookup remains only PUBLIC access. A Lookup can teleport back and forth to a class in the module of the lookup class and the module of the previous class lookup. Teleporting across modules can only decrease access but cannot increase it. Teleporting to some third module drops all accesses. In the above example, if C and D are in different modules, lookup2 records D as its lookup class and C as its previous lookup class and lookup2 has only PUBLIC access. lookup2 can teleport to other class in C 's module and D 's module. If class E is in a third module, lookup2.in(E.class) creates a Lookup on E with no access and lookup2 's lookup class D is recorded as its previous lookup class. Teleporting across modules restricts access to the public types that both the lookup class and the previous lookup class can equally access (see below). MethodHandles.privateLookupIn(T.class, lookup) can be used to teleport a lookup from class C to class T and create a new Lookup with private access if the lookup class is allowed to do deep reflection on T . The lookup must have MODULE and PRIVATE access to call privateLookupIn . A lookup on C in module M1 is allowed to do deep reflection on all classes in M1 . If T is in M1 , privateLookupIn produces a new Lookup on T with full capabilities. A lookup on C is also allowed to do deep reflection on T in another module M2 if M1 reads M2 and M2 opens the package containing T to at least M1 . T becomes the new lookup class and C becomes the new previous lookup class and MODULE access is dropped from the resulting Lookup . The resulting Lookup can be used to do member lookup or teleport to another lookup class by calling Lookup::in . But it cannot be used to obtain another private Lookup by calling privateLookupIn because it has no MODULE access.

# Cross-module access checks

A Lookup with UNCONDITIONAL mode can access public type in all modules when the type is in a package that is exported unconditionally . If a Lookup on LC in M1 has no previous lookup class, the lookup with PUBLIC mode can access all public types in modules that are readable to M1 and the type is in a package that is exported at least to M1 . If a Lookup on LC in M1 has a previous lookup class PLC on M0 , the lookup with PUBLIC mode can access the intersection of all public types that are accessible to M1 with all public types that are accessible to M0 . M0 reads M1 and hence the set of accessible types includes: unconditional-exported packages from M1 unconditional-exported packages from M0 if M1 reads M0 unconditional-exported packages from a third module M2 if both M0 and M1 read M2 qualified-exported packages from M1 to M0 qualified-exported packages from M0 to M1 if M1 reads M0 qualified-exported packages from a third module M2 to both M0 and M1 if both M0 and M1 read M2

# Access modes

Notes: Class C and class C1 are in module M1 , but D and D2 are in module M2 , and E is in module M3 . X stands for class which is inaccessible to the lookup. ANY stands for any of the example lookups. ORI indicates ORIGINAL bit set, PRO indicates PROTECTED bit set, PRI indicates PRIVATE bit set, PAC indicates PACKAGE bit set, MOD indicates MODULE bit set, 1R and 2R indicate PUBLIC bit set, U indicates UNCONDITIONAL bit set, IAE indicates IllegalAccessException thrown. Public access comes in three kinds: unconditional ( U ): the lookup assumes readability. The lookup has null previous lookup class. one-module-reads ( 1R ): the module access checking is performed with respect to the lookup class. The lookup has null previous lookup class. two-module-reads ( 2R ): the module access checking is performed with respect to the lookup class and the previous lookup class. The lookup has a non-null previous lookup class which is in a different module from the current lookup class. Any attempt to reach a third module loses all access. If a target class X is not accessible to Lookup::in all access modes are dropped.

# Security manager interactions

If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a SecurityException . Define smgr as the security manager, lookc as the lookup class of the current lookup object, refc as the containing class in which the member is being sought, and defc as the class in which the member is actually defined. (If a class or other type is being accessed, the refc and defc values are the class itself.) The value lookc is defined as not present if the current lookup object does not have full privilege access . The calls are made according to the following rules: Step 1: If lookc is not present, or if its class loader is not the same as or an ancestor of the class loader of refc , then smgr.checkPackageAccess(refcPkg) is called, where refcPkg is the package of refc . Step 2a: If the retrieved member is not public and lookc is not present, then smgr.checkPermission with RuntimePermission("accessDeclaredMembers") is called. Step 2b: If the retrieved class has a null class loader, and lookc is not present, then smgr.checkPermission with RuntimePermission("getClassLoader") is called. Step 3: If the retrieved member is not public, and if lookc is not present, and if defc and refc are different, then smgr.checkPackageAccess(defcPkg) is called, where defcPkg is the package of defc . Security checks are performed after other access checks have passed. Therefore, the above rules presuppose a member or class that is public, or else that is being accessed from a lookup class that has rights to access the member or class. If a security manager is present and the current lookup object does not have full privilege access , then defineClass , defineHiddenClass , defineHiddenClassWithClassData calls smgr.checkPermission with RuntimePermission("defineClass") .

# Caller sensitive methods

If a method handle for a caller-sensitive method is requested, the general rules for bytecode behaviors apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles. In cases where the lookup object is publicLookup() , or some other lookup object without the original access , the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an IllegalAccessException . Discussion: For example, the caller-sensitive method Class.forName(x) can return varying classes or throw varying exceptions, depending on the class loader of the class that calls it. A public lookup of Class.forName will fail, because there is no reasonable way to determine its bytecode behavior. If an application caches method handles for broad sharing, it should use publicLookup() to create them. If there is a lookup of Class.forName , it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible. The function MethodHandles.lookup is caller sensitive so that there can be a secure foundation for lookups. Nearly all other methods in the JSR 292 API rely on lookup objects to check access requests.

# Nested Class Summary

# Field Summary

# Method Summary

# Methods declared in class java.lang.Object

# Field Details

# PUBLIC

A Lookup with this lookup mode performs cross-module access check with respect to the lookup class and previous lookup class if present.

# PRIVATE

# PROTECTED

# PACKAGE

# MODULE

If this lookup mode is set, the previous lookup class is always null .

# UNCONDITIONAL

If this lookup mode is set, the previous lookup class is always null .

# ORIGINAL

If this lookup mode is set, the Lookup object must be created by the original lookup class by calling MethodHandles.lookup() method or by a bootstrap method invoked by the VM. The Lookup object with this lookup mode has full privilege access .

# Method Details

# lookupClass

If this lookup object has a previous lookup class , access checks are performed against both the lookup class and the previous lookup class. The class implies a maximum level of access permission, but the permissions may be additionally limited by the bitmask lookupModes , which controls whether non-public members can be accessed.

# previousLookupClass

A Lookup object produced by the factory methods, such as the lookup() and publicLookup() method, has null previous lookup class. A Lookup object has a non-null previous lookup class when this lookup was teleported from an old lookup class in one module to a new lookup class in another module.

# lookupModes

A freshly-created lookup object on the caller's class has all possible bits set, except UNCONDITIONAL . A lookup object on a new lookup class created from a previous lookup object may have some mode bits set to zero. Mode bits can also be directly cleared . Once cleared, mode bits cannot be restored from the downgraded lookup object. The purpose of this is to restrict access via the new lookup object, so that it can access only names which can be reached by the original lookup object, and also by the new lookup class.

# in

However, the resulting Lookup object is guaranteed to have no more access capabilities than the original. In particular, access capabilities can be lost as follows: If the new lookup class is different from the old lookup class, i.e. ORIGINAL access is lost. If the new lookup class is in a different module from the old one, i.e. MODULE access is lost. If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible, i.e. PROTECTED and PACKAGE access are lost. If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance, i.e. PRIVATE access is lost. (Protected members may continue to be accessible because of package sharing.) If the new lookup class is not accessible to this lookup, then no members, not even public members, will be accessible i.e. all access modes are lost. If the new lookup class, the old lookup class and the previous lookup class are all in different modules i.e. teleporting to a third module, all access modes are lost. The new previous lookup class is chosen as follows: If the new lookup object has UNCONDITIONAL bit, the new previous lookup class is null . If the new lookup class is in the same module as the old lookup class, the new previous lookup class is the old previous lookup class. If the new lookup class is in a different module from the old lookup class, the new previous lookup class is the old lookup class. The resulting lookup's capabilities for loading classes (used during findClass(java.lang.String) invocations) are determined by the lookup class' loader, which may change due to this operation.

# dropLookupMode

If this lookup is a public lookup , this lookup has UNCONDITIONAL mode set and it has no other mode set. When dropping UNCONDITIONAL on a public lookup then the resulting lookup has no access. If this lookup is not a public lookup, then the following applies regardless of its lookup modes . PROTECTED and ORIGINAL are always dropped and so the resulting lookup mode will never have these access capabilities. When dropping PACKAGE then the resulting lookup will not have PACKAGE or PRIVATE access. When dropping MODULE then the resulting lookup will not have MODULE , PACKAGE , or PRIVATE access. When dropping PUBLIC then the resulting lookup has no access.

# defineClass

The lookup modes for this lookup must include PACKAGE access as default (package) members will be accessible to the class. The PACKAGE lookup mode serves to authenticate that the lookup object was created by a caller in the runtime package (or derived from a lookup originally created by suitably privileged code to a target class in the runtime package). The bytes parameter is the class bytes of a valid class file (as defined by the The Java Virtual Machine Specification ) with a class name in the same package as the lookup class. This method does not run the class initializer. The class initializer may run at a later time, as detailed in section 12.4 of the The Java Language Specification . If there is a security manager and this lookup does not have full privilege access , its checkPermission method is first called to check RuntimePermission("defineClass") .

# defineHiddenClass

Ordinarily, a class or interface C is created by a class loader, which either defines C directly or delegates to another class loader. A class loader defines C directly by invoking ClassLoader::defineClass , which causes the Java Virtual Machine to derive C from a purported representation in class file format. In situations where use of a class loader is undesirable, a class or interface C can be created by this method instead. This method is capable of defining C , and thereby creating it, without invoking ClassLoader::defineClass . Instead, this method defines C as if by arranging for the Java Virtual Machine to derive a nonarray class or interface C from a purported representation in class file format using the following rules: The lookup modes for this Lookup must include full privilege access. This level of access is needed to create C in the module of the lookup class of this Lookup . The purported representation in bytes must be a ClassFile structure (JVMS 4.1 ) of a supported major and minor version. The major and minor version may differ from the class file version of the lookup class of this Lookup . The value of this_class must be a valid index in the constant_pool table, and the entry at that index must be a valid CONSTANT_Class_info structure. Let N be the binary name encoded in internal form that is specified by this structure. N must denote a class or interface in the same package as the lookup class. Let CN be the string N + "." + <suffix> , where <suffix> is an unqualified name. Let newBytes be the ClassFile structure given by bytes with an additional entry in the constant_pool table, indicating a CONSTANT_Utf8_info structure for CN , and where the CONSTANT_Class_info structure indicated by this_class refers to the new CONSTANT_Utf8_info structure. Let L be the defining class loader of the lookup class of this Lookup . C is derived with name CN , class loader L , and purported representation newBytes as if by the rules of JVMS 5.3.5 , with the following adjustments: The constant indicated by this_class is permitted to specify a name that includes a single "." character, even though this is not a valid binary class or interface name in internal form. The Java Virtual Machine marks L as the defining class loader of C , but no class loader is recorded as an initiating class loader of C . C is considered to have the same runtime package , module and protection domain as the lookup class of this Lookup . Let GN be the binary name obtained by taking N (a binary name encoded in internal form) and replacing ASCII forward slashes with ASCII periods. For the instance of Class representing C : Class.getName() returns the string GN + "/" + <suffix> , even though this is not a valid binary class or interface name. Class.descriptorString() returns the string "L" + N + "." + <suffix> + ";" , even though this is not a valid type descriptor name. Class.describeConstable() returns an empty optional as C cannot be described in nominal form . Let newBytes be the ClassFile structure given by bytes with an additional entry in the constant_pool table, indicating a CONSTANT_Utf8_info structure for CN , and where the CONSTANT_Class_info structure indicated by this_class refers to the new CONSTANT_Utf8_info structure. Let L be the defining class loader of the lookup class of this Lookup . C is derived with name CN , class loader L , and purported representation newBytes as if by the rules of JVMS 5.3.5 , with the following adjustments: The constant indicated by this_class is permitted to specify a name that includes a single "." character, even though this is not a valid binary class or interface name in internal form. The Java Virtual Machine marks L as the defining class loader of C , but no class loader is recorded as an initiating class loader of C . C is considered to have the same runtime package , module and protection domain as the lookup class of this Lookup . Let GN be the binary name obtained by taking N (a binary name encoded in internal form) and replacing ASCII forward slashes with ASCII periods. For the instance of Class representing C : Class.getName() returns the string GN + "/" + <suffix> , even though this is not a valid binary class or interface name. Class.descriptorString() returns the string "L" + N + "." + <suffix> + ";" , even though this is not a valid type descriptor name. Class.describeConstable() returns an empty optional as C cannot be described in nominal form . After C is derived, it is linked by the Java Virtual Machine. Linkage occurs as specified in JVMS 5.4.3 , with the following adjustments: During verification, whenever it is necessary to load the class named CN , the attempt succeeds, producing class C . No request is made of any class loader. On any attempt to resolve the entry in the run-time constant pool indicated by this_class , the symbolic reference is considered to be resolved to C and resolution always succeeds immediately. If the initialize parameter is true , then C is initialized by the Java Virtual Machine. The newly created class or interface C serves as the lookup class of the Lookup object returned by this method. C is hidden in the sense that no other class or interface can refer to C via a constant pool entry. That is, a hidden class or interface cannot be named as a supertype, a field type, a method parameter type, or a method return type by any other class. This is because a hidden class or interface does not have a binary name, so there is no internal form available to record in any class's constant pool. A hidden class or interface is not discoverable by Class.forName(String, boolean, ClassLoader) , ClassLoader.loadClass(String, boolean) , or findClass(String) , and is not modifiable by Java agents or tool agents using the JVM Tool Interface . A class or interface created by a class loader has a strong relationship with that class loader. That is, every Class object contains a reference to the ClassLoader that defined it . This means that a class created by a class loader may be unloaded if and only if its defining loader is not reachable and thus may be reclaimed by a garbage collector (JLS 12.7 ). By default, however, a hidden class or interface may be unloaded even if the class loader that is marked as its defining loader is reachable . This behavior is useful when a hidden class or interface serves multiple classes defined by arbitrary class loaders. In other cases, a hidden class or interface may be linked to a single class (or a small number of classes) with the same defining loader as the hidden class or interface. In such cases, where the hidden class or interface must be coterminous with a normal class or interface, the STRONG option may be passed in options . This arranges for a hidden class to have the same strong relationship with the class loader marked as its defining loader, as a normal class or interface has with its own defining loader. If STRONG is not used, then the invoker of defineHiddenClass may still prevent a hidden class or interface from being unloaded by ensuring that the Class object is reachable. The unloading characteristics are set for each hidden class when it is defined, and cannot be changed later. An advantage of allowing hidden classes to be unloaded independently of the class loader marked as their defining loader is that a very large number of hidden classes may be created by an application. In contrast, if STRONG is used, then the JVM may run out of memory, just as if normal classes were created by class loaders. Classes and interfaces in a nest are allowed to have mutual access to their private members. The nest relationship is determined by the NestHost attribute (JVMS 4.7.28 ) and the NestMembers attribute (JVMS 4.7.29 ) in a class file. By default, a hidden class belongs to a nest consisting only of itself because a hidden class has no binary name. The NESTMATE option can be passed in options to create a hidden class or interface C as a member of a nest. The nest to which C belongs is not based on any NestHost attribute in the ClassFile structure from which C was derived. Instead, the following rules determine the nest host of C : If the nest host of the lookup class of this Lookup has previously been determined, then let H be the nest host of the lookup class. Otherwise, the nest host of the lookup class is determined using the algorithm in JVMS 5.4.4 , yielding H . The nest host of C is determined to be H , the nest host of the lookup class. A hidden class or interface may be serializable, but this requires a custom serialization mechanism in order to ensure that instances are properly serialized and deserialized. The default serialization mechanism supports only classes and interfaces that are discoverable by their class name.

# defineHiddenClassWithClassData

This method is equivalent to calling defineHiddenClass(bytes, initialize, options) as if the hidden class is injected with a private static final unnamed field which is initialized with the given classData at the first instruction of the class initializer. The newly created class is linked by the Java Virtual Machine. The MethodHandles::classData and MethodHandles::classDataAt methods can be used to retrieve the classData .

# toString

(It may seem strange that protected access should be stronger than private access. Viewed independently from package access, protected access is the first to be lost, because it requires a direct subclass relationship between caller and callee.)

# findStatic

The returned method handle will have variable arity if and only if the method's variable arity modifier bit ( 0x0080 ) is set. If the returned method handle is invoked, the method's class will be initialized, if it has not already been initialized. Example: import static java.lang.invoke.MethodHandles.*; import static java.lang.invoke.MethodType.*; ... MethodHandle MH_asList = publicLookup().findStatic(Arrays.class, "asList", methodType(List.class, Object[].class)); assertEquals("[x, y]", MH_asList.invoke("x", "y").toString());

```

import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
  "asList", methodType(List.class, Object[].class));
assertEquals("[x, y]", MH_asList.invoke("x", "y").toString());

```

# findVirtual

When called, the handle will treat the first argument as a receiver and, for non-private methods, dispatch on the receiver's type to determine which method implementation to enter. For private methods the named method in refc will be invoked on the receiver. (The dispatching action is identical with that performed by an invokevirtual or invokeinterface instruction.) The first argument will be of type refc if the lookup class has full privileges to access the member. Otherwise the member must be protected and the first argument will be restricted in type to the lookup class. The returned method handle will have variable arity if and only if the method's variable arity modifier bit ( 0x0080 ) is set. Because of the general equivalence between invokevirtual instructions and method handles produced by findVirtual , if the class is MethodHandle and the name string is invokeExact or invoke , the resulting method handle is equivalent to one produced by MethodHandles.exactInvoker or MethodHandles.invoker with the same type argument. If the class is VarHandle and the name string corresponds to the name of a signature-polymorphic access mode method, the resulting method handle is equivalent to one produced by MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType) with the access mode corresponding to the name string and with the same type arguments. Example: import static java.lang.invoke.MethodHandles.*; import static java.lang.invoke.MethodType.*; ... MethodHandle MH_concat = publicLookup().findVirtual(String.class, "concat", methodType(String.class, String.class)); MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class, "hashCode", methodType(int.class)); MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class, "hashCode", methodType(int.class)); assertEquals("xy", (String) MH_concat.invokeExact("x", "y")); assertEquals("xy".hashCode(), (int) MH_hashCode.invokeExact((Object)"xy")); assertEquals("xy".hashCode(), (int) MH_hashCode_String.invokeExact("xy")); // interface method: MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class, "subSequence", methodType(CharSequence.class, int.class, int.class)); assertEquals("def", MH_subSequence.invoke("abcdefghi", 3, 6).toString()); // constructor "internal method" must be accessed differently: MethodType MT_newString = methodType(void.class); //()V for new String() try { assertEquals("impossible", lookup() .findVirtual(String.class, "<init>", MT_newString)); } catch (NoSuchMethodException ex) { } // OK MethodHandle MH_newString = publicLookup() .findConstructor(String.class, MT_newString); assertEquals("", (String) MH_newString.invokeExact());

```

import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_concat = publicLookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
  "hashCode", methodType(int.class));
MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
  "hashCode", methodType(int.class));
assertEquals("xy", (String) MH_concat.invokeExact("x", "y"));
assertEquals("xy".hashCode(), (int) MH_hashCode.invokeExact((Object)"xy"));
assertEquals("xy".hashCode(), (int) MH_hashCode_String.invokeExact("xy"));
// interface method:
MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
  "subSequence", methodType(CharSequence.class, int.class, int.class));
assertEquals("def", MH_subSequence.invoke("abcdefghi", 3, 6).toString());
// constructor "internal method" must be accessed differently:
MethodType MT_newString = methodType(void.class); //()V for new String()
try { assertEquals("impossible", lookup()
        .findVirtual(String.class, "<init>", MT_newString));
 } catch (NoSuchMethodException ex) { } // OK
MethodHandle MH_newString = publicLookup()
  .findConstructor(String.class, MT_newString);
assertEquals("", (String) MH_newString.invokeExact());

```

# findConstructor

The requested type must have a return type of void . (This is consistent with the JVM's treatment of constructor type descriptors.) The returned method handle will have variable arity if and only if the constructor's variable arity modifier bit ( 0x0080 ) is set. If the returned method handle is invoked, the constructor's class will be initialized, if it has not already been initialized. Example: import static java.lang.invoke.MethodHandles.*; import static java.lang.invoke.MethodType.*; ... MethodHandle MH_newArrayList = publicLookup().findConstructor( ArrayList.class, methodType(void.class, Collection.class)); Collection orig = Arrays.asList("x", "y"); Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig); assert(orig != copy); assertEquals(orig, copy); // a variable-arity constructor: MethodHandle MH_newProcessBuilder = publicLookup().findConstructor( ProcessBuilder.class, methodType(void.class, String[].class)); ProcessBuilder pb = (ProcessBuilder) MH_newProcessBuilder.invoke("x", "y", "z"); assertEquals("[x, y, z]", pb.command().toString());

```

import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_newArrayList = publicLookup().findConstructor(
  ArrayList.class, methodType(void.class, Collection.class));
Collection orig = Arrays.asList("x", "y");
Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
assert(orig != copy);
assertEquals(orig, copy);
// a variable-arity constructor:
MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
  ProcessBuilder.class, methodType(void.class, String[].class));
ProcessBuilder pb = (ProcessBuilder)
  MH_newProcessBuilder.invoke("x", "y", "z");
assertEquals("[x, y, z]", pb.command().toString());

```

# findClass

The lookup context here is determined by the lookup class , its class loader, and the lookup modes .

# ensureInitialized

This method returns when targetClass is fully initialized, or when targetClass is being initialized by the current thread.

# accessClass

If targetClass is in the same module as the lookup class, the lookup class is LC in module M1 and the previous lookup class is in module M0 or null if not present, targetClass is accessible if and only if one of the following is true: If this lookup has PRIVATE access, targetClass is LC or other class in the same nest of LC . If this lookup has PACKAGE access, targetClass is in the same runtime package of LC . If this lookup has MODULE access, targetClass is a public type in M1 . If this lookup has PUBLIC access, targetClass is a public type in a package exported by M1 to at least M0 if the previous lookup class is present; otherwise, targetClass is a public type in a package exported by M1 unconditionally. Otherwise, if this lookup has UNCONDITIONAL access, this lookup can access public types in all modules when the type is in a package that is exported unconditionally. Otherwise, targetClass is in a different module from lookupClass , and if this lookup does not have PUBLIC access, lookupClass is inaccessible. Otherwise, if this lookup has no previous lookup class , M1 is the module containing lookupClass and M2 is the module containing targetClass , then targetClass is accessible if and only if M1 reads M2 , and targetClass is public and in a package exported by M2 at least to M1 . Otherwise, if this lookup has a previous lookup class , M1 and M2 are as before, and M0 is the module containing the previous lookup class, then targetClass is accessible if and only if one of the following is true: targetClass is in M0 and M1 reads M0 and the type is in a package that is exported to at least M1 . targetClass is in M1 and M0 reads M1 and the type is in a package that is exported to at least M0 . targetClass is in a third module M2 and both M0 and M1 reads M2 and the type is in a package that is exported to at least both M0 and M2 . Otherwise, targetClass is not accessible.

# findSpecial

Before method resolution, if the explicitly specified caller class is not identical with the lookup class, or if this lookup object does not have private access privileges, the access fails. The returned method handle will have variable arity if and only if the method's variable arity modifier bit ( 0x0080 ) is set. (Note: JVM internal methods named "<init>" are not visible to this API, even though the invokespecial instruction can refer to them in special circumstances. Use findConstructor to access instance initialization methods in a safe manner.) Example: import static java.lang.invoke.MethodHandles.*; import static java.lang.invoke.MethodType.*; ... static class Listie extends ArrayList { public String toString() { return "[wee Listie]"; } static Lookup lookup() { return MethodHandles.lookup(); } } ... // no access to constructor via invokeSpecial: MethodHandle MH_newListie = Listie.lookup() .findConstructor(Listie.class, methodType(void.class)); Listie l = (Listie) MH_newListie.invokeExact(); try { assertEquals("impossible", Listie.lookup().findSpecial( Listie.class, "<init>", methodType(void.class), Listie.class)); } catch (NoSuchMethodException ex) { } // OK // access to super and self methods via invokeSpecial: MethodHandle MH_super = Listie.lookup().findSpecial( ArrayList.class, "toString" , methodType(String.class), Listie.class); MethodHandle MH_this = Listie.lookup().findSpecial( Listie.class, "toString" , methodType(String.class), Listie.class); MethodHandle MH_duper = Listie.lookup().findSpecial( Object.class, "toString" , methodType(String.class), Listie.class); assertEquals("[]", (String) MH_super.invokeExact(l)); assertEquals(""+l, (String) MH_this.invokeExact(l)); assertEquals("[]", (String) MH_duper.invokeExact(l)); // ArrayList method try { assertEquals("inaccessible", Listie.lookup().findSpecial( String.class, "toString", methodType(String.class), Listie.class)); } catch (IllegalAccessException ex) { } // OK Listie subl = new Listie() { public String toString() { return "[subclass]"; } }; assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method

```

import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
static class Listie extends ArrayList {
  public String toString() { return "[wee Listie]"; }
  static Lookup lookup() { return MethodHandles.lookup(); }
}
...
// no access to constructor via invokeSpecial:
MethodHandle MH_newListie = Listie.lookup()
  .findConstructor(Listie.class, methodType(void.class));
Listie l = (Listie) MH_newListie.invokeExact();
try { assertEquals("impossible", Listie.lookup().findSpecial(
        Listie.class, "<init>", methodType(void.class), Listie.class));
 } catch (NoSuchMethodException ex) { } // OK
// access to super and self methods via invokeSpecial:
MethodHandle MH_super = Listie.lookup().findSpecial(
  ArrayList.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_this = Listie.lookup().findSpecial(
  Listie.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_duper = Listie.lookup().findSpecial(
  Object.class, "toString" , methodType(String.class), Listie.class);
assertEquals("[]", (String) MH_super.invokeExact(l));
assertEquals(""+l, (String) MH_this.invokeExact(l));
assertEquals("[]", (String) MH_duper.invokeExact(l)); // ArrayList method
try { assertEquals("inaccessible", Listie.lookup().findSpecial(
        String.class, "toString", methodType(String.class), Listie.class));
 } catch (IllegalAccessException ex) { } // OK
Listie subl = new Listie() { public String toString() { return "[subclass]"; } };
assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method

```

# findGetter

# findSetter

# findVarHandle

Access checking is performed immediately on behalf of the lookup class. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the field is declared final , then the write, atomic update, numeric atomic update, and bitwise atomic update access modes are unsupported. if the field type is anything other than byte , short , char , int , long , float , or double then numeric atomic update access modes are unsupported. if the field type is anything other than boolean , byte , short , char , int or long then bitwise atomic update access modes are unsupported. If the field is declared volatile then the returned VarHandle will override access to the field (effectively ignore the volatile declaration) in accordance to its specified access modes. If the field type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double) , respectively).

# findStaticGetter

If the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.

# findStaticSetter

If the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.

# findStaticVarHandle

Access checking is performed immediately on behalf of the lookup class. If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the field is declared final , then the write, atomic update, numeric atomic update, and bitwise atomic update access modes are unsupported. if the field type is anything other than byte , short , char , int , long , float , or double , then numeric atomic update access modes are unsupported. if the field type is anything other than boolean , byte , short , char , int or long then bitwise atomic update access modes are unsupported. If the field is declared volatile then the returned VarHandle will override access to the field (effectively ignore the volatile declaration) in accordance to its specified access modes. If the field type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double) , respectively).

# bind

The returned method handle will have variable arity if and only if the method's variable arity modifier bit ( 0x0080 ) is set and the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.) This is almost equivalent to the following code, with some differences noted below: import static java.lang.invoke.MethodHandles.*; import static java.lang.invoke.MethodType.*; ... MethodHandle mh0 = lookup().findVirtual(defc, name, type); MethodHandle mh1 = mh0.bindTo(receiver); mh1 = mh1.withVarargs(mh0.isVarargsCollector()); return mh1; where defc is either receiver.getClass() or a super type of that class, in which the requested method is accessible to the lookup class. (Unlike bind , bindTo does not preserve variable arity. Also, bindTo may throw a ClassCastException in instances where bind would throw an IllegalAccessException , as in the case where the member is protected and the receiver is restricted by findVirtual to the lookup class.)

```

import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle mh0 = lookup().findVirtual(defc, name, type);
MethodHandle mh1 = mh0.bindTo(receiver);
mh1 = mh1.withVarargs(mh0.isVarargsCollector());
return mh1;

```

# unreflect

The returned method handle will have variable arity if and only if the method's variable arity modifier bit ( 0x0080 ) is set. If m is static, and if the returned method handle is invoked, the method's class will be initialized, if it has not already been initialized.

# unreflectSpecial

Before method resolution, if the explicitly specified caller class is not identical with the lookup class, or if this lookup object does not have private access privileges, the access fails. The returned method handle will have variable arity if and only if the method's variable arity modifier bit ( 0x0080 ) is set.

# unreflectConstructor

If the constructor's accessible flag is not set, access checking is performed immediately on behalf of the lookup class. The returned method handle will have variable arity if and only if the constructor's variable arity modifier bit ( 0x0080 ) is set. If the returned method handle is invoked, the constructor's class will be initialized, if it has not already been initialized.

# unreflectGetter

If the field is static, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.

# unreflectSetter

If the field is final , write access will not be allowed and access checking will fail, except under certain narrow circumstances documented for Field.set . A method handle is returned only if a corresponding call to the Field object's set method could return normally. In particular, fields which are both static and final may never be set. If the field is static , and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.

# unreflectVarHandle

Access checking is performed immediately on behalf of the lookup class, regardless of the value of the field's accessible flag. If the field is static, and if the returned VarHandle is operated on, the field's declaring class will be initialized, if it has not already been initialized. Certain access modes of the returned VarHandle are unsupported under the following conditions: if the field is declared final , then the write, atomic update, numeric atomic update, and bitwise atomic update access modes are unsupported. if the field type is anything other than byte , short , char , int , long , float , or double then numeric atomic update access modes are unsupported. if the field type is anything other than boolean , byte , short , char , int or long then bitwise atomic update access modes are unsupported. If the field is declared volatile then the returned VarHandle will override access to the field (effectively ignore the volatile declaration) in accordance to its specified access modes. If the field type is float or double then numeric and atomic update access modes compare values using their bitwise representation (see Float.floatToRawIntBits(float) and Double.doubleToRawLongBits(double) , respectively).

# revealDirect

# hasPrivateAccess

# hasFullPrivilegeAccess


---
